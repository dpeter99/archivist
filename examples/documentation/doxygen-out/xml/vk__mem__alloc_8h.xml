<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.5" xml:lang="en-US">
  <compounddef id="vk__mem__alloc_8h" kind="file" language="C++">
    <compoundname>vk_mem_alloc.h</compoundname>
    <includes local="no">vulkan/vulkan.h</includes>
    <includedby refid="_tools_8h" local="no">shadow-engine/shadow-renderer/inc/vlkx/vulkan/Tools.h</includedby>
    <includedby refid="_vulkan_module_8h" local="no">shadow-engine/shadow-renderer/inc/vlkx/vulkan/VulkanModule.h</includedby>
    <includedby refid="_vulkan_module_8cpp" local="no">shadow-engine/shadow-renderer/src/vulkan/VulkanModule.cpp</includedby>
    <incdepgraph>
      <node id="1">
        <label>shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h</label>
        <link refid="vk__mem__alloc_8h"/>
        <childnode refid="2" relation="include">
        </childnode>
      </node>
      <node id="2">
        <label>vulkan/vulkan.h</label>
      </node>
    </incdepgraph>
    <invincdepgraph>
      <node id="16">
        <label>shadow-engine/core/src/core/ShadowApplication.cpp</label>
        <link refid="_shadow_application_8cpp"/>
      </node>
      <node id="4">
        <label>shadow-engine/shadow-renderer/inc/temp/model/Builder.h</label>
        <link refid="_builder_8h"/>
        <childnode refid="5" relation="include">
        </childnode>
      </node>
      <node id="6">
        <label>shadow-engine/shadow-renderer/inc/vlkx/render/render_pass/GPUPass.h</label>
        <link refid="_g_p_u_pass_8h"/>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
      </node>
      <node id="3">
        <label>shadow-engine/shadow-renderer/inc/vlkx/render/render_pass/GenericRenderPass.h</label>
        <link refid="_generic_render_pass_8h"/>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
      </node>
      <node id="9">
        <label>shadow-engine/shadow-renderer/inc/vlkx/render/render_pass/ScreenRenderPass.h</label>
        <link refid="_screen_render_pass_8h"/>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
      </node>
      <node id="17">
        <label>shadow-engine/shadow-renderer/inc/vlkx/render/shader/Pipeline.h</label>
        <link refid="_pipeline_8h"/>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="18" relation="include">
        </childnode>
      </node>
      <node id="14">
        <label>shadow-engine/shadow-renderer/inc/vlkx/vulkan/SwapChain.h</label>
        <link refid="_swap_chain_8h"/>
        <childnode refid="15" relation="include">
        </childnode>
        <childnode refid="21" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
      </node>
      <node id="2">
        <label>shadow-engine/shadow-renderer/inc/vlkx/vulkan/Tools.h</label>
        <link refid="_tools_8h"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="22" relation="include">
        </childnode>
      </node>
      <node id="15">
        <label>shadow-engine/shadow-renderer/inc/vlkx/vulkan/VulkanModule.h</label>
        <link refid="_vulkan_module_8h"/>
        <childnode refid="16" relation="include">
        </childnode>
        <childnode refid="17" relation="include">
        </childnode>
        <childnode refid="19" relation="include">
        </childnode>
        <childnode refid="18" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="21" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="22" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
      </node>
      <node id="12">
        <label>shadow-engine/shadow-renderer/inc/vlkx/vulkan/abstraction/Buffer.h</label>
        <link refid="_buffer_8h"/>
        <childnode refid="13" relation="include">
        </childnode>
        <childnode refid="22" relation="include">
        </childnode>
      </node>
      <node id="19">
        <label>shadow-engine/shadow-renderer/inc/vlkx/vulkan/abstraction/Descriptor.h</label>
        <link refid="_descriptor_8h"/>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="20" relation="include">
        </childnode>
      </node>
      <node id="13">
        <label>shadow-engine/shadow-renderer/inc/vlkx/vulkan/abstraction/Image.h</label>
        <link refid="_image_8h"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="14" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
      </node>
      <node id="1">
        <label>shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h</label>
        <link refid="vk__mem__alloc_8h"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="15" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
      </node>
      <node id="18">
        <label>shadow-engine/shadow-renderer/src/render/pipeline/Pipeline.cpp</label>
        <link refid="_pipeline_8cpp"/>
      </node>
      <node id="7">
        <label>shadow-engine/shadow-renderer/src/render/render_pass/GPUPass.cpp</label>
        <link refid="_g_p_u_pass_8cpp"/>
      </node>
      <node id="11">
        <label>shadow-engine/shadow-renderer/src/render/render_pass/GenericRenderPass.cpp</label>
        <link refid="_generic_render_pass_8cpp"/>
      </node>
      <node id="8">
        <label>shadow-engine/shadow-renderer/src/render/render_pass/ScreenRenderPass.cpp</label>
        <link refid="_screen_render_pass_8cpp"/>
      </node>
      <node id="5">
        <label>shadow-engine/shadow-renderer/src/temp/model/Builder.cpp</label>
        <link refid="_builder_8cpp"/>
      </node>
      <node id="21">
        <label>shadow-engine/shadow-renderer/src/vulkan/SwapChain.cpp</label>
        <link refid="_swap_chain_8cpp"/>
      </node>
      <node id="25">
        <label>shadow-engine/shadow-renderer/src/vulkan/Tools.cpp</label>
        <link refid="_tools_8cpp"/>
      </node>
      <node id="10">
        <label>shadow-engine/shadow-renderer/src/vulkan/VulkanModule.cpp</label>
        <link refid="_vulkan_module_8cpp"/>
      </node>
      <node id="22">
        <label>shadow-engine/shadow-renderer/src/vulkan/abstraction/Buffer.cpp</label>
        <link refid="_buffer_8cpp"/>
      </node>
      <node id="23">
        <label>shadow-engine/shadow-renderer/src/vulkan/abstraction/Commands.cpp</label>
        <link refid="_commands_8cpp"/>
      </node>
      <node id="20">
        <label>shadow-engine/shadow-renderer/src/vulkan/abstraction/Descriptor.cpp</label>
        <link refid="_descriptor_8cpp"/>
      </node>
      <node id="24">
        <label>shadow-engine/shadow-renderer/src/vulkan/abstraction/Image.cpp</label>
        <link refid="_image_8cpp"/>
      </node>
    </invincdepgraph>
    <innerclass refid="struct_vma_device_memory_callbacks" prot="public">VmaDeviceMemoryCallbacks</innerclass>
    <innerclass refid="struct_vma_vulkan_functions" prot="public">VmaVulkanFunctions</innerclass>
    <innerclass refid="struct_vma_allocator_create_info" prot="public">VmaAllocatorCreateInfo</innerclass>
    <innerclass refid="struct_vma_allocator_info" prot="public">VmaAllocatorInfo</innerclass>
    <innerclass refid="struct_vma_statistics" prot="public">VmaStatistics</innerclass>
    <innerclass refid="struct_vma_detailed_statistics" prot="public">VmaDetailedStatistics</innerclass>
    <innerclass refid="struct_vma_total_statistics" prot="public">VmaTotalStatistics</innerclass>
    <innerclass refid="struct_vma_budget" prot="public">VmaBudget</innerclass>
    <innerclass refid="struct_vma_allocation_create_info" prot="public">VmaAllocationCreateInfo</innerclass>
    <innerclass refid="struct_vma_pool_create_info" prot="public">VmaPoolCreateInfo</innerclass>
    <innerclass refid="struct_vma_allocation_info" prot="public">VmaAllocationInfo</innerclass>
    <innerclass refid="struct_vma_defragmentation_info" prot="public">VmaDefragmentationInfo</innerclass>
    <innerclass refid="struct_vma_defragmentation_move" prot="public">VmaDefragmentationMove</innerclass>
    <innerclass refid="struct_vma_defragmentation_pass_move_info" prot="public">VmaDefragmentationPassMoveInfo</innerclass>
    <innerclass refid="struct_vma_defragmentation_stats" prot="public">VmaDefragmentationStats</innerclass>
    <innerclass refid="struct_vma_virtual_block_create_info" prot="public">VmaVirtualBlockCreateInfo</innerclass>
    <innerclass refid="struct_vma_virtual_allocation_create_info" prot="public">VmaVirtualAllocationCreateInfo</innerclass>
    <innerclass refid="struct_vma_virtual_allocation_info" prot="public">VmaVirtualAllocationInfo</innerclass>
      <sectiondef kind="define">
      <memberdef kind="define" id="vk__mem__alloc_8h_1a1a2407c283893638cc039bb31fcd74b6" prot="public" static="no">
        <name>VMA_VULKAN_VERSION</name>
        <initializer>1000000</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="144" column="22" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="144" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="vk__mem__alloc_8h_1af7b860e63b96d11e44ae8587ba06bbf4" prot="public" static="no">
        <name>VMA_DEDICATED_ALLOCATION</name>
        <initializer>0</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="181" column="22" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="181" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="vk__mem__alloc_8h_1a88bef97f86d70a34a4c0746e09a2680d" prot="public" static="no">
        <name>VMA_BIND_MEMORY2</name>
        <initializer>0</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="189" column="22" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="189" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="vk__mem__alloc_8h_1a05decf1cf4ebf767beba7acca6c1ec3a" prot="public" static="no">
        <name>VMA_MEMORY_BUDGET</name>
        <initializer>0</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="197" column="22" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="197" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="vk__mem__alloc_8h_1a7f9d5e71b70dd1a137c303a8a8262c10" prot="public" static="no">
        <name>VMA_BUFFER_DEVICE_ADDRESS</name>
        <initializer>0</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="206" column="22" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="206" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="vk__mem__alloc_8h_1a81af8a3a87e34bbb493848143cde43e4" prot="public" static="no">
        <name>VMA_MEMORY_PRIORITY</name>
        <initializer>0</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="215" column="22" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="215" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="vk__mem__alloc_8h_1a02cd76250a5695dbe9a33e5b6db51695" prot="public" static="no">
        <name>VMA_EXTERNAL_MEMORY</name>
        <initializer>0</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="224" column="22" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="224" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" prot="public" static="no">
        <name>VMA_CALL_PRE</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="234" column="13" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="234" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" prot="public" static="no">
        <name>VMA_CALL_POST</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="237" column="13" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="237" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" prot="public" static="no">
        <name>VMA_LEN_IF_NOT_NULL</name>
        <param><defname>len</defname></param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="252" column="13" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="252" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" prot="public" static="no">
        <name>VMA_NULLABLE</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="261" column="22" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="261" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" prot="public" static="no">
        <name>VMA_NOT_NULL</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="271" column="22" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="271" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" prot="public" static="no">
        <name>VMA_NOT_NULL_NON_DISPATCHABLE</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="281" column="22" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="281" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" prot="public" static="no">
        <name>VMA_NULLABLE_NON_DISPATCHABLE</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="289" column="22" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="289" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="vk__mem__alloc_8h_1ae25f0d55fd91cb166f002b63244800e1" prot="public" static="no">
        <name>VMA_STATS_STRING_ENABLED</name>
        <initializer>1</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="294" column="13" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="294" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="group__group__init_1ga4f87c9100d154a65a4ad495f7763cf7c" prot="public" static="no" strong="no">
        <type></type>
        <name>VmaAllocatorCreateFlagBits</name>
        <enumvalue id="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7ca4816ddaed324ba110172ca608a20f29d" prot="public">
          <name>VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT</name>
          <initializer>= 0x00000001</initializer>
          <briefdescription>
<para>Allocator and all objects created from it will not be synchronized internally, so you must guarantee they are used from only one thread at a time or synchronized externally by you. </para>
          </briefdescription>
          <detaileddescription>
<para>Using this flag may increase performance because internal mutexes are not used. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7cace7da7cc6e71a625dfa763c55a597878" prot="public">
          <name>VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT</name>
          <initializer>= 0x00000002</initializer>
          <briefdescription>
<para>Enables usage of VK_KHR_dedicated_allocation extension. </para>
          </briefdescription>
          <detaileddescription>
<para>The flag works only if <ref refid="struct_vma_allocator_create_info_1ae0ffc55139b54520a6bb704b29ffc285" kindref="member">VmaAllocatorCreateInfo::vulkanApiVersion</ref> `== VK_API_VERSION_1_0`. When it is `VK_API_VERSION_1_1`, the flag is ignored because the extension has been promoted to Vulkan 1.1.</para>
<para>Using this extension will automatically allocate dedicated blocks of memory for some buffers and images instead of suballocating place for them out of bigger memory blocks (as if you explicitly used <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" kindref="member">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</ref> flag) when it is recommended by the driver. It may improve performance on some GPUs.</para>
<para>You may set this flag only if you found out that following device extensions are supported, you enabled them while creating Vulkan device passed as <ref refid="struct_vma_allocator_create_info_1ac35aa355d3bfcbf6bb2eb88ccf68125c" kindref="member">VmaAllocatorCreateInfo::device</ref>, and you want them to be used internally by this library:</para>
<para><itemizedlist>
<listitem><para>VK_KHR_get_memory_requirements2 (device extension)</para>
</listitem><listitem><para>VK_KHR_dedicated_allocation (device extension)</para>
</listitem></itemizedlist>
</para>
<para>When this flag is set, you can experience following warnings reported by Vulkan validation layer. You can ignore them.</para>
<para>&gt; vkBindBufferMemory(): Binding memory to buffer 0x2d but vkGetBufferMemoryRequirements() has not been called on that buffer. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7ca8fb75bf07cd184ab903596295e863dee" prot="public">
          <name>VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</name>
          <initializer>= 0x00000004</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Enables usage of VK_KHR_bind_memory2 extension.</para>
<para>The flag works only if <ref refid="struct_vma_allocator_create_info_1ae0ffc55139b54520a6bb704b29ffc285" kindref="member">VmaAllocatorCreateInfo::vulkanApiVersion</ref> `== VK_API_VERSION_1_0`. When it is `VK_API_VERSION_1_1`, the flag is ignored because the extension has been promoted to Vulkan 1.1.</para>
<para>You may set this flag only if you found out that this device extension is supported, you enabled it while creating Vulkan device passed as <ref refid="struct_vma_allocator_create_info_1ac35aa355d3bfcbf6bb2eb88ccf68125c" kindref="member">VmaAllocatorCreateInfo::device</ref>, and you want it to be used internally by this library.</para>
<para>The extension provides functions `vkBindBufferMemory2KHR` and `vkBindImageMemory2KHR`, which allow to pass a chain of `pNext` structures while binding. This flag is required if you use `pNext` parameter in <ref refid="group__group__alloc_1ga4a71c30e3474a835bdd7fd0507740be7" kindref="member">vmaBindBufferMemory2()</ref> or <ref refid="group__group__alloc_1ga0216b9225b02a66ac610cb45d4729d00" kindref="member">vmaBindImageMemory2()</ref>. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7ca4d4687863f7bd4b418c6006dc04400b0" prot="public">
          <name>VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT</name>
          <initializer>= 0x00000008</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Enables usage of VK_EXT_memory_budget extension.</para>
<para>You may set this flag only if you found out that this device extension is supported, you enabled it while creating Vulkan device passed as <ref refid="struct_vma_allocator_create_info_1ac35aa355d3bfcbf6bb2eb88ccf68125c" kindref="member">VmaAllocatorCreateInfo::device</ref>, and you want it to be used internally by this library, along with another instance extension VK_KHR_get_physical_device_properties2, which is required by it (or Vulkan 1.1, where this extension is promoted).</para>
<para>The extension provides query for current memory usage and budget, which will probably be more accurate than an estimation used by the library otherwise. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7ca2acce4886d8078552efa38878413970f" prot="public">
          <name>VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT</name>
          <initializer>= 0x00000010</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Enables usage of VK_AMD_device_coherent_memory extension.</para>
<para>You may set this flag only if you:</para>
<para><itemizedlist>
<listitem><para>found out that this device extension is supported and enabled it while creating Vulkan device passed as <ref refid="struct_vma_allocator_create_info_1ac35aa355d3bfcbf6bb2eb88ccf68125c" kindref="member">VmaAllocatorCreateInfo::device</ref>,</para>
</listitem><listitem><para>checked that `VkPhysicalDeviceCoherentMemoryFeaturesAMD::deviceCoherentMemory` is true and set it while creating the Vulkan device,</para>
</listitem><listitem><para>want it to be used internally by this library.</para>
</listitem></itemizedlist>
</para>
<para>The extension and accompanying device feature provide access to memory types with `VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD` and `VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD` flags. They are useful mostly for writing breadcrumb markers - a common method for debugging GPU crash/hang/TDR.</para>
<para>When the extension is not enabled, such memory types are still enumerated, but their usage is illegal. To protect from this error, if you don&apos;t create the allocator with this flag, it will refuse to allocate any memory or create a custom pool in such memory type, returning `VK_ERROR_FEATURE_NOT_PRESENT`. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7ca5f1b28b0414319d1687e1f2b30ab0089" prot="public">
          <name>VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT</name>
          <initializer>= 0x00000020</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Enables usage of &quot;buffer device address&quot; feature, which allows you to use function `vkGetBufferDeviceAddress*` to get raw GPU pointer to a buffer and pass it for usage inside a shader.</para>
<para>You may set this flag only if you:</para>
<para>1. (For Vulkan version &lt; 1.2) Found as available and enabled device extension VK_KHR_buffer_device_address. This extension is promoted to core Vulkan 1.2. 2. Found as available and enabled device feature `VkPhysicalDeviceBufferDeviceAddressFeatures::bufferDeviceAddress`.</para>
<para>When this flag is set, you can create buffers with `VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT` using VMA. The library automatically adds `VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT` to allocated memory blocks wherever it might be needed.</para>
<para>For more information, see documentation chapter <ref refid="enabling_buffer_device_address" kindref="compound">Enabling buffer device address</ref>. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7caffdd7a5169be3dbd7cbf6b3619e4f78a" prot="public">
          <name>VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT</name>
          <initializer>= 0x00000040</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Enables usage of VK_EXT_memory_priority extension in the library.</para>
<para>You may set this flag only if you found available and enabled this device extension, along with `VkPhysicalDeviceMemoryPriorityFeaturesEXT::memoryPriority == VK_TRUE`, while creating Vulkan device passed as <ref refid="struct_vma_allocator_create_info_1ac35aa355d3bfcbf6bb2eb88ccf68125c" kindref="member">VmaAllocatorCreateInfo::device</ref>.</para>
<para>When this flag is used, <ref refid="struct_vma_allocation_create_info_1a983d39e1a2e63649d78a960aa2fdd0f7" kindref="member">VmaAllocationCreateInfo::priority</ref> and <ref refid="struct_vma_pool_create_info_1a16e686c688f6725f119ebf6e24ab5274" kindref="member">VmaPoolCreateInfo::priority</ref> are used to set priorities of allocated Vulkan memory. Without it, these variables are ignored.</para>
<para>A priority must be a floating-point value between 0 and 1, indicating the priority of the allocation relative to other memory allocations. Larger values are higher priority. The granularity of the priorities is implementation-dependent. It is automatically passed to every call to `vkAllocateMemory` done by the library using structure `VkMemoryPriorityAllocateInfoEXT`. The value to be used for default priority is 0.5. For more details, see the documentation of the VK_EXT_memory_priority extension. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7cae4d5ad929caba5f23eb502b13bd5286c" prot="public">
          <name>VMA_ALLOCATOR_CREATE_FLAG_BITS_MAX_ENUM</name>
          <initializer>= 0x7FFFFFFF</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Flags for created <ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="314" column="1" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="315" bodyend="428"/>
      </memberdef>
      <memberdef kind="enum" id="group__group__alloc_1gaa5846affa1e9da3800e3e78fae2305cc" prot="public" static="no" strong="no">
        <type></type>
        <name>VmaMemoryUsage</name>
        <enumvalue id="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305ccaf50d27e34e0925cf3a63db8c839121dd" prot="public">
          <name>VMA_MEMORY_USAGE_UNKNOWN</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>No intended memory usage specified. Use other members of <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref> to specify your requirements. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305ccac6b5dc1432d88647aa4cd456246eadf7" prot="public">
          <name>VMA_MEMORY_USAGE_GPU_ONLY</name>
          <initializer>= 1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><xrefsect id="deprecated_1_deprecated000001"><xreftitle>Deprecated</xreftitle><xrefdescription><para>Obsolete, preserved for backward compatibility. Prefers `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`. </para>
</xrefdescription></xrefsect></para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca40bdf4cddeffeb12f43d45ca1286e0a5" prot="public">
          <name>VMA_MEMORY_USAGE_CPU_ONLY</name>
          <initializer>= 2</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><xrefsect id="deprecated_1_deprecated000002"><xreftitle>Deprecated</xreftitle><xrefdescription><para>Obsolete, preserved for backward compatibility. Guarantees `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` and `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT`. </para>
</xrefdescription></xrefsect></para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca9066b52c5a7079bb74a69aaf8b92ff67" prot="public">
          <name>VMA_MEMORY_USAGE_CPU_TO_GPU</name>
          <initializer>= 3</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><xrefsect id="deprecated_1_deprecated000003"><xreftitle>Deprecated</xreftitle><xrefdescription><para>Obsolete, preserved for backward compatibility. Guarantees `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`, prefers `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`. </para>
</xrefdescription></xrefsect></para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca7b586d2fdaf82a463b58f581ed72be27" prot="public">
          <name>VMA_MEMORY_USAGE_GPU_TO_CPU</name>
          <initializer>= 4</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><xrefsect id="deprecated_1_deprecated000004"><xreftitle>Deprecated</xreftitle><xrefdescription><para>Obsolete, preserved for backward compatibility. Guarantees `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`, prefers `VK_MEMORY_PROPERTY_HOST_CACHED_BIT`. </para>
</xrefdescription></xrefsect></para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca416a444d4d0fc20067c3f76f32ff2500" prot="public">
          <name>VMA_MEMORY_USAGE_CPU_COPY</name>
          <initializer>= 5</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><xrefsect id="deprecated_1_deprecated000005"><xreftitle>Deprecated</xreftitle><xrefdescription><para>Obsolete, preserved for backward compatibility. Prefers not `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`. </para>
</xrefdescription></xrefsect></para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca835333d9072db63a653818030e17614d" prot="public">
          <name>VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED</name>
          <initializer>= 6</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Lazily allocated GPU memory having `VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT`. Exists mostly on mobile platforms. Using it on desktop PC or other GPUs with no such memory type present will fail the allocation.</para>
<para>Usage: Memory for transient attachment images (color attachments, depth attachments etc.), created with `VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT`.</para>
<para>Allocations with this usage are always created as dedicated - it implies <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" kindref="member">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</ref>. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e" prot="public">
          <name>VMA_MEMORY_USAGE_AUTO</name>
          <initializer>= 7</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Selects best memory type automatically. This flag is recommended for most common use cases.</para>
<para>When using this flag, if you want to map the allocation (using <ref refid="group__group__alloc_1ga13b93ec0ed38ad7232300cb94931c8d2" kindref="member">vmaMapMemory()</ref> or <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" kindref="member">VMA_ALLOCATION_CREATE_MAPPED_BIT</ref>), you must pass one of the flags: <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</ref> or <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</ref> in <ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">VmaAllocationCreateInfo::flags</ref>.</para>
<para>It can be used only with functions that let the library know `VkBufferCreateInfo` or `VkImageCreateInfo`, e.g. <ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer()</ref>, <ref refid="group__group__alloc_1gaa76142ae43535c862ad9e194a6e38aaa" kindref="member">vmaCreateImage()</ref>, <ref refid="group__group__alloc_1ga723f5683b363c306bf860dab1861f299" kindref="member">vmaFindMemoryTypeIndexForBufferInfo()</ref>, <ref refid="group__group__alloc_1gaaf05345771a087328949b485ff2da4db" kindref="member">vmaFindMemoryTypeIndexForImageInfo()</ref> and not with generic memory allocation functions. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305ccae2adb696d6a73c18bb20c23666661327" prot="public">
          <name>VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE</name>
          <initializer>= 8</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Selects best memory type automatically with preference for GPU (device) memory.</para>
<para>When using this flag, if you want to map the allocation (using <ref refid="group__group__alloc_1ga13b93ec0ed38ad7232300cb94931c8d2" kindref="member">vmaMapMemory()</ref> or <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" kindref="member">VMA_ALLOCATION_CREATE_MAPPED_BIT</ref>), you must pass one of the flags: <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</ref> or <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</ref> in <ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">VmaAllocationCreateInfo::flags</ref>.</para>
<para>It can be used only with functions that let the library know `VkBufferCreateInfo` or `VkImageCreateInfo`, e.g. <ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer()</ref>, <ref refid="group__group__alloc_1gaa76142ae43535c862ad9e194a6e38aaa" kindref="member">vmaCreateImage()</ref>, <ref refid="group__group__alloc_1ga723f5683b363c306bf860dab1861f299" kindref="member">vmaFindMemoryTypeIndexForBufferInfo()</ref>, <ref refid="group__group__alloc_1gaaf05345771a087328949b485ff2da4db" kindref="member">vmaFindMemoryTypeIndexForImageInfo()</ref> and not with generic memory allocation functions. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca9b422585242160b8ed3418310ee6664d" prot="public">
          <name>VMA_MEMORY_USAGE_AUTO_PREFER_HOST</name>
          <initializer>= 9</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Selects best memory type automatically with preference for CPU (host) memory.</para>
<para>When using this flag, if you want to map the allocation (using <ref refid="group__group__alloc_1ga13b93ec0ed38ad7232300cb94931c8d2" kindref="member">vmaMapMemory()</ref> or <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" kindref="member">VMA_ALLOCATION_CREATE_MAPPED_BIT</ref>), you must pass one of the flags: <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</ref> or <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</ref> in <ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">VmaAllocationCreateInfo::flags</ref>.</para>
<para>It can be used only with functions that let the library know `VkBufferCreateInfo` or `VkImageCreateInfo`, e.g. <ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer()</ref>, <ref refid="group__group__alloc_1gaa76142ae43535c862ad9e194a6e38aaa" kindref="member">vmaCreateImage()</ref>, <ref refid="group__group__alloc_1ga723f5683b363c306bf860dab1861f299" kindref="member">vmaFindMemoryTypeIndexForBufferInfo()</ref>, <ref refid="group__group__alloc_1gaaf05345771a087328949b485ff2da4db" kindref="member">vmaFindMemoryTypeIndexForImageInfo()</ref> and not with generic memory allocation functions. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca091e69437ef693e8d0d287f1c719ba6e" prot="public">
          <name>VMA_MEMORY_USAGE_MAX_ENUM</name>
          <initializer>= 0x7FFFFFFF</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Intended usage of the allocated memory. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="440" column="1" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="441" bodyend="519"/>
      </memberdef>
      <memberdef kind="enum" id="group__group__alloc_1gad9889c10c798b040d59c92f257cae597" prot="public" static="no" strong="no">
        <type></type>
        <name>VmaAllocationCreateFlagBits</name>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" prot="public">
          <name>VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</name>
          <initializer>= 0x00000001</initializer>
          <briefdescription>
<para>Set this flag if the allocation should have its own memory block. </para>
          </briefdescription>
          <detaileddescription>
<para>Use it for special, big resources, like fullscreen images used as attachments. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a89759603401014eb325eb22a3839f2ff" prot="public">
          <name>VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</name>
          <initializer>= 0x00000002</initializer>
          <briefdescription>
<para>Set this flag to only try to allocate from existing `VkDeviceMemory` blocks and never create new such block. </para>
          </briefdescription>
          <detaileddescription>
<para>If new allocation cannot be placed in any of the existing blocks, allocation fails with `VK_ERROR_OUT_OF_DEVICE_MEMORY` error.</para>
<para>You should not use <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" kindref="member">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</ref> and <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a89759603401014eb325eb22a3839f2ff" kindref="member">VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</ref> at the same time. It makes no sense. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" prot="public">
          <name>VMA_ALLOCATION_CREATE_MAPPED_BIT</name>
          <initializer>= 0x00000004</initializer>
          <briefdescription>
<para>Set this flag to use a memory that will be persistently mapped and retrieve pointer to it. </para>
          </briefdescription>
          <detaileddescription>
<para>Pointer to mapped memory will be returned through <ref refid="struct_vma_allocation_info_1a17a39eb34201a610347acb91b38eca79" kindref="member">VmaAllocationInfo::pMappedData</ref>.</para>
<para>It is valid to use this flag for allocation made from memory type that is not `HOST_VISIBLE`. This flag is then ignored and memory is not mapped. This is useful if you need an allocation that is efficient to use on GPU (`DEVICE_LOCAL`) and still want to map it directly if possible on platforms that support it (e.g. Intel GPU). </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597aa6f24f821cd6a7c5e4a443f7bf59c520" prot="public">
          <name>VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</name>
          <initializer>= 0x00000020</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><xrefsect id="deprecated_1_deprecated000006"><xreftitle>Deprecated</xreftitle><xrefdescription><para>Preserved for backward compatibility. Consider using <ref refid="group__group__alloc_1ga29b210b1f39e49de844fc7b6944736d7" kindref="member">vmaSetAllocationName()</ref> instead.</para>
</xrefdescription></xrefsect></para>
<para>Set this flag to treat <ref refid="struct_vma_allocation_create_info_1a74e2eb74b3772b657c59473ce605058a" kindref="member">VmaAllocationCreateInfo::pUserData</ref> as pointer to a null-terminated string. Instead of copying pointer value, a local copy of the string is made and stored in allocation&apos;s `pName`. The string is automatically freed together with the allocation. It is also used in <ref refid="group__group__stats_1ga9326cba3c64929b59a15c3ca9cdc8cdb" kindref="member">vmaBuildStatsString()</ref>. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a42ba3a2d2c7117953210b7c3ef8da0df" prot="public">
          <name>VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT</name>
          <initializer>= 0x00000040</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Allocation will be created from upper stack in a double stack pool.</para>
<para>This flag is only allowed for custom pools created with <ref refid="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726" kindref="member">VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</ref> flag. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a2310568c62208af432724305fe29ccea" prot="public">
          <name>VMA_ALLOCATION_CREATE_DONT_BIND_BIT</name>
          <initializer>= 0x00000080</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Create both buffer/image and allocation, but don&apos;t bind them together. It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions. The flag is meaningful only with functions that bind by default: <ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer()</ref>, <ref refid="group__group__alloc_1gaa76142ae43535c862ad9e194a6e38aaa" kindref="member">vmaCreateImage()</ref>. Otherwise it is ignored.</para>
<para>If you want to make sure the new buffer/image is not tied to the new memory allocation through `VkMemoryDedicatedAllocateInfoKHR` structure in case the allocation ends up in its own memory block, use also flag <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597afb0ee060cd733aaa5e249704ff589ad6" kindref="member">VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT</ref>. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597ab8b1764f3e9022368e440c057783b92d" prot="public">
          <name>VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT</name>
          <initializer>= 0x00000100</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Create allocation only if additional device memory required for it, if any, won&apos;t exceed memory budget. Otherwise return `VK_ERROR_OUT_OF_DEVICE_MEMORY`. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597afb0ee060cd733aaa5e249704ff589ad6" prot="public">
          <name>VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT</name>
          <initializer>= 0x00000200</initializer>
          <briefdescription>
<para>Set this flag if the allocated memory will have aliasing resources. </para>
          </briefdescription>
          <detaileddescription>
<para>Usage of this flag prevents supplying `VkMemoryDedicatedAllocateInfoKHR` when <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" kindref="member">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</ref> is specified. Otherwise created dedicated memory will not be suitable for aliasing resources, resulting in Vulkan Validation Layer errors. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5" prot="public">
          <name>VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</name>
          <initializer>= 0x00000400</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Requests possibility to map the allocation (using <ref refid="group__group__alloc_1ga13b93ec0ed38ad7232300cb94931c8d2" kindref="member">vmaMapMemory()</ref> or <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" kindref="member">VMA_ALLOCATION_CREATE_MAPPED_BIT</ref>).</para>
<para><itemizedlist>
<listitem><para>If you use <ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e" kindref="member">VMA_MEMORY_USAGE_AUTO</ref> or other `VMA_MEMORY_USAGE_AUTO*` value, you must use this flag to be able to map the allocation. Otherwise, mapping is incorrect.</para>
</listitem><listitem><para>If you use other value of <ref refid="group__group__alloc_1gaa5846affa1e9da3800e3e78fae2305cc" kindref="member">VmaMemoryUsage</ref>, this flag is ignored and mapping is always possible in memory types that are `HOST_VISIBLE`. This includes allocations created in <ref refid="custom_memory_pools" kindref="compound">Custom memory pools</ref>.</para>
</listitem></itemizedlist>
</para>
<para>Declares that mapped memory will only be written sequentially, e.g. using `memcpy()` or a loop writing number-by-number, never read or accessed randomly, so a memory type can be selected that is uncached and write-combined.</para>
<para><simplesect kind="warning"><para>Violating this declaration may work correctly, but will likely be very slow. Watch out for implicit reads introduced by doing e.g. `pMappedData[i] += x;` Better prepare your data in a local variable and `memcpy()` it to the mapped pointer all at once. </para>
</simplesect>
</para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492" prot="public">
          <name>VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</name>
          <initializer>= 0x00000800</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Requests possibility to map the allocation (using <ref refid="group__group__alloc_1ga13b93ec0ed38ad7232300cb94931c8d2" kindref="member">vmaMapMemory()</ref> or <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" kindref="member">VMA_ALLOCATION_CREATE_MAPPED_BIT</ref>).</para>
<para><itemizedlist>
<listitem><para>If you use <ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e" kindref="member">VMA_MEMORY_USAGE_AUTO</ref> or other `VMA_MEMORY_USAGE_AUTO*` value, you must use this flag to be able to map the allocation. Otherwise, mapping is incorrect.</para>
</listitem><listitem><para>If you use other value of <ref refid="group__group__alloc_1gaa5846affa1e9da3800e3e78fae2305cc" kindref="member">VmaMemoryUsage</ref>, this flag is ignored and mapping is always possible in memory types that are `HOST_VISIBLE`. This includes allocations created in <ref refid="custom_memory_pools" kindref="compound">Custom memory pools</ref>.</para>
</listitem></itemizedlist>
</para>
<para>Declares that mapped memory can be read, written, and accessed in random order, so a `HOST_CACHED` memory type is required. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11337f96eacf34c1016c339eac165cad" prot="public">
          <name>VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</name>
          <initializer>= 0x00001000</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Together with <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</ref> or <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</ref>, it says that despite request for host access, a not-`HOST_VISIBLE` memory type can be selected if it may improve performance.</para>
<para>By using this flag, you declare that you will check if the allocation ended up in a `HOST_VISIBLE` memory type (e.g. using <ref refid="group__group__alloc_1gaf6785483eda8b53561437e05e2177d7b" kindref="member">vmaGetAllocationMemoryProperties()</ref>) and if not, you will create some &quot;staging&quot; buffer and issue an explicit transfer to write/read your data. To prepare for this possibility, don&apos;t forget to add appropriate flags like `VK_BUFFER_USAGE_TRANSFER_DST_BIT`, `VK_BUFFER_USAGE_TRANSFER_SRC_BIT` to the parameters of created buffer or image. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8af1210cf591784afa026d94998f735d" prot="public">
          <name>VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</name>
          <initializer>= 0x00010000</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Allocation strategy that chooses smallest possible free range for the allocation to minimize memory usage and fragmentation, possibly at the expense of allocation time. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a0729e932b7ea170e3a128cad96c5cf6d" prot="public">
          <name>VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</name>
          <initializer>= 0x00020000</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Allocation strategy that chooses first suitable free range for the allocation - not necessarily in terms of the smallest offset but the one that is easiest and fastest to find to minimize allocation time, possibly at the expense of allocation quality. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8099acedc0d04cdccaaddcfe37fd227d" prot="public">
          <name>VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</name>
          <initializer>= 0x00040000</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Allocation strategy that chooses always the lowest offset in available space. This is not the most efficient strategy but achieves highly packed data. Used internally by defragmentation, not recomended in typical usage. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a839826775c62319466441f86496f036d" prot="public">
          <name>VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</name>
          <initializer>= VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Alias to <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8af1210cf591784afa026d94998f735d" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</ref>. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a33eb2052674f3ad92386c714a65fb777" prot="public">
          <name>VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</name>
          <initializer>= VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Alias to <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a0729e932b7ea170e3a128cad96c5cf6d" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</ref>. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8e16845d81ae3d27c47106d4770d5c7e" prot="public">
          <name>VMA_ALLOCATION_CREATE_STRATEGY_MASK</name>
          <initializer>=
        VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT |
        VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT |
        VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>A bit mask to extract only `STRATEGY` bits from entire set of flags. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597ae5633ec569f4899cf8f29e7385b2f882" prot="public">
          <name>VMA_ALLOCATION_CREATE_FLAG_BITS_MAX_ENUM</name>
          <initializer>= 0x7FFFFFFF</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Flags to be passed as <ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">VmaAllocationCreateInfo::flags</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="522" column="1" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="523" bodyend="651"/>
      </memberdef>
      <memberdef kind="enum" id="group__group__alloc_1ga9a7c45f9c863695d98c83fa5ac940fe7" prot="public" static="no" strong="no">
        <type></type>
        <name>VmaPoolCreateFlagBits</name>
        <enumvalue id="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7a9f1a499508a8edb4e8ba40aa0290a3d2" prot="public">
          <name>VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT</name>
          <initializer>= 0x00000002</initializer>
          <briefdescription>
<para>Use this flag if you always allocate only buffers and linear images or only optimal images out of this pool and so Buffer-Image Granularity can be ignored. </para>
          </briefdescription>
          <detaileddescription>
<para>This is an optional optimization flag.</para>
<para>If you always allocate using <ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer()</ref>, <ref refid="group__group__alloc_1gaa76142ae43535c862ad9e194a6e38aaa" kindref="member">vmaCreateImage()</ref>, <ref refid="group__group__alloc_1gaf7010aa90a4ccdda56f83db8597b9896" kindref="member">vmaAllocateMemoryForBuffer()</ref>, then you don&apos;t need to use it because allocator knows exact type of your allocations so it can handle Buffer-Image Granularity in the optimal way.</para>
<para>If you also allocate using <ref refid="group__group__alloc_1ga4b7f39281cb383c1496b68f97cb7f4c5" kindref="member">vmaAllocateMemoryForImage()</ref> or <ref refid="group__group__alloc_1gaf813f55a0667016a8cd68bb4b8b3b30c" kindref="member">vmaAllocateMemory()</ref>, exact type of such allocations is not known, so allocator must be conservative in handling Buffer-Image Granularity, which can lead to suboptimal allocation (wasted memory). In that case, if you can make sure you always allocate only buffers and linear images or only optimal images out of this pool, use this flag to make allocator disregard Buffer-Image Granularity and so make allocations faster and more optimal. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726" prot="public">
          <name>VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</name>
          <initializer>= 0x00000004</initializer>
          <briefdescription>
<para>Enables alternative, linear allocation algorithm in this pool. </para>
          </briefdescription>
          <detaileddescription>
<para>Specify this flag to enable linear allocation algorithm, which always creates new allocations after last one and doesn&apos;t reuse space from allocations freed in between. It trades memory consumption for simplified algorithm and data structure, which has better performance and uses less memory for metadata.</para>
<para>By using this flag, you can achieve behavior of free-at-once, stack, ring buffer, and double stack. For details, see documentation chapter <ref refid="custom_memory_pools_1linear_algorithm" kindref="member">Linear allocation algorithm</ref>. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7af4d270f8f42517a0f70037ceb6ac1d9c" prot="public">
          <name>VMA_POOL_CREATE_ALGORITHM_MASK</name>
          <initializer>=
        VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Bit mask to extract only `ALGORITHM` bits from entire set of flags. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7a1c7312bea9ea246846b9054fd6bd6aec" prot="public">
          <name>VMA_POOL_CREATE_FLAG_BITS_MAX_ENUM</name>
          <initializer>= 0x7FFFFFFF</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Flags to be passed as <ref refid="struct_vma_pool_create_info_1a8405139f63d078340ae74513a59f5446" kindref="member">VmaPoolCreateInfo::flags</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="656" column="1" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="657" bodyend="696"/>
      </memberdef>
      <memberdef kind="enum" id="group__group__alloc_1ga6552a65b71d16f378c6994b3ceaef50c" prot="public" static="no" strong="no">
        <type></type>
        <name>VmaDefragmentationFlagBits</name>
        <enumvalue id="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50ca2e6469bcf5a094776ceb5d118263f04b" prot="public">
          <name>VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT</name>
          <initializer>= 0x1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50caec35a4138111605a6ff32ca61aa871b6" prot="public">
          <name>VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT</name>
          <initializer>= 0x2</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50cafa162eac5be800bcdd4011427a71156d" prot="public">
          <name>VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT</name>
          <initializer>= 0x4</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50cae45a9469e5337731627758671741e412" prot="public">
          <name>VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT</name>
          <initializer>= 0x8</initializer>
          <briefdescription>
<para>Use the most roboust algorithm at the cost of time to compute and number of copies to make. Only available when bufferImageGranularity is greater than 1, since it aims to reduce alignment issues between different types of resources. Otherwise falls back to same behavior as <ref refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50cafa162eac5be800bcdd4011427a71156d" kindref="member">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT</ref>. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50cabcbbdb3bfd53c4c3ab4eaeb5fd4894e9" prot="public">
          <name>VMA_DEFRAGMENTATION_FLAG_ALGORITHM_MASK</name>
          <initializer>= 
        VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT |
        VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT |
        VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT |
        VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT</initializer>
          <briefdescription>
<para>A bit mask to extract only `ALGORITHM` bits from entire set of flags. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50cab87ec33154803bfeb5ac2b379f1d6a97" prot="public">
          <name>VMA_DEFRAGMENTATION_FLAG_BITS_MAX_ENUM</name>
          <initializer>= 0x7FFFFFFF</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Flags to be passed as <ref refid="struct_vma_defragmentation_info_1a3e23080c978ecf3abb3180f5b2069da7" kindref="member">VmaDefragmentationInfo::flags</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="701" column="1" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="702" bodyend="730"/>
      </memberdef>
      <memberdef kind="enum" id="group__group__alloc_1gada9e3861caf96f08894b0bcc160ec257" prot="public" static="no" strong="no">
        <type></type>
        <name>VmaDefragmentationMoveOperation</name>
        <enumvalue id="group__group__alloc_1ggada9e3861caf96f08894b0bcc160ec257ad4a06ac46c4cb1c67b0ebc1edfab9f18" prot="public">
          <name>VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY</name>
          <initializer>= 0</initializer>
          <briefdescription>
<para>Buffer/image has been recreated at `dstTmpAllocation`, data has been copied, old buffer/image has been destroyed. `srcAllocation` should be changed to point to the new place. This is the default value set by <ref refid="group__group__alloc_1gacbe4a77fdfa7ea29328d2f940d423ab7" kindref="member">vmaBeginDefragmentationPass()</ref>. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggada9e3861caf96f08894b0bcc160ec257ad25bc6f816b226b4fd5170e845f218d2" prot="public">
          <name>VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE</name>
          <initializer>= 1</initializer>
          <briefdescription>
<para>Set this value if you cannot move the allocation. New place reserved at `dstTmpAllocation` will be freed. `srcAllocation` will remain unchanged. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggada9e3861caf96f08894b0bcc160ec257a9786f8492a9be2c03bd26395e352ab85" prot="public">
          <name>VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY</name>
          <initializer>= 2</initializer>
          <briefdescription>
<para>Set this value if you decide to abandon the allocation and you destroyed the buffer/image. New place reserved at `dstTmpAllocation` will be freed, along with `srcAllocation`, which will be destroyed. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Operation performed on single defragmentation move. See structure <ref refid="struct_vma_defragmentation_move" kindref="compound">VmaDefragmentationMove</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="735" column="1" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="736" bodyend="743"/>
      </memberdef>
      <memberdef kind="enum" id="group__group__virtual_1ga88bcf8c1cd3bb1610ff7343811c65bca" prot="public" static="no" strong="no">
        <type></type>
        <name>VmaVirtualBlockCreateFlagBits</name>
        <enumvalue id="group__group__virtual_1gga88bcf8c1cd3bb1610ff7343811c65bcaae6423e2fa2f3c9211b21c819e3f10f96" prot="public">
          <name>VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT</name>
          <initializer>= 0x00000001</initializer>
          <briefdescription>
<para>Enables alternative, linear allocation algorithm in this virtual block. </para>
          </briefdescription>
          <detaileddescription>
<para>Specify this flag to enable linear allocation algorithm, which always creates new allocations after last one and doesn&apos;t reuse space from allocations freed in between. It trades memory consumption for simplified algorithm and data structure, which has better performance and uses less memory for metadata.</para>
<para>By using this flag, you can achieve behavior of free-at-once, stack, ring buffer, and double stack. For details, see documentation chapter <ref refid="custom_memory_pools_1linear_algorithm" kindref="member">Linear allocation algorithm</ref>. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__virtual_1gga88bcf8c1cd3bb1610ff7343811c65bcaaf9487467136e1a9e371894dc3a7c4844" prot="public">
          <name>VMA_VIRTUAL_BLOCK_CREATE_ALGORITHM_MASK</name>
          <initializer>=
        VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT</initializer>
          <briefdescription>
<para>Bit mask to extract only `ALGORITHM` bits from entire set of flags. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__virtual_1gga88bcf8c1cd3bb1610ff7343811c65bcaa5fc0d333c3d5687a8bbf57df9b377a87" prot="public">
          <name>VMA_VIRTUAL_BLOCK_CREATE_FLAG_BITS_MAX_ENUM</name>
          <initializer>= 0x7FFFFFFF</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Flags to be passed as <ref refid="struct_vma_virtual_block_create_info_1aaab9bf7e2d228c02ab6d90a72a6e6912" kindref="member">VmaVirtualBlockCreateInfo::flags</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="753" column="1" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="754" bodyend="774"/>
      </memberdef>
      <memberdef kind="enum" id="group__group__virtual_1ga2e9c64d405b14156fea7e10c4ad06cb6" prot="public" static="no" strong="no">
        <type></type>
        <name>VmaVirtualAllocationCreateFlagBits</name>
        <enumvalue id="group__group__virtual_1gga2e9c64d405b14156fea7e10c4ad06cb6a9524a329a55b5ec390d57d90b67ad78e" prot="public">
          <name>VMA_VIRTUAL_ALLOCATION_CREATE_UPPER_ADDRESS_BIT</name>
          <initializer>= VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT</initializer>
          <briefdescription>
<para>Allocation will be created from upper stack in a double stack pool. </para>
          </briefdescription>
          <detaileddescription>
<para>This flag is only allowed for virtual blocks created with <ref refid="group__group__virtual_1gga88bcf8c1cd3bb1610ff7343811c65bcaae6423e2fa2f3c9211b21c819e3f10f96" kindref="member">VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT</ref> flag. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__virtual_1gga2e9c64d405b14156fea7e10c4ad06cb6ae2a9591a62b5e3b1bdcbc81c6188a1bf" prot="public">
          <name>VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</name>
          <initializer>= VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</initializer>
          <briefdescription>
<para>Allocation strategy that tries to minimize memory usage. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__virtual_1gga2e9c64d405b14156fea7e10c4ad06cb6a562d10a46012719d33167d3dc5dbbf9b" prot="public">
          <name>VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</name>
          <initializer>= VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</initializer>
          <briefdescription>
<para>Allocation strategy that tries to minimize allocation time. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__virtual_1gga2e9c64d405b14156fea7e10c4ad06cb6a3bb82d2aedd587a64846a1d7778852e6" prot="public">
          <name>VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</name>
          <initializer>= VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Allocation strategy that chooses always the lowest offset in available space. This is not the most efficient strategy but achieves highly packed data. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__virtual_1gga2e9c64d405b14156fea7e10c4ad06cb6ac5b5e45c335368d18df59c9f27df17e3" prot="public">
          <name>VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MASK</name>
          <initializer>= VMA_ALLOCATION_CREATE_STRATEGY_MASK</initializer>
          <briefdescription>
<para>A bit mask to extract only `STRATEGY` bits from entire set of flags. </para>
          </briefdescription>
          <detaileddescription>
<para>These strategy flags are binary compatible with equivalent flags in <ref refid="group__group__alloc_1gad9889c10c798b040d59c92f257cae597" kindref="member">VmaAllocationCreateFlagBits</ref>. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__virtual_1gga2e9c64d405b14156fea7e10c4ad06cb6ac1163c03ea837fa663462dc286d6a1a9" prot="public">
          <name>VMA_VIRTUAL_ALLOCATION_CREATE_FLAG_BITS_MAX_ENUM</name>
          <initializer>= 0x7FFFFFFF</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Flags to be passed as <ref refid="struct_vma_virtual_allocation_create_info_1ab10e16956cc4bf20ced9de77d1129ea4" kindref="member">VmaVirtualAllocationCreateInfo::flags</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="779" column="1" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="780" bodyend="803"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="group__group__init_1gafd73b95e737ee7e76f827cb5472f559f" prot="public" static="no">
        <type>enum <ref refid="group__group__init_1ga4f87c9100d154a65a4ad495f7763cf7c" kindref="member">VmaAllocatorCreateFlagBits</ref></type>
        <definition>typedef enum VmaAllocatorCreateFlagBits VmaAllocatorCreateFlagBits</definition>
        <argsstring></argsstring>
        <name>VmaAllocatorCreateFlagBits</name>
        <briefdescription>
<para>Flags for created <ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="428" column="28"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__init_1gacfe6863e160722c2c1bbcf7573fddc4d" prot="public" static="no">
        <type>VkFlags</type>
        <definition>typedef VkFlags VmaAllocatorCreateFlags</definition>
        <argsstring></argsstring>
        <name>VmaAllocatorCreateFlags</name>
        <briefdescription>
<para>See <ref refid="group__group__init_1ga4f87c9100d154a65a4ad495f7763cf7c" kindref="member">VmaAllocatorCreateFlagBits</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="430" column="17" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="430" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1ga806e8499dde802e59eb72a1dc811c35f" prot="public" static="no">
        <type>enum <ref refid="group__group__alloc_1gaa5846affa1e9da3800e3e78fae2305cc" kindref="member">VmaMemoryUsage</ref></type>
        <definition>typedef enum VmaMemoryUsage VmaMemoryUsage</definition>
        <argsstring></argsstring>
        <name>VmaMemoryUsage</name>
        <briefdescription>
<para>Intended usage of the allocated memory. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="519" column="16"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1ga4fceecc301f4064dc808d3cd6c038941" prot="public" static="no">
        <type>enum <ref refid="group__group__alloc_1gad9889c10c798b040d59c92f257cae597" kindref="member">VmaAllocationCreateFlagBits</ref></type>
        <definition>typedef enum VmaAllocationCreateFlagBits VmaAllocationCreateFlagBits</definition>
        <argsstring></argsstring>
        <name>VmaAllocationCreateFlagBits</name>
        <briefdescription>
<para>Flags to be passed as <ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">VmaAllocationCreateInfo::flags</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="651" column="29"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1ga5225e5e11f8376f6a31a1791f3d6e817" prot="public" static="no">
        <type>VkFlags</type>
        <definition>typedef VkFlags VmaAllocationCreateFlags</definition>
        <argsstring></argsstring>
        <name>VmaAllocationCreateFlags</name>
        <briefdescription>
<para>See <ref refid="group__group__alloc_1gad9889c10c798b040d59c92f257cae597" kindref="member">VmaAllocationCreateFlagBits</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="653" column="17" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="653" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1ga4d4f2efc2509157a9e4ecd4fd7942303" prot="public" static="no">
        <type>enum <ref refid="group__group__alloc_1ga9a7c45f9c863695d98c83fa5ac940fe7" kindref="member">VmaPoolCreateFlagBits</ref></type>
        <definition>typedef enum VmaPoolCreateFlagBits VmaPoolCreateFlagBits</definition>
        <argsstring></argsstring>
        <name>VmaPoolCreateFlagBits</name>
        <briefdescription>
<para>Flags to be passed as <ref refid="struct_vma_pool_create_info_1a8405139f63d078340ae74513a59f5446" kindref="member">VmaPoolCreateInfo::flags</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="696" column="23"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1ga2770e325ea42e087c1b91fdf46d0292a" prot="public" static="no">
        <type>VkFlags</type>
        <definition>typedef VkFlags VmaPoolCreateFlags</definition>
        <argsstring></argsstring>
        <name>VmaPoolCreateFlags</name>
        <briefdescription>
<para>Flags to be passed as <ref refid="struct_vma_pool_create_info_1a8405139f63d078340ae74513a59f5446" kindref="member">VmaPoolCreateInfo::flags</ref>. See <ref refid="group__group__alloc_1ga9a7c45f9c863695d98c83fa5ac940fe7" kindref="member">VmaPoolCreateFlagBits</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="698" column="17" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="698" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1ga13415cc0b443353a7b5abda300b833fc" prot="public" static="no">
        <type>enum <ref refid="group__group__alloc_1ga6552a65b71d16f378c6994b3ceaef50c" kindref="member">VmaDefragmentationFlagBits</ref></type>
        <definition>typedef enum VmaDefragmentationFlagBits VmaDefragmentationFlagBits</definition>
        <argsstring></argsstring>
        <name>VmaDefragmentationFlagBits</name>
        <briefdescription>
<para>Flags to be passed as <ref refid="struct_vma_defragmentation_info_1a3e23080c978ecf3abb3180f5b2069da7" kindref="member">VmaDefragmentationInfo::flags</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="730" column="28"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1ga88a77cef37e5d3c4fc9eb328885d048d" prot="public" static="no">
        <type>VkFlags</type>
        <definition>typedef VkFlags VmaDefragmentationFlags</definition>
        <argsstring></argsstring>
        <name>VmaDefragmentationFlags</name>
        <briefdescription>
<para>See <ref refid="group__group__alloc_1ga6552a65b71d16f378c6994b3ceaef50c" kindref="member">VmaDefragmentationFlagBits</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="732" column="17" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="732" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1ga2ea666deeb3c2c74806a097e27cdb4a1" prot="public" static="no">
        <type>enum <ref refid="group__group__alloc_1gada9e3861caf96f08894b0bcc160ec257" kindref="member">VmaDefragmentationMoveOperation</ref></type>
        <definition>typedef enum VmaDefragmentationMoveOperation VmaDefragmentationMoveOperation</definition>
        <argsstring></argsstring>
        <name>VmaDefragmentationMoveOperation</name>
        <briefdescription>
<para>Operation performed on single defragmentation move. See structure <ref refid="struct_vma_defragmentation_move" kindref="compound">VmaDefragmentationMove</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="743" column="33"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__virtual_1ga0860ba1c0a67178fae4aecb63a78573e" prot="public" static="no">
        <type>enum <ref refid="group__group__virtual_1ga88bcf8c1cd3bb1610ff7343811c65bca" kindref="member">VmaVirtualBlockCreateFlagBits</ref></type>
        <definition>typedef enum VmaVirtualBlockCreateFlagBits VmaVirtualBlockCreateFlagBits</definition>
        <argsstring></argsstring>
        <name>VmaVirtualBlockCreateFlagBits</name>
        <briefdescription>
<para>Flags to be passed as <ref refid="struct_vma_virtual_block_create_info_1aaab9bf7e2d228c02ab6d90a72a6e6912" kindref="member">VmaVirtualBlockCreateInfo::flags</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="774" column="31"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__virtual_1ga4e49c2f0ab7f6b4868833e5bac78d91e" prot="public" static="no">
        <type>VkFlags</type>
        <definition>typedef VkFlags VmaVirtualBlockCreateFlags</definition>
        <argsstring></argsstring>
        <name>VmaVirtualBlockCreateFlags</name>
        <briefdescription>
<para>Flags to be passed as <ref refid="struct_vma_virtual_block_create_info_1aaab9bf7e2d228c02ab6d90a72a6e6912" kindref="member">VmaVirtualBlockCreateInfo::flags</ref>. See <ref refid="group__group__virtual_1ga88bcf8c1cd3bb1610ff7343811c65bca" kindref="member">VmaVirtualBlockCreateFlagBits</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="776" column="17" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="776" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__virtual_1ga936815e64946a6b6d812d08d10184c23" prot="public" static="no">
        <type>enum <ref refid="group__group__virtual_1ga2e9c64d405b14156fea7e10c4ad06cb6" kindref="member">VmaVirtualAllocationCreateFlagBits</ref></type>
        <definition>typedef enum VmaVirtualAllocationCreateFlagBits VmaVirtualAllocationCreateFlagBits</definition>
        <argsstring></argsstring>
        <name>VmaVirtualAllocationCreateFlagBits</name>
        <briefdescription>
<para>Flags to be passed as <ref refid="struct_vma_virtual_allocation_create_info_1ab10e16956cc4bf20ced9de77d1129ea4" kindref="member">VmaVirtualAllocationCreateInfo::flags</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="803" column="36"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__virtual_1gae96ffc099bf898257fb19e9410ed08a7" prot="public" static="no">
        <type>VkFlags</type>
        <definition>typedef VkFlags VmaVirtualAllocationCreateFlags</definition>
        <argsstring></argsstring>
        <name>VmaVirtualAllocationCreateFlags</name>
        <briefdescription>
<para>Flags to be passed as <ref refid="struct_vma_virtual_allocation_create_info_1ab10e16956cc4bf20ced9de77d1129ea4" kindref="member">VmaVirtualAllocationCreateInfo::flags</ref>. See <ref refid="group__group__virtual_1ga2e9c64d405b14156fea7e10c4ad06cb6" kindref="member">VmaVirtualAllocationCreateFlagBits</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="805" column="17" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="805" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__init_1gaaf884ddf34d1bb3be8365594d3882a0b" prot="public" static="no">
        <type>void(VKAPI_PTR *</type>
        <definition>typedef void(VKAPI_PTR * PFN_vmaAllocateDeviceMemoryFunction) (VmaAllocator VMA_NOT_NULL allocator, uint32_t memoryType, VkDeviceMemory VMA_NOT_NULL_NON_DISPATCHABLE memory, VkDeviceSize size, void *VMA_NULLABLE pUserData)</definition>
        <argsstring>)(VmaAllocator VMA_NOT_NULL allocator, uint32_t memoryType, VkDeviceMemory VMA_NOT_NULL_NON_DISPATCHABLE memory, VkDeviceSize size, void *VMA_NULLABLE pUserData)</argsstring>
        <name>PFN_vmaAllocateDeviceMemoryFunction</name>
        <briefdescription>
<para>Callback function called after successful vkAllocateMemory. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="917" column="9" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="917" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__init_1ga786c0d8679f6fd36ce796a19cc80afbe" prot="public" static="no">
        <type>void(VKAPI_PTR *</type>
        <definition>typedef void(VKAPI_PTR * PFN_vmaFreeDeviceMemoryFunction) (VmaAllocator VMA_NOT_NULL allocator, uint32_t memoryType, VkDeviceMemory VMA_NOT_NULL_NON_DISPATCHABLE memory, VkDeviceSize size, void *VMA_NULLABLE pUserData)</definition>
        <argsstring>)(VmaAllocator VMA_NOT_NULL allocator, uint32_t memoryType, VkDeviceMemory VMA_NOT_NULL_NON_DISPATCHABLE memory, VkDeviceSize size, void *VMA_NULLABLE pUserData)</argsstring>
        <name>PFN_vmaFreeDeviceMemoryFunction</name>
        <briefdescription>
<para>Callback function called before vkFreeMemory. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="925" column="9" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="925" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__init_1ga77692d3c8770ea8882d573206bd27b2b" prot="public" static="no">
        <type>struct <ref refid="struct_vma_device_memory_callbacks" kindref="compound">VmaDeviceMemoryCallbacks</ref></type>
        <definition>typedef struct VmaDeviceMemoryCallbacks VmaDeviceMemoryCallbacks</definition>
        <argsstring></argsstring>
        <name>VmaDeviceMemoryCallbacks</name>
        <briefdescription>
<para>Set of callbacks that the library will call for `vkAllocateMemory` and `vkFreeMemory`. </para>
        </briefdescription>
        <detaileddescription>
<para>Provided for informative purpose, e.g. to gather statistics about number of allocations or total amount of memory allocated in Vulkan.</para>
<para>Used in <ref refid="struct_vma_allocator_create_info_1afbb24551124b16bdaa29f92eb96b8c56" kindref="member">VmaAllocatorCreateInfo::pDeviceMemoryCallbacks</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="947" column="26"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__init_1gabb0a8e3b5040d847571cca6c7f9a8074" prot="public" static="no">
        <type>struct <ref refid="struct_vma_vulkan_functions" kindref="compound">VmaVulkanFunctions</ref></type>
        <definition>typedef struct VmaVulkanFunctions VmaVulkanFunctions</definition>
        <argsstring></argsstring>
        <name>VmaVulkanFunctions</name>
        <briefdescription>
<para>Pointers to some Vulkan functions - a subset used by the library. </para>
        </briefdescription>
        <detaileddescription>
<para>Used in <ref refid="struct_vma_allocator_create_info_1a5e45da0879451e58bee2f3a975f228f5" kindref="member">VmaAllocatorCreateInfo::pVulkanFunctions</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="997" column="20"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__init_1gaad9652301d33759b83e52d4f3605a14a" prot="public" static="no">
        <type>struct <ref refid="struct_vma_allocator_create_info" kindref="compound">VmaAllocatorCreateInfo</ref></type>
        <definition>typedef struct VmaAllocatorCreateInfo VmaAllocatorCreateInfo</definition>
        <argsstring></argsstring>
        <name>VmaAllocatorCreateInfo</name>
        <briefdescription>
<para>Description of a Allocator to be created. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1076" column="24"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__init_1ga1988031b0223fdbd564250fa1edd942c" prot="public" static="no">
        <type>struct <ref refid="struct_vma_allocator_info" kindref="compound">VmaAllocatorInfo</ref></type>
        <definition>typedef struct VmaAllocatorInfo VmaAllocatorInfo</definition>
        <argsstring></argsstring>
        <name>VmaAllocatorInfo</name>
        <briefdescription>
<para>Information about existing <ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> object. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1096" column="18"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__stats_1gac94bd1a382a3922ddc8de3af4d3ddd06" prot="public" static="no">
        <type>struct <ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref></type>
        <definition>typedef struct VmaStatistics VmaStatistics</definition>
        <argsstring></argsstring>
        <name>VmaStatistics</name>
        <briefdescription>
<para>Calculated statistics of memory usage e.g. in a specific memory type, heap, custom pool, or total. </para>
        </briefdescription>
        <detaileddescription>
<para>These are fast to calculate. See functions: <ref refid="group__group__stats_1ga620eaa8a9d919860f7deaf4d0148b2a1" kindref="member">vmaGetHeapBudgets()</ref>, <ref refid="group__group__stats_1ga7e489a68f893dbefc78a6ac9413c4220" kindref="member">vmaGetPoolStatistics()</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1134" column="15"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__stats_1ga9ab0c535a6ca655dc63b8609ab4b8394" prot="public" static="no">
        <type>struct <ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref></type>
        <definition>typedef struct VmaDetailedStatistics VmaDetailedStatistics</definition>
        <argsstring></argsstring>
        <name>VmaDetailedStatistics</name>
        <briefdescription>
<para>More detailed statistics than <ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>These are slower to calculate. Use for debugging purposes. See functions: <ref refid="group__group__stats_1gad176279c8da8f50399674b2ef03ca866" kindref="member">vmaCalculateStatistics()</ref>, <ref refid="group__group__stats_1ga54b57aa8f511406711f4b918028d8f60" kindref="member">vmaCalculatePoolStatistics()</ref>.</para>
<para>Previous version of the statistics API provided averages, but they have been removed because they can be easily calculated as:</para>
<para><programlisting><codeline><highlight class="normal">VkDeviceSize<sp/>allocationSizeAvg<sp/>=<sp/>detailedStats.statistics.allocationBytes<sp/>/<sp/>detailedStats.statistics.allocationCount;</highlight></codeline>
<codeline><highlight class="normal">VkDeviceSize<sp/>unusedBytes<sp/>=<sp/>detailedStats.statistics.blockBytes<sp/>-<sp/>detailedStats.statistics.allocationBytes;</highlight></codeline>
<codeline><highlight class="normal">VkDeviceSize<sp/>unusedRangeSizeAvg<sp/>=<sp/>unusedBytes<sp/>/<sp/>detailedStats.unusedRangeCount;</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1164" column="23"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__stats_1ga68916e729e55d513f88ffafbadddb770" prot="public" static="no">
        <type>struct <ref refid="struct_vma_total_statistics" kindref="compound">VmaTotalStatistics</ref></type>
        <definition>typedef struct VmaTotalStatistics VmaTotalStatistics</definition>
        <argsstring></argsstring>
        <name>VmaTotalStatistics</name>
        <briefdescription>
<para>General statistics from current state of the Allocator - total memory usage across all memory heaps and types. </para>
        </briefdescription>
        <detaileddescription>
<para>These are slower to calculate. Use for debugging purposes. See function <ref refid="group__group__stats_1gad176279c8da8f50399674b2ef03ca866" kindref="member">vmaCalculateStatistics()</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1177" column="20"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__stats_1gaa078667e71b1ef24e87a6a30d128381d" prot="public" static="no">
        <type>struct <ref refid="struct_vma_budget" kindref="compound">VmaBudget</ref></type>
        <definition>typedef struct VmaBudget VmaBudget</definition>
        <argsstring></argsstring>
        <name>VmaBudget</name>
        <briefdescription>
<para>Statistics of current memory usage and available budget for a specific memory heap. </para>
        </briefdescription>
        <detaileddescription>
<para>These are fast to calculate. See function <ref refid="group__group__stats_1ga620eaa8a9d919860f7deaf4d0148b2a1" kindref="member">vmaGetHeapBudgets()</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1208" column="11"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1ga3bf110892ea2fb4649fedb68488d026a" prot="public" static="no">
        <type>struct <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref></type>
        <definition>typedef struct VmaAllocationCreateInfo VmaAllocationCreateInfo</definition>
        <argsstring></argsstring>
        <name>VmaAllocationCreateInfo</name>
        <briefdescription>
<para>Parameters of new <ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>To be used with functions like <ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer()</ref>, <ref refid="group__group__alloc_1gaa76142ae43535c862ad9e194a6e38aaa" kindref="member">vmaCreateImage()</ref>, and many others. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1269" column="25"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1ga1017aa83489c0eee8d2163d2bf253f67" prot="public" static="no">
        <type>struct <ref refid="struct_vma_pool_create_info" kindref="compound">VmaPoolCreateInfo</ref></type>
        <definition>typedef struct VmaPoolCreateInfo VmaPoolCreateInfo</definition>
        <argsstring></argsstring>
        <name>VmaPoolCreateInfo</name>
        <briefdescription>
<para>Describes parameter of created <ref refid="struct_vma_pool" kindref="compound">VmaPool</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1326" column="19"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1ga1cf7774606721026a68aabe3af2e5b50" prot="public" static="no">
        <type>struct <ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref></type>
        <definition>typedef struct VmaAllocationInfo VmaAllocationInfo</definition>
        <argsstring></argsstring>
        <name>VmaAllocationInfo</name>
        <briefdescription>
<para>Parameters of <ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> objects, that can be retrieved using function <ref refid="group__group__alloc_1gab9c96ca6bb55ad9069829fe8355bbb79" kindref="member">vmaGetAllocationInfo()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1393" column="19"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1ga2bf47f96bf92bed2a49461bd9af3acfa" prot="public" static="no">
        <type>struct <ref refid="struct_vma_defragmentation_info" kindref="compound">VmaDefragmentationInfo</ref></type>
        <definition>typedef struct VmaDefragmentationInfo VmaDefragmentationInfo</definition>
        <argsstring></argsstring>
        <name>VmaDefragmentationInfo</name>
        <briefdescription>
<para>Parameters for defragmentation. </para>
        </briefdescription>
        <detaileddescription>
<para>To be used with function <ref refid="group__group__alloc_1ga0cdd7b0b8653745fa95af9e78d919e70" kindref="member">vmaBeginDefragmentation()</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1418" column="24"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1ga563f4b43d3e31ed603d80cacc9ba8589" prot="public" static="no">
        <type>struct <ref refid="struct_vma_defragmentation_move" kindref="compound">VmaDefragmentationMove</ref></type>
        <definition>typedef struct VmaDefragmentationMove VmaDefragmentationMove</definition>
        <argsstring></argsstring>
        <name>VmaDefragmentationMove</name>
        <briefdescription>
<para>Single move of an allocation to be done for defragmentation. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1434" column="24"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1gad6799e8e2b1527abfc84d33bc44aeaf5" prot="public" static="no">
        <type>struct <ref refid="struct_vma_defragmentation_pass_move_info" kindref="compound">VmaDefragmentationPassMoveInfo</ref></type>
        <definition>typedef struct VmaDefragmentationPassMoveInfo VmaDefragmentationPassMoveInfo</definition>
        <argsstring></argsstring>
        <name>VmaDefragmentationPassMoveInfo</name>
        <briefdescription>
<para>Parameters for incremental defragmentation steps. </para>
        </briefdescription>
        <detaileddescription>
<para>To be used with function <ref refid="group__group__alloc_1gacbe4a77fdfa7ea29328d2f940d423ab7" kindref="member">vmaBeginDefragmentationPass()</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1468" column="32"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1gad94034192259c2e34a4d1c5e27810403" prot="public" static="no">
        <type>struct <ref refid="struct_vma_defragmentation_stats" kindref="compound">VmaDefragmentationStats</ref></type>
        <definition>typedef struct VmaDefragmentationStats VmaDefragmentationStats</definition>
        <argsstring></argsstring>
        <name>VmaDefragmentationStats</name>
        <briefdescription>
<para>Statistics returned for defragmentation process in function <ref refid="group__group__alloc_1gae419e366d1c015716165bdfd5aafef6f" kindref="member">vmaEndDefragmentation()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1481" column="25"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__virtual_1ga4753d42d40217a3a652a3cdf253ad773" prot="public" static="no">
        <type>struct <ref refid="struct_vma_virtual_block_create_info" kindref="compound">VmaVirtualBlockCreateInfo</ref></type>
        <definition>typedef struct VmaVirtualBlockCreateInfo VmaVirtualBlockCreateInfo</definition>
        <argsstring></argsstring>
        <name>VmaVirtualBlockCreateInfo</name>
        <briefdescription>
<para>Parameters of created <ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref> object to be passed to <ref refid="group__group__virtual_1ga869baad02bf3b5fb012d61e1a43f92c5" kindref="member">vmaCreateVirtualBlock()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1509" column="27"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__virtual_1gac3c90d80bedc6847a41b82d0e2158c9e" prot="public" static="no">
        <type>struct <ref refid="struct_vma_virtual_allocation_create_info" kindref="compound">VmaVirtualAllocationCreateInfo</ref></type>
        <definition>typedef struct VmaVirtualAllocationCreateInfo VmaVirtualAllocationCreateInfo</definition>
        <argsstring></argsstring>
        <name>VmaVirtualAllocationCreateInfo</name>
        <briefdescription>
<para>Parameters of created virtual allocation to be passed to <ref refid="group__group__virtual_1ga2f6cd8f6b98e754be7016b5860d02dac" kindref="member">vmaVirtualAllocate()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1532" column="32"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__virtual_1ga75bc33ff7cf18c98e101f570dc2a5ebc" prot="public" static="no">
        <type>struct <ref refid="struct_vma_virtual_allocation_info" kindref="compound">VmaVirtualAllocationInfo</ref></type>
        <definition>typedef struct VmaVirtualAllocationInfo VmaVirtualAllocationInfo</definition>
        <argsstring></argsstring>
        <name>VmaVirtualAllocationInfo</name>
        <briefdescription>
<para>Parameters of an existing virtual allocation, returned by <ref refid="group__group__virtual_1ga64b8c2939b82f83fbec507f29a43307b" kindref="member">vmaGetVirtualAllocationInfo()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1552" column="26"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__group__virtual_1ga565936f8d98d225b536a2d9703bc7676" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>VK_DEFINE_NON_DISPATCHABLE_HANDLE</definition>
        <argsstring>(VmaVirtualAllocation)</argsstring>
        <name>VK_DEFINE_NON_DISPATCHABLE_HANDLE</name>
        <param>
          <type><ref refid="struct_vma_virtual_allocation" kindref="compound">VmaVirtualAllocation</ref></type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="890" column="1" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="890" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="group__group__init_1gaf77c946fbecfcc54d02c3d1c1e7e23e7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateAllocator</definition>
        <argsstring>(const VmaAllocatorCreateInfo *VMA_NOT_NULL pCreateInfo, VmaAllocator VMA_NULLABLE *VMA_NOT_NULL pAllocator)</argsstring>
        <name>vmaCreateAllocator</name>
        <param>
          <type>const <ref refid="struct_vma_allocator_create_info" kindref="compound">VmaAllocatorCreateInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pCreateInfo</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocator</declname>
        </param>
        <briefdescription>
<para>Creates <ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> object. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1566" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1566" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__init_1ga0383c8c957625914e9b89bd165ff13f3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaDestroyAllocator</definition>
        <argsstring>(VmaAllocator VMA_NULLABLE allocator)</argsstring>
        <name>vmaDestroyAllocator</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>allocator</declname>
        </param>
        <briefdescription>
<para>Destroys allocator object. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1571" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1571" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__init_1gaacc98daf40a09cddb3ca7940aba9bc3e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaGetAllocatorInfo</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocatorInfo *VMA_NOT_NULL pAllocatorInfo)</argsstring>
        <name>vmaGetAllocatorInfo</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocator_info" kindref="compound">VmaAllocatorInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocatorInfo</declname>
        </param>
        <briefdescription>
<para>Returns information about existing <ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> object - handle to Vulkan device etc. </para>
        </briefdescription>
        <detaileddescription>
<para>It might be useful if you want to keep just the <ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> handle and fetch other required handles to `VkPhysicalDevice`, `VkDevice` etc. every time using this function. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1579" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1579" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__init_1gadcc2ca5c2f692c8c6b77bc7bcee97751" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaGetPhysicalDeviceProperties</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, const VkPhysicalDeviceProperties *VMA_NULLABLE *VMA_NOT_NULL ppPhysicalDeviceProperties)</argsstring>
        <name>vmaGetPhysicalDeviceProperties</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>const VkPhysicalDeviceProperties *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>ppPhysicalDeviceProperties</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>PhysicalDeviceProperties are fetched from physicalDevice by the allocator. You can access it here, without fetching it again on your own. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1587" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1587" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__init_1ga33698c6107c0da349c1dbf43615284df" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaGetMemoryProperties</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, const VkPhysicalDeviceMemoryProperties *VMA_NULLABLE *VMA_NOT_NULL ppPhysicalDeviceMemoryProperties)</argsstring>
        <name>vmaGetMemoryProperties</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>const VkPhysicalDeviceMemoryProperties *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>ppPhysicalDeviceMemoryProperties</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>PhysicalDeviceMemoryProperties are fetched from physicalDevice by the allocator. You can access it here, without fetching it again on your own. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1595" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1595" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__init_1ga27cc36c466d171c3e4e0d062c48dc1e6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaGetMemoryTypeProperties</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, uint32_t memoryTypeIndex, VkMemoryPropertyFlags *VMA_NOT_NULL pFlags)</argsstring>
        <name>vmaGetMemoryTypeProperties</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>memoryTypeIndex</declname>
        </param>
        <param>
          <type>VkMemoryPropertyFlags *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pFlags</declname>
        </param>
        <briefdescription>
<para>Given Memory Type Index, returns Property Flags of this memory type. </para>
        </briefdescription>
        <detaileddescription>
<para>This is just a convenience function. Same information can be obtained using <ref refid="group__group__init_1ga33698c6107c0da349c1dbf43615284df" kindref="member">vmaGetMemoryProperties()</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1605" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1605" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__init_1gab8e037d09b55f13312f792e0cd98cc03" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaSetCurrentFrameIndex</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, uint32_t frameIndex)</argsstring>
        <name>vmaSetCurrentFrameIndex</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>frameIndex</declname>
        </param>
        <briefdescription>
<para>Sets index of the current frame. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1612" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1612" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__stats_1gad176279c8da8f50399674b2ef03ca866" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaCalculateStatistics</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaTotalStatistics *VMA_NOT_NULL pStats)</argsstring>
        <name>vmaCalculateStatistics</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_total_statistics" kindref="compound">VmaTotalStatistics</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pStats</declname>
        </param>
        <briefdescription>
<para>Retrieves statistics from current state of the Allocator. </para>
        </briefdescription>
        <detaileddescription>
<para>This function is called &quot;calculate&quot; not &quot;get&quot; because it has to traverse all internal data structures, so it may be quite slow. Use it for debugging purposes. For faster but more brief statistics suitable to be called every frame or every allocation, use <ref refid="group__group__stats_1ga620eaa8a9d919860f7deaf4d0148b2a1" kindref="member">vmaGetHeapBudgets()</ref>.</para>
<para>Note that when using allocator from multiple threads, returned information may immediately become outdated. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1633" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1633" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__stats_1ga620eaa8a9d919860f7deaf4d0148b2a1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaGetHeapBudgets</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaBudget *VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(&quot;VkPhysicalDeviceMemoryProperties::memoryHeapCount&quot;) pBudgets)</argsstring>
        <name>vmaGetHeapBudgets</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_budget" kindref="compound">VmaBudget</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref> <ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(&quot;VkPhysicalDeviceMemoryProperties::memoryHeapCount&quot;)</type>
          <declname>pBudgets</declname>
        </param>
        <briefdescription>
<para>Retrieves information about current memory usage and budget for all memory heaps. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pBudgets</parametername>
</parameternamelist>
<parameterdescription>
<para>Must point to array with number of elements at least equal to number of memory heaps in physical device used.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This function is called &quot;get&quot; not &quot;calculate&quot; because it is very fast, suitable to be called every frame or every allocation. For more detailed statistics use <ref refid="group__group__stats_1gad176279c8da8f50399674b2ef03ca866" kindref="member">vmaCalculateStatistics()</ref>.</para>
<para>Note that when using allocator from multiple threads, returned information may immediately become outdated. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1648" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1648" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga03cee2bfc7fef20382fa56f5870f3b2f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaFindMemoryTypeIndex</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, uint32_t memoryTypeBits, const VmaAllocationCreateInfo *VMA_NOT_NULL pAllocationCreateInfo, uint32_t *VMA_NOT_NULL pMemoryTypeIndex)</argsstring>
        <name>vmaFindMemoryTypeIndex</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>memoryTypeBits</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocationCreateInfo</declname>
        </param>
        <param>
          <type>uint32_t *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pMemoryTypeIndex</declname>
        </param>
        <briefdescription>
<para>Helps to find memoryTypeIndex, given memoryTypeBits and <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>This algorithm tries to find a memory type that:</para>
<para><itemizedlist>
<listitem><para>Is allowed by memoryTypeBits.</para>
</listitem><listitem><para>Contains all the flags from pAllocationCreateInfo-&gt;requiredFlags.</para>
</listitem><listitem><para>Matches intended usage.</para>
</listitem><listitem><para>Has as many flags from pAllocationCreateInfo-&gt;preferredFlags as possible.</para>
</listitem></itemizedlist>
</para>
<para><simplesect kind="return"><para>Returns VK_ERROR_FEATURE_NOT_PRESENT if not found. Receiving such result from this function or any other allocating function probably means that your device doesn&apos;t support any memory type with requested features for the specific type of resource you want to use it for. Please check parameters of your resource, like image layout (OPTIMAL versus LINEAR) or mip level count. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1675" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1675" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga723f5683b363c306bf860dab1861f299" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaFindMemoryTypeIndexForBufferInfo</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, const VkBufferCreateInfo *VMA_NOT_NULL pBufferCreateInfo, const VmaAllocationCreateInfo *VMA_NOT_NULL pAllocationCreateInfo, uint32_t *VMA_NOT_NULL pMemoryTypeIndex)</argsstring>
        <name>vmaFindMemoryTypeIndexForBufferInfo</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>const VkBufferCreateInfo *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pBufferCreateInfo</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocationCreateInfo</declname>
        </param>
        <param>
          <type>uint32_t *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pMemoryTypeIndex</declname>
        </param>
        <briefdescription>
<para>Helps to find memoryTypeIndex, given VkBufferCreateInfo and <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>It can be useful e.g. to determine value to be used as <ref refid="struct_vma_pool_create_info_1a596fa76b685d3f1f688f84a709a5b319" kindref="member">VmaPoolCreateInfo::memoryTypeIndex</ref>. It internally creates a temporary, dummy buffer that never has memory bound. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1687" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1687" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gaaf05345771a087328949b485ff2da4db" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaFindMemoryTypeIndexForImageInfo</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, const VkImageCreateInfo *VMA_NOT_NULL pImageCreateInfo, const VmaAllocationCreateInfo *VMA_NOT_NULL pAllocationCreateInfo, uint32_t *VMA_NOT_NULL pMemoryTypeIndex)</argsstring>
        <name>vmaFindMemoryTypeIndexForImageInfo</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>const VkImageCreateInfo *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pImageCreateInfo</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocationCreateInfo</declname>
        </param>
        <param>
          <type>uint32_t *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pMemoryTypeIndex</declname>
        </param>
        <briefdescription>
<para>Helps to find memoryTypeIndex, given VkImageCreateInfo and <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>It can be useful e.g. to determine value to be used as <ref refid="struct_vma_pool_create_info_1a596fa76b685d3f1f688f84a709a5b319" kindref="member">VmaPoolCreateInfo::memoryTypeIndex</ref>. It internally creates a temporary, dummy image that never has memory bound. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1699" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1699" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga250d4f6f4c09a6a03b82323f999c9c4e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreatePool</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, const VmaPoolCreateInfo *VMA_NOT_NULL pCreateInfo, VmaPool VMA_NULLABLE *VMA_NOT_NULL pPool)</argsstring>
        <name>vmaCreatePool</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_pool_create_info" kindref="compound">VmaPoolCreateInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pCreateInfo</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pPool</declname>
        </param>
        <briefdescription>
<para>Allocates Vulkan device memory and creates <ref refid="struct_vma_pool" kindref="compound">VmaPool</ref> object. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para>Allocator object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pCreateInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Parameters of pool to create. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pPool</parametername>
</parameternamelist>
<parameterdescription>
<para>Handle to created pool. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1711" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1711" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gad03da7fd4d8b772bc2a299bc34850d98" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaDestroyPool</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaPool VMA_NULLABLE pool)</argsstring>
        <name>vmaDestroyPool</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pool</declname>
        </param>
        <briefdescription>
<para>Destroys <ref refid="struct_vma_pool" kindref="compound">VmaPool</ref> object and frees Vulkan device memory. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1718" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1718" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__stats_1ga7e489a68f893dbefc78a6ac9413c4220" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaGetPoolStatistics</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaPool VMA_NOT_NULL pool, VmaStatistics *VMA_NOT_NULL pPoolStats)</argsstring>
        <name>vmaGetPoolStatistics</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pool</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pPoolStats</declname>
        </param>
        <briefdescription>
<para>Retrieves statistics of existing <ref refid="struct_vma_pool" kindref="compound">VmaPool</ref> object. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para>Allocator object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pool</parametername>
</parameternamelist>
<parameterdescription>
<para>Pool object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pPoolStats</parametername>
</parameternamelist>
<parameterdescription>
<para>Statistics of specified pool. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1735" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1735" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__stats_1ga54b57aa8f511406711f4b918028d8f60" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaCalculatePoolStatistics</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaPool VMA_NOT_NULL pool, VmaDetailedStatistics *VMA_NOT_NULL pPoolStats)</argsstring>
        <name>vmaCalculatePoolStatistics</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pool</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pPoolStats</declname>
        </param>
        <briefdescription>
<para>Retrieves detailed statistics of existing <ref refid="struct_vma_pool" kindref="compound">VmaPool</ref> object. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para>Allocator object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pool</parametername>
</parameternamelist>
<parameterdescription>
<para>Pool object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pPoolStats</parametername>
</parameternamelist>
<parameterdescription>
<para>Statistics of specified pool. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1746" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1746" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga19e2e174d6acb8abfdeb8c200517a468" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaCheckPoolCorruption</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaPool VMA_NOT_NULL pool)</argsstring>
        <name>vmaCheckPoolCorruption</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pool</declname>
        </param>
        <briefdescription>
<para>Checks magic number in margins around all allocations in given memory pool in search for corruptions. </para>
        </briefdescription>
        <detaileddescription>
<para>Corruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero, `VMA_DEBUG_MARGIN` is defined to nonzero and the pool is created in memory type that is `HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](<ref refid="debugging_memory_usage_1debugging_memory_usage_corruption_detection" kindref="member">Corruption detection</ref>).</para>
<para>Possible return values:</para>
<para><itemizedlist>
<listitem><para>`VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for specified pool.</para>
</listitem><listitem><para>`VK_SUCCESS` - corruption detection has been performed and succeeded.</para>
</listitem><listitem><para>`VK_ERROR_UNKNOWN` - corruption detection has been performed and found memory corruptions around one of the allocations. `VMA_ASSERT` is also fired in that case.</para>
</listitem><listitem><para>Other value: Error returned by Vulkan, e.g. memory mapping failure. </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1772" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1772" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga77b2f609887eabcc36ab90e94230acbf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaGetPoolName</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaPool VMA_NOT_NULL pool, const char *VMA_NULLABLE *VMA_NOT_NULL ppName)</argsstring>
        <name>vmaGetPoolName</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pool</declname>
        </param>
        <param>
          <type>const char *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>ppName</declname>
        </param>
        <briefdescription>
<para>Retrieves name of a custom pool. </para>
        </briefdescription>
        <detaileddescription>
<para>After the call `ppName` is either null or points to an internally-owned null-terminated string containing name of the pool that was previously set. The pointer becomes invalid when the pool is destroyed or its name is changed using <ref refid="group__group__alloc_1gac0322f7ac6c6425492aec787397d5597" kindref="member">vmaSetPoolName()</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1782" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1782" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gac0322f7ac6c6425492aec787397d5597" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaSetPoolName</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaPool VMA_NOT_NULL pool, const char *VMA_NULLABLE pName)</argsstring>
        <name>vmaSetPoolName</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pool</declname>
        </param>
        <param>
          <type>const char *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pName</declname>
        </param>
        <briefdescription>
<para>Sets name of a custom pool. </para>
        </briefdescription>
        <detaileddescription>
<para>`pName` can be either null or pointer to a null-terminated string with new name for the pool. Function makes internal copy of the string, so it can be changed or freed immediately after this call. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1792" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1792" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gaf813f55a0667016a8cd68bb4b8b3b30c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemory</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, const VkMemoryRequirements *VMA_NOT_NULL pVkMemoryRequirements, const VmaAllocationCreateInfo *VMA_NOT_NULL pCreateInfo, VmaAllocation VMA_NULLABLE *VMA_NOT_NULL pAllocation, VmaAllocationInfo *VMA_NULLABLE pAllocationInfo)</argsstring>
        <name>vmaAllocateMemory</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>const VkMemoryRequirements *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pVkMemoryRequirements</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pCreateInfo</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocation</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref> *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pAllocationInfo</declname>
        </param>
        <briefdescription>
<para>General purpose memory allocation. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pVkMemoryRequirements</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pCreateInfo</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pAllocation</parametername>
</parameternamelist>
<parameterdescription>
<para>Handle to allocated memory. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pAllocationInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Optional. Information about allocated memory. It can be later fetched using function <ref refid="group__group__alloc_1gab9c96ca6bb55ad9069829fe8355bbb79" kindref="member">vmaGetAllocationInfo()</ref>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
You should free the memory using <ref refid="group__group__alloc_1ga5c9baca5124d440046bbe508f61d2839" kindref="member">vmaFreeMemory()</ref> or <ref refid="group__group__alloc_1ga033c6727ed2efed0745ec24ce01d5e1b" kindref="member">vmaFreeMemoryPages()</ref>.</para>
<para>It is recommended to use <ref refid="group__group__alloc_1gaf7010aa90a4ccdda56f83db8597b9896" kindref="member">vmaAllocateMemoryForBuffer()</ref>, <ref refid="group__group__alloc_1ga4b7f39281cb383c1496b68f97cb7f4c5" kindref="member">vmaAllocateMemoryForImage()</ref>, <ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer()</ref>, <ref refid="group__group__alloc_1gaa76142ae43535c862ad9e194a6e38aaa" kindref="member">vmaCreateImage()</ref> instead whenever possible. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1810" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1810" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gafe6834626398ff26264a94ab7581e150" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemoryPages</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, const VkMemoryRequirements *VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(allocationCount) pVkMemoryRequirements, const VmaAllocationCreateInfo *VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(allocationCount) pCreateInfo, size_t allocationCount, VmaAllocation VMA_NULLABLE *VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(allocationCount) pAllocations, VmaAllocationInfo *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) pAllocationInfo)</argsstring>
        <name>vmaAllocateMemoryPages</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>const VkMemoryRequirements *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref> <ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)</type>
          <declname>pVkMemoryRequirements</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref> <ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)</type>
          <declname>pCreateInfo</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>allocationCount</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref> <ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)</type>
          <declname>pAllocations</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref> *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> <ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)</type>
          <declname>pAllocationInfo</declname>
        </param>
        <briefdescription>
<para>General purpose memory allocation for multiple allocation objects at once. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para>Allocator object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pVkMemoryRequirements</parametername>
</parameternamelist>
<parameterdescription>
<para>Memory requirements for each allocation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pCreateInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Creation parameters for each allocation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>allocationCount</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of allocations to make. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pAllocations</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to array that will be filled with handles to created allocations. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pAllocationInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Optional. Pointer to array that will be filled with parameters of created allocations.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
You should free the memory using <ref refid="group__group__alloc_1ga5c9baca5124d440046bbe508f61d2839" kindref="member">vmaFreeMemory()</ref> or <ref refid="group__group__alloc_1ga033c6727ed2efed0745ec24ce01d5e1b" kindref="member">vmaFreeMemoryPages()</ref>.</para>
<para>Word &quot;pages&quot; is just a suggestion to use this function to allocate pieces of memory needed for sparse binding. It is just a general purpose allocation function able to make multiple allocations at once. It may be internally optimized to be more efficient than calling <ref refid="group__group__alloc_1gaf813f55a0667016a8cd68bb4b8b3b30c" kindref="member">vmaAllocateMemory()</ref> `allocationCount` times.</para>
<para>All allocations are made using same parameters. All of them are created out of the same memory pool and type. If any allocation fails, all allocations already made within this function call are also freed, so that when returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1836" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1836" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gaf7010aa90a4ccdda56f83db8597b9896" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemoryForBuffer</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VkBuffer VMA_NOT_NULL_NON_DISPATCHABLE buffer, const VmaAllocationCreateInfo *VMA_NOT_NULL pCreateInfo, VmaAllocation VMA_NULLABLE *VMA_NOT_NULL pAllocation, VmaAllocationInfo *VMA_NULLABLE pAllocationInfo)</argsstring>
        <name>vmaAllocateMemoryForBuffer</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>VkBuffer <ref refid="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" kindref="member">VMA_NOT_NULL_NON_DISPATCHABLE</ref></type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pCreateInfo</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocation</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref> *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pAllocationInfo</declname>
        </param>
        <briefdescription>
<para>Allocates memory suitable for given `VkBuffer`. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pCreateInfo</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pAllocation</parametername>
</parameternamelist>
<parameterdescription>
<para>Handle to allocated memory. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pAllocationInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Optional. Information about allocated memory. It can be later fetched using function <ref refid="group__group__alloc_1gab9c96ca6bb55ad9069829fe8355bbb79" kindref="member">vmaGetAllocationInfo()</ref>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
It only creates <ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>. To bind the memory to the buffer, use <ref refid="group__group__alloc_1ga7748e60ccc54e240777a848cb260bb19" kindref="member">vmaBindBufferMemory()</ref>.</para>
<para>This is a special-purpose function. In most cases you should use <ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer()</ref>.</para>
<para>You must free the allocation using <ref refid="group__group__alloc_1ga5c9baca5124d440046bbe508f61d2839" kindref="member">vmaFreeMemory()</ref> when no longer needed. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1858" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1858" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga4b7f39281cb383c1496b68f97cb7f4c5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemoryForImage</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VkImage VMA_NOT_NULL_NON_DISPATCHABLE image, const VmaAllocationCreateInfo *VMA_NOT_NULL pCreateInfo, VmaAllocation VMA_NULLABLE *VMA_NOT_NULL pAllocation, VmaAllocationInfo *VMA_NULLABLE pAllocationInfo)</argsstring>
        <name>vmaAllocateMemoryForImage</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>VkImage <ref refid="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" kindref="member">VMA_NOT_NULL_NON_DISPATCHABLE</ref></type>
          <declname>image</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pCreateInfo</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocation</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref> *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pAllocationInfo</declname>
        </param>
        <briefdescription>
<para>Allocates memory suitable for given `VkImage`. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>image</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pCreateInfo</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pAllocation</parametername>
</parameternamelist>
<parameterdescription>
<para>Handle to allocated memory. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pAllocationInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Optional. Information about allocated memory. It can be later fetched using function <ref refid="group__group__alloc_1gab9c96ca6bb55ad9069829fe8355bbb79" kindref="member">vmaGetAllocationInfo()</ref>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
It only creates <ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>. To bind the memory to the buffer, use <ref refid="group__group__alloc_1ga3a5d8d9f2a29b42cf87f0f8dfef591f4" kindref="member">vmaBindImageMemory()</ref>.</para>
<para>This is a special-purpose function. In most cases you should use <ref refid="group__group__alloc_1gaa76142ae43535c862ad9e194a6e38aaa" kindref="member">vmaCreateImage()</ref>.</para>
<para>You must free the allocation using <ref refid="group__group__alloc_1ga5c9baca5124d440046bbe508f61d2839" kindref="member">vmaFreeMemory()</ref> when no longer needed. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1879" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1879" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga5c9baca5124d440046bbe508f61d2839" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaFreeMemory</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, const VmaAllocation VMA_NULLABLE allocation)</argsstring>
        <name>vmaFreeMemory</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>allocation</declname>
        </param>
        <briefdescription>
<para>Frees memory previously allocated using <ref refid="group__group__alloc_1gaf813f55a0667016a8cd68bb4b8b3b30c" kindref="member">vmaAllocateMemory()</ref>, <ref refid="group__group__alloc_1gaf7010aa90a4ccdda56f83db8597b9896" kindref="member">vmaAllocateMemoryForBuffer()</ref>, or <ref refid="group__group__alloc_1ga4b7f39281cb383c1496b68f97cb7f4c5" kindref="member">vmaAllocateMemoryForImage()</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>Passing `VK_NULL_HANDLE` as `allocation` is valid. Such function call is just skipped. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1890" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1890" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga033c6727ed2efed0745ec24ce01d5e1b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaFreeMemoryPages</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, size_t allocationCount, const VmaAllocation VMA_NULLABLE *VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(allocationCount) pAllocations)</argsstring>
        <name>vmaFreeMemoryPages</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>allocationCount</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref> <ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)</type>
          <declname>pAllocations</declname>
        </param>
        <briefdescription>
<para>Frees memory and destroys multiple allocations. </para>
        </briefdescription>
        <detaileddescription>
<para>Word &quot;pages&quot; is just a suggestion to use this function to free pieces of memory used for sparse binding. It is just a general purpose function to free memory and destroy allocations made using e.g. <ref refid="group__group__alloc_1gaf813f55a0667016a8cd68bb4b8b3b30c" kindref="member">vmaAllocateMemory()</ref>, <ref refid="group__group__alloc_1gafe6834626398ff26264a94ab7581e150" kindref="member">vmaAllocateMemoryPages()</ref> and other functions. It may be internally optimized to be more efficient than calling <ref refid="group__group__alloc_1ga5c9baca5124d440046bbe508f61d2839" kindref="member">vmaFreeMemory()</ref> `allocationCount` times.</para>
<para>Allocations in `pAllocations` array can come from any memory pools and types. Passing `VK_NULL_HANDLE` as elements of `pAllocations` array is valid. Such entries are just skipped. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1904" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1904" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gab9c96ca6bb55ad9069829fe8355bbb79" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaGetAllocationInfo</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VmaAllocationInfo *VMA_NOT_NULL pAllocationInfo)</argsstring>
        <name>vmaGetAllocationInfo</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocationInfo</declname>
        </param>
        <briefdescription>
<para>Returns current information about specified allocation. </para>
        </briefdescription>
        <detaileddescription>
<para>Current paramteres of given allocation are returned in `pAllocationInfo`.</para>
<para>Although this function doesn&apos;t lock any mutex, so it should be quite efficient, you should avoid calling it too often. You can retrieve same <ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref> structure while creating your resource, from function <ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer()</ref>, <ref refid="group__group__alloc_1gaa76142ae43535c862ad9e194a6e38aaa" kindref="member">vmaCreateImage()</ref>. You can remember it if you are sure parameters don&apos;t change (e.g. due to defragmentation). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1919" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1919" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gac1f392a3c70a647f0c53a9ddaa7a6f14" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaSetAllocationUserData</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, void *VMA_NULLABLE pUserData)</argsstring>
        <name>vmaSetAllocationUserData</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type>void *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pUserData</declname>
        </param>
        <briefdescription>
<para>Sets pUserData in given allocation to new value. </para>
        </briefdescription>
        <detaileddescription>
<para>The value of pointer `pUserData` is copied to allocation&apos;s `pUserData`. It is opaque, so you can use it however you want - e.g. as a pointer, ordinal number or some handle to you own data. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1930" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1930" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga29b210b1f39e49de844fc7b6944736d7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaSetAllocationName</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, const char *VMA_NULLABLE pName)</argsstring>
        <name>vmaSetAllocationName</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type>const char *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pName</declname>
        </param>
        <briefdescription>
<para>Sets pName in given allocation to new value. </para>
        </briefdescription>
        <detaileddescription>
<para>`pName` must be either null, or pointer to a null-terminated string. The function makes local copy of the string and sets it as allocation&apos;s `pName`. String passed as pName doesn&apos;t need to be valid for whole lifetime of the allocation - you can free it after this call. String previously pointed by allocation&apos;s `pName` is freed from memory. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1943" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1943" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gaf6785483eda8b53561437e05e2177d7b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaGetAllocationMemoryProperties</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VkMemoryPropertyFlags *VMA_NOT_NULL pFlags)</argsstring>
        <name>vmaGetAllocationMemoryProperties</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type>VkMemoryPropertyFlags *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pFlags</declname>
        </param>
        <briefdescription>
<para>Given an allocation, returns Property Flags of its memory type. </para>
        </briefdescription>
        <detaileddescription>
<para>This is just a convenience function. Same information can be obtained using <ref refid="group__group__alloc_1gab9c96ca6bb55ad9069829fe8355bbb79" kindref="member">vmaGetAllocationInfo()</ref> + <ref refid="group__group__init_1ga33698c6107c0da349c1dbf43615284df" kindref="member">vmaGetMemoryProperties()</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1954" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1954" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga13b93ec0ed38ad7232300cb94931c8d2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaMapMemory</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, void *VMA_NULLABLE *VMA_NOT_NULL ppData)</argsstring>
        <name>vmaMapMemory</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type>void *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>ppData</declname>
        </param>
        <briefdescription>
<para>Maps memory represented by given allocation and returns pointer to it. </para>
        </briefdescription>
        <detaileddescription>
<para>Maps memory represented by given allocation to make it accessible to CPU code. When succeeded, `*ppData` contains pointer to first byte of this memory.</para>
<para><simplesect kind="warning"><para>If the allocation is part of a bigger `VkDeviceMemory` block, returned pointer is correctly offsetted to the beginning of region assigned to this particular allocation. Unlike the result of `vkMapMemory`, it points to the allocation, not to the beginning of the whole block. You should not add <ref refid="struct_vma_allocation_info_1a4a3c732388dbdc7a23f9365b00825268" kindref="member">VmaAllocationInfo::offset</ref> to it!</para>
</simplesect>
Mapping is internally reference-counted and synchronized, so despite raw Vulkan function `vkMapMemory()` cannot be used to map same block of `VkDeviceMemory` multiple times simultaneously, it is safe to call this function on allocations assigned to the same memory block. Actual Vulkan memory will be mapped on first mapping and unmapped on last unmapping.</para>
<para>If the function succeeded, you must call <ref refid="group__group__alloc_1gaec4645c1787976e2b50d2dfd31279a2b" kindref="member">vmaUnmapMemory()</ref> to unmap the allocation when mapping is no longer needed or before freeing the allocation, at the latest.</para>
<para>It also safe to call this function multiple times on the same allocation. You must call <ref refid="group__group__alloc_1gaec4645c1787976e2b50d2dfd31279a2b" kindref="member">vmaUnmapMemory()</ref> same number of times as you called <ref refid="group__group__alloc_1ga13b93ec0ed38ad7232300cb94931c8d2" kindref="member">vmaMapMemory()</ref>.</para>
<para>It is also safe to call this function on allocation created with <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" kindref="member">VMA_ALLOCATION_CREATE_MAPPED_BIT</ref> flag. Its memory stays mapped all the time. You must still call <ref refid="group__group__alloc_1gaec4645c1787976e2b50d2dfd31279a2b" kindref="member">vmaUnmapMemory()</ref> same number of times as you called <ref refid="group__group__alloc_1ga13b93ec0ed38ad7232300cb94931c8d2" kindref="member">vmaMapMemory()</ref>. You must not call <ref refid="group__group__alloc_1gaec4645c1787976e2b50d2dfd31279a2b" kindref="member">vmaUnmapMemory()</ref> additional time to free the &quot;0-th&quot; mapping made automatically due to <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" kindref="member">VMA_ALLOCATION_CREATE_MAPPED_BIT</ref> flag.</para>
<para>This function fails when used on allocation made in memory type that is not `HOST_VISIBLE`.</para>
<para>This function doesn&apos;t automatically flush or invalidate caches. If the allocation is made from a memory types that is not `HOST_COHERENT`, you also need to use <ref refid="group__group__alloc_1ga1059764930e85ac377a92b5237b5b919" kindref="member">vmaInvalidateAllocation()</ref> / <ref refid="group__group__alloc_1gab8093faf3afb114596d964d4bd24cb4a" kindref="member">vmaFlushAllocation()</ref>, as required by Vulkan specification. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1996" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1996" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gaec4645c1787976e2b50d2dfd31279a2b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaUnmapMemory</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation)</argsstring>
        <name>vmaUnmapMemory</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <briefdescription>
<para>Unmaps memory represented by given allocation, mapped previously using <ref refid="group__group__alloc_1ga13b93ec0ed38ad7232300cb94931c8d2" kindref="member">vmaMapMemory()</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>For details, see description of <ref refid="group__group__alloc_1ga13b93ec0ed38ad7232300cb94931c8d2" kindref="member">vmaMapMemory()</ref>.</para>
<para>This function doesn&apos;t automatically flush or invalidate caches. If the allocation is made from a memory types that is not `HOST_COHERENT`, you also need to use <ref refid="group__group__alloc_1ga1059764930e85ac377a92b5237b5b919" kindref="member">vmaInvalidateAllocation()</ref> / <ref refid="group__group__alloc_1gab8093faf3afb114596d964d4bd24cb4a" kindref="member">vmaFlushAllocation()</ref>, as required by Vulkan specification. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2009" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2009" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gab8093faf3afb114596d964d4bd24cb4a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaFlushAllocation</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VkDeviceSize offset, VkDeviceSize size)</argsstring>
        <name>vmaFlushAllocation</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type>VkDeviceSize</type>
          <declname>offset</declname>
        </param>
        <param>
          <type>VkDeviceSize</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Flushes memory of given allocation. </para>
        </briefdescription>
        <detaileddescription>
<para>Calls `vkFlushMappedMemoryRanges()` for memory associated with given range of given allocation. It needs to be called after writing to a mapped memory for memory types that are not `HOST_COHERENT`. Unmap operation doesn&apos;t do that automatically.</para>
<para><itemizedlist>
<listitem><para>`offset` must be relative to the beginning of allocation.</para>
</listitem><listitem><para>`size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation.</para>
</listitem><listitem><para>`offset` and `size` don&apos;t have to be aligned. They are internally rounded down/up to multiply of `nonCoherentAtomSize`.</para>
</listitem><listitem><para>If `size` is 0, this call is ignored.</para>
</listitem><listitem><para>If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`, this call is ignored.</para>
</listitem></itemizedlist>
</para>
<para>Warning! `offset` and `size` are relative to the contents of given `allocation`. If you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively. Do not pass allocation&apos;s offset as `offset`!!!</para>
<para>This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is called, otherwise `VK_SUCCESS`. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2034" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2034" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga1059764930e85ac377a92b5237b5b919" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaInvalidateAllocation</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VkDeviceSize offset, VkDeviceSize size)</argsstring>
        <name>vmaInvalidateAllocation</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type>VkDeviceSize</type>
          <declname>offset</declname>
        </param>
        <param>
          <type>VkDeviceSize</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Invalidates memory of given allocation. </para>
        </briefdescription>
        <detaileddescription>
<para>Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given range of given allocation. It needs to be called before reading from a mapped memory for memory types that are not `HOST_COHERENT`. Map operation doesn&apos;t do that automatically.</para>
<para><itemizedlist>
<listitem><para>`offset` must be relative to the beginning of allocation.</para>
</listitem><listitem><para>`size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation.</para>
</listitem><listitem><para>`offset` and `size` don&apos;t have to be aligned. They are internally rounded down/up to multiply of `nonCoherentAtomSize`.</para>
</listitem><listitem><para>If `size` is 0, this call is ignored.</para>
</listitem><listitem><para>If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`, this call is ignored.</para>
</listitem></itemizedlist>
</para>
<para>Warning! `offset` and `size` are relative to the contents of given `allocation`. If you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively. Do not pass allocation&apos;s offset as `offset`!!!</para>
<para>This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is called, otherwise `VK_SUCCESS`. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2061" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2061" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga09b0a57c5c45949a324ac7c0a4ec42d5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaFlushAllocations</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, uint32_t allocationCount, const VmaAllocation VMA_NOT_NULL *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) allocations, const VkDeviceSize *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) offsets, const VkDeviceSize *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) sizes)</argsstring>
        <name>vmaFlushAllocations</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>allocationCount</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref> *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> <ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)</type>
          <declname>allocations</declname>
        </param>
        <param>
          <type>const VkDeviceSize *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> <ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)</type>
          <declname>offsets</declname>
        </param>
        <param>
          <type>const VkDeviceSize *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> <ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)</type>
          <declname>sizes</declname>
        </param>
        <briefdescription>
<para>Flushes memory of given set of allocations. </para>
        </briefdescription>
        <detaileddescription>
<para>Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations. For more information, see documentation of <ref refid="group__group__alloc_1gab8093faf3afb114596d964d4bd24cb4a" kindref="member">vmaFlushAllocation()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>allocationCount</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>allocations</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offsets</parametername>
</parameternamelist>
<parameterdescription>
<para>If not null, it must point to an array of offsets of regions to flush, relative to the beginning of respective allocations. Null means all ofsets are zero. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sizes</parametername>
</parameternamelist>
<parameterdescription>
<para>If not null, it must point to an array of sizes of regions to flush in respective allocations. Null means `VK_WHOLE_SIZE` for all allocations.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is called, otherwise `VK_SUCCESS`. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2081" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2081" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga693a1ae5faed72fac89f12685e1d366f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaInvalidateAllocations</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, uint32_t allocationCount, const VmaAllocation VMA_NOT_NULL *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) allocations, const VkDeviceSize *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) offsets, const VkDeviceSize *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) sizes)</argsstring>
        <name>vmaInvalidateAllocations</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>allocationCount</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref> *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> <ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)</type>
          <declname>allocations</declname>
        </param>
        <param>
          <type>const VkDeviceSize *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> <ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)</type>
          <declname>offsets</declname>
        </param>
        <param>
          <type>const VkDeviceSize *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> <ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)</type>
          <declname>sizes</declname>
        </param>
        <briefdescription>
<para>Invalidates memory of given set of allocations. </para>
        </briefdescription>
        <detaileddescription>
<para>Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations. For more information, see documentation of <ref refid="group__group__alloc_1ga1059764930e85ac377a92b5237b5b919" kindref="member">vmaInvalidateAllocation()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>allocationCount</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>allocations</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offsets</parametername>
</parameternamelist>
<parameterdescription>
<para>If not null, it must point to an array of offsets of regions to flush, relative to the beginning of respective allocations. Null means all ofsets are zero. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sizes</parametername>
</parameternamelist>
<parameterdescription>
<para>If not null, it must point to an array of sizes of regions to flush in respective allocations. Null means `VK_WHOLE_SIZE` for all allocations.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is called, otherwise `VK_SUCCESS`. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2102" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2102" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga0baa58dd12991e7b0fe42dcdf22bb100" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaCheckCorruption</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, uint32_t memoryTypeBits)</argsstring>
        <name>vmaCheckCorruption</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>memoryTypeBits</declname>
        </param>
        <briefdescription>
<para>Checks magic number in margins around all allocations in given memory types (in both default and custom pools) in search for corruptions. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>memoryTypeBits</parametername>
</parameternamelist>
<parameterdescription>
<para>Bit mask, where each bit set means that a memory type with that index should be checked.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Corruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero, `VMA_DEBUG_MARGIN` is defined to nonzero and only for memory types that are `HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](<ref refid="debugging_memory_usage_1debugging_memory_usage_corruption_detection" kindref="member">Corruption detection</ref>).</para>
<para>Possible return values:</para>
<para><itemizedlist>
<listitem><para>`VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for any of specified memory types.</para>
</listitem><listitem><para>`VK_SUCCESS` - corruption detection has been performed and succeeded.</para>
</listitem><listitem><para>`VK_ERROR_UNKNOWN` - corruption detection has been performed and found memory corruptions around one of the allocations. `VMA_ASSERT` is also fired in that case.</para>
</listitem><listitem><para>Other value: Error returned by Vulkan, e.g. memory mapping failure. </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2126" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2126" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga0cdd7b0b8653745fa95af9e78d919e70" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaBeginDefragmentation</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, const VmaDefragmentationInfo *VMA_NOT_NULL pInfo, VmaDefragmentationContext VMA_NULLABLE *VMA_NOT_NULL pContext)</argsstring>
        <name>vmaBeginDefragmentation</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_defragmentation_info" kindref="compound">VmaDefragmentationInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pInfo</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_defragmentation_context" kindref="compound">VmaDefragmentationContext</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pContext</declname>
        </param>
        <briefdescription>
<para>Begins defragmentation process. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para>Allocator object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Structure filled with parameters of defragmentation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pContext</parametername>
</parameternamelist>
<parameterdescription>
<para>Context object that must be passed to <ref refid="group__group__alloc_1gae419e366d1c015716165bdfd5aafef6f" kindref="member">vmaEndDefragmentation()</ref> to finish defragmentation. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><itemizedlist>
<listitem><para>`VK_SUCCESS` if defragmentation can begin.</para>
</listitem><listitem><para>`VK_ERROR_FEATURE_NOT_PRESENT` if defragmentation is not supported.</para>
</listitem></itemizedlist>
</para>
</simplesect>
For more information about defragmentation, see documentation chapter: [Defragmentation](<ref refid="defragmentation" kindref="compound">Defragmentation</ref>). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2142" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2142" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gae419e366d1c015716165bdfd5aafef6f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaEndDefragmentation</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaDefragmentationContext VMA_NOT_NULL context, VmaDefragmentationStats *VMA_NULLABLE pStats)</argsstring>
        <name>vmaEndDefragmentation</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_defragmentation_context" kindref="compound">VmaDefragmentationContext</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>context</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_defragmentation_stats" kindref="compound">VmaDefragmentationStats</ref> *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pStats</declname>
        </param>
        <briefdescription>
<para>Ends defragmentation process. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para>Allocator object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>context</parametername>
</parameternamelist>
<parameterdescription>
<para>Context object that has been created by <ref refid="group__group__alloc_1ga0cdd7b0b8653745fa95af9e78d919e70" kindref="member">vmaBeginDefragmentation()</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pStats</parametername>
</parameternamelist>
<parameterdescription>
<para>Optional stats for the defragmentation. Can be null.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Use this function to finish defragmentation started by <ref refid="group__group__alloc_1ga0cdd7b0b8653745fa95af9e78d919e70" kindref="member">vmaBeginDefragmentation()</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2155" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2155" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gacbe4a77fdfa7ea29328d2f940d423ab7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaBeginDefragmentationPass</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaDefragmentationContext VMA_NOT_NULL context, VmaDefragmentationPassMoveInfo *VMA_NOT_NULL pPassInfo)</argsstring>
        <name>vmaBeginDefragmentationPass</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_defragmentation_context" kindref="compound">VmaDefragmentationContext</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>context</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_defragmentation_pass_move_info" kindref="compound">VmaDefragmentationPassMoveInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pPassInfo</declname>
        </param>
        <briefdescription>
<para>Starts single defragmentation pass. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para>Allocator object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>context</parametername>
</parameternamelist>
<parameterdescription>
<para>Context object that has been created by <ref refid="group__group__alloc_1ga0cdd7b0b8653745fa95af9e78d919e70" kindref="member">vmaBeginDefragmentation()</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pPassInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Computed informations for current pass. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><itemizedlist>
<listitem><para>`VK_SUCCESS` if no more moves are possible. Then you can omit call to <ref refid="group__group__alloc_1gabbc69db60f82972ddffaceb6653e344a" kindref="member">vmaEndDefragmentationPass()</ref> and simply end whole defragmentation.</para>
</listitem><listitem><para>`VK_INCOMPLETE` if there are pending moves returned in `pPassInfo`. You need to perform them, call <ref refid="group__group__alloc_1gabbc69db60f82972ddffaceb6653e344a" kindref="member">vmaEndDefragmentationPass()</ref>, and then preferably try another pass with <ref refid="group__group__alloc_1gacbe4a77fdfa7ea29328d2f940d423ab7" kindref="member">vmaBeginDefragmentationPass()</ref>. </para>
</listitem></itemizedlist>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2170" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2170" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gabbc69db60f82972ddffaceb6653e344a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaEndDefragmentationPass</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaDefragmentationContext VMA_NOT_NULL context, VmaDefragmentationPassMoveInfo *VMA_NOT_NULL pPassInfo)</argsstring>
        <name>vmaEndDefragmentationPass</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_defragmentation_context" kindref="compound">VmaDefragmentationContext</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>context</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_defragmentation_pass_move_info" kindref="compound">VmaDefragmentationPassMoveInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pPassInfo</declname>
        </param>
        <briefdescription>
<para>Ends single defragmentation pass. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para>Allocator object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>context</parametername>
</parameternamelist>
<parameterdescription>
<para>Context object that has been created by <ref refid="group__group__alloc_1ga0cdd7b0b8653745fa95af9e78d919e70" kindref="member">vmaBeginDefragmentation()</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pPassInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Computed informations for current pass filled by <ref refid="group__group__alloc_1gacbe4a77fdfa7ea29328d2f940d423ab7" kindref="member">vmaBeginDefragmentationPass()</ref> and possibly modified by you.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Returns `VK_SUCCESS` if no more moves are possible or `VK_INCOMPLETE` if more defragmentations are possible.</para>
<para>Ends incremental defragmentation pass and commits all defragmentation moves from `pPassInfo`. After this call:</para>
<para><itemizedlist>
<listitem><para>Allocations at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==` <ref refid="group__group__alloc_1ggada9e3861caf96f08894b0bcc160ec257ad4a06ac46c4cb1c67b0ebc1edfab9f18" kindref="member">VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY</ref> (which is the default) will be pointing to the new destination place.</para>
</listitem><listitem><para>Allocation at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==` <ref refid="group__group__alloc_1ggada9e3861caf96f08894b0bcc160ec257a9786f8492a9be2c03bd26395e352ab85" kindref="member">VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY</ref> will be freed.</para>
</listitem></itemizedlist>
</para>
<para>If no more moves are possible you can end whole defragmentation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2193" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2193" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga7748e60ccc54e240777a848cb260bb19" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindBufferMemory</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VkBuffer VMA_NOT_NULL_NON_DISPATCHABLE buffer)</argsstring>
        <name>vmaBindBufferMemory</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type>VkBuffer <ref refid="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" kindref="member">VMA_NOT_NULL_NON_DISPATCHABLE</ref></type>
          <declname>buffer</declname>
        </param>
        <briefdescription>
<para>Binds buffer to allocation. </para>
        </briefdescription>
        <detaileddescription>
<para>Binds specified buffer to region of memory represented by specified allocation. Gets `VkDeviceMemory` handle and offset from the allocation. If you want to create a buffer, allocate memory for it and bind them together separately, you should use this function for binding instead of standard `vkBindBufferMemory()`, because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won&apos;t happen from multiple threads simultaneously (which is illegal in Vulkan).</para>
<para>It is recommended to use function <ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer()</ref> instead of this one. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2210" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2210" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga4a71c30e3474a835bdd7fd0507740be7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindBufferMemory2</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VkDeviceSize allocationLocalOffset, VkBuffer VMA_NOT_NULL_NON_DISPATCHABLE buffer, const void *VMA_NULLABLE pNext)</argsstring>
        <name>vmaBindBufferMemory2</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type>VkDeviceSize</type>
          <declname>allocationLocalOffset</declname>
        </param>
        <param>
          <type>VkBuffer <ref refid="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" kindref="member">VMA_NOT_NULL_NON_DISPATCHABLE</ref></type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>const void *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pNext</declname>
        </param>
        <briefdescription>
<para>Binds buffer to allocation with additional parameters. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>allocation</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>allocationLocalOffset</parametername>
</parameternamelist>
<parameterdescription>
<para>Additional offset to be added while binding, relative to the beginning of the `allocation`. Normally it should be 0. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pNext</parametername>
</parameternamelist>
<parameterdescription>
<para>A chain of structures to be attached to `VkBindBufferMemoryInfoKHR` structure used internally. Normally it should be null.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This function is similar to <ref refid="group__group__alloc_1ga7748e60ccc54e240777a848cb260bb19" kindref="member">vmaBindBufferMemory()</ref>, but it provides additional parameters.</para>
<para>If `pNext` is not null, <ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> object must have been created with <ref refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7ca8fb75bf07cd184ab903596295e863dee" kindref="member">VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</ref> flag or with <ref refid="struct_vma_allocator_create_info_1ae0ffc55139b54520a6bb704b29ffc285" kindref="member">VmaAllocatorCreateInfo::vulkanApiVersion</ref> `&gt;= VK_API_VERSION_1_1`. Otherwise the call fails. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2228" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2228" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga3a5d8d9f2a29b42cf87f0f8dfef591f4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindImageMemory</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VkImage VMA_NOT_NULL_NON_DISPATCHABLE image)</argsstring>
        <name>vmaBindImageMemory</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type>VkImage <ref refid="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" kindref="member">VMA_NOT_NULL_NON_DISPATCHABLE</ref></type>
          <declname>image</declname>
        </param>
        <briefdescription>
<para>Binds image to allocation. </para>
        </briefdescription>
        <detaileddescription>
<para>Binds specified image to region of memory represented by specified allocation. Gets `VkDeviceMemory` handle and offset from the allocation. If you want to create an image, allocate memory for it and bind them together separately, you should use this function for binding instead of standard `vkBindImageMemory()`, because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won&apos;t happen from multiple threads simultaneously (which is illegal in Vulkan).</para>
<para>It is recommended to use function <ref refid="group__group__alloc_1gaa76142ae43535c862ad9e194a6e38aaa" kindref="member">vmaCreateImage()</ref> instead of this one. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2247" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2247" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga0216b9225b02a66ac610cb45d4729d00" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindImageMemory2</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VkDeviceSize allocationLocalOffset, VkImage VMA_NOT_NULL_NON_DISPATCHABLE image, const void *VMA_NULLABLE pNext)</argsstring>
        <name>vmaBindImageMemory2</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type>VkDeviceSize</type>
          <declname>allocationLocalOffset</declname>
        </param>
        <param>
          <type>VkImage <ref refid="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" kindref="member">VMA_NOT_NULL_NON_DISPATCHABLE</ref></type>
          <declname>image</declname>
        </param>
        <param>
          <type>const void *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pNext</declname>
        </param>
        <briefdescription>
<para>Binds image to allocation with additional parameters. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>allocation</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>allocationLocalOffset</parametername>
</parameternamelist>
<parameterdescription>
<para>Additional offset to be added while binding, relative to the beginning of the `allocation`. Normally it should be 0. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>image</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pNext</parametername>
</parameternamelist>
<parameterdescription>
<para>A chain of structures to be attached to `VkBindImageMemoryInfoKHR` structure used internally. Normally it should be null.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This function is similar to <ref refid="group__group__alloc_1ga3a5d8d9f2a29b42cf87f0f8dfef591f4" kindref="member">vmaBindImageMemory()</ref>, but it provides additional parameters.</para>
<para>If `pNext` is not null, <ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> object must have been created with <ref refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7ca8fb75bf07cd184ab903596295e863dee" kindref="member">VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</ref> flag or with <ref refid="struct_vma_allocator_create_info_1ae0ffc55139b54520a6bb704b29ffc285" kindref="member">VmaAllocatorCreateInfo::vulkanApiVersion</ref> `&gt;= VK_API_VERSION_1_1`. Otherwise the call fails. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2265" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2265" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateBuffer</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, const VkBufferCreateInfo *VMA_NOT_NULL pBufferCreateInfo, const VmaAllocationCreateInfo *VMA_NOT_NULL pAllocationCreateInfo, VkBuffer VMA_NULLABLE_NON_DISPATCHABLE *VMA_NOT_NULL pBuffer, VmaAllocation VMA_NULLABLE *VMA_NOT_NULL pAllocation, VmaAllocationInfo *VMA_NULLABLE pAllocationInfo)</argsstring>
        <name>vmaCreateBuffer</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>const VkBufferCreateInfo *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pBufferCreateInfo</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocationCreateInfo</declname>
        </param>
        <param>
          <type>VkBuffer <ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pBuffer</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocation</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref> *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pAllocationInfo</declname>
        </param>
        <briefdescription>
<para>Creates a new `VkBuffer`, allocates and binds memory for it. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pBufferCreateInfo</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pAllocationCreateInfo</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pBuffer</parametername>
</parameternamelist>
<parameterdescription>
<para>Buffer that was created. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pAllocation</parametername>
</parameternamelist>
<parameterdescription>
<para>Allocation that was created. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pAllocationInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Optional. Information about allocated memory. It can be later fetched using function <ref refid="group__group__alloc_1gab9c96ca6bb55ad9069829fe8355bbb79" kindref="member">vmaGetAllocationInfo()</ref>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This function automatically:</para>
<para><orderedlist>
<listitem><para>Creates buffer.</para>
</listitem><listitem><para>Allocates appropriate memory for it.</para>
</listitem><listitem><para>Binds the buffer with the memory.</para>
</listitem></orderedlist>
</para>
<para>If any of these operations fail, buffer and allocation are not created, returned value is negative error code, `*pBuffer` and `*pAllocation` are null.</para>
<para>If the function succeeded, you must destroy both buffer and allocation when you no longer need them using either convenience function <ref refid="group__group__alloc_1gafcc45e5a6388ab35daa9a46688baee20" kindref="member">vmaDestroyBuffer()</ref> or separately, using `vkDestroyBuffer()` and <ref refid="group__group__alloc_1ga5c9baca5124d440046bbe508f61d2839" kindref="member">vmaFreeMemory()</ref>.</para>
<para>If <ref refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7cace7da7cc6e71a625dfa763c55a597878" kindref="member">VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT</ref> flag was used, VK_KHR_dedicated_allocation extension is used internally to query driver whether it requires or prefers the new buffer to have dedicated allocation. If yes, and if dedicated allocation is possible (<ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a89759603401014eb325eb22a3839f2ff" kindref="member">VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</ref> is not used), it creates dedicated allocation for this buffer, just like when using <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" kindref="member">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</ref>.</para>
<para><simplesect kind="note"><para>This function creates a new `VkBuffer`. Sub-allocation of parts of one large buffer, although recommended as a good practice, is out of scope of this library and could be implemented by the user as a higher-level logic on top of VMA. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2306" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2306" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga0a4d6890fe94cf4d234ca1d78af91229" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateBufferWithAlignment</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, const VkBufferCreateInfo *VMA_NOT_NULL pBufferCreateInfo, const VmaAllocationCreateInfo *VMA_NOT_NULL pAllocationCreateInfo, VkDeviceSize minAlignment, VkBuffer VMA_NULLABLE_NON_DISPATCHABLE *VMA_NOT_NULL pBuffer, VmaAllocation VMA_NULLABLE *VMA_NOT_NULL pAllocation, VmaAllocationInfo *VMA_NULLABLE pAllocationInfo)</argsstring>
        <name>vmaCreateBufferWithAlignment</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>const VkBufferCreateInfo *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pBufferCreateInfo</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocationCreateInfo</declname>
        </param>
        <param>
          <type>VkDeviceSize</type>
          <declname>minAlignment</declname>
        </param>
        <param>
          <type>VkBuffer <ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pBuffer</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocation</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref> *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pAllocationInfo</declname>
        </param>
        <briefdescription>
<para>Creates a buffer with additional minimum alignment. </para>
        </briefdescription>
        <detaileddescription>
<para>Similar to <ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer()</ref> but provides additional parameter `minAlignment` which allows to specify custom, minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g. for interop with OpenGL. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2320" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2320" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga41a76d0f9f98a001900a889f55973536" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateAliasingBuffer</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, const VkBufferCreateInfo *VMA_NOT_NULL pBufferCreateInfo, VkBuffer VMA_NULLABLE_NON_DISPATCHABLE *VMA_NOT_NULL pBuffer)</argsstring>
        <name>vmaCreateAliasingBuffer</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type>const VkBufferCreateInfo *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pBufferCreateInfo</declname>
        </param>
        <param>
          <type>VkBuffer <ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pBuffer</declname>
        </param>
        <briefdescription>
<para>Creates a new `VkBuffer`, binds already created memory for it. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>allocation</parametername>
</parameternamelist>
<parameterdescription>
<para>Allocation that provides memory to be used for binding new buffer to it. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pBufferCreateInfo</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pBuffer</parametername>
</parameternamelist>
<parameterdescription>
<para>Buffer that was created.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This function automatically:</para>
<para><orderedlist>
<listitem><para>Creates buffer.</para>
</listitem><listitem><para>Binds the buffer with the supplied memory.</para>
</listitem></orderedlist>
</para>
<para>If any of these operations fail, buffer is not created, returned value is negative error code and `*pBuffer` is null.</para>
<para>If the function succeeded, you must destroy the buffer when you no longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding allocation you can use convenience function <ref refid="group__group__alloc_1gafcc45e5a6388ab35daa9a46688baee20" kindref="member">vmaDestroyBuffer()</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2348" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2348" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gafcc45e5a6388ab35daa9a46688baee20" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaDestroyBuffer</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VkBuffer VMA_NULLABLE_NON_DISPATCHABLE buffer, VmaAllocation VMA_NULLABLE allocation)</argsstring>
        <name>vmaDestroyBuffer</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>VkBuffer <ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref></type>
          <declname>buffer</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>allocation</declname>
        </param>
        <briefdescription>
<para>Destroys Vulkan buffer and frees allocated memory. </para>
        </briefdescription>
        <detaileddescription>
<para>This is just a convenience function equivalent to:</para>
<para><programlisting><codeline><highlight class="normal">vkDestroyBuffer(device,<sp/>buffer,<sp/>allocationCallbacks);</highlight></codeline>
<codeline><highlight class="normal">vmaFreeMemory(allocator,<sp/>allocation);</highlight></codeline>
</programlisting></para>
<para>It it safe to pass null as buffer and/or allocation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2365" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2365" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gaa76142ae43535c862ad9e194a6e38aaa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateImage</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, const VkImageCreateInfo *VMA_NOT_NULL pImageCreateInfo, const VmaAllocationCreateInfo *VMA_NOT_NULL pAllocationCreateInfo, VkImage VMA_NULLABLE_NON_DISPATCHABLE *VMA_NOT_NULL pImage, VmaAllocation VMA_NULLABLE *VMA_NOT_NULL pAllocation, VmaAllocationInfo *VMA_NULLABLE pAllocationInfo)</argsstring>
        <name>vmaCreateImage</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>const VkImageCreateInfo *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pImageCreateInfo</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocationCreateInfo</declname>
        </param>
        <param>
          <type>VkImage <ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pImage</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocation</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref> *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pAllocationInfo</declname>
        </param>
        <briefdescription>
<para>Function similar to <ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2371" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2371" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga9ef2c5794b39fea75da48305e3a17084" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateAliasingImage</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, const VkImageCreateInfo *VMA_NOT_NULL pImageCreateInfo, VkImage VMA_NULLABLE_NON_DISPATCHABLE *VMA_NOT_NULL pImage)</argsstring>
        <name>vmaCreateAliasingImage</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type>const VkImageCreateInfo *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pImageCreateInfo</declname>
        </param>
        <param>
          <type>VkImage <ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pImage</declname>
        </param>
        <briefdescription>
<para>Function similar to <ref refid="group__group__alloc_1ga41a76d0f9f98a001900a889f55973536" kindref="member">vmaCreateAliasingBuffer()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2380" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2380" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga2f6367e612daace5c5ecd7ef9e47c3fd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaDestroyImage</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VkImage VMA_NULLABLE_NON_DISPATCHABLE image, VmaAllocation VMA_NULLABLE allocation)</argsstring>
        <name>vmaDestroyImage</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>VkImage <ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref></type>
          <declname>image</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>allocation</declname>
        </param>
        <briefdescription>
<para>Destroys Vulkan image and frees allocated memory. </para>
        </briefdescription>
        <detaileddescription>
<para>This is just a convenience function equivalent to:</para>
<para><programlisting><codeline><highlight class="normal">vkDestroyImage(device,<sp/>image,<sp/>allocationCallbacks);</highlight></codeline>
<codeline><highlight class="normal">vmaFreeMemory(allocator,<sp/>allocation);</highlight></codeline>
</programlisting></para>
<para>It it safe to pass null as image and/or allocation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2397" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2397" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__virtual_1ga869baad02bf3b5fb012d61e1a43f92c5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateVirtualBlock</definition>
        <argsstring>(const VmaVirtualBlockCreateInfo *VMA_NOT_NULL pCreateInfo, VmaVirtualBlock VMA_NULLABLE *VMA_NOT_NULL pVirtualBlock)</argsstring>
        <name>vmaCreateVirtualBlock</name>
        <param>
          <type>const <ref refid="struct_vma_virtual_block_create_info" kindref="compound">VmaVirtualBlockCreateInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pCreateInfo</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pVirtualBlock</declname>
        </param>
        <briefdescription>
<para>Creates new <ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref> object. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pCreateInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Parameters for creation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pVirtualBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Returned virtual block object or `VMA_NULL` if creation failed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2414" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2414" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__virtual_1ga1a464943809fb27dd3b78d1cd6e3d534" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaDestroyVirtualBlock</definition>
        <argsstring>(VmaVirtualBlock VMA_NULLABLE virtualBlock)</argsstring>
        <name>vmaDestroyVirtualBlock</name>
        <param>
          <type><ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>virtualBlock</declname>
        </param>
        <briefdescription>
<para>Destroys <ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref> object. </para>
        </briefdescription>
        <detaileddescription>
<para>Please note that you should consciously handle virtual allocations that could remain unfreed in the block. You should either free them individually using <ref refid="group__group__virtual_1ga9f82fb8b8160d10bb469ae06b90134d2" kindref="member">vmaVirtualFree()</ref> or call <ref refid="group__group__virtual_1ga3114a4b34e1225b3d0a246b219d29d9d" kindref="member">vmaClearVirtualBlock()</ref> if you are sure this is what you want. If you do neither, an assert is called.</para>
<para>If you keep pointers to some additional metadata associated with your virtual allocations in their `pUserData`, don&apos;t forget to free them. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2427" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2427" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__virtual_1ga59f870a818a9acf8506aa36760549a48" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkBool32 <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkBool32 VMA_CALL_POST vmaIsVirtualBlockEmpty</definition>
        <argsstring>(VmaVirtualBlock VMA_NOT_NULL virtualBlock)</argsstring>
        <name>vmaIsVirtualBlockEmpty</name>
        <param>
          <type><ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>virtualBlock</declname>
        </param>
        <briefdescription>
<para>Returns true of the <ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref> is empty - contains 0 virtual allocations and has all its space available for new allocations. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2432" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2432" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__virtual_1ga64b8c2939b82f83fbec507f29a43307b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaGetVirtualAllocationInfo</definition>
        <argsstring>(VmaVirtualBlock VMA_NOT_NULL virtualBlock, VmaVirtualAllocation VMA_NOT_NULL_NON_DISPATCHABLE allocation, VmaVirtualAllocationInfo *VMA_NOT_NULL pVirtualAllocInfo)</argsstring>
        <name>vmaGetVirtualAllocationInfo</name>
        <param>
          <type><ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>virtualBlock</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_virtual_allocation" kindref="compound">VmaVirtualAllocation</ref> <ref refid="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" kindref="member">VMA_NOT_NULL_NON_DISPATCHABLE</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_virtual_allocation_info" kindref="compound">VmaVirtualAllocationInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pVirtualAllocInfo</declname>
        </param>
        <briefdescription>
<para>Returns information about a specific virtual allocation within a virtual block, like its size and `pUserData` pointer. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2437" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2437" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__virtual_1ga2f6cd8f6b98e754be7016b5860d02dac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaVirtualAllocate</definition>
        <argsstring>(VmaVirtualBlock VMA_NOT_NULL virtualBlock, const VmaVirtualAllocationCreateInfo *VMA_NOT_NULL pCreateInfo, VmaVirtualAllocation VMA_NULLABLE_NON_DISPATCHABLE *VMA_NOT_NULL pAllocation, VkDeviceSize *VMA_NULLABLE pOffset)</argsstring>
        <name>vmaVirtualAllocate</name>
        <param>
          <type><ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>virtualBlock</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_virtual_allocation_create_info" kindref="compound">VmaVirtualAllocationCreateInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pCreateInfo</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_virtual_allocation" kindref="compound">VmaVirtualAllocation</ref> <ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocation</declname>
        </param>
        <param>
          <type>VkDeviceSize *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pOffset</declname>
        </param>
        <briefdescription>
<para>Allocates new virtual allocation inside given <ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>If the allocation fails due to not enough free space available, `VK_ERROR_OUT_OF_DEVICE_MEMORY` is returned (despite the function doesn&apos;t ever allocate actual GPU memory). `pAllocation` is then set to `VK_NULL_HANDLE` and `pOffset`, if not null, it set to `UINT64_MAX`.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>virtualBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Virtual block </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pCreateInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Parameters for the allocation </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pAllocation</parametername>
</parameternamelist>
<parameterdescription>
<para>Returned handle of the new allocation </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pOffset</parametername>
</parameternamelist>
<parameterdescription>
<para>Returned offset of the new allocation. Optional, can be null. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2452" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2452" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__virtual_1ga9f82fb8b8160d10bb469ae06b90134d2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaVirtualFree</definition>
        <argsstring>(VmaVirtualBlock VMA_NOT_NULL virtualBlock, VmaVirtualAllocation VMA_NULLABLE_NON_DISPATCHABLE allocation)</argsstring>
        <name>vmaVirtualFree</name>
        <param>
          <type><ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>virtualBlock</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_virtual_allocation" kindref="compound">VmaVirtualAllocation</ref> <ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref></type>
          <declname>allocation</declname>
        </param>
        <briefdescription>
<para>Frees virtual allocation inside given <ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>It is correct to call this function with `allocation == VK_NULL_HANDLE` - it does nothing. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2462" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2462" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__virtual_1ga3114a4b34e1225b3d0a246b219d29d9d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaClearVirtualBlock</definition>
        <argsstring>(VmaVirtualBlock VMA_NOT_NULL virtualBlock)</argsstring>
        <name>vmaClearVirtualBlock</name>
        <param>
          <type><ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>virtualBlock</declname>
        </param>
        <briefdescription>
<para>Frees all virtual allocations inside given <ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>You must either call this function or free each virtual allocation individually with <ref refid="group__group__virtual_1ga9f82fb8b8160d10bb469ae06b90134d2" kindref="member">vmaVirtualFree()</ref> before destroying a virtual block. Otherwise, an assert is called.</para>
<para>If you keep pointer to some additional metadata associated with your virtual allocation in its `pUserData`, don&apos;t forget to free it as well. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2474" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2474" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__virtual_1ga9e697c001a3750c3bf1a081ee15f6b10" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaSetVirtualAllocationUserData</definition>
        <argsstring>(VmaVirtualBlock VMA_NOT_NULL virtualBlock, VmaVirtualAllocation VMA_NOT_NULL_NON_DISPATCHABLE allocation, void *VMA_NULLABLE pUserData)</argsstring>
        <name>vmaSetVirtualAllocationUserData</name>
        <param>
          <type><ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>virtualBlock</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_virtual_allocation" kindref="compound">VmaVirtualAllocation</ref> <ref refid="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" kindref="member">VMA_NOT_NULL_NON_DISPATCHABLE</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type>void *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pUserData</declname>
        </param>
        <briefdescription>
<para>Changes custom pointer associated with given virtual allocation. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2479" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2479" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__virtual_1gac63bab2c8ae8e74451a11ef6dab48a5d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaGetVirtualBlockStatistics</definition>
        <argsstring>(VmaVirtualBlock VMA_NOT_NULL virtualBlock, VmaStatistics *VMA_NOT_NULL pStats)</argsstring>
        <name>vmaGetVirtualBlockStatistics</name>
        <param>
          <type><ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>virtualBlock</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pStats</declname>
        </param>
        <briefdescription>
<para>Calculates and returns statistics about virtual allocations and memory usage in given <ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>This function is fast to call. For more detailed statistics, see <ref refid="group__group__virtual_1ga87017b57fb0e9623573f07c236c37566" kindref="member">vmaCalculateVirtualBlockStatistics()</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2488" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2488" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__virtual_1ga87017b57fb0e9623573f07c236c37566" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaCalculateVirtualBlockStatistics</definition>
        <argsstring>(VmaVirtualBlock VMA_NOT_NULL virtualBlock, VmaDetailedStatistics *VMA_NOT_NULL pStats)</argsstring>
        <name>vmaCalculateVirtualBlockStatistics</name>
        <param>
          <type><ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>virtualBlock</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pStats</declname>
        </param>
        <briefdescription>
<para>Calculates and returns detailed statistics about virtual allocations and memory usage in given <ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>This function is slow to call. Use for debugging purposes. For less detailed statistics, see <ref refid="group__group__virtual_1gac63bab2c8ae8e74451a11ef6dab48a5d" kindref="member">vmaGetVirtualBlockStatistics()</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2497" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2497" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__stats_1ga874ef8790380b6643ee5c1144ae5b32b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaBuildVirtualBlockStatsString</definition>
        <argsstring>(VmaVirtualBlock VMA_NOT_NULL virtualBlock, char *VMA_NULLABLE *VMA_NOT_NULL ppStatsString, VkBool32 detailedMap)</argsstring>
        <name>vmaBuildVirtualBlockStatsString</name>
        <param>
          <type><ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>virtualBlock</declname>
        </param>
        <param>
          <type>char *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>ppStatsString</declname>
        </param>
        <param>
          <type>VkBool32</type>
          <declname>detailedMap</declname>
        </param>
        <briefdescription>
<para>Builds and returns a null-terminated string in JSON format with information about given <ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>virtualBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>Virtual block. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">ppStatsString</parametername>
</parameternamelist>
<parameterdescription>
<para>Returned string. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>detailedMap</parametername>
</parameternamelist>
<parameterdescription>
<para>Pass `VK_FALSE` to only obtain statistics as returned by <ref refid="group__group__virtual_1ga87017b57fb0e9623573f07c236c37566" kindref="member">vmaCalculateVirtualBlockStatistics()</ref>. Pass `VK_TRUE` to also obtain full list of allocations and free spaces.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Returned string must be freed using <ref refid="group__group__stats_1ga5b3acd266c1f20d0b360d4259ff411bf" kindref="member">vmaFreeVirtualBlockStatsString()</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2516" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2516" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__stats_1ga5b3acd266c1f20d0b360d4259ff411bf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaFreeVirtualBlockStatsString</definition>
        <argsstring>(VmaVirtualBlock VMA_NOT_NULL virtualBlock, char *VMA_NULLABLE pStatsString)</argsstring>
        <name>vmaFreeVirtualBlockStatsString</name>
        <param>
          <type><ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>virtualBlock</declname>
        </param>
        <param>
          <type>char *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pStatsString</declname>
        </param>
        <briefdescription>
<para>Frees a string returned by <ref refid="group__group__stats_1ga874ef8790380b6643ee5c1144ae5b32b" kindref="member">vmaBuildVirtualBlockStatsString()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2522" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2522" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__stats_1ga9326cba3c64929b59a15c3ca9cdc8cdb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaBuildStatsString</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, char *VMA_NULLABLE *VMA_NOT_NULL ppStatsString, VkBool32 detailedMap)</argsstring>
        <name>vmaBuildStatsString</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>char *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>ppStatsString</declname>
        </param>
        <param>
          <type>VkBool32</type>
          <declname>detailedMap</declname>
        </param>
        <briefdescription>
<para>Builds and returns statistics as a null-terminated string in JSON format. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">ppStatsString</parametername>
</parameternamelist>
<parameterdescription>
<para>Must be freed using <ref refid="group__group__stats_1gad9b3c6a5dce6aea00719ccb2d3a780f3" kindref="member">vmaFreeStatsString()</ref> function. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>detailedMap</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2531" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2531" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__stats_1gad9b3c6a5dce6aea00719ccb2d3a780f3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaFreeStatsString</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, char *VMA_NULLABLE pStatsString)</argsstring>
        <name>vmaFreeStatsString</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>char *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pStatsString</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2536" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2536" declcolumn="33"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Copyright<sp/>(c)<sp/>2017-2022<sp/>Advanced<sp/>Micro<sp/>Devices,<sp/>Inc.<sp/>All<sp/>rights<sp/>reserved.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Permission<sp/>is<sp/>hereby<sp/>granted,<sp/>free<sp/>of<sp/>charge,<sp/>to<sp/>any<sp/>person<sp/>obtaining<sp/>a<sp/>copy</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5"><highlight class="normal"></highlight><highlight class="comment">//<sp/>of<sp/>this<sp/>software<sp/>and<sp/>associated<sp/>documentation<sp/>files<sp/>(the<sp/>&quot;Software&quot;),<sp/>to<sp/>deal</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight><highlight class="comment">//<sp/>in<sp/>the<sp/>Software<sp/>without<sp/>restriction,<sp/>including<sp/>without<sp/>limitation<sp/>the<sp/>rights</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7"><highlight class="normal"></highlight><highlight class="comment">//<sp/>to<sp/>use,<sp/>copy,<sp/>modify,<sp/>merge,<sp/>publish,<sp/>distribute,<sp/>sublicense,<sp/>and/or<sp/>sell</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8"><highlight class="normal"></highlight><highlight class="comment">//<sp/>copies<sp/>of<sp/>the<sp/>Software,<sp/>and<sp/>to<sp/>permit<sp/>persons<sp/>to<sp/>whom<sp/>the<sp/>Software<sp/>is</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9"><highlight class="normal"></highlight><highlight class="comment">//<sp/>furnished<sp/>to<sp/>do<sp/>so,<sp/>subject<sp/>to<sp/>the<sp/>following<sp/>conditions:</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11"><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>above<sp/>copyright<sp/>notice<sp/>and<sp/>this<sp/>permission<sp/>notice<sp/>shall<sp/>be<sp/>included<sp/>in</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12"><highlight class="normal"></highlight><highlight class="comment">//<sp/>all<sp/>copies<sp/>or<sp/>substantial<sp/>portions<sp/>of<sp/>the<sp/>Software.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14"><highlight class="normal"></highlight><highlight class="comment">//<sp/>THE<sp/>SOFTWARE<sp/>IS<sp/>PROVIDED<sp/>&quot;AS<sp/>IS&quot;,<sp/>WITHOUT<sp/>WARRANTY<sp/>OF<sp/>ANY<sp/>KIND,<sp/>EXPRESS<sp/>OR</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15"><highlight class="normal"></highlight><highlight class="comment">//<sp/>IMPLIED,<sp/>INCLUDING<sp/>BUT<sp/>NOT<sp/>LIMITED<sp/>TO<sp/>THE<sp/>WARRANTIES<sp/>OF<sp/>MERCHANTABILITY,</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16"><highlight class="normal"></highlight><highlight class="comment">//<sp/>FITNESS<sp/>FOR<sp/>A<sp/>PARTICULAR<sp/>PURPOSE<sp/>AND<sp/>NONINFRINGEMENT.<sp/><sp/>IN<sp/>NO<sp/>EVENT<sp/>SHALL<sp/>THE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17"><highlight class="normal"></highlight><highlight class="comment">//<sp/>AUTHORS<sp/>OR<sp/>COPYRIGHT<sp/>HOLDERS<sp/>BE<sp/>LIABLE<sp/>FOR<sp/>ANY<sp/>CLAIM,<sp/>DAMAGES<sp/>OR<sp/>OTHER</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="18"><highlight class="normal"></highlight><highlight class="comment">//<sp/>LIABILITY,<sp/>WHETHER<sp/>IN<sp/>AN<sp/>ACTION<sp/>OF<sp/>CONTRACT,<sp/>TORT<sp/>OR<sp/>OTHERWISE,<sp/>ARISING<sp/>FROM,</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="19"><highlight class="normal"></highlight><highlight class="comment">//<sp/>OUT<sp/>OF<sp/>OR<sp/>IN<sp/>CONNECTION<sp/>WITH<sp/>THE<sp/>SOFTWARE<sp/>OR<sp/>THE<sp/>USE<sp/>OR<sp/>OTHER<sp/>DEALINGS<sp/>IN</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="20"><highlight class="normal"></highlight><highlight class="comment">//<sp/>THE<sp/>SOFTWARE.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="21"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="22"><highlight class="normal"></highlight></codeline>
<codeline lineno="23"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>AMD_VULKAN_MEMORY_ALLOCATOR_H</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="24"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>AMD_VULKAN_MEMORY_ALLOCATOR_H</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="25"><highlight class="normal"></highlight></codeline>
<codeline lineno="125"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>__cplusplus</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="126"><highlight class="normal"></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/></highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="127"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="128"><highlight class="normal"></highlight></codeline>
<codeline lineno="129"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VULKAN_H_</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="130"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#include<sp/>&lt;vulkan/vulkan.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="131"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="132"><highlight class="normal"></highlight></codeline>
<codeline lineno="133"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Define<sp/>this<sp/>macro<sp/>to<sp/>declare<sp/>maximum<sp/>supported<sp/>Vulkan<sp/>version<sp/>in<sp/>format<sp/>AAABBBCCC,</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="134"><highlight class="normal"></highlight><highlight class="comment">//<sp/>where<sp/>AAA<sp/>=<sp/>major,<sp/>BBB<sp/>=<sp/>minor,<sp/>CCC<sp/>=<sp/>patch.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="135"><highlight class="normal"></highlight><highlight class="comment">//<sp/>If<sp/>you<sp/>want<sp/>to<sp/>use<sp/>version<sp/>&gt;<sp/>1.0,<sp/>it<sp/>still<sp/>needs<sp/>to<sp/>be<sp/>enabled<sp/>via<sp/>VmaAllocatorCreateInfo::vulkanApiVersion.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="136"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>!defined(VMA_VULKAN_VERSION)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="137"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#if<sp/>defined(VK_VERSION_1_3)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="138"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_VULKAN_VERSION<sp/>1003000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="139"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#elif<sp/>defined(VK_VERSION_1_2)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="140"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_VULKAN_VERSION<sp/>1002000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="141"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#elif<sp/>defined(VK_VERSION_1_1)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="142"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_VULKAN_VERSION<sp/>1001000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="143"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="144" refid="vk__mem__alloc_8h_1a1a2407c283893638cc039bb31fcd74b6" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_VULKAN_VERSION<sp/>1000000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="145"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="146"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="147"><highlight class="normal"></highlight></codeline>
<codeline lineno="148"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>defined(__ANDROID__)<sp/>&amp;&amp;<sp/>defined(VK_NO_PROTOTYPES)<sp/>&amp;&amp;<sp/>VMA_STATIC_VULKAN_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="149"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>PFN_vkGetInstanceProcAddr<sp/>vkGetInstanceProcAddr;</highlight></codeline>
<codeline lineno="150"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>PFN_vkGetDeviceProcAddr<sp/>vkGetDeviceProcAddr;</highlight></codeline>
<codeline lineno="151"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>PFN_vkGetPhysicalDeviceProperties<sp/>vkGetPhysicalDeviceProperties;</highlight></codeline>
<codeline lineno="152"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>PFN_vkGetPhysicalDeviceMemoryProperties<sp/>vkGetPhysicalDeviceMemoryProperties;</highlight></codeline>
<codeline lineno="153"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>PFN_vkAllocateMemory<sp/>vkAllocateMemory;</highlight></codeline>
<codeline lineno="154"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>PFN_vkFreeMemory<sp/>vkFreeMemory;</highlight></codeline>
<codeline lineno="155"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>PFN_vkMapMemory<sp/>vkMapMemory;</highlight></codeline>
<codeline lineno="156"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>PFN_vkUnmapMemory<sp/>vkUnmapMemory;</highlight></codeline>
<codeline lineno="157"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>PFN_vkFlushMappedMemoryRanges<sp/>vkFlushMappedMemoryRanges;</highlight></codeline>
<codeline lineno="158"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>PFN_vkInvalidateMappedMemoryRanges<sp/>vkInvalidateMappedMemoryRanges;</highlight></codeline>
<codeline lineno="159"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>PFN_vkBindBufferMemory<sp/>vkBindBufferMemory;</highlight></codeline>
<codeline lineno="160"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>PFN_vkBindImageMemory<sp/>vkBindImageMemory;</highlight></codeline>
<codeline lineno="161"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>PFN_vkGetBufferMemoryRequirements<sp/>vkGetBufferMemoryRequirements;</highlight></codeline>
<codeline lineno="162"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>PFN_vkGetImageMemoryRequirements<sp/>vkGetImageMemoryRequirements;</highlight></codeline>
<codeline lineno="163"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>PFN_vkCreateBuffer<sp/>vkCreateBuffer;</highlight></codeline>
<codeline lineno="164"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>PFN_vkDestroyBuffer<sp/>vkDestroyBuffer;</highlight></codeline>
<codeline lineno="165"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>PFN_vkCreateImage<sp/>vkCreateImage;</highlight></codeline>
<codeline lineno="166"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>PFN_vkDestroyImage<sp/>vkDestroyImage;</highlight></codeline>
<codeline lineno="167"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>PFN_vkCmdCopyBuffer<sp/>vkCmdCopyBuffer;</highlight></codeline>
<codeline lineno="168"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#if<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1001000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>PFN_vkGetBufferMemoryRequirements2<sp/>vkGetBufferMemoryRequirements2;</highlight></codeline>
<codeline lineno="170"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>PFN_vkGetImageMemoryRequirements2<sp/>vkGetImageMemoryRequirements2;</highlight></codeline>
<codeline lineno="171"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>PFN_vkBindBufferMemory2<sp/>vkBindBufferMemory2;</highlight></codeline>
<codeline lineno="172"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>PFN_vkBindImageMemory2<sp/>vkBindImageMemory2;</highlight></codeline>
<codeline lineno="173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>PFN_vkGetPhysicalDeviceMemoryProperties2<sp/>vkGetPhysicalDeviceMemoryProperties2;</highlight></codeline>
<codeline lineno="174"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1001000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="175"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>defined(__ANDROID__)<sp/>&amp;&amp;<sp/>VMA_STATIC_VULKAN_FUNCTIONS<sp/>&amp;&amp;<sp/>VK_NO_PROTOTYPES</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="176"><highlight class="normal"></highlight></codeline>
<codeline lineno="177"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>!defined(VMA_DEDICATED_ALLOCATION)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="178"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#if<sp/>VK_KHR_get_memory_requirements2<sp/>&amp;&amp;<sp/>VK_KHR_dedicated_allocation</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="179"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_DEDICATED_ALLOCATION<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="180"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="181" refid="vk__mem__alloc_8h_1af7b860e63b96d11e44ae8587ba06bbf4" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_DEDICATED_ALLOCATION<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="182"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="183"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="184"><highlight class="normal"></highlight></codeline>
<codeline lineno="185"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>!defined(VMA_BIND_MEMORY2)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="186"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#if<sp/>VK_KHR_bind_memory2</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="187"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_BIND_MEMORY2<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="188"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="189" refid="vk__mem__alloc_8h_1a88bef97f86d70a34a4c0746e09a2680d" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_BIND_MEMORY2<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="190"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="191"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="192"><highlight class="normal"></highlight></codeline>
<codeline lineno="193"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>!defined(VMA_MEMORY_BUDGET)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="194"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#if<sp/>VK_EXT_memory_budget<sp/>&amp;&amp;<sp/>(VK_KHR_get_physical_device_properties2<sp/>||<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1001000)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="195"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_MEMORY_BUDGET<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="196"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="197" refid="vk__mem__alloc_8h_1a05decf1cf4ebf767beba7acca6c1ec3a" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_MEMORY_BUDGET<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="198"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="199"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="200"><highlight class="normal"></highlight></codeline>
<codeline lineno="201"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Defined<sp/>to<sp/>1<sp/>when<sp/>VK_KHR_buffer_device_address<sp/>device<sp/>extension<sp/>or<sp/>equivalent<sp/>core<sp/>Vulkan<sp/>1.2<sp/>feature<sp/>is<sp/>defined<sp/>in<sp/>its<sp/>headers.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="202"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>!defined(VMA_BUFFER_DEVICE_ADDRESS)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="203"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#if<sp/>VK_KHR_buffer_device_address<sp/>||<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1002000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="204"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_BUFFER_DEVICE_ADDRESS<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="205"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="206" refid="vk__mem__alloc_8h_1a7f9d5e71b70dd1a137c303a8a8262c10" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_BUFFER_DEVICE_ADDRESS<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="207"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="208"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="209"><highlight class="normal"></highlight></codeline>
<codeline lineno="210"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Defined<sp/>to<sp/>1<sp/>when<sp/>VK_EXT_memory_priority<sp/>device<sp/>extension<sp/>is<sp/>defined<sp/>in<sp/>Vulkan<sp/>headers.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="211"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>!defined(VMA_MEMORY_PRIORITY)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="212"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#if<sp/>VK_EXT_memory_priority</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="213"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_MEMORY_PRIORITY<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="214"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="215" refid="vk__mem__alloc_8h_1a81af8a3a87e34bbb493848143cde43e4" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_MEMORY_PRIORITY<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="216"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="217"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="218"><highlight class="normal"></highlight></codeline>
<codeline lineno="219"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Defined<sp/>to<sp/>1<sp/>when<sp/>VK_KHR_external_memory<sp/>device<sp/>extension<sp/>is<sp/>defined<sp/>in<sp/>Vulkan<sp/>headers.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="220"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>!defined(VMA_EXTERNAL_MEMORY)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="221"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#if<sp/>VK_KHR_external_memory</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="222"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_EXTERNAL_MEMORY<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="223"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="224" refid="vk__mem__alloc_8h_1a02cd76250a5695dbe9a33e5b6db51695" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_EXTERNAL_MEMORY<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="225"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="226"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="227"><highlight class="normal"></highlight></codeline>
<codeline lineno="228"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Define<sp/>these<sp/>macros<sp/>to<sp/>decorate<sp/>all<sp/>public<sp/>functions<sp/>with<sp/>additional<sp/>code,</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="229"><highlight class="normal"></highlight><highlight class="comment">//<sp/>before<sp/>and<sp/>after<sp/>returned<sp/>type,<sp/>appropriately.<sp/>This<sp/>may<sp/>be<sp/>useful<sp/>for</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="230"><highlight class="normal"></highlight><highlight class="comment">//<sp/>exporting<sp/>the<sp/>functions<sp/>when<sp/>compiling<sp/>VMA<sp/>as<sp/>a<sp/>separate<sp/>library.<sp/>Example:</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="231"><highlight class="normal"></highlight><highlight class="comment">//<sp/>#define<sp/>VMA_CALL_PRE<sp/><sp/>__declspec(dllexport)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="232"><highlight class="normal"></highlight><highlight class="comment">//<sp/>#define<sp/>VMA_CALL_POST<sp/>__cdecl</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="233"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_CALL_PRE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="234" refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#define<sp/>VMA_CALL_PRE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="235"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="236"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_CALL_POST</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="237" refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#define<sp/>VMA_CALL_POST</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="238"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="239"><highlight class="normal"></highlight></codeline>
<codeline lineno="240"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Define<sp/>this<sp/>macro<sp/>to<sp/>decorate<sp/>pointers<sp/>with<sp/>an<sp/>attribute<sp/>specifying<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="241"><highlight class="normal"></highlight><highlight class="comment">//<sp/>length<sp/>of<sp/>the<sp/>array<sp/>they<sp/>point<sp/>to<sp/>if<sp/>they<sp/>are<sp/>not<sp/>null.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="242"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="243"><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>length<sp/>may<sp/>be<sp/>one<sp/>of</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="244"><highlight class="normal"></highlight><highlight class="comment">//<sp/>-<sp/>The<sp/>name<sp/>of<sp/>another<sp/>parameter<sp/>in<sp/>the<sp/>argument<sp/>list<sp/>where<sp/>the<sp/>pointer<sp/>is<sp/>declared</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="245"><highlight class="normal"></highlight><highlight class="comment">//<sp/>-<sp/>The<sp/>name<sp/>of<sp/>another<sp/>member<sp/>in<sp/>the<sp/>struct<sp/>where<sp/>the<sp/>pointer<sp/>is<sp/>declared</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="246"><highlight class="normal"></highlight><highlight class="comment">//<sp/>-<sp/>The<sp/>name<sp/>of<sp/>a<sp/>member<sp/>of<sp/>a<sp/>struct<sp/>type,<sp/>meaning<sp/>the<sp/>value<sp/>of<sp/>that<sp/>member<sp/>in</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="247"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/>the<sp/>context<sp/>of<sp/>the<sp/>call.<sp/>For<sp/>example</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="248"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/>VMA_LEN_IF_NOT_NULL(&quot;VkPhysicalDeviceMemoryProperties::memoryHeapCount&quot;),</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="249"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/>this<sp/>means<sp/>the<sp/>number<sp/>of<sp/>memory<sp/>heaps<sp/>available<sp/>in<sp/>the<sp/>device<sp/>associated</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="250"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/>with<sp/>the<sp/>VmaAllocator<sp/>being<sp/>dealt<sp/>with.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="251"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_LEN_IF_NOT_NULL</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="252" refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#define<sp/>VMA_LEN_IF_NOT_NULL(len)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="253"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="254"><highlight class="normal"></highlight></codeline>
<codeline lineno="255"><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>VMA_NULLABLE<sp/>macro<sp/>is<sp/>defined<sp/>to<sp/>be<sp/>_Nullable<sp/>when<sp/>compiling<sp/>with<sp/>Clang.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="256"><highlight class="normal"></highlight><highlight class="comment">//<sp/>see:<sp/>https://clang.llvm.org/docs/AttributeReference.html#nullable</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="257"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_NULLABLE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="258"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#ifdef<sp/>__clang__</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="259"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_NULLABLE<sp/>_Nullable</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="260"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="261" refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_NULLABLE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="262"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="263"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="264"><highlight class="normal"></highlight></codeline>
<codeline lineno="265"><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>VMA_NOT_NULL<sp/>macro<sp/>is<sp/>defined<sp/>to<sp/>be<sp/>_Nonnull<sp/>when<sp/>compiling<sp/>with<sp/>Clang.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="266"><highlight class="normal"></highlight><highlight class="comment">//<sp/>see:<sp/>https://clang.llvm.org/docs/AttributeReference.html#nonnull</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="267"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_NOT_NULL</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="268"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#ifdef<sp/>__clang__</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="269"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_NOT_NULL<sp/>_Nonnull</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="270"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="271" refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_NOT_NULL</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="272"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="273"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="274"><highlight class="normal"></highlight></codeline>
<codeline lineno="275"><highlight class="normal"></highlight><highlight class="comment">//<sp/>If<sp/>non-dispatchable<sp/>handles<sp/>are<sp/>represented<sp/>as<sp/>pointers<sp/>then<sp/>we<sp/>can<sp/>give</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="276"><highlight class="normal"></highlight><highlight class="comment">//<sp/>then<sp/>nullability<sp/>annotations</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="277"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_NOT_NULL_NON_DISPATCHABLE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="278"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#if<sp/>defined(__LP64__)<sp/>||<sp/>defined(_WIN64)<sp/>||<sp/>(defined(__x86_64__)<sp/>&amp;&amp;<sp/>!defined(__ILP32__)<sp/>)<sp/>||<sp/>defined(_M_X64)<sp/>||<sp/>defined(__ia64)<sp/>||<sp/>defined<sp/>(_M_IA64)<sp/>||<sp/>defined(__aarch64__)<sp/>||<sp/>defined(__powerpc64__)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="279"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_NOT_NULL_NON_DISPATCHABLE<sp/>VMA_NOT_NULL</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="280"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="281" refid="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_NOT_NULL_NON_DISPATCHABLE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="282"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="283"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="284"><highlight class="normal"></highlight></codeline>
<codeline lineno="285"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_NULLABLE_NON_DISPATCHABLE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="286"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#if<sp/>defined(__LP64__)<sp/>||<sp/>defined(_WIN64)<sp/>||<sp/>(defined(__x86_64__)<sp/>&amp;&amp;<sp/>!defined(__ILP32__)<sp/>)<sp/>||<sp/>defined(_M_X64)<sp/>||<sp/>defined(__ia64)<sp/>||<sp/>defined<sp/>(_M_IA64)<sp/>||<sp/>defined(__aarch64__)<sp/>||<sp/>defined(__powerpc64__)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="287"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_NULLABLE_NON_DISPATCHABLE<sp/>VMA_NULLABLE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="288"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="289" refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_NULLABLE_NON_DISPATCHABLE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="290"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="291"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="292"><highlight class="normal"></highlight></codeline>
<codeline lineno="293"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="294" refid="vk__mem__alloc_8h_1ae25f0d55fd91cb166f002b63244800e1" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#define<sp/>VMA_STATS_STRING_ENABLED<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="295"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="296"><highlight class="normal"></highlight></codeline>
<codeline lineno="299"><highlight class="comment">//<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="300"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/>INTERFACE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="301"><highlight class="normal"></highlight><highlight class="comment">//<sp/></highlight></codeline>
<codeline lineno="304"><highlight class="comment"></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="305"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Sections<sp/>for<sp/>managing<sp/>code<sp/>placement<sp/>in<sp/>file,<sp/>only<sp/>for<sp/>development<sp/>purposes<sp/>e.g.<sp/>for<sp/>convenient<sp/>folding<sp/>inside<sp/>an<sp/>IDE.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="306"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_ENUM_DECLARATIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="307"><highlight class="normal"></highlight></codeline>
<codeline lineno="314" refid="group__group__init_1ga4f87c9100d154a65a4ad495f7763cf7c" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/><ref refid="group__group__init_1ga4f87c9100d154a65a4ad495f7763cf7c" kindref="member">VmaAllocatorCreateFlagBits</ref></highlight></codeline>
<codeline lineno="315"><highlight class="normal">{</highlight></codeline>
<codeline lineno="320" refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7ca4816ddaed324ba110172ca608a20f29d" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7ca4816ddaed324ba110172ca608a20f29d" kindref="member">VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT</ref><sp/>=<sp/>0x00000001,</highlight></codeline>
<codeline lineno="345" refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7cace7da7cc6e71a625dfa763c55a597878" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7cace7da7cc6e71a625dfa763c55a597878" kindref="member">VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT</ref><sp/>=<sp/>0x00000002,</highlight></codeline>
<codeline lineno="360" refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7ca8fb75bf07cd184ab903596295e863dee" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7ca8fb75bf07cd184ab903596295e863dee" kindref="member">VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</ref><sp/>=<sp/>0x00000004,</highlight></codeline>
<codeline lineno="372" refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7ca4d4687863f7bd4b418c6006dc04400b0" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7ca4d4687863f7bd4b418c6006dc04400b0" kindref="member">VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT</ref><sp/>=<sp/>0x00000008,</highlight></codeline>
<codeline lineno="390" refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7ca2acce4886d8078552efa38878413970f" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7ca2acce4886d8078552efa38878413970f" kindref="member">VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT</ref><sp/>=<sp/>0x00000010,</highlight></codeline>
<codeline lineno="408" refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7ca5f1b28b0414319d1687e1f2b30ab0089" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7ca5f1b28b0414319d1687e1f2b30ab0089" kindref="member">VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT</ref><sp/>=<sp/>0x00000020,</highlight></codeline>
<codeline lineno="425" refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7caffdd7a5169be3dbd7cbf6b3619e4f78a" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7caffdd7a5169be3dbd7cbf6b3619e4f78a" kindref="member">VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT</ref><sp/>=<sp/>0x00000040,</highlight></codeline>
<codeline lineno="426"><highlight class="normal"></highlight></codeline>
<codeline lineno="427"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7cae4d5ad929caba5f23eb502b13bd5286c" kindref="member">VMA_ALLOCATOR_CREATE_FLAG_BITS_MAX_ENUM</ref><sp/>=<sp/>0x7FFFFFFF</highlight></codeline>
<codeline lineno="428" refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7cae4d5ad929caba5f23eb502b13bd5286c" refkind="member"><highlight class="normal">}<sp/><ref refid="group__group__init_1ga4f87c9100d154a65a4ad495f7763cf7c" kindref="member">VmaAllocatorCreateFlagBits</ref>;</highlight></codeline>
<codeline lineno="430" refid="group__group__init_1gacfe6863e160722c2c1bbcf7573fddc4d" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VkFlags<sp/><ref refid="group__group__init_1gacfe6863e160722c2c1bbcf7573fddc4d" kindref="member">VmaAllocatorCreateFlags</ref>;</highlight></codeline>
<codeline lineno="431"><highlight class="normal"></highlight></codeline>
<codeline lineno="440" refid="group__group__alloc_1gaa5846affa1e9da3800e3e78fae2305cc" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1gaa5846affa1e9da3800e3e78fae2305cc" kindref="member">VmaMemoryUsage</ref></highlight></codeline>
<codeline lineno="441"><highlight class="normal">{</highlight></codeline>
<codeline lineno="445" refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305ccaf50d27e34e0925cf3a63db8c839121dd" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305ccaf50d27e34e0925cf3a63db8c839121dd" kindref="member">VMA_MEMORY_USAGE_UNKNOWN</ref><sp/>=<sp/>0,</highlight></codeline>
<codeline lineno="450" refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305ccac6b5dc1432d88647aa4cd456246eadf7" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305ccac6b5dc1432d88647aa4cd456246eadf7" kindref="member">VMA_MEMORY_USAGE_GPU_ONLY</ref><sp/>=<sp/>1,</highlight></codeline>
<codeline lineno="455" refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca40bdf4cddeffeb12f43d45ca1286e0a5" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca40bdf4cddeffeb12f43d45ca1286e0a5" kindref="member">VMA_MEMORY_USAGE_CPU_ONLY</ref><sp/>=<sp/>2,</highlight></codeline>
<codeline lineno="460" refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca9066b52c5a7079bb74a69aaf8b92ff67" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca9066b52c5a7079bb74a69aaf8b92ff67" kindref="member">VMA_MEMORY_USAGE_CPU_TO_GPU</ref><sp/>=<sp/>3,</highlight></codeline>
<codeline lineno="465" refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca7b586d2fdaf82a463b58f581ed72be27" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca7b586d2fdaf82a463b58f581ed72be27" kindref="member">VMA_MEMORY_USAGE_GPU_TO_CPU</ref><sp/>=<sp/>4,</highlight></codeline>
<codeline lineno="470" refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca416a444d4d0fc20067c3f76f32ff2500" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca416a444d4d0fc20067c3f76f32ff2500" kindref="member">VMA_MEMORY_USAGE_CPU_COPY</ref><sp/>=<sp/>5,</highlight></codeline>
<codeline lineno="479" refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca835333d9072db63a653818030e17614d" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca835333d9072db63a653818030e17614d" kindref="member">VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED</ref><sp/>=<sp/>6,</highlight></codeline>
<codeline lineno="492" refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e" kindref="member">VMA_MEMORY_USAGE_AUTO</ref><sp/>=<sp/>7,</highlight></codeline>
<codeline lineno="504" refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305ccae2adb696d6a73c18bb20c23666661327" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305ccae2adb696d6a73c18bb20c23666661327" kindref="member">VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE</ref><sp/>=<sp/>8,</highlight></codeline>
<codeline lineno="516" refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca9b422585242160b8ed3418310ee6664d" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca9b422585242160b8ed3418310ee6664d" kindref="member">VMA_MEMORY_USAGE_AUTO_PREFER_HOST</ref><sp/>=<sp/>9,</highlight></codeline>
<codeline lineno="517"><highlight class="normal"></highlight></codeline>
<codeline lineno="518"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca091e69437ef693e8d0d287f1c719ba6e" kindref="member">VMA_MEMORY_USAGE_MAX_ENUM</ref><sp/>=<sp/>0x7FFFFFFF</highlight></codeline>
<codeline lineno="519" refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca091e69437ef693e8d0d287f1c719ba6e" refkind="member"><highlight class="normal">}<sp/><ref refid="group__group__alloc_1gaa5846affa1e9da3800e3e78fae2305cc" kindref="member">VmaMemoryUsage</ref>;</highlight></codeline>
<codeline lineno="520"><highlight class="normal"></highlight></codeline>
<codeline lineno="522" refid="group__group__alloc_1gad9889c10c798b040d59c92f257cae597" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1gad9889c10c798b040d59c92f257cae597" kindref="member">VmaAllocationCreateFlagBits</ref></highlight></codeline>
<codeline lineno="523"><highlight class="normal">{</highlight></codeline>
<codeline lineno="528" refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" kindref="member">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</ref><sp/>=<sp/>0x00000001,</highlight></codeline>
<codeline lineno="529"><highlight class="normal"></highlight></codeline>
<codeline lineno="538" refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a89759603401014eb325eb22a3839f2ff" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a89759603401014eb325eb22a3839f2ff" kindref="member">VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</ref><sp/>=<sp/>0x00000002,</highlight></codeline>
<codeline lineno="549" refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" kindref="member">VMA_ALLOCATION_CREATE_MAPPED_BIT</ref><sp/>=<sp/>0x00000004,</highlight></codeline>
<codeline lineno="557" refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597aa6f24f821cd6a7c5e4a443f7bf59c520" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597aa6f24f821cd6a7c5e4a443f7bf59c520" kindref="member">VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</ref><sp/>=<sp/>0x00000020,</highlight></codeline>
<codeline lineno="562" refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a42ba3a2d2c7117953210b7c3ef8da0df" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a42ba3a2d2c7117953210b7c3ef8da0df" kindref="member">VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT</ref><sp/>=<sp/>0x00000040,</highlight></codeline>
<codeline lineno="572" refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a2310568c62208af432724305fe29ccea" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a2310568c62208af432724305fe29ccea" kindref="member">VMA_ALLOCATION_CREATE_DONT_BIND_BIT</ref><sp/>=<sp/>0x00000080,</highlight></codeline>
<codeline lineno="576" refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597ab8b1764f3e9022368e440c057783b92d" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597ab8b1764f3e9022368e440c057783b92d" kindref="member">VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT</ref><sp/>=<sp/>0x00000100,</highlight></codeline>
<codeline lineno="582" refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597afb0ee060cd733aaa5e249704ff589ad6" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597afb0ee060cd733aaa5e249704ff589ad6" kindref="member">VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT</ref><sp/>=<sp/>0x00000200,</highlight></codeline>
<codeline lineno="598" refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</ref><sp/>=<sp/>0x00000400,</highlight></codeline>
<codeline lineno="610" refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</ref><sp/>=<sp/>0x00000800,</highlight></codeline>
<codeline lineno="622" refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11337f96eacf34c1016c339eac165cad" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11337f96eacf34c1016c339eac165cad" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</ref><sp/>=<sp/>0x00001000,</highlight></codeline>
<codeline lineno="626" refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8af1210cf591784afa026d94998f735d" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8af1210cf591784afa026d94998f735d" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</ref><sp/>=<sp/>0x00010000,</highlight></codeline>
<codeline lineno="631" refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a0729e932b7ea170e3a128cad96c5cf6d" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a0729e932b7ea170e3a128cad96c5cf6d" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</ref><sp/>=<sp/>0x00020000,</highlight></codeline>
<codeline lineno="636" refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8099acedc0d04cdccaaddcfe37fd227d" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8099acedc0d04cdccaaddcfe37fd227d" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</ref><sp/><sp/>=<sp/>0x00040000,</highlight></codeline>
<codeline lineno="639" refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a839826775c62319466441f86496f036d" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a839826775c62319466441f86496f036d" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</ref><sp/>=<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8af1210cf591784afa026d94998f735d" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</ref>,</highlight></codeline>
<codeline lineno="642" refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a33eb2052674f3ad92386c714a65fb777" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a33eb2052674f3ad92386c714a65fb777" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</ref><sp/>=<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a0729e932b7ea170e3a128cad96c5cf6d" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</ref>,</highlight></codeline>
<codeline lineno="645"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8e16845d81ae3d27c47106d4770d5c7e" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MASK</ref><sp/>=</highlight></codeline>
<codeline lineno="646"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8af1210cf591784afa026d94998f735d" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</ref><sp/>|</highlight></codeline>
<codeline lineno="647"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a0729e932b7ea170e3a128cad96c5cf6d" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</ref><sp/>|</highlight></codeline>
<codeline lineno="648" refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8e16845d81ae3d27c47106d4770d5c7e" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8099acedc0d04cdccaaddcfe37fd227d" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</ref>,</highlight></codeline>
<codeline lineno="649"><highlight class="normal"></highlight></codeline>
<codeline lineno="650"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597ae5633ec569f4899cf8f29e7385b2f882" kindref="member">VMA_ALLOCATION_CREATE_FLAG_BITS_MAX_ENUM</ref><sp/>=<sp/>0x7FFFFFFF</highlight></codeline>
<codeline lineno="651" refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597ae5633ec569f4899cf8f29e7385b2f882" refkind="member"><highlight class="normal">}<sp/><ref refid="group__group__alloc_1gad9889c10c798b040d59c92f257cae597" kindref="member">VmaAllocationCreateFlagBits</ref>;</highlight></codeline>
<codeline lineno="653" refid="group__group__alloc_1ga5225e5e11f8376f6a31a1791f3d6e817" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VkFlags<sp/><ref refid="group__group__alloc_1ga5225e5e11f8376f6a31a1791f3d6e817" kindref="member">VmaAllocationCreateFlags</ref>;</highlight></codeline>
<codeline lineno="654"><highlight class="normal"></highlight></codeline>
<codeline lineno="656" refid="group__group__alloc_1ga9a7c45f9c863695d98c83fa5ac940fe7" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1ga9a7c45f9c863695d98c83fa5ac940fe7" kindref="member">VmaPoolCreateFlagBits</ref></highlight></codeline>
<codeline lineno="657"><highlight class="normal">{</highlight></codeline>
<codeline lineno="675" refid="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7a9f1a499508a8edb4e8ba40aa0290a3d2" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7a9f1a499508a8edb4e8ba40aa0290a3d2" kindref="member">VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT</ref><sp/>=<sp/>0x00000002,</highlight></codeline>
<codeline lineno="676"><highlight class="normal"></highlight></codeline>
<codeline lineno="688" refid="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726" kindref="member">VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</ref><sp/>=<sp/>0x00000004,</highlight></codeline>
<codeline lineno="689"><highlight class="normal"></highlight></codeline>
<codeline lineno="692"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7af4d270f8f42517a0f70037ceb6ac1d9c" kindref="member">VMA_POOL_CREATE_ALGORITHM_MASK</ref><sp/>=</highlight></codeline>
<codeline lineno="693" refid="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7af4d270f8f42517a0f70037ceb6ac1d9c" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726" kindref="member">VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</ref>,</highlight></codeline>
<codeline lineno="694"><highlight class="normal"></highlight></codeline>
<codeline lineno="695"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7a1c7312bea9ea246846b9054fd6bd6aec" kindref="member">VMA_POOL_CREATE_FLAG_BITS_MAX_ENUM</ref><sp/>=<sp/>0x7FFFFFFF</highlight></codeline>
<codeline lineno="696" refid="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7a1c7312bea9ea246846b9054fd6bd6aec" refkind="member"><highlight class="normal">}<sp/><ref refid="group__group__alloc_1ga9a7c45f9c863695d98c83fa5ac940fe7" kindref="member">VmaPoolCreateFlagBits</ref>;</highlight></codeline>
<codeline lineno="698" refid="group__group__alloc_1ga2770e325ea42e087c1b91fdf46d0292a" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VkFlags<sp/><ref refid="group__group__alloc_1ga2770e325ea42e087c1b91fdf46d0292a" kindref="member">VmaPoolCreateFlags</ref>;</highlight></codeline>
<codeline lineno="699"><highlight class="normal"></highlight></codeline>
<codeline lineno="701" refid="group__group__alloc_1ga6552a65b71d16f378c6994b3ceaef50c" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1ga6552a65b71d16f378c6994b3ceaef50c" kindref="member">VmaDefragmentationFlagBits</ref></highlight></codeline>
<codeline lineno="702"><highlight class="normal">{</highlight></codeline>
<codeline lineno="703"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>\brief<sp/>Use<sp/>simple<sp/>but<sp/>fast<sp/>algorithm<sp/>for<sp/>defragmentation.</highlight></codeline>
<codeline lineno="704"><highlight class="comment"><sp/><sp/><sp/><sp/>May<sp/>not<sp/>achieve<sp/>best<sp/>results<sp/>but<sp/>will<sp/>require<sp/>least<sp/>time<sp/>to<sp/>compute<sp/>and<sp/>least<sp/>allocations<sp/>to<sp/>copy.</highlight></codeline>
<codeline lineno="705"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="706" refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50ca2e6469bcf5a094776ceb5d118263f04b" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50ca2e6469bcf5a094776ceb5d118263f04b" kindref="member">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT</ref><sp/>=<sp/>0x1,</highlight></codeline>
<codeline lineno="707"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>\brief<sp/>Default<sp/>defragmentation<sp/>algorithm,<sp/>applied<sp/>also<sp/>when<sp/>no<sp/>`ALGORITHM`<sp/>flag<sp/>is<sp/>specified.</highlight></codeline>
<codeline lineno="708"><highlight class="comment"><sp/><sp/><sp/><sp/>Offers<sp/>a<sp/>balance<sp/>between<sp/>defragmentation<sp/>quality<sp/>and<sp/>the<sp/>amount<sp/>of<sp/>allocations<sp/>and<sp/>bytes<sp/>that<sp/>need<sp/>to<sp/>be<sp/>moved.</highlight></codeline>
<codeline lineno="709"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="710" refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50caec35a4138111605a6ff32ca61aa871b6" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50caec35a4138111605a6ff32ca61aa871b6" kindref="member">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT</ref><sp/>=<sp/>0x2,</highlight></codeline>
<codeline lineno="711"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>\brief<sp/>Perform<sp/>full<sp/>defragmentation<sp/>of<sp/>memory.</highlight></codeline>
<codeline lineno="712"><highlight class="comment"><sp/><sp/><sp/><sp/>Can<sp/>result<sp/>in<sp/>notably<sp/>more<sp/>time<sp/>to<sp/>compute<sp/>and<sp/>allocations<sp/>to<sp/>copy,<sp/>but<sp/>will<sp/>achieve<sp/>best<sp/>memory<sp/>packing.</highlight></codeline>
<codeline lineno="713"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="714" refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50cafa162eac5be800bcdd4011427a71156d" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50cafa162eac5be800bcdd4011427a71156d" kindref="member">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT</ref><sp/>=<sp/>0x4,</highlight></codeline>
<codeline lineno="720" refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50cae45a9469e5337731627758671741e412" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50cae45a9469e5337731627758671741e412" kindref="member">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT</ref><sp/>=<sp/>0x8,</highlight></codeline>
<codeline lineno="721"><highlight class="normal"></highlight></codeline>
<codeline lineno="723"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50cabcbbdb3bfd53c4c3ab4eaeb5fd4894e9" kindref="member">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_MASK</ref><sp/>=<sp/></highlight></codeline>
<codeline lineno="724"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50ca2e6469bcf5a094776ceb5d118263f04b" kindref="member">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT</ref><sp/>|</highlight></codeline>
<codeline lineno="725"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50caec35a4138111605a6ff32ca61aa871b6" kindref="member">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT</ref><sp/>|</highlight></codeline>
<codeline lineno="726"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50cafa162eac5be800bcdd4011427a71156d" kindref="member">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT</ref><sp/>|</highlight></codeline>
<codeline lineno="727" refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50cabcbbdb3bfd53c4c3ab4eaeb5fd4894e9" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50cae45a9469e5337731627758671741e412" kindref="member">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT</ref>,</highlight></codeline>
<codeline lineno="728"><highlight class="normal"></highlight></codeline>
<codeline lineno="729"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50cab87ec33154803bfeb5ac2b379f1d6a97" kindref="member">VMA_DEFRAGMENTATION_FLAG_BITS_MAX_ENUM</ref><sp/>=<sp/>0x7FFFFFFF</highlight></codeline>
<codeline lineno="730" refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50cab87ec33154803bfeb5ac2b379f1d6a97" refkind="member"><highlight class="normal">}<sp/><ref refid="group__group__alloc_1ga6552a65b71d16f378c6994b3ceaef50c" kindref="member">VmaDefragmentationFlagBits</ref>;</highlight></codeline>
<codeline lineno="732" refid="group__group__alloc_1ga88a77cef37e5d3c4fc9eb328885d048d" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VkFlags<sp/><ref refid="group__group__alloc_1ga88a77cef37e5d3c4fc9eb328885d048d" kindref="member">VmaDefragmentationFlags</ref>;</highlight></codeline>
<codeline lineno="733"><highlight class="normal"></highlight></codeline>
<codeline lineno="735" refid="group__group__alloc_1gada9e3861caf96f08894b0bcc160ec257" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1gada9e3861caf96f08894b0bcc160ec257" kindref="member">VmaDefragmentationMoveOperation</ref></highlight></codeline>
<codeline lineno="736"><highlight class="normal">{</highlight></codeline>
<codeline lineno="738" refid="group__group__alloc_1ggada9e3861caf96f08894b0bcc160ec257ad4a06ac46c4cb1c67b0ebc1edfab9f18" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggada9e3861caf96f08894b0bcc160ec257ad4a06ac46c4cb1c67b0ebc1edfab9f18" kindref="member">VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY</ref><sp/>=<sp/>0,</highlight></codeline>
<codeline lineno="740" refid="group__group__alloc_1ggada9e3861caf96f08894b0bcc160ec257ad25bc6f816b226b4fd5170e845f218d2" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggada9e3861caf96f08894b0bcc160ec257ad25bc6f816b226b4fd5170e845f218d2" kindref="member">VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE</ref><sp/>=<sp/>1,</highlight></codeline>
<codeline lineno="742" refid="group__group__alloc_1ggada9e3861caf96f08894b0bcc160ec257a9786f8492a9be2c03bd26395e352ab85" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggada9e3861caf96f08894b0bcc160ec257a9786f8492a9be2c03bd26395e352ab85" kindref="member">VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY</ref><sp/>=<sp/>2,</highlight></codeline>
<codeline lineno="743" refid="group__group__alloc_1ga2ea666deeb3c2c74806a097e27cdb4a1" refkind="member"><highlight class="normal">}<sp/><ref refid="group__group__alloc_1gada9e3861caf96f08894b0bcc160ec257" kindref="member">VmaDefragmentationMoveOperation</ref>;</highlight></codeline>
<codeline lineno="744"><highlight class="normal"></highlight></codeline>
<codeline lineno="753" refid="group__group__virtual_1ga88bcf8c1cd3bb1610ff7343811c65bca" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/><ref refid="group__group__virtual_1ga88bcf8c1cd3bb1610ff7343811c65bca" kindref="member">VmaVirtualBlockCreateFlagBits</ref></highlight></codeline>
<codeline lineno="754"><highlight class="normal">{</highlight></codeline>
<codeline lineno="766" refid="group__group__virtual_1gga88bcf8c1cd3bb1610ff7343811c65bcaae6423e2fa2f3c9211b21c819e3f10f96" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__virtual_1gga88bcf8c1cd3bb1610ff7343811c65bcaae6423e2fa2f3c9211b21c819e3f10f96" kindref="member">VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT</ref><sp/>=<sp/>0x00000001,</highlight></codeline>
<codeline lineno="767"><highlight class="normal"></highlight></codeline>
<codeline lineno="770"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__virtual_1gga88bcf8c1cd3bb1610ff7343811c65bcaaf9487467136e1a9e371894dc3a7c4844" kindref="member">VMA_VIRTUAL_BLOCK_CREATE_ALGORITHM_MASK</ref><sp/>=</highlight></codeline>
<codeline lineno="771" refid="group__group__virtual_1gga88bcf8c1cd3bb1610ff7343811c65bcaaf9487467136e1a9e371894dc3a7c4844" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__group__virtual_1gga88bcf8c1cd3bb1610ff7343811c65bcaae6423e2fa2f3c9211b21c819e3f10f96" kindref="member">VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT</ref>,</highlight></codeline>
<codeline lineno="772"><highlight class="normal"></highlight></codeline>
<codeline lineno="773"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__virtual_1gga88bcf8c1cd3bb1610ff7343811c65bcaa5fc0d333c3d5687a8bbf57df9b377a87" kindref="member">VMA_VIRTUAL_BLOCK_CREATE_FLAG_BITS_MAX_ENUM</ref><sp/>=<sp/>0x7FFFFFFF</highlight></codeline>
<codeline lineno="774" refid="group__group__virtual_1gga88bcf8c1cd3bb1610ff7343811c65bcaa5fc0d333c3d5687a8bbf57df9b377a87" refkind="member"><highlight class="normal">}<sp/><ref refid="group__group__virtual_1ga88bcf8c1cd3bb1610ff7343811c65bca" kindref="member">VmaVirtualBlockCreateFlagBits</ref>;</highlight></codeline>
<codeline lineno="776" refid="group__group__virtual_1ga4e49c2f0ab7f6b4868833e5bac78d91e" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VkFlags<sp/><ref refid="group__group__virtual_1ga4e49c2f0ab7f6b4868833e5bac78d91e" kindref="member">VmaVirtualBlockCreateFlags</ref>;</highlight></codeline>
<codeline lineno="777"><highlight class="normal"></highlight></codeline>
<codeline lineno="779" refid="group__group__virtual_1ga2e9c64d405b14156fea7e10c4ad06cb6" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/><ref refid="group__group__virtual_1ga2e9c64d405b14156fea7e10c4ad06cb6" kindref="member">VmaVirtualAllocationCreateFlagBits</ref></highlight></codeline>
<codeline lineno="780"><highlight class="normal">{</highlight></codeline>
<codeline lineno="785" refid="group__group__virtual_1gga2e9c64d405b14156fea7e10c4ad06cb6a9524a329a55b5ec390d57d90b67ad78e" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__virtual_1gga2e9c64d405b14156fea7e10c4ad06cb6a9524a329a55b5ec390d57d90b67ad78e" kindref="member">VMA_VIRTUAL_ALLOCATION_CREATE_UPPER_ADDRESS_BIT</ref><sp/>=<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a42ba3a2d2c7117953210b7c3ef8da0df" kindref="member">VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT</ref>,</highlight></codeline>
<codeline lineno="788" refid="group__group__virtual_1gga2e9c64d405b14156fea7e10c4ad06cb6ae2a9591a62b5e3b1bdcbc81c6188a1bf" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__virtual_1gga2e9c64d405b14156fea7e10c4ad06cb6ae2a9591a62b5e3b1bdcbc81c6188a1bf" kindref="member">VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</ref><sp/>=<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8af1210cf591784afa026d94998f735d" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</ref>,</highlight></codeline>
<codeline lineno="791" refid="group__group__virtual_1gga2e9c64d405b14156fea7e10c4ad06cb6a562d10a46012719d33167d3dc5dbbf9b" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__virtual_1gga2e9c64d405b14156fea7e10c4ad06cb6a562d10a46012719d33167d3dc5dbbf9b" kindref="member">VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</ref><sp/>=<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a0729e932b7ea170e3a128cad96c5cf6d" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</ref>,</highlight></codeline>
<codeline lineno="795" refid="group__group__virtual_1gga2e9c64d405b14156fea7e10c4ad06cb6a3bb82d2aedd587a64846a1d7778852e6" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__virtual_1gga2e9c64d405b14156fea7e10c4ad06cb6a3bb82d2aedd587a64846a1d7778852e6" kindref="member">VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</ref><sp/>=<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8099acedc0d04cdccaaddcfe37fd227d" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</ref>,</highlight></codeline>
<codeline lineno="800" refid="group__group__virtual_1gga2e9c64d405b14156fea7e10c4ad06cb6ac5b5e45c335368d18df59c9f27df17e3" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__virtual_1gga2e9c64d405b14156fea7e10c4ad06cb6ac5b5e45c335368d18df59c9f27df17e3" kindref="member">VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MASK</ref><sp/>=<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8e16845d81ae3d27c47106d4770d5c7e" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MASK</ref>,</highlight></codeline>
<codeline lineno="801"><highlight class="normal"></highlight></codeline>
<codeline lineno="802"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__virtual_1gga2e9c64d405b14156fea7e10c4ad06cb6ac1163c03ea837fa663462dc286d6a1a9" kindref="member">VMA_VIRTUAL_ALLOCATION_CREATE_FLAG_BITS_MAX_ENUM</ref><sp/>=<sp/>0x7FFFFFFF</highlight></codeline>
<codeline lineno="803" refid="group__group__virtual_1gga2e9c64d405b14156fea7e10c4ad06cb6ac1163c03ea837fa663462dc286d6a1a9" refkind="member"><highlight class="normal">}<sp/><ref refid="group__group__virtual_1ga2e9c64d405b14156fea7e10c4ad06cb6" kindref="member">VmaVirtualAllocationCreateFlagBits</ref>;</highlight></codeline>
<codeline lineno="805" refid="group__group__virtual_1gae96ffc099bf898257fb19e9410ed08a7" refkind="member"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VkFlags<sp/><ref refid="group__group__virtual_1gae96ffc099bf898257fb19e9410ed08a7" kindref="member">VmaVirtualAllocationCreateFlags</ref>;</highlight></codeline>
<codeline lineno="806"><highlight class="normal"></highlight></codeline>
<codeline lineno="809"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_ENUM_DECLARATIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="810"><highlight class="normal"></highlight></codeline>
<codeline lineno="811"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_DATA_TYPES_DECLARATIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="812"><highlight class="normal"></highlight></codeline>
<codeline lineno="826"><highlight class="normal">VK_DEFINE_HANDLE(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref>)</highlight></codeline>
<codeline lineno="827"><highlight class="normal"></highlight></codeline>
<codeline lineno="828"><highlight class="normal"></highlight></codeline>
<codeline lineno="843"><highlight class="normal">VK_DEFINE_HANDLE(<ref refid="struct_vma_pool" kindref="compound">VmaPool</ref>)</highlight></codeline>
<codeline lineno="844"><highlight class="normal"></highlight></codeline>
<codeline lineno="845" refid="struct_vma_allocation" refkind="compound"><highlight class="normal"></highlight></codeline>
<codeline lineno="866"><highlight class="normal">VK_DEFINE_HANDLE(<ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>)</highlight></codeline>
<codeline lineno="867"><highlight class="normal"></highlight></codeline>
<codeline lineno="874"><highlight class="normal">VK_DEFINE_HANDLE(<ref refid="struct_vma_defragmentation_context" kindref="compound">VmaDefragmentationContext</ref>)</highlight></codeline>
<codeline lineno="875"><highlight class="normal"></highlight></codeline>
<codeline lineno="890" refid="group__group__virtual_1ga565936f8d98d225b536a2d9703bc7676" refkind="member"><highlight class="normal"><ref refid="group__group__virtual_1ga565936f8d98d225b536a2d9703bc7676" kindref="member">VK_DEFINE_NON_DISPATCHABLE_HANDLE</ref>(<ref refid="struct_vma_virtual_allocation" kindref="compound">VmaVirtualAllocation</ref>);</highlight></codeline>
<codeline lineno="891"><highlight class="normal"></highlight></codeline>
<codeline lineno="907"><highlight class="normal">VK_DEFINE_HANDLE(<ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref>)</highlight></codeline>
<codeline lineno="908"><highlight class="normal"></highlight></codeline>
<codeline lineno="917" refid="group__group__init_1gaaf884ddf34d1bb3be8365594d3882a0b" refkind="member"><highlight class="normal">typedef<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>(VKAPI_PTR*<sp/><ref refid="group__group__init_1gaaf884ddf34d1bb3be8365594d3882a0b" kindref="member">PFN_vmaAllocateDeviceMemoryFunction</ref>)(</highlight></codeline>
<codeline lineno="918"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocator,</highlight></codeline>
<codeline lineno="919"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memoryType,</highlight></codeline>
<codeline lineno="920"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceMemory<sp/><ref refid="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" kindref="member">VMA_NOT_NULL_NON_DISPATCHABLE</ref><sp/>memory,</highlight></codeline>
<codeline lineno="921"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size,</highlight></codeline>
<codeline lineno="922"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pUserData);</highlight></codeline>
<codeline lineno="923"><highlight class="normal"></highlight></codeline>
<codeline lineno="925" refid="group__group__init_1ga786c0d8679f6fd36ce796a19cc80afbe" refkind="member"><highlight class="normal">typedef<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>(VKAPI_PTR*<sp/><ref refid="group__group__init_1ga786c0d8679f6fd36ce796a19cc80afbe" kindref="member">PFN_vmaFreeDeviceMemoryFunction</ref>)(</highlight></codeline>
<codeline lineno="926"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocator,</highlight></codeline>
<codeline lineno="927"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memoryType,</highlight></codeline>
<codeline lineno="928"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceMemory<sp/><ref refid="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" kindref="member">VMA_NOT_NULL_NON_DISPATCHABLE</ref><sp/>memory,</highlight></codeline>
<codeline lineno="929"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size,</highlight></codeline>
<codeline lineno="930"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pUserData);</highlight></codeline>
<codeline lineno="931"><highlight class="normal"></highlight></codeline>
<codeline lineno="939" refid="struct_vma_device_memory_callbacks" refkind="compound"><highlight class="normal">typedef<sp/>struct<sp/><ref refid="struct_vma_device_memory_callbacks" kindref="compound">VmaDeviceMemoryCallbacks</ref></highlight></codeline>
<codeline lineno="940"><highlight class="normal">{</highlight></codeline>
<codeline lineno="942" refid="struct_vma_device_memory_callbacks_1ac02066cbe29d1f2f97c68c8c462ee3d5" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__init_1gaaf884ddf34d1bb3be8365594d3882a0b" kindref="member">PFN_vmaAllocateDeviceMemoryFunction</ref><sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_device_memory_callbacks_1ac02066cbe29d1f2f97c68c8c462ee3d5" kindref="member">pfnAllocate</ref>;</highlight></codeline>
<codeline lineno="944" refid="struct_vma_device_memory_callbacks_1a74348a8b9bdb165535e010ed195bfdb9" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__init_1ga786c0d8679f6fd36ce796a19cc80afbe" kindref="member">PFN_vmaFreeDeviceMemoryFunction</ref><sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_device_memory_callbacks_1a74348a8b9bdb165535e010ed195bfdb9" kindref="member">pfnFree</ref>;</highlight></codeline>
<codeline lineno="946" refid="struct_vma_device_memory_callbacks_1a84102b94fa445b59a8b02b44e7dcb43f" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_device_memory_callbacks_1a84102b94fa445b59a8b02b44e7dcb43f" kindref="member">pUserData</ref>;</highlight></codeline>
<codeline lineno="947" refid="group__group__init_1ga77692d3c8770ea8882d573206bd27b2b" refkind="member"><highlight class="normal">}<sp/><ref refid="struct_vma_device_memory_callbacks" kindref="compound">VmaDeviceMemoryCallbacks</ref>;</highlight></codeline>
<codeline lineno="948"><highlight class="normal"></highlight></codeline>
<codeline lineno="953" refid="struct_vma_vulkan_functions" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="struct_vma_vulkan_functions" kindref="compound">VmaVulkanFunctions</ref></highlight></codeline>
<codeline lineno="954"><highlight class="normal">{</highlight></codeline>
<codeline lineno="956" refid="struct_vma_vulkan_functions_1a2ee50e592de96365bd2a56885d04a20e" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>PFN_vkGetInstanceProcAddr<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_vulkan_functions_1a2ee50e592de96365bd2a56885d04a20e" kindref="member">vkGetInstanceProcAddr</ref>;</highlight></codeline>
<codeline lineno="958" refid="struct_vma_vulkan_functions_1a5619d8409f652f337efd902a9f5470df" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>PFN_vkGetDeviceProcAddr<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_vulkan_functions_1a5619d8409f652f337efd902a9f5470df" kindref="member">vkGetDeviceProcAddr</ref>;</highlight></codeline>
<codeline lineno="959" refid="struct_vma_vulkan_functions_1a66827591f603617a14fee4a33ddeba64" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>PFN_vkGetPhysicalDeviceProperties<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_vulkan_functions_1a66827591f603617a14fee4a33ddeba64" kindref="member">vkGetPhysicalDeviceProperties</ref>;</highlight></codeline>
<codeline lineno="960" refid="struct_vma_vulkan_functions_1a2c85ad20b45bce9e6e623595ee3ec02b" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>PFN_vkGetPhysicalDeviceMemoryProperties<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_vulkan_functions_1a2c85ad20b45bce9e6e623595ee3ec02b" kindref="member">vkGetPhysicalDeviceMemoryProperties</ref>;</highlight></codeline>
<codeline lineno="961" refid="struct_vma_vulkan_functions_1ac1dafb0df4996598ff0b9db1bb929567" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>PFN_vkAllocateMemory<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_vulkan_functions_1ac1dafb0df4996598ff0b9db1bb929567" kindref="member">vkAllocateMemory</ref>;</highlight></codeline>
<codeline lineno="962" refid="struct_vma_vulkan_functions_1a1c9c93c0511b3b72000e702a8ffb1203" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>PFN_vkFreeMemory<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_vulkan_functions_1a1c9c93c0511b3b72000e702a8ffb1203" kindref="member">vkFreeMemory</ref>;</highlight></codeline>
<codeline lineno="963" refid="struct_vma_vulkan_functions_1ab2e0998e48dac62e3e4f934029bb9b4b" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>PFN_vkMapMemory<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_vulkan_functions_1ab2e0998e48dac62e3e4f934029bb9b4b" kindref="member">vkMapMemory</ref>;</highlight></codeline>
<codeline lineno="964" refid="struct_vma_vulkan_functions_1afe6d22b81344f5a7ed0e53c5ea79ba4f" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>PFN_vkUnmapMemory<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_vulkan_functions_1afe6d22b81344f5a7ed0e53c5ea79ba4f" kindref="member">vkUnmapMemory</ref>;</highlight></codeline>
<codeline lineno="965" refid="struct_vma_vulkan_functions_1a32ffd215651586145db81d98c103370a" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>PFN_vkFlushMappedMemoryRanges<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_vulkan_functions_1a32ffd215651586145db81d98c103370a" kindref="member">vkFlushMappedMemoryRanges</ref>;</highlight></codeline>
<codeline lineno="966" refid="struct_vma_vulkan_functions_1a882aaf8c7bb1172393e9c7c217224e24" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>PFN_vkInvalidateMappedMemoryRanges<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_vulkan_functions_1a882aaf8c7bb1172393e9c7c217224e24" kindref="member">vkInvalidateMappedMemoryRanges</ref>;</highlight></codeline>
<codeline lineno="967" refid="struct_vma_vulkan_functions_1a7ad8f3b7e1681ed017f4472850cc62fa" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>PFN_vkBindBufferMemory<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_vulkan_functions_1a7ad8f3b7e1681ed017f4472850cc62fa" kindref="member">vkBindBufferMemory</ref>;</highlight></codeline>
<codeline lineno="968" refid="struct_vma_vulkan_functions_1ad56c50d472fb75cc892b44f3ef3a51aa" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>PFN_vkBindImageMemory<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_vulkan_functions_1ad56c50d472fb75cc892b44f3ef3a51aa" kindref="member">vkBindImageMemory</ref>;</highlight></codeline>
<codeline lineno="969" refid="struct_vma_vulkan_functions_1aea05477481ca6f88a38182de3e0fc26a" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>PFN_vkGetBufferMemoryRequirements<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_vulkan_functions_1aea05477481ca6f88a38182de3e0fc26a" kindref="member">vkGetBufferMemoryRequirements</ref>;</highlight></codeline>
<codeline lineno="970" refid="struct_vma_vulkan_functions_1aed58624ef2f8d410b7889db504ff55c7" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>PFN_vkGetImageMemoryRequirements<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_vulkan_functions_1aed58624ef2f8d410b7889db504ff55c7" kindref="member">vkGetImageMemoryRequirements</ref>;</highlight></codeline>
<codeline lineno="971" refid="struct_vma_vulkan_functions_1a0bd2f3dbbfb386e856fcb0bde76329e0" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>PFN_vkCreateBuffer<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_vulkan_functions_1a0bd2f3dbbfb386e856fcb0bde76329e0" kindref="member">vkCreateBuffer</ref>;</highlight></codeline>
<codeline lineno="972" refid="struct_vma_vulkan_functions_1a8d54d31cc46f21c00fa5fc78085dfc90" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>PFN_vkDestroyBuffer<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_vulkan_functions_1a8d54d31cc46f21c00fa5fc78085dfc90" kindref="member">vkDestroyBuffer</ref>;</highlight></codeline>
<codeline lineno="973" refid="struct_vma_vulkan_functions_1abf5b72637db39313cfe1645cb7f07fdd" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>PFN_vkCreateImage<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_vulkan_functions_1abf5b72637db39313cfe1645cb7f07fdd" kindref="member">vkCreateImage</ref>;</highlight></codeline>
<codeline lineno="974" refid="struct_vma_vulkan_functions_1a14b5141287f45780bb1194a1ba6ff272" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>PFN_vkDestroyImage<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_vulkan_functions_1a14b5141287f45780bb1194a1ba6ff272" kindref="member">vkDestroyImage</ref>;</highlight></codeline>
<codeline lineno="975" refid="struct_vma_vulkan_functions_1a470630135f3c5fd8b3195f8fedc32a58" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>PFN_vkCmdCopyBuffer<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_vulkan_functions_1a470630135f3c5fd8b3195f8fedc32a58" kindref="member">vkCmdCopyBuffer</ref>;</highlight></codeline>
<codeline lineno="976"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_DEDICATED_ALLOCATION<sp/>||<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1001000</highlight></codeline>
<codeline lineno="978"><highlight class="normal"><sp/><sp/><sp/><sp/>PFN_vkGetBufferMemoryRequirements2KHR<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>vkGetBufferMemoryRequirements2KHR;</highlight></codeline>
<codeline lineno="980"><highlight class="normal"><sp/><sp/><sp/><sp/>PFN_vkGetImageMemoryRequirements2KHR<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>vkGetImageMemoryRequirements2KHR;</highlight></codeline>
<codeline lineno="981"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="982"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_BIND_MEMORY2<sp/>||<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1001000</highlight></codeline>
<codeline lineno="984"><highlight class="normal"><sp/><sp/><sp/><sp/>PFN_vkBindBufferMemory2KHR<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>vkBindBufferMemory2KHR;</highlight></codeline>
<codeline lineno="986"><highlight class="normal"><sp/><sp/><sp/><sp/>PFN_vkBindImageMemory2KHR<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>vkBindImageMemory2KHR;</highlight></codeline>
<codeline lineno="987"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="988"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_MEMORY_BUDGET<sp/>||<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1001000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="989"><highlight class="normal"><sp/><sp/><sp/><sp/>PFN_vkGetPhysicalDeviceMemoryProperties2KHR<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>vkGetPhysicalDeviceMemoryProperties2KHR;</highlight></codeline>
<codeline lineno="990"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="991"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1003000</highlight></codeline>
<codeline lineno="993"><highlight class="normal"><sp/><sp/><sp/><sp/>PFN_vkGetDeviceBufferMemoryRequirements<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>vkGetDeviceBufferMemoryRequirements;</highlight></codeline>
<codeline lineno="995"><highlight class="normal"><sp/><sp/><sp/><sp/>PFN_vkGetDeviceImageMemoryRequirements<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>vkGetDeviceImageMemoryRequirements;</highlight></codeline>
<codeline lineno="996"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="997" refid="group__group__init_1gabb0a8e3b5040d847571cca6c7f9a8074" refkind="member"><highlight class="normal">}<sp/><ref refid="struct_vma_vulkan_functions" kindref="compound">VmaVulkanFunctions</ref>;</highlight></codeline>
<codeline lineno="998"><highlight class="normal"></highlight></codeline>
<codeline lineno="1000" refid="struct_vma_allocator_create_info" refkind="compound"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="struct_vma_allocator_create_info" kindref="compound">VmaAllocatorCreateInfo</ref></highlight></codeline>
<codeline lineno="1001"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1003" refid="struct_vma_allocator_create_info_1a392ea2ecbaff93f91a7c49f735ad4346" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__init_1gacfe6863e160722c2c1bbcf7573fddc4d" kindref="member">VmaAllocatorCreateFlags</ref><sp/><ref refid="struct_vma_allocator_create_info_1a392ea2ecbaff93f91a7c49f735ad4346" kindref="member">flags</ref>;</highlight></codeline>
<codeline lineno="1005"><highlight class="normal"></highlight></codeline>
<codeline lineno="1006" refid="struct_vma_allocator_create_info_1ad09ce637aa92cb7c8c2a742943668087" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkPhysicalDevice<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/><ref refid="struct_vma_allocator_create_info_1ad09ce637aa92cb7c8c2a742943668087" kindref="member">physicalDevice</ref>;</highlight></codeline>
<codeline lineno="1008"><highlight class="normal"></highlight></codeline>
<codeline lineno="1009" refid="struct_vma_allocator_create_info_1ac35aa355d3bfcbf6bb2eb88ccf68125c" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDevice<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/><ref refid="struct_vma_allocator_create_info_1ac35aa355d3bfcbf6bb2eb88ccf68125c" kindref="member">device</ref>;</highlight></codeline>
<codeline lineno="1011"><highlight class="normal"></highlight></codeline>
<codeline lineno="1012" refid="struct_vma_allocator_create_info_1a8e4714298e3121cdd8b214a1ae7a637a" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/><ref refid="struct_vma_allocator_create_info_1a8e4714298e3121cdd8b214a1ae7a637a" kindref="member">preferredLargeHeapBlockSize</ref>;</highlight></codeline>
<codeline lineno="1014"><highlight class="normal"></highlight></codeline>
<codeline lineno="1015" refid="struct_vma_allocator_create_info_1aa84222aa55c2b42c1eff64b16978c8c2" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_allocator_create_info_1aa84222aa55c2b42c1eff64b16978c8c2" kindref="member">pAllocationCallbacks</ref>;</highlight></codeline>
<codeline lineno="1017"><highlight class="normal"></highlight></codeline>
<codeline lineno="1018" refid="struct_vma_allocator_create_info_1afbb24551124b16bdaa29f92eb96b8c56" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_device_memory_callbacks" kindref="compound">VmaDeviceMemoryCallbacks</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_allocator_create_info_1afbb24551124b16bdaa29f92eb96b8c56" kindref="member">pDeviceMemoryCallbacks</ref>;</highlight></codeline>
<codeline lineno="1043" refid="struct_vma_allocator_create_info_1ad19447d8c50cdb04f0f473009edccd7c" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_allocator_create_info_1ad19447d8c50cdb04f0f473009edccd7c" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(</highlight><highlight class="stringliteral">&quot;VkPhysicalDeviceMemoryProperties::memoryHeapCount&quot;</highlight><highlight class="normal">)<sp/>pHeapSizeLimit;</highlight></codeline>
<codeline lineno="1044"><highlight class="normal"></highlight></codeline>
<codeline lineno="1049" refid="struct_vma_allocator_create_info_1a5e45da0879451e58bee2f3a975f228f5" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/><ref refid="struct_vma_vulkan_functions" kindref="compound">VmaVulkanFunctions</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_allocator_create_info_1a5e45da0879451e58bee2f3a975f228f5" kindref="member">pVulkanFunctions</ref>;</highlight></codeline>
<codeline lineno="1054" refid="struct_vma_allocator_create_info_1aa2d4e3d86e6828834a56cf9f9406149a" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkInstance<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/><ref refid="struct_vma_allocator_create_info_1aa2d4e3d86e6828834a56cf9f9406149a" kindref="member">instance</ref>;</highlight></codeline>
<codeline lineno="1063" refid="struct_vma_allocator_create_info_1ae0ffc55139b54520a6bb704b29ffc285" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/><ref refid="struct_vma_allocator_create_info_1ae0ffc55139b54520a6bb704b29ffc285" kindref="member">vulkanApiVersion</ref>;</highlight></codeline>
<codeline lineno="1064"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_EXTERNAL_MEMORY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1074"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkExternalMemoryHandleTypeFlagsKHR*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(</highlight><highlight class="stringliteral">&quot;VkPhysicalDeviceMemoryProperties::memoryTypeCount&quot;</highlight><highlight class="normal">)<sp/>pTypeExternalMemoryHandleTypes;</highlight></codeline>
<codeline lineno="1075"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>VMA_EXTERNAL_MEMORY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1076" refid="group__group__init_1gaad9652301d33759b83e52d4f3605a14a" refkind="member"><highlight class="normal">}<sp/><ref refid="struct_vma_allocator_create_info" kindref="compound">VmaAllocatorCreateInfo</ref>;</highlight></codeline>
<codeline lineno="1077"><highlight class="normal"></highlight></codeline>
<codeline lineno="1079" refid="struct_vma_allocator_info" refkind="compound"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="struct_vma_allocator_info" kindref="compound">VmaAllocatorInfo</ref></highlight></codeline>
<codeline lineno="1080"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1085" refid="struct_vma_allocator_info_1a5b69acb4900a1a00b550ddec43de3eee" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkInstance<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/><ref refid="struct_vma_allocator_info_1a5b69acb4900a1a00b550ddec43de3eee" kindref="member">instance</ref>;</highlight></codeline>
<codeline lineno="1090" refid="struct_vma_allocator_info_1a45d976f4f410b9e57fd945af74400d5a" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkPhysicalDevice<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/><ref refid="struct_vma_allocator_info_1a45d976f4f410b9e57fd945af74400d5a" kindref="member">physicalDevice</ref>;</highlight></codeline>
<codeline lineno="1095" refid="struct_vma_allocator_info_1a9d4477914a3cbd67fcedd95e928c27a9" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDevice<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/><ref refid="struct_vma_allocator_info_1a9d4477914a3cbd67fcedd95e928c27a9" kindref="member">device</ref>;</highlight></codeline>
<codeline lineno="1096" refid="group__group__init_1ga1988031b0223fdbd564250fa1edd942c" refkind="member"><highlight class="normal">}<sp/><ref refid="struct_vma_allocator_info" kindref="compound">VmaAllocatorInfo</ref>;</highlight></codeline>
<codeline lineno="1097"><highlight class="normal"></highlight></codeline>
<codeline lineno="1110" refid="struct_vma_statistics" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref></highlight></codeline>
<codeline lineno="1111"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1114" refid="struct_vma_statistics_1a309179d5853a6a7cd534df497ee43957" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/><ref refid="struct_vma_statistics_1a309179d5853a6a7cd534df497ee43957" kindref="member">blockCount</ref>;</highlight></codeline>
<codeline lineno="1119" refid="struct_vma_statistics_1ab0ff76e50f58f9f54b6f265e5bf5dde2" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/><ref refid="struct_vma_statistics_1ab0ff76e50f58f9f54b6f265e5bf5dde2" kindref="member">allocationCount</ref>;</highlight></codeline>
<codeline lineno="1126" refid="struct_vma_statistics_1a2afbc1c7aa8ad7bbb8de06215ba7e5c4" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/><ref refid="struct_vma_statistics_1a2afbc1c7aa8ad7bbb8de06215ba7e5c4" kindref="member">blockBytes</ref>;</highlight></codeline>
<codeline lineno="1133" refid="struct_vma_statistics_1a21db06eba3422f87a2b4b4703d879c16" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/><ref refid="struct_vma_statistics_1a21db06eba3422f87a2b4b4703d879c16" kindref="member">allocationBytes</ref>;</highlight></codeline>
<codeline lineno="1134" refid="group__group__stats_1gac94bd1a382a3922ddc8de3af4d3ddd06" refkind="member"><highlight class="normal">}<sp/><ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref>;</highlight></codeline>
<codeline lineno="1135"><highlight class="normal"></highlight></codeline>
<codeline lineno="1150" refid="struct_vma_detailed_statistics" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref></highlight></codeline>
<codeline lineno="1151"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1153" refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref><sp/><ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>;</highlight></codeline>
<codeline lineno="1155" refid="struct_vma_detailed_statistics_1ab721bf04892e8b67802d4ddb7734638a" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/><ref refid="struct_vma_detailed_statistics_1ab721bf04892e8b67802d4ddb7734638a" kindref="member">unusedRangeCount</ref>;</highlight></codeline>
<codeline lineno="1157" refid="struct_vma_detailed_statistics_1a6fb397e7487e10f2a52e241577d2a2b8" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/><ref refid="struct_vma_detailed_statistics_1a6fb397e7487e10f2a52e241577d2a2b8" kindref="member">allocationSizeMin</ref>;</highlight></codeline>
<codeline lineno="1159" refid="struct_vma_detailed_statistics_1a06b2add24eed3449a66ff151979a0201" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/><ref refid="struct_vma_detailed_statistics_1a06b2add24eed3449a66ff151979a0201" kindref="member">allocationSizeMax</ref>;</highlight></codeline>
<codeline lineno="1161" refid="struct_vma_detailed_statistics_1a830eda847ed735d0e91da25cfcf797a4" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/><ref refid="struct_vma_detailed_statistics_1a830eda847ed735d0e91da25cfcf797a4" kindref="member">unusedRangeSizeMin</ref>;</highlight></codeline>
<codeline lineno="1163" refid="struct_vma_detailed_statistics_1af98943b5da98cf441ffa04b67914c78c" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/><ref refid="struct_vma_detailed_statistics_1af98943b5da98cf441ffa04b67914c78c" kindref="member">unusedRangeSizeMax</ref>;</highlight></codeline>
<codeline lineno="1164" refid="group__group__stats_1ga9ab0c535a6ca655dc63b8609ab4b8394" refkind="member"><highlight class="normal">}<sp/><ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>;</highlight></codeline>
<codeline lineno="1165"><highlight class="normal"></highlight></codeline>
<codeline lineno="1172" refid="struct_vma_total_statistics" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="struct_vma_total_statistics" kindref="compound">VmaTotalStatistics</ref></highlight></codeline>
<codeline lineno="1173"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1174" refid="struct_vma_total_statistics_1acb70e5b7fe543813ed8ba9282640969d" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref><sp/><ref refid="struct_vma_total_statistics_1acb70e5b7fe543813ed8ba9282640969d" kindref="member">memoryType</ref>[VK_MAX_MEMORY_TYPES];</highlight></codeline>
<codeline lineno="1175" refid="struct_vma_total_statistics_1a39beeba5b3a2e7cfe5f5e2331a2705ce" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref><sp/><ref refid="struct_vma_total_statistics_1a39beeba5b3a2e7cfe5f5e2331a2705ce" kindref="member">memoryHeap</ref>[VK_MAX_MEMORY_HEAPS];</highlight></codeline>
<codeline lineno="1176" refid="struct_vma_total_statistics_1a76f1935f7101883f5bb2a03b6c5649d2" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref><sp/><ref refid="struct_vma_total_statistics_1a76f1935f7101883f5bb2a03b6c5649d2" kindref="member">total</ref>;</highlight></codeline>
<codeline lineno="1177" refid="group__group__stats_1ga68916e729e55d513f88ffafbadddb770" refkind="member"><highlight class="normal">}<sp/><ref refid="struct_vma_total_statistics" kindref="compound">VmaTotalStatistics</ref>;</highlight></codeline>
<codeline lineno="1178"><highlight class="normal"></highlight></codeline>
<codeline lineno="1184" refid="struct_vma_budget" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="struct_vma_budget" kindref="compound">VmaBudget</ref></highlight></codeline>
<codeline lineno="1185"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1188" refid="struct_vma_budget_1a6d15ab3a798fd62d9efa3a1e1f83bf54" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref><sp/><ref refid="struct_vma_budget_1a6d15ab3a798fd62d9efa3a1e1f83bf54" kindref="member">statistics</ref>;</highlight></codeline>
<codeline lineno="1197" refid="struct_vma_budget_1a84dd1ecca8b0110259eb206dbadb11f6" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/><ref refid="struct_vma_budget_1a84dd1ecca8b0110259eb206dbadb11f6" kindref="member">usage</ref>;</highlight></codeline>
<codeline lineno="1207" refid="struct_vma_budget_1ab82e1d1754c2d210d0bdf90220bc6cdd" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/><ref refid="struct_vma_budget_1ab82e1d1754c2d210d0bdf90220bc6cdd" kindref="member">budget</ref>;</highlight></codeline>
<codeline lineno="1208" refid="group__group__stats_1gaa078667e71b1ef24e87a6a30d128381d" refkind="member"><highlight class="normal">}<sp/><ref refid="struct_vma_budget" kindref="compound">VmaBudget</ref>;</highlight></codeline>
<codeline lineno="1209"><highlight class="normal"></highlight></codeline>
<codeline lineno="1221" refid="struct_vma_allocation_create_info" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref></highlight></codeline>
<codeline lineno="1222"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1224" refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ga5225e5e11f8376f6a31a1791f3d6e817" kindref="member">VmaAllocationCreateFlags</ref><sp/><ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref>;</highlight></codeline>
<codeline lineno="1230" refid="struct_vma_allocation_create_info_1accb8b06b1f677d858cb9af20705fa910" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1gaa5846affa1e9da3800e3e78fae2305cc" kindref="member">VmaMemoryUsage</ref><sp/><ref refid="struct_vma_allocation_create_info_1accb8b06b1f677d858cb9af20705fa910" kindref="member">usage</ref>;</highlight></codeline>
<codeline lineno="1235" refid="struct_vma_allocation_create_info_1a9166390303ff42d783305bc31c2b6b90" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkMemoryPropertyFlags<sp/><ref refid="struct_vma_allocation_create_info_1a9166390303ff42d783305bc31c2b6b90" kindref="member">requiredFlags</ref>;</highlight></codeline>
<codeline lineno="1240" refid="struct_vma_allocation_create_info_1a7fe8d81a1ad10b2a2faacacee5b15d6d" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkMemoryPropertyFlags<sp/><ref refid="struct_vma_allocation_create_info_1a7fe8d81a1ad10b2a2faacacee5b15d6d" kindref="member">preferredFlags</ref>;</highlight></codeline>
<codeline lineno="1248" refid="struct_vma_allocation_create_info_1a3bf940c0271d85d6ba32a4d820075055" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/><ref refid="struct_vma_allocation_create_info_1a3bf940c0271d85d6ba32a4d820075055" kindref="member">memoryTypeBits</ref>;</highlight></codeline>
<codeline lineno="1254" refid="struct_vma_allocation_create_info_1ad5aa903b9be1fa934abf2dd6c650fca6" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_allocation_create_info_1ad5aa903b9be1fa934abf2dd6c650fca6" kindref="member">pool</ref>;</highlight></codeline>
<codeline lineno="1261" refid="struct_vma_allocation_create_info_1a74e2eb74b3772b657c59473ce605058a" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_allocation_create_info_1a74e2eb74b3772b657c59473ce605058a" kindref="member">pUserData</ref>;</highlight></codeline>
<codeline lineno="1268" refid="struct_vma_allocation_create_info_1a983d39e1a2e63649d78a960aa2fdd0f7" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info_1a983d39e1a2e63649d78a960aa2fdd0f7" kindref="member">priority</ref>;</highlight></codeline>
<codeline lineno="1269" refid="group__group__alloc_1ga3bf110892ea2fb4649fedb68488d026a" refkind="member"><highlight class="normal">}<sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>;</highlight></codeline>
<codeline lineno="1270"><highlight class="normal"></highlight></codeline>
<codeline lineno="1272" refid="struct_vma_pool_create_info" refkind="compound"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="struct_vma_pool_create_info" kindref="compound">VmaPoolCreateInfo</ref></highlight></codeline>
<codeline lineno="1273"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1276" refid="struct_vma_pool_create_info_1a596fa76b685d3f1f688f84a709a5b319" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/><ref refid="struct_vma_pool_create_info_1a596fa76b685d3f1f688f84a709a5b319" kindref="member">memoryTypeIndex</ref>;</highlight></codeline>
<codeline lineno="1279" refid="struct_vma_pool_create_info_1a8405139f63d078340ae74513a59f5446" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ga2770e325ea42e087c1b91fdf46d0292a" kindref="member">VmaPoolCreateFlags</ref><sp/><ref refid="struct_vma_pool_create_info_1a8405139f63d078340ae74513a59f5446" kindref="member">flags</ref>;</highlight></codeline>
<codeline lineno="1289" refid="struct_vma_pool_create_info_1aa4265160536cdb9be821b7686c16c676" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/><ref refid="struct_vma_pool_create_info_1aa4265160536cdb9be821b7686c16c676" kindref="member">blockSize</ref>;</highlight></codeline>
<codeline lineno="1294" refid="struct_vma_pool_create_info_1ad8006fb803185c0a699d30f3e9a865ae" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/><ref refid="struct_vma_pool_create_info_1ad8006fb803185c0a699d30f3e9a865ae" kindref="member">minBlockCount</ref>;</highlight></codeline>
<codeline lineno="1302" refid="struct_vma_pool_create_info_1ae41142f2834fcdc82baa4883c187b75c" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/><ref refid="struct_vma_pool_create_info_1ae41142f2834fcdc82baa4883c187b75c" kindref="member">maxBlockCount</ref>;</highlight></codeline>
<codeline lineno="1308" refid="struct_vma_pool_create_info_1a16e686c688f6725f119ebf6e24ab5274" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/><ref refid="struct_vma_pool_create_info_1a16e686c688f6725f119ebf6e24ab5274" kindref="member">priority</ref>;</highlight></codeline>
<codeline lineno="1315" refid="struct_vma_pool_create_info_1ade3eca546f0c6ab4e8fbf20eb6d854cb" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/><ref refid="struct_vma_pool_create_info_1ade3eca546f0c6ab4e8fbf20eb6d854cb" kindref="member">minAllocationAlignment</ref>;</highlight></codeline>
<codeline lineno="1325" refid="struct_vma_pool_create_info_1a4e264310c10272ba393c0ba2111ce416" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_pool_create_info_1a4e264310c10272ba393c0ba2111ce416" kindref="member">pMemoryAllocateNext</ref>;</highlight></codeline>
<codeline lineno="1326" refid="group__group__alloc_1ga1017aa83489c0eee8d2163d2bf253f67" refkind="member"><highlight class="normal">}<sp/><ref refid="struct_vma_pool_create_info" kindref="compound">VmaPoolCreateInfo</ref>;</highlight></codeline>
<codeline lineno="1327"><highlight class="normal"></highlight></codeline>
<codeline lineno="1336" refid="struct_vma_allocation_info" refkind="compound"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref></highlight></codeline>
<codeline lineno="1337"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1342" refid="struct_vma_allocation_info_1a7f6b0aa58c135e488e6b40a388dad9d5" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/><ref refid="struct_vma_allocation_info_1a7f6b0aa58c135e488e6b40a388dad9d5" kindref="member">memoryType</ref>;</highlight></codeline>
<codeline lineno="1349" refid="struct_vma_allocation_info_1abaf12cc4e13fbe5208ca6e5bb1a21c19" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceMemory<sp/><ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref><sp/><ref refid="struct_vma_allocation_info_1abaf12cc4e13fbe5208ca6e5bb1a21c19" kindref="member">deviceMemory</ref>;</highlight></codeline>
<codeline lineno="1359" refid="struct_vma_allocation_info_1a4a3c732388dbdc7a23f9365b00825268" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/><ref refid="struct_vma_allocation_info_1a4a3c732388dbdc7a23f9365b00825268" kindref="member">offset</ref>;</highlight></codeline>
<codeline lineno="1370" refid="struct_vma_allocation_info_1aac76d113a6a5ccbb09fea00fb25fd18f" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/><ref refid="struct_vma_allocation_info_1aac76d113a6a5ccbb09fea00fb25fd18f" kindref="member">size</ref>;</highlight></codeline>
<codeline lineno="1379" refid="struct_vma_allocation_info_1a17a39eb34201a610347acb91b38eca79" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_allocation_info_1a17a39eb34201a610347acb91b38eca79" kindref="member">pMappedData</ref>;</highlight></codeline>
<codeline lineno="1384" refid="struct_vma_allocation_info_1ad0ea9d64dd733ffd7beff7af6d289ad0" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_allocation_info_1ad0ea9d64dd733ffd7beff7af6d289ad0" kindref="member">pUserData</ref>;</highlight></codeline>
<codeline lineno="1392" refid="struct_vma_allocation_info_1ad82b9dfb58e5415da0ee8521c1fbf429" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_allocation_info_1ad82b9dfb58e5415da0ee8521c1fbf429" kindref="member">pName</ref>;</highlight></codeline>
<codeline lineno="1393" refid="group__group__alloc_1ga1cf7774606721026a68aabe3af2e5b50" refkind="member"><highlight class="normal">}<sp/><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref>;</highlight></codeline>
<codeline lineno="1394"><highlight class="normal"></highlight></codeline>
<codeline lineno="1399" refid="struct_vma_defragmentation_info" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="struct_vma_defragmentation_info" kindref="compound">VmaDefragmentationInfo</ref></highlight></codeline>
<codeline lineno="1400"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1402" refid="struct_vma_defragmentation_info_1a3e23080c978ecf3abb3180f5b2069da7" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ga88a77cef37e5d3c4fc9eb328885d048d" kindref="member">VmaDefragmentationFlags</ref><sp/><ref refid="struct_vma_defragmentation_info_1a3e23080c978ecf3abb3180f5b2069da7" kindref="member">flags</ref>;</highlight></codeline>
<codeline lineno="1407" refid="struct_vma_defragmentation_info_1a3302955190e6b5f0d8103698753de949" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_defragmentation_info_1a3302955190e6b5f0d8103698753de949" kindref="member">pool</ref>;</highlight></codeline>
<codeline lineno="1412" refid="struct_vma_defragmentation_info_1a637ada77b02179a27fa92290000afac4" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/><ref refid="struct_vma_defragmentation_info_1a637ada77b02179a27fa92290000afac4" kindref="member">maxBytesPerPass</ref>;</highlight></codeline>
<codeline lineno="1417" refid="struct_vma_defragmentation_info_1ac2db29d309bebc4f7d55041416e9694b" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/><ref refid="struct_vma_defragmentation_info_1ac2db29d309bebc4f7d55041416e9694b" kindref="member">maxAllocationsPerPass</ref>;</highlight></codeline>
<codeline lineno="1418" refid="group__group__alloc_1ga2bf47f96bf92bed2a49461bd9af3acfa" refkind="member"><highlight class="normal">}<sp/><ref refid="struct_vma_defragmentation_info" kindref="compound">VmaDefragmentationInfo</ref>;</highlight></codeline>
<codeline lineno="1419"><highlight class="normal"></highlight></codeline>
<codeline lineno="1421" refid="struct_vma_defragmentation_move" refkind="compound"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="struct_vma_defragmentation_move" kindref="compound">VmaDefragmentationMove</ref></highlight></codeline>
<codeline lineno="1422"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1424" refid="struct_vma_defragmentation_move_1a20996a4686c9246dff77b375ac4a91e2" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1gada9e3861caf96f08894b0bcc160ec257" kindref="member">VmaDefragmentationMoveOperation</ref><sp/><ref refid="struct_vma_defragmentation_move_1a20996a4686c9246dff77b375ac4a91e2" kindref="member">operation</ref>;</highlight></codeline>
<codeline lineno="1426" refid="struct_vma_defragmentation_move_1a51c1ff05d7c1290499c4af2ffe238df5" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/><ref refid="struct_vma_defragmentation_move_1a51c1ff05d7c1290499c4af2ffe238df5" kindref="member">srcAllocation</ref>;</highlight></codeline>
<codeline lineno="1433" refid="struct_vma_defragmentation_move_1a4568ef03127bffa6000fe811205aeda4" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/><ref refid="struct_vma_defragmentation_move_1a4568ef03127bffa6000fe811205aeda4" kindref="member">dstTmpAllocation</ref>;</highlight></codeline>
<codeline lineno="1434" refid="group__group__alloc_1ga563f4b43d3e31ed603d80cacc9ba8589" refkind="member"><highlight class="normal">}<sp/><ref refid="struct_vma_defragmentation_move" kindref="compound">VmaDefragmentationMove</ref>;</highlight></codeline>
<codeline lineno="1435"><highlight class="normal"></highlight></codeline>
<codeline lineno="1440" refid="struct_vma_defragmentation_pass_move_info" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="struct_vma_defragmentation_pass_move_info" kindref="compound">VmaDefragmentationPassMoveInfo</ref></highlight></codeline>
<codeline lineno="1441"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1443" refid="struct_vma_defragmentation_pass_move_info_1a1b3e18c23f9691f35baf183e615c4408" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/><ref refid="struct_vma_defragmentation_pass_move_info_1a1b3e18c23f9691f35baf183e615c4408" kindref="member">moveCount</ref>;</highlight></codeline>
<codeline lineno="1467" refid="struct_vma_defragmentation_pass_move_info_1a761d239e4d75f197dc301c33be31d140" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_defragmentation_move" kindref="compound">VmaDefragmentationMove</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_defragmentation_pass_move_info_1a761d239e4d75f197dc301c33be31d140" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(<ref refid="struct_vma_defragmentation_pass_move_info_1a1b3e18c23f9691f35baf183e615c4408" kindref="member">moveCount</ref>)<sp/>pMoves;</highlight></codeline>
<codeline lineno="1468" refid="group__group__alloc_1gad6799e8e2b1527abfc84d33bc44aeaf5" refkind="member"><highlight class="normal">}<sp/><ref refid="struct_vma_defragmentation_pass_move_info" kindref="compound">VmaDefragmentationPassMoveInfo</ref>;</highlight></codeline>
<codeline lineno="1469"><highlight class="normal"></highlight></codeline>
<codeline lineno="1471" refid="struct_vma_defragmentation_stats" refkind="compound"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="struct_vma_defragmentation_stats" kindref="compound">VmaDefragmentationStats</ref></highlight></codeline>
<codeline lineno="1472"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1474" refid="struct_vma_defragmentation_stats_1a36f9d5df2a10ba2a36b16e126d60572d" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/><ref refid="struct_vma_defragmentation_stats_1a36f9d5df2a10ba2a36b16e126d60572d" kindref="member">bytesMoved</ref>;</highlight></codeline>
<codeline lineno="1476" refid="struct_vma_defragmentation_stats_1ab0cb9ac0dbc106c77e384ea676422f28" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/><ref refid="struct_vma_defragmentation_stats_1ab0cb9ac0dbc106c77e384ea676422f28" kindref="member">bytesFreed</ref>;</highlight></codeline>
<codeline lineno="1478" refid="struct_vma_defragmentation_stats_1aefeabf130022008eadd75999478af3f9" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/><ref refid="struct_vma_defragmentation_stats_1aefeabf130022008eadd75999478af3f9" kindref="member">allocationsMoved</ref>;</highlight></codeline>
<codeline lineno="1480" refid="struct_vma_defragmentation_stats_1a0113f1877904a5d1ee8f409216ff276b" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/><ref refid="struct_vma_defragmentation_stats_1a0113f1877904a5d1ee8f409216ff276b" kindref="member">deviceMemoryBlocksFreed</ref>;</highlight></codeline>
<codeline lineno="1481" refid="group__group__alloc_1gad94034192259c2e34a4d1c5e27810403" refkind="member"><highlight class="normal">}<sp/><ref refid="struct_vma_defragmentation_stats" kindref="compound">VmaDefragmentationStats</ref>;</highlight></codeline>
<codeline lineno="1482"><highlight class="normal"></highlight></codeline>
<codeline lineno="1491" refid="struct_vma_virtual_block_create_info" refkind="compound"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="struct_vma_virtual_block_create_info" kindref="compound">VmaVirtualBlockCreateInfo</ref></highlight></codeline>
<codeline lineno="1492"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1498" refid="struct_vma_virtual_block_create_info_1a670ab8c6a6e822f3c36781d79e8824e9" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/><ref refid="struct_vma_virtual_block_create_info_1a670ab8c6a6e822f3c36781d79e8824e9" kindref="member">size</ref>;</highlight></codeline>
<codeline lineno="1499"><highlight class="normal"></highlight></codeline>
<codeline lineno="1502" refid="struct_vma_virtual_block_create_info_1aaab9bf7e2d228c02ab6d90a72a6e6912" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__virtual_1ga4e49c2f0ab7f6b4868833e5bac78d91e" kindref="member">VmaVirtualBlockCreateFlags</ref><sp/><ref refid="struct_vma_virtual_block_create_info_1aaab9bf7e2d228c02ab6d90a72a6e6912" kindref="member">flags</ref>;</highlight></codeline>
<codeline lineno="1503"><highlight class="normal"></highlight></codeline>
<codeline lineno="1508" refid="struct_vma_virtual_block_create_info_1ac94ae661443d34d2201bf6e685d5de92" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_virtual_block_create_info_1ac94ae661443d34d2201bf6e685d5de92" kindref="member">pAllocationCallbacks</ref>;</highlight></codeline>
<codeline lineno="1509" refid="group__group__virtual_1ga4753d42d40217a3a652a3cdf253ad773" refkind="member"><highlight class="normal">}<sp/><ref refid="struct_vma_virtual_block_create_info" kindref="compound">VmaVirtualBlockCreateInfo</ref>;</highlight></codeline>
<codeline lineno="1510"><highlight class="normal"></highlight></codeline>
<codeline lineno="1512" refid="struct_vma_virtual_allocation_create_info" refkind="compound"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="struct_vma_virtual_allocation_create_info" kindref="compound">VmaVirtualAllocationCreateInfo</ref></highlight></codeline>
<codeline lineno="1513"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1518" refid="struct_vma_virtual_allocation_create_info_1aae08752b86817abd0d944c6025dc603e" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/><ref refid="struct_vma_virtual_allocation_create_info_1aae08752b86817abd0d944c6025dc603e" kindref="member">size</ref>;</highlight></codeline>
<codeline lineno="1523" refid="struct_vma_virtual_allocation_create_info_1a9d19709872fc1904a105079e1c885821" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/><ref refid="struct_vma_virtual_allocation_create_info_1a9d19709872fc1904a105079e1c885821" kindref="member">alignment</ref>;</highlight></codeline>
<codeline lineno="1526" refid="struct_vma_virtual_allocation_create_info_1ab10e16956cc4bf20ced9de77d1129ea4" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__virtual_1gae96ffc099bf898257fb19e9410ed08a7" kindref="member">VmaVirtualAllocationCreateFlags</ref><sp/><ref refid="struct_vma_virtual_allocation_create_info_1ab10e16956cc4bf20ced9de77d1129ea4" kindref="member">flags</ref>;</highlight></codeline>
<codeline lineno="1531" refid="struct_vma_virtual_allocation_create_info_1aa84c85b0b8037cd4972172a0507de360" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_virtual_allocation_create_info_1aa84c85b0b8037cd4972172a0507de360" kindref="member">pUserData</ref>;</highlight></codeline>
<codeline lineno="1532" refid="group__group__virtual_1gac3c90d80bedc6847a41b82d0e2158c9e" refkind="member"><highlight class="normal">}<sp/><ref refid="struct_vma_virtual_allocation_create_info" kindref="compound">VmaVirtualAllocationCreateInfo</ref>;</highlight></codeline>
<codeline lineno="1533"><highlight class="normal"></highlight></codeline>
<codeline lineno="1535" refid="struct_vma_virtual_allocation_info" refkind="compound"><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="struct_vma_virtual_allocation_info" kindref="compound">VmaVirtualAllocationInfo</ref></highlight></codeline>
<codeline lineno="1536"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1541" refid="struct_vma_virtual_allocation_info_1accb40a8205f49ccca3de975da7d1a2b5" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/><ref refid="struct_vma_virtual_allocation_info_1accb40a8205f49ccca3de975da7d1a2b5" kindref="member">offset</ref>;</highlight></codeline>
<codeline lineno="1546" refid="struct_vma_virtual_allocation_info_1afb6d6bd0a6813869ea0842048d40aa2b" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/><ref refid="struct_vma_virtual_allocation_info_1afb6d6bd0a6813869ea0842048d40aa2b" kindref="member">size</ref>;</highlight></codeline>
<codeline lineno="1551" refid="struct_vma_virtual_allocation_info_1a224aa08739618d27066a16b7f60a2bbc" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="struct_vma_virtual_allocation_info_1a224aa08739618d27066a16b7f60a2bbc" kindref="member">pUserData</ref>;</highlight></codeline>
<codeline lineno="1552" refid="group__group__virtual_1ga75bc33ff7cf18c98e101f570dc2a5ebc" refkind="member"><highlight class="normal">}<sp/><ref refid="struct_vma_virtual_allocation_info" kindref="compound">VmaVirtualAllocationInfo</ref>;</highlight></codeline>
<codeline lineno="1553"><highlight class="normal"></highlight></codeline>
<codeline lineno="1556"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_DATA_TYPES_DECLARATIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1557"><highlight class="normal"></highlight></codeline>
<codeline lineno="1558"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_FUNCTION_HEADERS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1559"><highlight class="normal"></highlight></codeline>
<codeline lineno="1566" refid="group__group__init_1gaf77c946fbecfcc54d02c3d1c1e7e23e7" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__init_1gaf77c946fbecfcc54d02c3d1c1e7e23e7" kindref="member">vmaCreateAllocator</ref>(</highlight></codeline>
<codeline lineno="1567"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocator_create_info" kindref="compound">VmaAllocatorCreateInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pCreateInfo,</highlight></codeline>
<codeline lineno="1568"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pAllocator);</highlight></codeline>
<codeline lineno="1569"><highlight class="normal"></highlight></codeline>
<codeline lineno="1571" refid="group__group__init_1ga0383c8c957625914e9b89bd165ff13f3" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__init_1ga0383c8c957625914e9b89bd165ff13f3" kindref="member">vmaDestroyAllocator</ref>(</highlight></codeline>
<codeline lineno="1572"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>allocator);</highlight></codeline>
<codeline lineno="1573"><highlight class="normal"></highlight></codeline>
<codeline lineno="1579" refid="group__group__init_1gaacc98daf40a09cddb3ca7940aba9bc3e" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__init_1gaacc98daf40a09cddb3ca7940aba9bc3e" kindref="member">vmaGetAllocatorInfo</ref>(</highlight></codeline>
<codeline lineno="1580"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1581"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator_info" kindref="compound">VmaAllocatorInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pAllocatorInfo);</highlight></codeline>
<codeline lineno="1582"><highlight class="normal"></highlight></codeline>
<codeline lineno="1587" refid="group__group__init_1gadcc2ca5c2f692c8c6b77bc7bcee97751" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__init_1gadcc2ca5c2f692c8c6b77bc7bcee97751" kindref="member">vmaGetPhysicalDeviceProperties</ref>(</highlight></codeline>
<codeline lineno="1588"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1589"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkPhysicalDeviceProperties*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>ppPhysicalDeviceProperties);</highlight></codeline>
<codeline lineno="1590"><highlight class="normal"></highlight></codeline>
<codeline lineno="1595" refid="group__group__init_1ga33698c6107c0da349c1dbf43615284df" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__init_1ga33698c6107c0da349c1dbf43615284df" kindref="member">vmaGetMemoryProperties</ref>(</highlight></codeline>
<codeline lineno="1596"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1597"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkPhysicalDeviceMemoryProperties*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>ppPhysicalDeviceMemoryProperties);</highlight></codeline>
<codeline lineno="1598"><highlight class="normal"></highlight></codeline>
<codeline lineno="1605" refid="group__group__init_1ga27cc36c466d171c3e4e0d062c48dc1e6" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__init_1ga27cc36c466d171c3e4e0d062c48dc1e6" kindref="member">vmaGetMemoryTypeProperties</ref>(</highlight></codeline>
<codeline lineno="1606"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1607"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>memoryTypeIndex,</highlight></codeline>
<codeline lineno="1608"><highlight class="normal"><sp/><sp/><sp/><sp/>VkMemoryPropertyFlags*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pFlags);</highlight></codeline>
<codeline lineno="1609"><highlight class="normal"></highlight></codeline>
<codeline lineno="1612" refid="group__group__init_1gab8e037d09b55f13312f792e0cd98cc03" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__init_1gab8e037d09b55f13312f792e0cd98cc03" kindref="member">vmaSetCurrentFrameIndex</ref>(</highlight></codeline>
<codeline lineno="1613"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1614"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>frameIndex);</highlight></codeline>
<codeline lineno="1615"><highlight class="normal"></highlight></codeline>
<codeline lineno="1633" refid="group__group__stats_1gad176279c8da8f50399674b2ef03ca866" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__stats_1gad176279c8da8f50399674b2ef03ca866" kindref="member">vmaCalculateStatistics</ref>(</highlight></codeline>
<codeline lineno="1634"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1635"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_total_statistics" kindref="compound">VmaTotalStatistics</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pStats);</highlight></codeline>
<codeline lineno="1636"><highlight class="normal"></highlight></codeline>
<codeline lineno="1648" refid="group__group__stats_1ga620eaa8a9d919860f7deaf4d0148b2a1" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__stats_1ga620eaa8a9d919860f7deaf4d0148b2a1" kindref="member">vmaGetHeapBudgets</ref>(</highlight></codeline>
<codeline lineno="1649"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1650"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_budget" kindref="compound">VmaBudget</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/><ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(</highlight><highlight class="stringliteral">&quot;VkPhysicalDeviceMemoryProperties::memoryHeapCount&quot;</highlight><highlight class="normal">)<sp/>pBudgets);</highlight></codeline>
<codeline lineno="1651"><highlight class="normal"></highlight></codeline>
<codeline lineno="1675" refid="group__group__alloc_1ga03cee2bfc7fef20382fa56f5870f3b2f" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga03cee2bfc7fef20382fa56f5870f3b2f" kindref="member">vmaFindMemoryTypeIndex</ref>(</highlight></codeline>
<codeline lineno="1676"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1677"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>memoryTypeBits,</highlight></codeline>
<codeline lineno="1678"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pAllocationCreateInfo,</highlight></codeline>
<codeline lineno="1679"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pMemoryTypeIndex);</highlight></codeline>
<codeline lineno="1680"><highlight class="normal"></highlight></codeline>
<codeline lineno="1687" refid="group__group__alloc_1ga723f5683b363c306bf860dab1861f299" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga723f5683b363c306bf860dab1861f299" kindref="member">vmaFindMemoryTypeIndexForBufferInfo</ref>(</highlight></codeline>
<codeline lineno="1688"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1689"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkBufferCreateInfo*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pBufferCreateInfo,</highlight></codeline>
<codeline lineno="1690"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pAllocationCreateInfo,</highlight></codeline>
<codeline lineno="1691"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pMemoryTypeIndex);</highlight></codeline>
<codeline lineno="1692"><highlight class="normal"></highlight></codeline>
<codeline lineno="1699" refid="group__group__alloc_1gaaf05345771a087328949b485ff2da4db" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gaaf05345771a087328949b485ff2da4db" kindref="member">vmaFindMemoryTypeIndexForImageInfo</ref>(</highlight></codeline>
<codeline lineno="1700"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1701"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkImageCreateInfo*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pImageCreateInfo,</highlight></codeline>
<codeline lineno="1702"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pAllocationCreateInfo,</highlight></codeline>
<codeline lineno="1703"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pMemoryTypeIndex);</highlight></codeline>
<codeline lineno="1704"><highlight class="normal"></highlight></codeline>
<codeline lineno="1711" refid="group__group__alloc_1ga250d4f6f4c09a6a03b82323f999c9c4e" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga250d4f6f4c09a6a03b82323f999c9c4e" kindref="member">vmaCreatePool</ref>(</highlight></codeline>
<codeline lineno="1712"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1713"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_pool_create_info" kindref="compound">VmaPoolCreateInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pCreateInfo,</highlight></codeline>
<codeline lineno="1714"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pPool);</highlight></codeline>
<codeline lineno="1715"><highlight class="normal"></highlight></codeline>
<codeline lineno="1718" refid="group__group__alloc_1gad03da7fd4d8b772bc2a299bc34850d98" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gad03da7fd4d8b772bc2a299bc34850d98" kindref="member">vmaDestroyPool</ref>(</highlight></codeline>
<codeline lineno="1719"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1720"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>pool);</highlight></codeline>
<codeline lineno="1721"><highlight class="normal"></highlight></codeline>
<codeline lineno="1735" refid="group__group__stats_1ga7e489a68f893dbefc78a6ac9413c4220" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__stats_1ga7e489a68f893dbefc78a6ac9413c4220" kindref="member">vmaGetPoolStatistics</ref>(</highlight></codeline>
<codeline lineno="1736"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1737"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pool,</highlight></codeline>
<codeline lineno="1738"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pPoolStats);</highlight></codeline>
<codeline lineno="1739"><highlight class="normal"></highlight></codeline>
<codeline lineno="1746" refid="group__group__stats_1ga54b57aa8f511406711f4b918028d8f60" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__stats_1ga54b57aa8f511406711f4b918028d8f60" kindref="member">vmaCalculatePoolStatistics</ref>(</highlight></codeline>
<codeline lineno="1747"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1748"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pool,</highlight></codeline>
<codeline lineno="1749"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pPoolStats);</highlight></codeline>
<codeline lineno="1750"><highlight class="normal"></highlight></codeline>
<codeline lineno="1772" refid="group__group__alloc_1ga19e2e174d6acb8abfdeb8c200517a468" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga19e2e174d6acb8abfdeb8c200517a468" kindref="member">vmaCheckPoolCorruption</ref>(</highlight></codeline>
<codeline lineno="1773"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1774"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pool);</highlight></codeline>
<codeline lineno="1775"><highlight class="normal"></highlight></codeline>
<codeline lineno="1782" refid="group__group__alloc_1ga77b2f609887eabcc36ab90e94230acbf" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga77b2f609887eabcc36ab90e94230acbf" kindref="member">vmaGetPoolName</ref>(</highlight></codeline>
<codeline lineno="1783"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1784"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pool,</highlight></codeline>
<codeline lineno="1785"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>ppName);</highlight></codeline>
<codeline lineno="1786"><highlight class="normal"></highlight></codeline>
<codeline lineno="1792" refid="group__group__alloc_1gac0322f7ac6c6425492aec787397d5597" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gac0322f7ac6c6425492aec787397d5597" kindref="member">vmaSetPoolName</ref>(</highlight></codeline>
<codeline lineno="1793"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1794"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pool,</highlight></codeline>
<codeline lineno="1795"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>pName);</highlight></codeline>
<codeline lineno="1796"><highlight class="normal"></highlight></codeline>
<codeline lineno="1810" refid="group__group__alloc_1gaf813f55a0667016a8cd68bb4b8b3b30c" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gaf813f55a0667016a8cd68bb4b8b3b30c" kindref="member">vmaAllocateMemory</ref>(</highlight></codeline>
<codeline lineno="1811"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1812"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkMemoryRequirements*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pVkMemoryRequirements,</highlight></codeline>
<codeline lineno="1813"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pCreateInfo,</highlight></codeline>
<codeline lineno="1814"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pAllocation,</highlight></codeline>
<codeline lineno="1815"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>pAllocationInfo);</highlight></codeline>
<codeline lineno="1816"><highlight class="normal"></highlight></codeline>
<codeline lineno="1836" refid="group__group__alloc_1gafe6834626398ff26264a94ab7581e150" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gafe6834626398ff26264a94ab7581e150" kindref="member">vmaAllocateMemoryPages</ref>(</highlight></codeline>
<codeline lineno="1837"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1838"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkMemoryRequirements*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/><ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)<sp/>pVkMemoryRequirements,</highlight></codeline>
<codeline lineno="1839"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/><ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)<sp/>pCreateInfo,</highlight></codeline>
<codeline lineno="1840"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>allocationCount,</highlight></codeline>
<codeline lineno="1841"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/><ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)<sp/>pAllocations,</highlight></codeline>
<codeline lineno="1842"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)<sp/>pAllocationInfo);</highlight></codeline>
<codeline lineno="1843"><highlight class="normal"></highlight></codeline>
<codeline lineno="1858" refid="group__group__alloc_1gaf7010aa90a4ccdda56f83db8597b9896" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gaf7010aa90a4ccdda56f83db8597b9896" kindref="member">vmaAllocateMemoryForBuffer</ref>(</highlight></codeline>
<codeline lineno="1859"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1860"><highlight class="normal"><sp/><sp/><sp/><sp/>VkBuffer<sp/><ref refid="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" kindref="member">VMA_NOT_NULL_NON_DISPATCHABLE</ref><sp/>buffer,</highlight></codeline>
<codeline lineno="1861"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pCreateInfo,</highlight></codeline>
<codeline lineno="1862"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pAllocation,</highlight></codeline>
<codeline lineno="1863"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>pAllocationInfo);</highlight></codeline>
<codeline lineno="1864"><highlight class="normal"></highlight></codeline>
<codeline lineno="1879" refid="group__group__alloc_1ga4b7f39281cb383c1496b68f97cb7f4c5" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga4b7f39281cb383c1496b68f97cb7f4c5" kindref="member">vmaAllocateMemoryForImage</ref>(</highlight></codeline>
<codeline lineno="1880"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1881"><highlight class="normal"><sp/><sp/><sp/><sp/>VkImage<sp/><ref refid="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" kindref="member">VMA_NOT_NULL_NON_DISPATCHABLE</ref><sp/>image,</highlight></codeline>
<codeline lineno="1882"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pCreateInfo,</highlight></codeline>
<codeline lineno="1883"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pAllocation,</highlight></codeline>
<codeline lineno="1884"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>pAllocationInfo);</highlight></codeline>
<codeline lineno="1885"><highlight class="normal"></highlight></codeline>
<codeline lineno="1890" refid="group__group__alloc_1ga5c9baca5124d440046bbe508f61d2839" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga5c9baca5124d440046bbe508f61d2839" kindref="member">vmaFreeMemory</ref>(</highlight></codeline>
<codeline lineno="1891"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1892"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>allocation);</highlight></codeline>
<codeline lineno="1893"><highlight class="normal"></highlight></codeline>
<codeline lineno="1904" refid="group__group__alloc_1ga033c6727ed2efed0745ec24ce01d5e1b" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga033c6727ed2efed0745ec24ce01d5e1b" kindref="member">vmaFreeMemoryPages</ref>(</highlight></codeline>
<codeline lineno="1905"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1906"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>allocationCount,</highlight></codeline>
<codeline lineno="1907"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/><ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)<sp/>pAllocations);</highlight></codeline>
<codeline lineno="1908"><highlight class="normal"></highlight></codeline>
<codeline lineno="1919" refid="group__group__alloc_1gab9c96ca6bb55ad9069829fe8355bbb79" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gab9c96ca6bb55ad9069829fe8355bbb79" kindref="member">vmaGetAllocationInfo</ref>(</highlight></codeline>
<codeline lineno="1920"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1921"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="1922"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pAllocationInfo);</highlight></codeline>
<codeline lineno="1923"><highlight class="normal"></highlight></codeline>
<codeline lineno="1930" refid="group__group__alloc_1gac1f392a3c70a647f0c53a9ddaa7a6f14" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gac1f392a3c70a647f0c53a9ddaa7a6f14" kindref="member">vmaSetAllocationUserData</ref>(</highlight></codeline>
<codeline lineno="1931"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1932"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="1933"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>pUserData);</highlight></codeline>
<codeline lineno="1934"><highlight class="normal"></highlight></codeline>
<codeline lineno="1943" refid="group__group__alloc_1ga29b210b1f39e49de844fc7b6944736d7" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga29b210b1f39e49de844fc7b6944736d7" kindref="member">vmaSetAllocationName</ref>(</highlight></codeline>
<codeline lineno="1944"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1945"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="1946"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>pName);</highlight></codeline>
<codeline lineno="1947"><highlight class="normal"></highlight></codeline>
<codeline lineno="1954" refid="group__group__alloc_1gaf6785483eda8b53561437e05e2177d7b" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gaf6785483eda8b53561437e05e2177d7b" kindref="member">vmaGetAllocationMemoryProperties</ref>(</highlight></codeline>
<codeline lineno="1955"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1956"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="1957"><highlight class="normal"><sp/><sp/><sp/><sp/>VkMemoryPropertyFlags*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pFlags);</highlight></codeline>
<codeline lineno="1958"><highlight class="normal"></highlight></codeline>
<codeline lineno="1996" refid="group__group__alloc_1ga13b93ec0ed38ad7232300cb94931c8d2" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga13b93ec0ed38ad7232300cb94931c8d2" kindref="member">vmaMapMemory</ref>(</highlight></codeline>
<codeline lineno="1997"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="1998"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="1999"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>ppData);</highlight></codeline>
<codeline lineno="2000"><highlight class="normal"></highlight></codeline>
<codeline lineno="2009" refid="group__group__alloc_1gaec4645c1787976e2b50d2dfd31279a2b" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gaec4645c1787976e2b50d2dfd31279a2b" kindref="member">vmaUnmapMemory</ref>(</highlight></codeline>
<codeline lineno="2010"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="2011"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocation);</highlight></codeline>
<codeline lineno="2012"><highlight class="normal"></highlight></codeline>
<codeline lineno="2034" refid="group__group__alloc_1gab8093faf3afb114596d964d4bd24cb4a" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gab8093faf3afb114596d964d4bd24cb4a" kindref="member">vmaFlushAllocation</ref>(</highlight></codeline>
<codeline lineno="2035"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="2036"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="2037"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>offset,</highlight></codeline>
<codeline lineno="2038"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size);</highlight></codeline>
<codeline lineno="2039"><highlight class="normal"></highlight></codeline>
<codeline lineno="2061" refid="group__group__alloc_1ga1059764930e85ac377a92b5237b5b919" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga1059764930e85ac377a92b5237b5b919" kindref="member">vmaInvalidateAllocation</ref>(</highlight></codeline>
<codeline lineno="2062"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="2063"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="2064"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>offset,</highlight></codeline>
<codeline lineno="2065"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size);</highlight></codeline>
<codeline lineno="2066"><highlight class="normal"></highlight></codeline>
<codeline lineno="2081" refid="group__group__alloc_1ga09b0a57c5c45949a324ac7c0a4ec42d5" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga09b0a57c5c45949a324ac7c0a4ec42d5" kindref="member">vmaFlushAllocations</ref>(</highlight></codeline>
<codeline lineno="2082"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="2083"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>allocationCount,</highlight></codeline>
<codeline lineno="2084"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)<sp/>allocations,</highlight></codeline>
<codeline lineno="2085"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)<sp/>offsets,</highlight></codeline>
<codeline lineno="2086"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)<sp/>sizes);</highlight></codeline>
<codeline lineno="2087"><highlight class="normal"></highlight></codeline>
<codeline lineno="2102" refid="group__group__alloc_1ga693a1ae5faed72fac89f12685e1d366f" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga693a1ae5faed72fac89f12685e1d366f" kindref="member">vmaInvalidateAllocations</ref>(</highlight></codeline>
<codeline lineno="2103"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="2104"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>allocationCount,</highlight></codeline>
<codeline lineno="2105"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)<sp/>allocations,</highlight></codeline>
<codeline lineno="2106"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)<sp/>offsets,</highlight></codeline>
<codeline lineno="2107"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/><ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)<sp/>sizes);</highlight></codeline>
<codeline lineno="2108"><highlight class="normal"></highlight></codeline>
<codeline lineno="2126" refid="group__group__alloc_1ga0baa58dd12991e7b0fe42dcdf22bb100" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga0baa58dd12991e7b0fe42dcdf22bb100" kindref="member">vmaCheckCorruption</ref>(</highlight></codeline>
<codeline lineno="2127"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="2128"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>memoryTypeBits);</highlight></codeline>
<codeline lineno="2129"><highlight class="normal"></highlight></codeline>
<codeline lineno="2142" refid="group__group__alloc_1ga0cdd7b0b8653745fa95af9e78d919e70" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga0cdd7b0b8653745fa95af9e78d919e70" kindref="member">vmaBeginDefragmentation</ref>(</highlight></codeline>
<codeline lineno="2143"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="2144"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_defragmentation_info" kindref="compound">VmaDefragmentationInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pInfo,</highlight></codeline>
<codeline lineno="2145"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_defragmentation_context" kindref="compound">VmaDefragmentationContext</ref><sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pContext);</highlight></codeline>
<codeline lineno="2146"><highlight class="normal"></highlight></codeline>
<codeline lineno="2155" refid="group__group__alloc_1gae419e366d1c015716165bdfd5aafef6f" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gae419e366d1c015716165bdfd5aafef6f" kindref="member">vmaEndDefragmentation</ref>(</highlight></codeline>
<codeline lineno="2156"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="2157"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_defragmentation_context" kindref="compound">VmaDefragmentationContext</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>context,</highlight></codeline>
<codeline lineno="2158"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_defragmentation_stats" kindref="compound">VmaDefragmentationStats</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>pStats);</highlight></codeline>
<codeline lineno="2159"><highlight class="normal"></highlight></codeline>
<codeline lineno="2170" refid="group__group__alloc_1gacbe4a77fdfa7ea29328d2f940d423ab7" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gacbe4a77fdfa7ea29328d2f940d423ab7" kindref="member">vmaBeginDefragmentationPass</ref>(</highlight></codeline>
<codeline lineno="2171"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="2172"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_defragmentation_context" kindref="compound">VmaDefragmentationContext</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>context,</highlight></codeline>
<codeline lineno="2173"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_defragmentation_pass_move_info" kindref="compound">VmaDefragmentationPassMoveInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pPassInfo);</highlight></codeline>
<codeline lineno="2174"><highlight class="normal"></highlight></codeline>
<codeline lineno="2193" refid="group__group__alloc_1gabbc69db60f82972ddffaceb6653e344a" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gabbc69db60f82972ddffaceb6653e344a" kindref="member">vmaEndDefragmentationPass</ref>(</highlight></codeline>
<codeline lineno="2194"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="2195"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_defragmentation_context" kindref="compound">VmaDefragmentationContext</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>context,</highlight></codeline>
<codeline lineno="2196"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_defragmentation_pass_move_info" kindref="compound">VmaDefragmentationPassMoveInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pPassInfo);</highlight></codeline>
<codeline lineno="2197"><highlight class="normal"></highlight></codeline>
<codeline lineno="2210" refid="group__group__alloc_1ga7748e60ccc54e240777a848cb260bb19" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga7748e60ccc54e240777a848cb260bb19" kindref="member">vmaBindBufferMemory</ref>(</highlight></codeline>
<codeline lineno="2211"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="2212"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="2213"><highlight class="normal"><sp/><sp/><sp/><sp/>VkBuffer<sp/><ref refid="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" kindref="member">VMA_NOT_NULL_NON_DISPATCHABLE</ref><sp/>buffer);</highlight></codeline>
<codeline lineno="2214"><highlight class="normal"></highlight></codeline>
<codeline lineno="2228" refid="group__group__alloc_1ga4a71c30e3474a835bdd7fd0507740be7" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga4a71c30e3474a835bdd7fd0507740be7" kindref="member">vmaBindBufferMemory2</ref>(</highlight></codeline>
<codeline lineno="2229"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="2230"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="2231"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocationLocalOffset,</highlight></codeline>
<codeline lineno="2232"><highlight class="normal"><sp/><sp/><sp/><sp/>VkBuffer<sp/><ref refid="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" kindref="member">VMA_NOT_NULL_NON_DISPATCHABLE</ref><sp/>buffer,</highlight></codeline>
<codeline lineno="2233"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>pNext);</highlight></codeline>
<codeline lineno="2234"><highlight class="normal"></highlight></codeline>
<codeline lineno="2247" refid="group__group__alloc_1ga3a5d8d9f2a29b42cf87f0f8dfef591f4" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga3a5d8d9f2a29b42cf87f0f8dfef591f4" kindref="member">vmaBindImageMemory</ref>(</highlight></codeline>
<codeline lineno="2248"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="2249"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="2250"><highlight class="normal"><sp/><sp/><sp/><sp/>VkImage<sp/><ref refid="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" kindref="member">VMA_NOT_NULL_NON_DISPATCHABLE</ref><sp/>image);</highlight></codeline>
<codeline lineno="2251"><highlight class="normal"></highlight></codeline>
<codeline lineno="2265" refid="group__group__alloc_1ga0216b9225b02a66ac610cb45d4729d00" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga0216b9225b02a66ac610cb45d4729d00" kindref="member">vmaBindImageMemory2</ref>(</highlight></codeline>
<codeline lineno="2266"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="2267"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="2268"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocationLocalOffset,</highlight></codeline>
<codeline lineno="2269"><highlight class="normal"><sp/><sp/><sp/><sp/>VkImage<sp/><ref refid="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" kindref="member">VMA_NOT_NULL_NON_DISPATCHABLE</ref><sp/>image,</highlight></codeline>
<codeline lineno="2270"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>pNext);</highlight></codeline>
<codeline lineno="2271"><highlight class="normal"></highlight></codeline>
<codeline lineno="2306" refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer</ref>(</highlight></codeline>
<codeline lineno="2307"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="2308"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkBufferCreateInfo*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pBufferCreateInfo,</highlight></codeline>
<codeline lineno="2309"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pAllocationCreateInfo,</highlight></codeline>
<codeline lineno="2310"><highlight class="normal"><sp/><sp/><sp/><sp/>VkBuffer<sp/><ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pBuffer,</highlight></codeline>
<codeline lineno="2311"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pAllocation,</highlight></codeline>
<codeline lineno="2312"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>pAllocationInfo);</highlight></codeline>
<codeline lineno="2313"><highlight class="normal"></highlight></codeline>
<codeline lineno="2320" refid="group__group__alloc_1ga0a4d6890fe94cf4d234ca1d78af91229" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga0a4d6890fe94cf4d234ca1d78af91229" kindref="member">vmaCreateBufferWithAlignment</ref>(</highlight></codeline>
<codeline lineno="2321"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="2322"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkBufferCreateInfo*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pBufferCreateInfo,</highlight></codeline>
<codeline lineno="2323"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pAllocationCreateInfo,</highlight></codeline>
<codeline lineno="2324"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>minAlignment,</highlight></codeline>
<codeline lineno="2325"><highlight class="normal"><sp/><sp/><sp/><sp/>VkBuffer<sp/><ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pBuffer,</highlight></codeline>
<codeline lineno="2326"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pAllocation,</highlight></codeline>
<codeline lineno="2327"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>pAllocationInfo);</highlight></codeline>
<codeline lineno="2328"><highlight class="normal"></highlight></codeline>
<codeline lineno="2348" refid="group__group__alloc_1ga41a76d0f9f98a001900a889f55973536" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga41a76d0f9f98a001900a889f55973536" kindref="member">vmaCreateAliasingBuffer</ref>(</highlight></codeline>
<codeline lineno="2349"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="2350"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="2351"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkBufferCreateInfo*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pBufferCreateInfo,</highlight></codeline>
<codeline lineno="2352"><highlight class="normal"><sp/><sp/><sp/><sp/>VkBuffer<sp/><ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pBuffer);</highlight></codeline>
<codeline lineno="2353"><highlight class="normal"></highlight></codeline>
<codeline lineno="2365" refid="group__group__alloc_1gafcc45e5a6388ab35daa9a46688baee20" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gafcc45e5a6388ab35daa9a46688baee20" kindref="member">vmaDestroyBuffer</ref>(</highlight></codeline>
<codeline lineno="2366"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="2367"><highlight class="normal"><sp/><sp/><sp/><sp/>VkBuffer<sp/><ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref><sp/>buffer,</highlight></codeline>
<codeline lineno="2368"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>allocation);</highlight></codeline>
<codeline lineno="2369"><highlight class="normal"></highlight></codeline>
<codeline lineno="2371" refid="group__group__alloc_1gaa76142ae43535c862ad9e194a6e38aaa" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gaa76142ae43535c862ad9e194a6e38aaa" kindref="member">vmaCreateImage</ref>(</highlight></codeline>
<codeline lineno="2372"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="2373"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkImageCreateInfo*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pImageCreateInfo,</highlight></codeline>
<codeline lineno="2374"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pAllocationCreateInfo,</highlight></codeline>
<codeline lineno="2375"><highlight class="normal"><sp/><sp/><sp/><sp/>VkImage<sp/><ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pImage,</highlight></codeline>
<codeline lineno="2376"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pAllocation,</highlight></codeline>
<codeline lineno="2377"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>pAllocationInfo);</highlight></codeline>
<codeline lineno="2378"><highlight class="normal"></highlight></codeline>
<codeline lineno="2380" refid="group__group__alloc_1ga9ef2c5794b39fea75da48305e3a17084" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga9ef2c5794b39fea75da48305e3a17084" kindref="member">vmaCreateAliasingImage</ref>(</highlight></codeline>
<codeline lineno="2381"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="2382"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="2383"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkImageCreateInfo*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pImageCreateInfo,</highlight></codeline>
<codeline lineno="2384"><highlight class="normal"><sp/><sp/><sp/><sp/>VkImage<sp/><ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pImage);</highlight></codeline>
<codeline lineno="2385"><highlight class="normal"></highlight></codeline>
<codeline lineno="2397" refid="group__group__alloc_1ga2f6367e612daace5c5ecd7ef9e47c3fd" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga2f6367e612daace5c5ecd7ef9e47c3fd" kindref="member">vmaDestroyImage</ref>(</highlight></codeline>
<codeline lineno="2398"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="2399"><highlight class="normal"><sp/><sp/><sp/><sp/>VkImage<sp/><ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref><sp/>image,</highlight></codeline>
<codeline lineno="2400"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>allocation);</highlight></codeline>
<codeline lineno="2401"><highlight class="normal"></highlight></codeline>
<codeline lineno="2414" refid="group__group__virtual_1ga869baad02bf3b5fb012d61e1a43f92c5" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__virtual_1ga869baad02bf3b5fb012d61e1a43f92c5" kindref="member">vmaCreateVirtualBlock</ref>(</highlight></codeline>
<codeline lineno="2415"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_virtual_block_create_info" kindref="compound">VmaVirtualBlockCreateInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pCreateInfo,</highlight></codeline>
<codeline lineno="2416"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref><sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pVirtualBlock);</highlight></codeline>
<codeline lineno="2417"><highlight class="normal"></highlight></codeline>
<codeline lineno="2427" refid="group__group__virtual_1ga1a464943809fb27dd3b78d1cd6e3d534" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__virtual_1ga1a464943809fb27dd3b78d1cd6e3d534" kindref="member">vmaDestroyVirtualBlock</ref>(</highlight></codeline>
<codeline lineno="2428"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref><sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>virtualBlock);</highlight></codeline>
<codeline lineno="2429"><highlight class="normal"></highlight></codeline>
<codeline lineno="2432" refid="group__group__virtual_1ga59f870a818a9acf8506aa36760549a48" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkBool32<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__virtual_1ga59f870a818a9acf8506aa36760549a48" kindref="member">vmaIsVirtualBlockEmpty</ref>(</highlight></codeline>
<codeline lineno="2433"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>virtualBlock);</highlight></codeline>
<codeline lineno="2434"><highlight class="normal"></highlight></codeline>
<codeline lineno="2437" refid="group__group__virtual_1ga64b8c2939b82f83fbec507f29a43307b" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__virtual_1ga64b8c2939b82f83fbec507f29a43307b" kindref="member">vmaGetVirtualAllocationInfo</ref>(</highlight></codeline>
<codeline lineno="2438"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>virtualBlock,</highlight></codeline>
<codeline lineno="2439"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_virtual_allocation" kindref="compound">VmaVirtualAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" kindref="member">VMA_NOT_NULL_NON_DISPATCHABLE</ref><sp/>allocation,<sp/><ref refid="struct_vma_virtual_allocation_info" kindref="compound">VmaVirtualAllocationInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pVirtualAllocInfo);</highlight></codeline>
<codeline lineno="2440"><highlight class="normal"></highlight></codeline>
<codeline lineno="2452" refid="group__group__virtual_1ga2f6cd8f6b98e754be7016b5860d02dac" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__virtual_1ga2f6cd8f6b98e754be7016b5860d02dac" kindref="member">vmaVirtualAllocate</ref>(</highlight></codeline>
<codeline lineno="2453"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>virtualBlock,</highlight></codeline>
<codeline lineno="2454"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_virtual_allocation_create_info" kindref="compound">VmaVirtualAllocationCreateInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pCreateInfo,</highlight></codeline>
<codeline lineno="2455"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_virtual_allocation" kindref="compound">VmaVirtualAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pAllocation,</highlight></codeline>
<codeline lineno="2456"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>pOffset);</highlight></codeline>
<codeline lineno="2457"><highlight class="normal"></highlight></codeline>
<codeline lineno="2462" refid="group__group__virtual_1ga9f82fb8b8160d10bb469ae06b90134d2" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__virtual_1ga9f82fb8b8160d10bb469ae06b90134d2" kindref="member">vmaVirtualFree</ref>(</highlight></codeline>
<codeline lineno="2463"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>virtualBlock,</highlight></codeline>
<codeline lineno="2464"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_virtual_allocation" kindref="compound">VmaVirtualAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref><sp/>allocation);</highlight></codeline>
<codeline lineno="2465"><highlight class="normal"></highlight></codeline>
<codeline lineno="2474" refid="group__group__virtual_1ga3114a4b34e1225b3d0a246b219d29d9d" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__virtual_1ga3114a4b34e1225b3d0a246b219d29d9d" kindref="member">vmaClearVirtualBlock</ref>(</highlight></codeline>
<codeline lineno="2475"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>virtualBlock);</highlight></codeline>
<codeline lineno="2476"><highlight class="normal"></highlight></codeline>
<codeline lineno="2479" refid="group__group__virtual_1ga9e697c001a3750c3bf1a081ee15f6b10" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__virtual_1ga9e697c001a3750c3bf1a081ee15f6b10" kindref="member">vmaSetVirtualAllocationUserData</ref>(</highlight></codeline>
<codeline lineno="2480"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>virtualBlock,</highlight></codeline>
<codeline lineno="2481"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_virtual_allocation" kindref="compound">VmaVirtualAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" kindref="member">VMA_NOT_NULL_NON_DISPATCHABLE</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="2482"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>pUserData);</highlight></codeline>
<codeline lineno="2483"><highlight class="normal"></highlight></codeline>
<codeline lineno="2488" refid="group__group__virtual_1gac63bab2c8ae8e74451a11ef6dab48a5d" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__virtual_1gac63bab2c8ae8e74451a11ef6dab48a5d" kindref="member">vmaGetVirtualBlockStatistics</ref>(</highlight></codeline>
<codeline lineno="2489"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>virtualBlock,</highlight></codeline>
<codeline lineno="2490"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pStats);</highlight></codeline>
<codeline lineno="2491"><highlight class="normal"></highlight></codeline>
<codeline lineno="2497" refid="group__group__virtual_1ga87017b57fb0e9623573f07c236c37566" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__virtual_1ga87017b57fb0e9623573f07c236c37566" kindref="member">vmaCalculateVirtualBlockStatistics</ref>(</highlight></codeline>
<codeline lineno="2498"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>virtualBlock,</highlight></codeline>
<codeline lineno="2499"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pStats);</highlight></codeline>
<codeline lineno="2500"><highlight class="normal"></highlight></codeline>
<codeline lineno="2503"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2516" refid="group__group__stats_1ga874ef8790380b6643ee5c1144ae5b32b" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__stats_1ga874ef8790380b6643ee5c1144ae5b32b" kindref="member">vmaBuildVirtualBlockStatsString</ref>(</highlight></codeline>
<codeline lineno="2517"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>virtualBlock,</highlight></codeline>
<codeline lineno="2518"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>ppStatsString,</highlight></codeline>
<codeline lineno="2519"><highlight class="normal"><sp/><sp/><sp/><sp/>VkBool32<sp/>detailedMap);</highlight></codeline>
<codeline lineno="2520"><highlight class="normal"></highlight></codeline>
<codeline lineno="2522" refid="group__group__stats_1ga5b3acd266c1f20d0b360d4259ff411bf" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__stats_1ga5b3acd266c1f20d0b360d4259ff411bf" kindref="member">vmaFreeVirtualBlockStatsString</ref>(</highlight></codeline>
<codeline lineno="2523"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>virtualBlock,</highlight></codeline>
<codeline lineno="2524"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>pStatsString);</highlight></codeline>
<codeline lineno="2525"><highlight class="normal"></highlight></codeline>
<codeline lineno="2531" refid="group__group__stats_1ga9326cba3c64929b59a15c3ca9cdc8cdb" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__stats_1ga9326cba3c64929b59a15c3ca9cdc8cdb" kindref="member">vmaBuildStatsString</ref>(</highlight></codeline>
<codeline lineno="2532"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="2533"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>ppStatsString,</highlight></codeline>
<codeline lineno="2534"><highlight class="normal"><sp/><sp/><sp/><sp/>VkBool32<sp/>detailedMap);</highlight></codeline>
<codeline lineno="2535"><highlight class="normal"></highlight></codeline>
<codeline lineno="2536" refid="group__group__stats_1gad9b3c6a5dce6aea00719ccb2d3a780f3" refkind="member"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__stats_1gad9b3c6a5dce6aea00719ccb2d3a780f3" kindref="member">vmaFreeStatsString</ref>(</highlight></codeline>
<codeline lineno="2537"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="2538"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>pStatsString);</highlight></codeline>
<codeline lineno="2539"><highlight class="normal"></highlight></codeline>
<codeline lineno="2542"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2543"><highlight class="normal"></highlight></codeline>
<codeline lineno="2544"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_FUNCTION_HEADERS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2545"><highlight class="normal"></highlight></codeline>
<codeline lineno="2546"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>__cplusplus</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2547"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2548"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2549"><highlight class="normal"></highlight></codeline>
<codeline lineno="2550"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>AMD_VULKAN_MEMORY_ALLOCATOR_H</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2551"><highlight class="normal"></highlight></codeline>
<codeline lineno="2554"><highlight class="comment">//<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2555"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/>IMPLEMENTATION</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2556"><highlight class="normal"></highlight><highlight class="comment">//<sp/></highlight></codeline>
<codeline lineno="2559"><highlight class="comment"></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2560"><highlight class="normal"></highlight><highlight class="comment">//<sp/>For<sp/>Visual<sp/>Studio<sp/>IntelliSense.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2561"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>defined(__cplusplus)<sp/>&amp;&amp;<sp/>defined(__INTELLISENSE__)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2562"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>VMA_IMPLEMENTATION</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2563"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2564"><highlight class="normal"></highlight></codeline>
<codeline lineno="2565"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>VMA_IMPLEMENTATION</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2566"><highlight class="normal"></highlight><highlight class="preprocessor">#undef<sp/>VMA_IMPLEMENTATION</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2567"><highlight class="normal"></highlight></codeline>
<codeline lineno="2568"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdint&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2569"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2570"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstring&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2571"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;utility&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2572"><highlight class="normal"></highlight></codeline>
<codeline lineno="2573"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>_MSC_VER</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2574"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#include<sp/>&lt;intrin.h&gt;</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>For<sp/>functions<sp/>like<sp/>__popcnt,<sp/>_BitScanForward<sp/>etc.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2575"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2576"><highlight class="normal"></highlight></codeline>
<codeline lineno="2577"><highlight class="normal"></highlight><highlight class="comment">/*******************************************************************************</highlight></codeline>
<codeline lineno="2578"><highlight class="comment">CONFIGURATION<sp/>SECTION</highlight></codeline>
<codeline lineno="2579"><highlight class="comment"></highlight></codeline>
<codeline lineno="2580"><highlight class="comment">Define<sp/>some<sp/>of<sp/>these<sp/>macros<sp/>before<sp/>each<sp/>#include<sp/>of<sp/>this<sp/>header<sp/>or<sp/>change<sp/>them</highlight></codeline>
<codeline lineno="2581"><highlight class="comment">here<sp/>if<sp/>you<sp/>need<sp/>other<sp/>then<sp/>default<sp/>behavior<sp/>depending<sp/>on<sp/>your<sp/>environment.</highlight></codeline>
<codeline lineno="2582"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2583"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_CONFIGURATION</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2584"><highlight class="normal"></highlight></codeline>
<codeline lineno="2585"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="2586"><highlight class="comment">Define<sp/>this<sp/>macro<sp/>to<sp/>1<sp/>to<sp/>make<sp/>the<sp/>library<sp/>fetch<sp/>pointers<sp/>to<sp/>Vulkan<sp/>functions</highlight></codeline>
<codeline lineno="2587"><highlight class="comment">internally,<sp/>like:</highlight></codeline>
<codeline lineno="2588"><highlight class="comment"></highlight></codeline>
<codeline lineno="2589"><highlight class="comment"><sp/><sp/><sp/><sp/>vulkanFunctions.vkAllocateMemory<sp/>=<sp/>&amp;vkAllocateMemory;</highlight></codeline>
<codeline lineno="2590"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2591"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>!defined(VMA_STATIC_VULKAN_FUNCTIONS)<sp/>&amp;&amp;<sp/>!defined(VK_NO_PROTOTYPES)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2592"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#define<sp/>VMA_STATIC_VULKAN_FUNCTIONS<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2593"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2594"><highlight class="normal"></highlight></codeline>
<codeline lineno="2595"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="2596"><highlight class="comment">Define<sp/>this<sp/>macro<sp/>to<sp/>1<sp/>to<sp/>make<sp/>the<sp/>library<sp/>fetch<sp/>pointers<sp/>to<sp/>Vulkan<sp/>functions</highlight></codeline>
<codeline lineno="2597"><highlight class="comment">internally,<sp/>like:</highlight></codeline>
<codeline lineno="2598"><highlight class="comment"></highlight></codeline>
<codeline lineno="2599"><highlight class="comment"><sp/><sp/><sp/><sp/>vulkanFunctions.vkAllocateMemory<sp/>=<sp/>(PFN_vkAllocateMemory)vkGetDeviceProcAddr(device,<sp/>&quot;vkAllocateMemory&quot;);</highlight></codeline>
<codeline lineno="2600"><highlight class="comment"></highlight></codeline>
<codeline lineno="2601"><highlight class="comment">To<sp/>use<sp/>this<sp/>feature<sp/>in<sp/>new<sp/>versions<sp/>of<sp/>VMA<sp/>you<sp/>now<sp/>have<sp/>to<sp/>pass</highlight></codeline>
<codeline lineno="2602"><highlight class="comment">VmaVulkanFunctions::vkGetInstanceProcAddr<sp/>and<sp/>vkGetDeviceProcAddr<sp/>as</highlight></codeline>
<codeline lineno="2603"><highlight class="comment">VmaAllocatorCreateInfo::pVulkanFunctions.<sp/>Other<sp/>members<sp/>can<sp/>be<sp/>null.</highlight></codeline>
<codeline lineno="2604"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2605"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>!defined(VMA_DYNAMIC_VULKAN_FUNCTIONS)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2606"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#define<sp/>VMA_DYNAMIC_VULKAN_FUNCTIONS<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2607"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2608"><highlight class="normal"></highlight></codeline>
<codeline lineno="2609"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_USE_STL_SHARED_MUTEX</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2610"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compiler<sp/>conforms<sp/>to<sp/>C++17.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2611"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#if<sp/>__cplusplus<sp/>&gt;=<sp/>201703L</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2612"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_USE_STL_SHARED_MUTEX<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2613"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Visual<sp/>studio<sp/>defines<sp/>__cplusplus<sp/>properly<sp/>only<sp/>when<sp/>passed<sp/>additional<sp/>parameter:<sp/>/Zc:__cplusplus</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2614"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Otherwise<sp/>it<sp/>is<sp/>always<sp/>199711L,<sp/>despite<sp/>shared_mutex<sp/>works<sp/>since<sp/>Visual<sp/>Studio<sp/>2015<sp/>Update<sp/>2.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2615"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#elif<sp/>defined(_MSC_FULL_VER)<sp/>&amp;&amp;<sp/>_MSC_FULL_VER<sp/>&gt;=<sp/>190023918<sp/>&amp;&amp;<sp/>__cplusplus<sp/>==<sp/>199711L<sp/>&amp;&amp;<sp/>_MSVC_LANG<sp/>&gt;=<sp/>201703L</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2616"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_USE_STL_SHARED_MUTEX<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2617"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2618"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_USE_STL_SHARED_MUTEX<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2619"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2620"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2621"><highlight class="normal"></highlight></codeline>
<codeline lineno="2622"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="2623"><highlight class="comment">Define<sp/>this<sp/>macro<sp/>to<sp/>include<sp/>custom<sp/>header<sp/>files<sp/>without<sp/>having<sp/>to<sp/>edit<sp/>this<sp/>file<sp/>directly,<sp/>e.g.:</highlight></codeline>
<codeline lineno="2624"><highlight class="comment"></highlight></codeline>
<codeline lineno="2625"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>Inside<sp/>of<sp/>&quot;my_vma_configuration_user_includes.h&quot;:</highlight></codeline>
<codeline lineno="2626"><highlight class="comment"></highlight></codeline>
<codeline lineno="2627"><highlight class="comment"><sp/><sp/><sp/><sp/>#include<sp/>&quot;my_custom_assert.h&quot;<sp/>//<sp/>for<sp/>MY_CUSTOM_ASSERT</highlight></codeline>
<codeline lineno="2628"><highlight class="comment"><sp/><sp/><sp/><sp/>#include<sp/>&quot;my_custom_min.h&quot;<sp/>//<sp/>for<sp/>my_custom_min</highlight></codeline>
<codeline lineno="2629"><highlight class="comment"><sp/><sp/><sp/><sp/>#include<sp/>&lt;algorithm&gt;</highlight></codeline>
<codeline lineno="2630"><highlight class="comment"><sp/><sp/><sp/><sp/>#include<sp/>&lt;mutex&gt;</highlight></codeline>
<codeline lineno="2631"><highlight class="comment"></highlight></codeline>
<codeline lineno="2632"><highlight class="comment"><sp/><sp/><sp/><sp/>//<sp/>Inside<sp/>a<sp/>different<sp/>file,<sp/>which<sp/>includes<sp/>&quot;vk_mem_alloc.h&quot;:</highlight></codeline>
<codeline lineno="2633"><highlight class="comment"></highlight></codeline>
<codeline lineno="2634"><highlight class="comment"><sp/><sp/><sp/><sp/>#define<sp/>VMA_CONFIGURATION_USER_INCLUDES_H<sp/>&quot;my_vma_configuration_user_includes.h&quot;</highlight></codeline>
<codeline lineno="2635"><highlight class="comment"><sp/><sp/><sp/><sp/>#define<sp/>VMA_ASSERT(expr)<sp/>MY_CUSTOM_ASSERT(expr)</highlight></codeline>
<codeline lineno="2636"><highlight class="comment"><sp/><sp/><sp/><sp/>#define<sp/>VMA_MIN(v1,<sp/>v2)<sp/><sp/>(my_custom_min(v1,<sp/>v2))</highlight></codeline>
<codeline lineno="2637"><highlight class="comment"><sp/><sp/><sp/><sp/>#include<sp/>&quot;vk_mem_alloc.h&quot;</highlight></codeline>
<codeline lineno="2638"><highlight class="comment"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline lineno="2639"><highlight class="comment"></highlight></codeline>
<codeline lineno="2640"><highlight class="comment">The<sp/>following<sp/>headers<sp/>are<sp/>used<sp/>in<sp/>this<sp/>CONFIGURATION<sp/>section<sp/>only,<sp/>so<sp/>feel<sp/>free<sp/>to</highlight></codeline>
<codeline lineno="2641"><highlight class="comment">remove<sp/>them<sp/>if<sp/>not<sp/>needed.</highlight></codeline>
<codeline lineno="2642"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2643"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>!defined(VMA_CONFIGURATION_USER_INCLUDES_H)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2644"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#include<sp/>&lt;cassert&gt;</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>for<sp/>assert</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2645"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#include<sp/>&lt;algorithm&gt;</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>for<sp/>min,<sp/>max</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2646"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#include<sp/>&lt;mutex&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2647"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2648"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#include<sp/>VMA_CONFIGURATION_USER_INCLUDES_H</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2649"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2650"><highlight class="normal"></highlight></codeline>
<codeline lineno="2651"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_NULL</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2652"><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Value<sp/>used<sp/>as<sp/>null<sp/>pointer.<sp/>Define<sp/>it<sp/>to<sp/>e.g.:<sp/>nullptr,<sp/>NULL,<sp/>0,<sp/>(void*)0.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2653"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/>#define<sp/>VMA_NULL<sp/><sp/><sp/>nullptr</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2654"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2655"><highlight class="normal"></highlight></codeline>
<codeline lineno="2656"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>defined(__ANDROID_API__)<sp/>&amp;&amp;<sp/>(__ANDROID_API__<sp/>&lt;<sp/>16)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2657"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2658"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>vma_aligned_alloc(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>alignment,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size)</highlight></codeline>
<codeline lineno="2659"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2660"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>alignment<sp/>must<sp/>be<sp/>&gt;=<sp/>sizeof(void*)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2661"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(alignment<sp/>&lt;<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*))</highlight></codeline>
<codeline lineno="2662"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2663"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alignment<sp/>=<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*);</highlight></codeline>
<codeline lineno="2664"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2665"><highlight class="normal"></highlight></codeline>
<codeline lineno="2666"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>memalign(alignment,<sp/>size);</highlight></codeline>
<codeline lineno="2667"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2668"><highlight class="normal"></highlight><highlight class="preprocessor">#elif<sp/>defined(__APPLE__)<sp/>||<sp/>defined(__ANDROID__)<sp/>||<sp/>(defined(__linux__)<sp/>&amp;&amp;<sp/>defined(__GLIBCXX__)<sp/>&amp;&amp;<sp/>!defined(_GLIBCXX_HAVE_ALIGNED_ALLOC))</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2669"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cstdlib&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2670"><highlight class="normal"></highlight></codeline>
<codeline lineno="2671"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>defined(__APPLE__)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2672"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;AvailabilityMacros.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2673"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2674"><highlight class="normal"></highlight></codeline>
<codeline lineno="2675"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>vma_aligned_alloc(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>alignment,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size)</highlight></codeline>
<codeline lineno="2676"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2677"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Unfortunately,<sp/>aligned_alloc<sp/>causes<sp/>VMA<sp/>to<sp/>crash<sp/>due<sp/>to<sp/>it<sp/>returning<sp/>null<sp/>pointers.<sp/>(At<sp/>least<sp/>under<sp/>11.4)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2678"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Therefore,<sp/>for<sp/>now<sp/>disable<sp/>this<sp/>specific<sp/>exception<sp/>until<sp/>a<sp/>proper<sp/>solution<sp/>is<sp/>found.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2679"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//#if<sp/>defined(__APPLE__)<sp/>&amp;&amp;<sp/>(defined(MAC_OS_X_VERSION_10_16)<sp/>||<sp/>defined(__IPHONE_14_0))</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2680"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//#if<sp/>MAC_OS_X_VERSION_MAX_ALLOWED<sp/>&gt;=<sp/>MAC_OS_X_VERSION_10_16<sp/>||<sp/>__IPHONE_OS_VERSION_MAX_ALLOWED<sp/>&gt;=<sp/>__IPHONE_14_0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2681"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/>//<sp/>For<sp/>C++14,<sp/>usr/include/malloc/_malloc.h<sp/>declares<sp/>aligned_alloc())<sp/>only</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2682"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/>//<sp/>with<sp/>the<sp/>MacOSX11.0<sp/>SDK<sp/>in<sp/>Xcode<sp/>12<sp/>(which<sp/>is<sp/>what<sp/>adds</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2683"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/>//<sp/>MAC_OS_X_VERSION_10_16),<sp/>even<sp/>though<sp/>the<sp/>function<sp/>is<sp/>marked</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2684"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/>//<sp/>availabe<sp/>for<sp/>10.15.<sp/>That<sp/>is<sp/>why<sp/>the<sp/>preprocessor<sp/>checks<sp/>for<sp/>10.16<sp/>but</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2685"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/>//<sp/>the<sp/>__builtin_available<sp/>checks<sp/>for<sp/>10.15.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2686"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/>//<sp/>People<sp/>who<sp/>use<sp/>C++17<sp/>could<sp/>call<sp/>aligned_alloc<sp/>with<sp/>the<sp/>10.15<sp/>SDK<sp/>already.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2687"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/>if<sp/>(__builtin_available(macOS<sp/>10.15,<sp/>iOS<sp/>13,<sp/>*))</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2688"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>aligned_alloc(alignment,<sp/>size);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2689"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2690"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2691"><highlight class="normal"></highlight></codeline>
<codeline lineno="2692"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>alignment<sp/>must<sp/>be<sp/>&gt;=<sp/>sizeof(void*)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2693"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(alignment<sp/>&lt;<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*))</highlight></codeline>
<codeline lineno="2694"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2695"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alignment<sp/>=<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*);</highlight></codeline>
<codeline lineno="2696"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2697"><highlight class="normal"></highlight></codeline>
<codeline lineno="2698"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*pointer;</highlight></codeline>
<codeline lineno="2699"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(posix_memalign(&amp;pointer,<sp/>alignment,<sp/>size)<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="2700"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>pointer;</highlight></codeline>
<codeline lineno="2701"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="2702"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2703"><highlight class="normal"></highlight><highlight class="preprocessor">#elif<sp/>defined(_WIN32)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2704"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>vma_aligned_alloc(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>alignment,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size)</highlight></codeline>
<codeline lineno="2705"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2706"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>_aligned_malloc(size,<sp/>alignment);</highlight></codeline>
<codeline lineno="2707"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2708"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2709"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>vma_aligned_alloc(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>alignment,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size)</highlight></codeline>
<codeline lineno="2710"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2711"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>aligned_alloc(alignment,<sp/>size);</highlight></codeline>
<codeline lineno="2712"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2713"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2714"><highlight class="normal"></highlight></codeline>
<codeline lineno="2715"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>defined(_WIN32)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2716"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>vma_aligned_free(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>ptr)</highlight></codeline>
<codeline lineno="2717"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2718"><highlight class="normal"><sp/><sp/><sp/><sp/>_aligned_free(ptr);</highlight></codeline>
<codeline lineno="2719"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2720"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2721"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>vma_aligned_free(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>ptr)</highlight></codeline>
<codeline lineno="2722"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2723"><highlight class="normal"><sp/><sp/><sp/><sp/>free(ptr);</highlight></codeline>
<codeline lineno="2724"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2725"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2726"><highlight class="normal"></highlight></codeline>
<codeline lineno="2727"><highlight class="normal"></highlight><highlight class="comment">//<sp/>If<sp/>your<sp/>compiler<sp/>is<sp/>not<sp/>compatible<sp/>with<sp/>C++11<sp/>and<sp/>definition<sp/>of</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2728"><highlight class="normal"></highlight><highlight class="comment">//<sp/>aligned_alloc()<sp/>function<sp/>is<sp/>missing,<sp/>uncommeting<sp/>following<sp/>line<sp/>may<sp/>help:</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2729"><highlight class="normal"></highlight></codeline>
<codeline lineno="2730"><highlight class="normal"></highlight><highlight class="comment">//#include<sp/>&lt;malloc.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2731"><highlight class="normal"></highlight></codeline>
<codeline lineno="2732"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Normal<sp/>assert<sp/>to<sp/>check<sp/>for<sp/>programmer&apos;s<sp/>errors,<sp/>especially<sp/>in<sp/>Debug<sp/>configuration.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2733"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_ASSERT</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2734"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/>#ifdef<sp/>NDEBUG</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2735"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_ASSERT(expr)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2736"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/>#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2737"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_ASSERT(expr)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>assert(expr)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2738"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2739"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2740"><highlight class="normal"></highlight></codeline>
<codeline lineno="2741"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Assert<sp/>that<sp/>will<sp/>be<sp/>called<sp/>very<sp/>often,<sp/>like<sp/>inside<sp/>data<sp/>structures<sp/>e.g.<sp/>operator[].</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2742"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Making<sp/>it<sp/>non-empty<sp/>can<sp/>make<sp/>program<sp/>slow.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2743"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_HEAVY_ASSERT</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2744"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/>#ifdef<sp/>NDEBUG</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2745"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_HEAVY_ASSERT(expr)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2746"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/>#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2747"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_HEAVY_ASSERT(expr)<sp/><sp/><sp/></highlight><highlight class="comment">//VMA_ASSERT(expr)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2748"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2749"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2750"><highlight class="normal"></highlight></codeline>
<codeline lineno="2751"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_ALIGN_OF</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2752"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/>#define<sp/>VMA_ALIGN_OF(type)<sp/><sp/><sp/><sp/><sp/><sp/><sp/>(__alignof(type))</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2753"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2754"><highlight class="normal"></highlight></codeline>
<codeline lineno="2755"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_SYSTEM_ALIGNED_MALLOC</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2756"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/>#define<sp/>VMA_SYSTEM_ALIGNED_MALLOC(size,<sp/>alignment)<sp/>vma_aligned_alloc((alignment),<sp/>(size))</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2757"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2758"><highlight class="normal"></highlight></codeline>
<codeline lineno="2759"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_SYSTEM_ALIGNED_FREE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2760"><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>VMA_SYSTEM_FREE<sp/>is<sp/>the<sp/>old<sp/>name,<sp/>but<sp/>might<sp/>have<sp/>been<sp/>defined<sp/>by<sp/>the<sp/>user</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2761"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/>#if<sp/>defined(VMA_SYSTEM_FREE)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2762"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_SYSTEM_ALIGNED_FREE(ptr)<sp/><sp/><sp/><sp/><sp/>VMA_SYSTEM_FREE(ptr)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2763"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/>#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2764"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_SYSTEM_ALIGNED_FREE(ptr)<sp/><sp/><sp/><sp/><sp/>vma_aligned_free(ptr)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2765"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2766"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2767"><highlight class="normal"></highlight></codeline>
<codeline lineno="2768"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_COUNT_BITS_SET</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2769"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Returns<sp/>number<sp/>of<sp/>bits<sp/>set<sp/>to<sp/>1<sp/>in<sp/>(v)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2770"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#define<sp/>VMA_COUNT_BITS_SET(v)<sp/>VmaCountBitsSet(v)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2771"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2772"><highlight class="normal"></highlight></codeline>
<codeline lineno="2773"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_BITSCAN_LSB</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2774"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Scans<sp/>integer<sp/>for<sp/>index<sp/>of<sp/>first<sp/>nonzero<sp/>value<sp/>from<sp/>the<sp/>Least<sp/>Significant<sp/>Bit<sp/>(LSB).<sp/>If<sp/>mask<sp/>is<sp/>0<sp/>then<sp/>returns<sp/>UINT8_MAX</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2775"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#define<sp/>VMA_BITSCAN_LSB(mask)<sp/>VmaBitScanLSB(mask)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2776"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2777"><highlight class="normal"></highlight></codeline>
<codeline lineno="2778"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_BITSCAN_MSB</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2779"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Scans<sp/>integer<sp/>for<sp/>index<sp/>of<sp/>first<sp/>nonzero<sp/>value<sp/>from<sp/>the<sp/>Most<sp/>Significant<sp/>Bit<sp/>(MSB).<sp/>If<sp/>mask<sp/>is<sp/>0<sp/>then<sp/>returns<sp/>UINT8_MAX</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2780"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#define<sp/>VMA_BITSCAN_MSB(mask)<sp/>VmaBitScanMSB(mask)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2781"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2782"><highlight class="normal"></highlight></codeline>
<codeline lineno="2783"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_MIN</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2784"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/>#define<sp/>VMA_MIN(v1,<sp/>v2)<sp/><sp/><sp/><sp/>((std::min)((v1),<sp/>(v2)))</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2785"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2786"><highlight class="normal"></highlight></codeline>
<codeline lineno="2787"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_MAX</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2788"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/>#define<sp/>VMA_MAX(v1,<sp/>v2)<sp/><sp/><sp/><sp/>((std::max)((v1),<sp/>(v2)))</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2789"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2790"><highlight class="normal"></highlight></codeline>
<codeline lineno="2791"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_SWAP</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2792"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/>#define<sp/>VMA_SWAP(v1,<sp/>v2)<sp/><sp/><sp/>std::swap((v1),<sp/>(v2))</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2793"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2794"><highlight class="normal"></highlight></codeline>
<codeline lineno="2795"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_SORT</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2796"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/>#define<sp/>VMA_SORT(beg,<sp/>end,<sp/>cmp)<sp/><sp/>std::sort(beg,<sp/>end,<sp/>cmp)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2797"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2798"><highlight class="normal"></highlight></codeline>
<codeline lineno="2799"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_DEBUG_LOG</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2800"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/>#define<sp/>VMA_DEBUG_LOG(format,<sp/>...)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2801"><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="2802"><highlight class="comment"><sp/><sp/><sp/>#define<sp/>VMA_DEBUG_LOG(format,<sp/>...)<sp/>do<sp/>{<sp/>\</highlight></codeline>
<codeline lineno="2803"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(format,<sp/>__VA_ARGS__);<sp/>\</highlight></codeline>
<codeline lineno="2804"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;\n&quot;);<sp/>\</highlight></codeline>
<codeline lineno="2805"><highlight class="comment"><sp/><sp/><sp/>}<sp/>while(false)</highlight></codeline>
<codeline lineno="2806"><highlight class="comment"><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2807"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2808"><highlight class="normal"></highlight></codeline>
<codeline lineno="2809"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Define<sp/>this<sp/>macro<sp/>to<sp/>1<sp/>to<sp/>enable<sp/>functions:<sp/>vmaBuildStatsString,<sp/>vmaFreeStatsString.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2810"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2811"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaUint32ToStr(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>outStr,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>strLen,<sp/>uint32_t<sp/>num)</highlight></codeline>
<codeline lineno="2812"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2813"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snprintf(outStr,<sp/>strLen,<sp/></highlight><highlight class="stringliteral">&quot;%u&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(num));</highlight></codeline>
<codeline lineno="2814"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2815"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaUint64ToStr(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>outStr,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>strLen,<sp/>uint64_t<sp/>num)</highlight></codeline>
<codeline lineno="2816"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2817"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snprintf(outStr,<sp/>strLen,<sp/></highlight><highlight class="stringliteral">&quot;%llu&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(num));</highlight></codeline>
<codeline lineno="2818"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2819"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaPtrToStr(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>outStr,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>strLen,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>ptr)</highlight></codeline>
<codeline lineno="2820"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2821"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snprintf(outStr,<sp/>strLen,<sp/></highlight><highlight class="stringliteral">&quot;%p&quot;</highlight><highlight class="normal">,<sp/>ptr);</highlight></codeline>
<codeline lineno="2822"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2823"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2824"><highlight class="normal"></highlight></codeline>
<codeline lineno="2825"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_MUTEX</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2826"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaMutex</highlight></codeline>
<codeline lineno="2827"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2828"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="2829"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Lock()<sp/>{<sp/>m_Mutex.lock();<sp/>}</highlight></codeline>
<codeline lineno="2830"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Unlock()<sp/>{<sp/>m_Mutex.unlock();<sp/>}</highlight></codeline>
<codeline lineno="2831"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>TryLock()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Mutex.try_lock();<sp/>}</highlight></codeline>
<codeline lineno="2832"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="2833"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::mutex<sp/>m_Mutex;</highlight></codeline>
<codeline lineno="2834"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="2835"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#define<sp/>VMA_MUTEX<sp/>VmaMutex</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2836"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2837"><highlight class="normal"></highlight></codeline>
<codeline lineno="2838"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Read-write<sp/>mutex,<sp/>where<sp/>&quot;read&quot;<sp/>is<sp/>shared<sp/>access,<sp/>&quot;write&quot;<sp/>is<sp/>exclusive<sp/>access.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2839"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_RW_MUTEX</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2840"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#if<sp/>VMA_USE_STL_SHARED_MUTEX</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2841"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Use<sp/>std::shared_mutex<sp/>from<sp/>C++17.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2842"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#include<sp/>&lt;shared_mutex&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2843"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaRWMutex</highlight></codeline>
<codeline lineno="2844"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2845"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="2846"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>LockRead()<sp/>{<sp/>m_Mutex.lock_shared();<sp/>}</highlight></codeline>
<codeline lineno="2847"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>UnlockRead()<sp/>{<sp/>m_Mutex.unlock_shared();<sp/>}</highlight></codeline>
<codeline lineno="2848"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>TryLockRead()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Mutex.try_lock_shared();<sp/>}</highlight></codeline>
<codeline lineno="2849"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>LockWrite()<sp/>{<sp/>m_Mutex.lock();<sp/>}</highlight></codeline>
<codeline lineno="2850"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>UnlockWrite()<sp/>{<sp/>m_Mutex.unlock();<sp/>}</highlight></codeline>
<codeline lineno="2851"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>TryLockWrite()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Mutex.try_lock();<sp/>}</highlight></codeline>
<codeline lineno="2852"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="2853"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::shared_mutex<sp/>m_Mutex;</highlight></codeline>
<codeline lineno="2854"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="2855"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_RW_MUTEX<sp/>VmaRWMutex</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2856"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#elif<sp/>defined(_WIN32)<sp/>&amp;&amp;<sp/>defined(WINVER)<sp/>&amp;&amp;<sp/>WINVER<sp/>&gt;=<sp/>0x0600</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2857"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Use<sp/>SRWLOCK<sp/>from<sp/>WinAPI.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2858"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Minimum<sp/>supported<sp/>client<sp/>=<sp/>Windows<sp/>Vista,<sp/>server<sp/>=<sp/>Windows<sp/>Server<sp/>2008.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2859"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaRWMutex</highlight></codeline>
<codeline lineno="2860"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2861"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="2862"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaRWMutex()<sp/>{<sp/>InitializeSRWLock(&amp;m_Lock);<sp/>}</highlight></codeline>
<codeline lineno="2863"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>LockRead()<sp/>{<sp/>AcquireSRWLockShared(&amp;m_Lock);<sp/>}</highlight></codeline>
<codeline lineno="2864"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>UnlockRead()<sp/>{<sp/>ReleaseSRWLockShared(&amp;m_Lock);<sp/>}</highlight></codeline>
<codeline lineno="2865"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>TryLockRead()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>TryAcquireSRWLockShared(&amp;m_Lock)<sp/>!=<sp/>FALSE;<sp/>}</highlight></codeline>
<codeline lineno="2866"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>LockWrite()<sp/>{<sp/>AcquireSRWLockExclusive(&amp;m_Lock);<sp/>}</highlight></codeline>
<codeline lineno="2867"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>UnlockWrite()<sp/>{<sp/>ReleaseSRWLockExclusive(&amp;m_Lock);<sp/>}</highlight></codeline>
<codeline lineno="2868"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>TryLockWrite()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>TryAcquireSRWLockExclusive(&amp;m_Lock)<sp/>!=<sp/>FALSE;<sp/>}</highlight></codeline>
<codeline lineno="2869"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="2870"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SRWLOCK<sp/>m_Lock;</highlight></codeline>
<codeline lineno="2871"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="2872"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_RW_MUTEX<sp/>VmaRWMutex</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2873"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2874"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Less<sp/>efficient<sp/>fallback:<sp/>Use<sp/>normal<sp/>mutex.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2875"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaRWMutex</highlight></codeline>
<codeline lineno="2876"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="2877"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="2878"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>LockRead()<sp/>{<sp/>m_Mutex.Lock();<sp/>}</highlight></codeline>
<codeline lineno="2879"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>UnlockRead()<sp/>{<sp/>m_Mutex.Unlock();<sp/>}</highlight></codeline>
<codeline lineno="2880"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>TryLockRead()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Mutex.TryLock();<sp/>}</highlight></codeline>
<codeline lineno="2881"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>LockWrite()<sp/>{<sp/>m_Mutex.Lock();<sp/>}</highlight></codeline>
<codeline lineno="2882"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>UnlockWrite()<sp/>{<sp/>m_Mutex.Unlock();<sp/>}</highlight></codeline>
<codeline lineno="2883"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>TryLockWrite()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Mutex.TryLock();<sp/>}</highlight></codeline>
<codeline lineno="2884"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="2885"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_MUTEX<sp/>m_Mutex;</highlight></codeline>
<codeline lineno="2886"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="2887"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_RW_MUTEX<sp/>VmaRWMutex</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2888"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>VMA_USE_STL_SHARED_MUTEX</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2889"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#ifndef<sp/>VMA_RW_MUTEX</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2890"><highlight class="normal"></highlight></codeline>
<codeline lineno="2891"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="2892"><highlight class="comment">If<sp/>providing<sp/>your<sp/>own<sp/>implementation,<sp/>you<sp/>need<sp/>to<sp/>implement<sp/>a<sp/>subset<sp/>of<sp/>std::atomic.</highlight></codeline>
<codeline lineno="2893"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2894"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_ATOMIC_UINT32</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2895"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#include<sp/>&lt;atomic&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2896"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#define<sp/>VMA_ATOMIC_UINT32<sp/>std::atomic&lt;uint32_t&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2897"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2898"><highlight class="normal"></highlight></codeline>
<codeline lineno="2899"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_ATOMIC_UINT64</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2900"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#include<sp/>&lt;atomic&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2901"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#define<sp/>VMA_ATOMIC_UINT64<sp/>std::atomic&lt;uint64_t&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2902"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2903"><highlight class="normal"></highlight></codeline>
<codeline lineno="2904"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_DEBUG_ALWAYS_DEDICATED_MEMORY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2909"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#define<sp/>VMA_DEBUG_ALWAYS_DEDICATED_MEMORY<sp/>(0)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2910"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2911"><highlight class="normal"></highlight></codeline>
<codeline lineno="2912"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_MIN_ALIGNMENT</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2917"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#ifdef<sp/>VMA_DEBUG_ALIGNMENT<sp/></highlight><highlight class="comment">//<sp/>Old<sp/>name</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2918"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_MIN_ALIGNMENT<sp/>VMA_DEBUG_ALIGNMENT</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2919"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2920"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#define<sp/>VMA_MIN_ALIGNMENT<sp/>(1)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2921"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2922"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2923"><highlight class="normal"></highlight></codeline>
<codeline lineno="2924"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_DEBUG_MARGIN</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2929"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#define<sp/>VMA_DEBUG_MARGIN<sp/>(0)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2930"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2931"><highlight class="normal"></highlight></codeline>
<codeline lineno="2932"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_DEBUG_INITIALIZE_ALLOCATIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2937"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#define<sp/>VMA_DEBUG_INITIALIZE_ALLOCATIONS<sp/>(0)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2938"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2939"><highlight class="normal"></highlight></codeline>
<codeline lineno="2940"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_DEBUG_DETECT_CORRUPTION</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2946"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#define<sp/>VMA_DEBUG_DETECT_CORRUPTION<sp/>(0)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2947"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2948"><highlight class="normal"></highlight></codeline>
<codeline lineno="2949"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_DEBUG_GLOBAL_MUTEX</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2954"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#define<sp/>VMA_DEBUG_GLOBAL_MUTEX<sp/>(0)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2955"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2956"><highlight class="normal"></highlight></codeline>
<codeline lineno="2957"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_DEBUG_MIN_BUFFER_IMAGE_GRANULARITY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2962"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#define<sp/>VMA_DEBUG_MIN_BUFFER_IMAGE_GRANULARITY<sp/>(1)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2963"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2964"><highlight class="normal"></highlight></codeline>
<codeline lineno="2965"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_DEBUG_DONT_EXCEED_MAX_MEMORY_ALLOCATION_COUNT</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2966"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="2967"><highlight class="comment"><sp/><sp/><sp/><sp/>Set<sp/>this<sp/>to<sp/>1<sp/>to<sp/>make<sp/>VMA<sp/>never<sp/>exceed<sp/>VkPhysicalDeviceLimits::maxMemoryAllocationCount</highlight></codeline>
<codeline lineno="2968"><highlight class="comment"><sp/><sp/><sp/><sp/>and<sp/>return<sp/>error<sp/>instead<sp/>of<sp/>leaving<sp/>up<sp/>to<sp/>Vulkan<sp/>implementation<sp/>what<sp/>to<sp/>do<sp/>in<sp/>such<sp/>cases.</highlight></codeline>
<codeline lineno="2969"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2970"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#define<sp/>VMA_DEBUG_DONT_EXCEED_MAX_MEMORY_ALLOCATION_COUNT<sp/>(0)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2971"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2972"><highlight class="normal"></highlight></codeline>
<codeline lineno="2973"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_SMALL_HEAP_MAX_SIZE</highlight></codeline>
<codeline lineno="2975"><highlight class="preprocessor"><sp/><sp/><sp/>#define<sp/>VMA_SMALL_HEAP_MAX_SIZE<sp/>(1024ull<sp/>*<sp/>1024<sp/>*<sp/>1024)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2976"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2977"><highlight class="normal"></highlight></codeline>
<codeline lineno="2978"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_DEFAULT_LARGE_HEAP_BLOCK_SIZE</highlight></codeline>
<codeline lineno="2980"><highlight class="preprocessor"><sp/><sp/><sp/>#define<sp/>VMA_DEFAULT_LARGE_HEAP_BLOCK_SIZE<sp/>(256ull<sp/>*<sp/>1024<sp/>*<sp/>1024)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2981"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2982"><highlight class="normal"></highlight></codeline>
<codeline lineno="2983"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="2984"><highlight class="comment">Mapping<sp/>hysteresis<sp/>is<sp/>a<sp/>logic<sp/>that<sp/>launches<sp/>when<sp/>vmaMapMemory/vmaUnmapMemory<sp/>is<sp/>called</highlight></codeline>
<codeline lineno="2985"><highlight class="comment">or<sp/>a<sp/>persistently<sp/>mapped<sp/>allocation<sp/>is<sp/>created<sp/>and<sp/>destroyed<sp/>several<sp/>times<sp/>in<sp/>a<sp/>row.</highlight></codeline>
<codeline lineno="2986"><highlight class="comment">It<sp/>keeps<sp/>additional<sp/>+1<sp/>mapping<sp/>of<sp/>a<sp/>device<sp/>memory<sp/>block<sp/>to<sp/>prevent<sp/>calling<sp/>actual</highlight></codeline>
<codeline lineno="2987"><highlight class="comment">vkMapMemory/vkUnmapMemory<sp/>too<sp/>many<sp/>times,<sp/>which<sp/>may<sp/>improve<sp/>performance<sp/>and<sp/>help</highlight></codeline>
<codeline lineno="2988"><highlight class="comment">tools<sp/>like<sp/>RenderDOc.</highlight></codeline>
<codeline lineno="2989"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2990"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_MAPPING_HYSTERESIS_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2991"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#define<sp/>VMA_MAPPING_HYSTERESIS_ENABLED<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2992"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2993"><highlight class="normal"></highlight></codeline>
<codeline lineno="2994"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_CLASS_NO_COPY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2995"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#define<sp/>VMA_CLASS_NO_COPY(className)<sp/>\</highlight></codeline>
<codeline lineno="2996"><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>private:<sp/>\</highlight></codeline>
<codeline lineno="2997"><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>className(const<sp/>className&amp;)<sp/>=<sp/>delete;<sp/>\</highlight></codeline>
<codeline lineno="2998"><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>className&amp;<sp/>operator=(const<sp/>className&amp;)<sp/>=<sp/>delete;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2999"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3000"><highlight class="normal"></highlight></codeline>
<codeline lineno="3001"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>VMA_VALIDATE(cond)<sp/>do<sp/>{<sp/>if(!(cond))<sp/>{<sp/>\</highlight></codeline>
<codeline lineno="3002"><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/>&quot;Validation<sp/>failed:<sp/>&quot;</highlight><highlight class="normal"><sp/>#cond);<sp/>\</highlight></codeline>
<codeline lineno="3003"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>false;<sp/>\</highlight></codeline>
<codeline lineno="3004"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>}<sp/>while(false)</highlight></codeline>
<codeline lineno="3005"><highlight class="normal"></highlight></codeline>
<codeline lineno="3006"><highlight class="normal"></highlight><highlight class="comment">/*******************************************************************************</highlight></codeline>
<codeline lineno="3007"><highlight class="comment">END<sp/>OF<sp/>CONFIGURATION</highlight></codeline>
<codeline lineno="3008"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3009"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_CONFIGURATION</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3010"><highlight class="normal"></highlight></codeline>
<codeline lineno="3011"><highlight class="normal"></highlight></codeline>
<codeline lineno="3012"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint8_t<sp/>VMA_ALLOCATION_FILL_PATTERN_CREATED<sp/>=<sp/>0xDC;</highlight></codeline>
<codeline lineno="3013"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint8_t<sp/>VMA_ALLOCATION_FILL_PATTERN_DESTROYED<sp/>=<sp/>0xEF;</highlight></codeline>
<codeline lineno="3014"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Decimal<sp/>2139416166,<sp/>float<sp/>NaN,<sp/>little-endian<sp/>binary<sp/>66<sp/>E6<sp/>84<sp/>7F.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3015"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>VMA_CORRUPTION_DETECTION_MAGIC_VALUE<sp/>=<sp/>0x7F84E666;</highlight></codeline>
<codeline lineno="3016"><highlight class="normal"></highlight></codeline>
<codeline lineno="3017"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Copy<sp/>of<sp/>some<sp/>Vulkan<sp/>definitions<sp/>so<sp/>we<sp/>don&apos;t<sp/>need<sp/>to<sp/>check<sp/>their<sp/>existence<sp/>just<sp/>to<sp/>handle<sp/>few<sp/>constants.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3018"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD_COPY<sp/>=<sp/>0x00000040;</highlight></codeline>
<codeline lineno="3019"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD_COPY<sp/>=<sp/>0x00000080;</highlight></codeline>
<codeline lineno="3020"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_COPY<sp/>=<sp/>0x00020000;</highlight></codeline>
<codeline lineno="3021"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>VK_IMAGE_CREATE_DISJOINT_BIT_COPY<sp/>=<sp/>0x00000200;</highlight></codeline>
<codeline lineno="3022"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>int32_t<sp/>VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT_COPY<sp/>=<sp/>1000158000;</highlight></codeline>
<codeline lineno="3023"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>VMA_ALLOCATION_INTERNAL_STRATEGY_MIN_OFFSET<sp/>=<sp/>0x10000000u;</highlight></codeline>
<codeline lineno="3024"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>VMA_ALLOCATION_TRY_COUNT<sp/>=<sp/>32;</highlight></codeline>
<codeline lineno="3025"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>VMA_VENDOR_ID_AMD<sp/>=<sp/>4098;</highlight></codeline>
<codeline lineno="3026"><highlight class="normal"></highlight></codeline>
<codeline lineno="3027"><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>one<sp/>is<sp/>tricky.<sp/>Vulkan<sp/>specification<sp/>defines<sp/>this<sp/>code<sp/>as<sp/>available<sp/>since</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3028"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Vulkan<sp/>1.0,<sp/>but<sp/>doesn&apos;t<sp/>actually<sp/>define<sp/>it<sp/>in<sp/>Vulkan<sp/>SDK<sp/>earlier<sp/>than<sp/>1.2.131.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3029"><highlight class="normal"></highlight><highlight class="comment">//<sp/>See<sp/>pull<sp/>request<sp/>#207.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3030"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>VK_ERROR_UNKNOWN_COPY<sp/>((VkResult)-13)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3031"><highlight class="normal"></highlight></codeline>
<codeline lineno="3032"><highlight class="normal"></highlight></codeline>
<codeline lineno="3033"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3034"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Correspond<sp/>to<sp/>values<sp/>of<sp/>enum<sp/>VmaSuballocationType.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3035"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>VMA_SUBALLOCATION_TYPE_NAMES[]<sp/>=</highlight></codeline>
<codeline lineno="3036"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3037"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;FREE&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="3038"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;UNKNOWN&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="3039"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;BUFFER&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="3040"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;IMAGE_UNKNOWN&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="3041"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;IMAGE_LINEAR&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="3042"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;IMAGE_OPTIMAL&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="3043"><highlight class="normal">};</highlight></codeline>
<codeline lineno="3044"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3045"><highlight class="normal"></highlight></codeline>
<codeline lineno="3046"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>VkAllocationCallbacks<sp/>VmaEmptyAllocationCallbacks<sp/>=</highlight></codeline>
<codeline lineno="3047"><highlight class="normal"><sp/><sp/><sp/><sp/>{<sp/>VMA_NULL,<sp/>VMA_NULL,<sp/>VMA_NULL,<sp/>VMA_NULL,<sp/>VMA_NULL,<sp/>VMA_NULL<sp/>};</highlight></codeline>
<codeline lineno="3048"><highlight class="normal"></highlight></codeline>
<codeline lineno="3049"><highlight class="normal"></highlight></codeline>
<codeline lineno="3050"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_ENUM_DECLARATIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3051"><highlight class="normal"></highlight></codeline>
<codeline lineno="3052"><highlight class="normal"></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/>VmaSuballocationType</highlight></codeline>
<codeline lineno="3053"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3054"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_SUBALLOCATION_TYPE_FREE<sp/>=<sp/>0,</highlight></codeline>
<codeline lineno="3055"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_SUBALLOCATION_TYPE_UNKNOWN<sp/>=<sp/>1,</highlight></codeline>
<codeline lineno="3056"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_SUBALLOCATION_TYPE_BUFFER<sp/>=<sp/>2,</highlight></codeline>
<codeline lineno="3057"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_SUBALLOCATION_TYPE_IMAGE_UNKNOWN<sp/>=<sp/>3,</highlight></codeline>
<codeline lineno="3058"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_SUBALLOCATION_TYPE_IMAGE_LINEAR<sp/>=<sp/>4,</highlight></codeline>
<codeline lineno="3059"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL<sp/>=<sp/>5,</highlight></codeline>
<codeline lineno="3060"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_SUBALLOCATION_TYPE_MAX_ENUM<sp/>=<sp/>0x7FFFFFFF</highlight></codeline>
<codeline lineno="3061"><highlight class="normal">};</highlight></codeline>
<codeline lineno="3062"><highlight class="normal"></highlight></codeline>
<codeline lineno="3063"><highlight class="normal"></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/>VMA_CACHE_OPERATION</highlight></codeline>
<codeline lineno="3064"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3065"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_CACHE_FLUSH,</highlight></codeline>
<codeline lineno="3066"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_CACHE_INVALIDATE</highlight></codeline>
<codeline lineno="3067"><highlight class="normal">};</highlight></codeline>
<codeline lineno="3068"><highlight class="normal"></highlight></codeline>
<codeline lineno="3069"><highlight class="normal"></highlight><highlight class="keyword">enum<sp/>class</highlight><highlight class="normal"><sp/>VmaAllocationRequestType</highlight></codeline>
<codeline lineno="3070"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3071"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespace_catch_1af85c0d46dfe687d923a157362fd07737a960b44c579bc2f6818d2daaf9e4c16f0" kindref="member">Normal</ref>,</highlight></codeline>
<codeline lineno="3072"><highlight class="normal"><sp/><sp/><sp/><sp/>TLSF,</highlight></codeline>
<codeline lineno="3073"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Used<sp/>by<sp/>&quot;Linear&quot;<sp/>algorithm.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3074"><highlight class="normal"><sp/><sp/><sp/><sp/>UpperAddress,</highlight></codeline>
<codeline lineno="3075"><highlight class="normal"><sp/><sp/><sp/><sp/>EndOf1st,</highlight></codeline>
<codeline lineno="3076"><highlight class="normal"><sp/><sp/><sp/><sp/>EndOf2nd,</highlight></codeline>
<codeline lineno="3077"><highlight class="normal">};</highlight></codeline>
<codeline lineno="3078"><highlight class="normal"></highlight></codeline>
<codeline lineno="3079"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_ENUM_DECLARATIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3080"><highlight class="normal"></highlight></codeline>
<codeline lineno="3081"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_FORWARD_DECLARATIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3082"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Opaque<sp/>handle<sp/>used<sp/>by<sp/>allocation<sp/>algorithms<sp/>to<sp/>identify<sp/>single<sp/>allocation<sp/>in<sp/>any<sp/>conforming<sp/>way.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3083"><highlight class="normal"><ref refid="group__group__virtual_1ga565936f8d98d225b536a2d9703bc7676" kindref="member">VK_DEFINE_NON_DISPATCHABLE_HANDLE</ref>(VmaAllocHandle);</highlight></codeline>
<codeline lineno="3084"><highlight class="normal"></highlight></codeline>
<codeline lineno="3085"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaMutexLock;</highlight></codeline>
<codeline lineno="3086"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaMutexLockRead;</highlight></codeline>
<codeline lineno="3087"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaMutexLockWrite;</highlight></codeline>
<codeline lineno="3088"><highlight class="normal"></highlight></codeline>
<codeline lineno="3089"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="3090"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">AtomicTransactionalIncrement;</highlight></codeline>
<codeline lineno="3091"><highlight class="normal"></highlight></codeline>
<codeline lineno="3092"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="3093"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaStlAllocator;</highlight></codeline>
<codeline lineno="3094"><highlight class="normal"></highlight></codeline>
<codeline lineno="3095"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AllocatorT&gt;</highlight></codeline>
<codeline lineno="3096"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaVector;</highlight></codeline>
<codeline lineno="3097"><highlight class="normal"></highlight></codeline>
<codeline lineno="3098"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AllocatorT,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>N&gt;</highlight></codeline>
<codeline lineno="3099"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaSmallVector;</highlight></codeline>
<codeline lineno="3100"><highlight class="normal"></highlight></codeline>
<codeline lineno="3101"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="3102"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaPoolAllocator;</highlight></codeline>
<codeline lineno="3103"><highlight class="normal"></highlight></codeline>
<codeline lineno="3104"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="3105"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaListItem;</highlight></codeline>
<codeline lineno="3106"><highlight class="normal"></highlight></codeline>
<codeline lineno="3107"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="3108"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaRawList;</highlight></codeline>
<codeline lineno="3109"><highlight class="normal"></highlight></codeline>
<codeline lineno="3110"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AllocatorT&gt;</highlight></codeline>
<codeline lineno="3111"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaList;</highlight></codeline>
<codeline lineno="3112"><highlight class="normal"></highlight></codeline>
<codeline lineno="3113"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>ItemTypeTraits&gt;</highlight></codeline>
<codeline lineno="3114"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaIntrusiveLinkedList;</highlight></codeline>
<codeline lineno="3115"><highlight class="normal"></highlight></codeline>
<codeline lineno="3116"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Unused<sp/>in<sp/>this<sp/>version</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3117"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3118"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T1,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T2&gt;</highlight></codeline>
<codeline lineno="3119"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaPair;</highlight></codeline>
<codeline lineno="3120"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>FirstT,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>SecondT&gt;</highlight></codeline>
<codeline lineno="3121"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaPairFirstLess;</highlight></codeline>
<codeline lineno="3122"><highlight class="normal"></highlight></codeline>
<codeline lineno="3123"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>KeyT,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>ValueT&gt;</highlight></codeline>
<codeline lineno="3124"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaMap;</highlight></codeline>
<codeline lineno="3125"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3126"><highlight class="normal"></highlight></codeline>
<codeline lineno="3127"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3128"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaStringBuilder;</highlight></codeline>
<codeline lineno="3129"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaJsonWriter;</highlight></codeline>
<codeline lineno="3130"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3131"><highlight class="normal"></highlight></codeline>
<codeline lineno="3132"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaDeviceMemoryBlock;</highlight></codeline>
<codeline lineno="3133"><highlight class="normal"></highlight></codeline>
<codeline lineno="3134"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaDedicatedAllocationListItemTraits;</highlight></codeline>
<codeline lineno="3135"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaDedicatedAllocationList;</highlight></codeline>
<codeline lineno="3136"><highlight class="normal"></highlight></codeline>
<codeline lineno="3137"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaSuballocation;</highlight></codeline>
<codeline lineno="3138"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaSuballocationOffsetLess;</highlight></codeline>
<codeline lineno="3139"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaSuballocationOffsetGreater;</highlight></codeline>
<codeline lineno="3140"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaSuballocationItemSizeLess;</highlight></codeline>
<codeline lineno="3141"><highlight class="normal"></highlight></codeline>
<codeline lineno="3142"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VmaList&lt;VmaSuballocation,<sp/>VmaStlAllocator&lt;VmaSuballocation&gt;&gt;<sp/>VmaSuballocationList;</highlight></codeline>
<codeline lineno="3143"><highlight class="normal"></highlight></codeline>
<codeline lineno="3144"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaAllocationRequest;</highlight></codeline>
<codeline lineno="3145"><highlight class="normal"></highlight></codeline>
<codeline lineno="3146"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaBlockMetadata;</highlight></codeline>
<codeline lineno="3147"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaBlockMetadata_Linear;</highlight></codeline>
<codeline lineno="3148"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaBlockMetadata_TLSF;</highlight></codeline>
<codeline lineno="3149"><highlight class="normal"></highlight></codeline>
<codeline lineno="3150"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaBlockVector;</highlight></codeline>
<codeline lineno="3151"><highlight class="normal"></highlight></codeline>
<codeline lineno="3152"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaPoolListItemTraits;</highlight></codeline>
<codeline lineno="3153"><highlight class="normal"></highlight></codeline>
<codeline lineno="3154"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaCurrentBudgetData;</highlight></codeline>
<codeline lineno="3155"><highlight class="normal"></highlight></codeline>
<codeline lineno="3156"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaAllocationObjectAllocator;</highlight></codeline>
<codeline lineno="3157"><highlight class="normal"></highlight></codeline>
<codeline lineno="3158"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_FORWARD_DECLARATIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3159"><highlight class="normal"></highlight></codeline>
<codeline lineno="3160"><highlight class="normal"></highlight></codeline>
<codeline lineno="3161"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3162"><highlight class="normal"></highlight></codeline>
<codeline lineno="3163"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="3164"><highlight class="comment">Returns<sp/>number<sp/>of<sp/>bits<sp/>set<sp/>to<sp/>1<sp/>in<sp/>(v).</highlight></codeline>
<codeline lineno="3165"><highlight class="comment"></highlight></codeline>
<codeline lineno="3166"><highlight class="comment">On<sp/>specific<sp/>platforms<sp/>and<sp/>compilers<sp/>you<sp/>can<sp/>use<sp/>instrinsics<sp/>like:</highlight></codeline>
<codeline lineno="3167"><highlight class="comment"></highlight></codeline>
<codeline lineno="3168"><highlight class="comment">Visual<sp/>Studio:</highlight></codeline>
<codeline lineno="3169"><highlight class="comment"><sp/><sp/><sp/><sp/>return<sp/>__popcnt(v);</highlight></codeline>
<codeline lineno="3170"><highlight class="comment">GCC,<sp/>Clang:</highlight></codeline>
<codeline lineno="3171"><highlight class="comment"><sp/><sp/><sp/><sp/>return<sp/>static_cast&lt;uint32_t&gt;(__builtin_popcount(v));</highlight></codeline>
<codeline lineno="3172"><highlight class="comment"></highlight></codeline>
<codeline lineno="3173"><highlight class="comment">Define<sp/>macro<sp/>VMA_COUNT_BITS_SET<sp/>to<sp/>provide<sp/>your<sp/>optimized<sp/>implementation.</highlight></codeline>
<codeline lineno="3174"><highlight class="comment">But<sp/>you<sp/>need<sp/>to<sp/>check<sp/>in<sp/>runtime<sp/>whether<sp/>user&apos;s<sp/>CPU<sp/>supports<sp/>these,<sp/>as<sp/>some<sp/>old<sp/>processors<sp/>don&apos;t.</highlight></codeline>
<codeline lineno="3175"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3176"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>uint32_t<sp/>VmaCountBitsSet(uint32_t<sp/>v)</highlight></codeline>
<codeline lineno="3177"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3178"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>c<sp/>=<sp/>v<sp/>-<sp/>((v<sp/>&gt;&gt;<sp/>1)<sp/>&amp;<sp/>0x55555555);</highlight></codeline>
<codeline lineno="3179"><highlight class="normal"><sp/><sp/><sp/><sp/>c<sp/>=<sp/>((c<sp/>&gt;&gt;<sp/>2)<sp/>&amp;<sp/>0x33333333)<sp/>+<sp/>(c<sp/>&amp;<sp/>0x33333333);</highlight></codeline>
<codeline lineno="3180"><highlight class="normal"><sp/><sp/><sp/><sp/>c<sp/>=<sp/>((c<sp/>&gt;&gt;<sp/>4)<sp/>+<sp/>c)<sp/>&amp;<sp/>0x0F0F0F0F;</highlight></codeline>
<codeline lineno="3181"><highlight class="normal"><sp/><sp/><sp/><sp/>c<sp/>=<sp/>((c<sp/>&gt;&gt;<sp/>8)<sp/>+<sp/>c)<sp/>&amp;<sp/>0x00FF00FF;</highlight></codeline>
<codeline lineno="3182"><highlight class="normal"><sp/><sp/><sp/><sp/>c<sp/>=<sp/>((c<sp/>&gt;&gt;<sp/>16)<sp/>+<sp/>c)<sp/>&amp;<sp/>0x0000FFFF;</highlight></codeline>
<codeline lineno="3183"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>c;</highlight></codeline>
<codeline lineno="3184"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3185"><highlight class="normal"></highlight></codeline>
<codeline lineno="3186"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>uint8_t<sp/>VmaBitScanLSB(uint64_t<sp/>mask)</highlight></codeline>
<codeline lineno="3187"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3188"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>defined(_MSC_VER)<sp/>&amp;&amp;<sp/>defined(_WIN64)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3189"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/>pos;</highlight></codeline>
<codeline lineno="3190"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(_BitScanForward64(&amp;pos,<sp/>mask))</highlight></codeline>
<codeline lineno="3191"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">uint8_t</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(pos);</highlight></codeline>
<codeline lineno="3192"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>UINT8_MAX;</highlight></codeline>
<codeline lineno="3193"><highlight class="normal"></highlight><highlight class="preprocessor">#elif<sp/>defined<sp/>__GNUC__<sp/>||<sp/>defined<sp/>__clang__</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3194"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">uint8_t</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(__builtin_ffsll(mask))<sp/>-<sp/>1U;</highlight></codeline>
<codeline lineno="3195"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3196"><highlight class="normal"><sp/><sp/><sp/><sp/>uint8_t<sp/>pos<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="3197"><highlight class="normal"><sp/><sp/><sp/><sp/>uint64_t<sp/>bit<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="3198"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3199"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(mask<sp/>&amp;<sp/>bit)</highlight></codeline>
<codeline lineno="3201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>pos;</highlight></codeline>
<codeline lineno="3202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bit<sp/>&lt;&lt;=<sp/>1;</highlight></codeline>
<codeline lineno="3203"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(pos++<sp/>&lt;<sp/>63);</highlight></codeline>
<codeline lineno="3204"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>UINT8_MAX;</highlight></codeline>
<codeline lineno="3205"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3206"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3207"><highlight class="normal"></highlight></codeline>
<codeline lineno="3208"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>uint8_t<sp/>VmaBitScanLSB(uint32_t<sp/>mask)</highlight></codeline>
<codeline lineno="3209"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3210"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>_MSC_VER</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3211"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/>pos;</highlight></codeline>
<codeline lineno="3212"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(_BitScanForward(&amp;pos,<sp/>mask))</highlight></codeline>
<codeline lineno="3213"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">uint8_t</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(pos);</highlight></codeline>
<codeline lineno="3214"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>UINT8_MAX;</highlight></codeline>
<codeline lineno="3215"><highlight class="normal"></highlight><highlight class="preprocessor">#elif<sp/>defined<sp/>__GNUC__<sp/>||<sp/>defined<sp/>__clang__</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3216"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">uint8_t</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(__builtin_ffs(mask))<sp/>-<sp/>1U;</highlight></codeline>
<codeline lineno="3217"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3218"><highlight class="normal"><sp/><sp/><sp/><sp/>uint8_t<sp/>pos<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="3219"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>bit<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="3220"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3221"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3222"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(mask<sp/>&amp;<sp/>bit)</highlight></codeline>
<codeline lineno="3223"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>pos;</highlight></codeline>
<codeline lineno="3224"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bit<sp/>&lt;&lt;=<sp/>1;</highlight></codeline>
<codeline lineno="3225"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(pos++<sp/>&lt;<sp/>31);</highlight></codeline>
<codeline lineno="3226"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>UINT8_MAX;</highlight></codeline>
<codeline lineno="3227"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3228"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3229"><highlight class="normal"></highlight></codeline>
<codeline lineno="3230"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>uint8_t<sp/>VmaBitScanMSB(uint64_t<sp/>mask)</highlight></codeline>
<codeline lineno="3231"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3232"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>defined(_MSC_VER)<sp/>&amp;&amp;<sp/>defined(_WIN64)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3233"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/>pos;</highlight></codeline>
<codeline lineno="3234"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(_BitScanReverse64(&amp;pos,<sp/>mask))</highlight></codeline>
<codeline lineno="3235"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">uint8_t</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(pos);</highlight></codeline>
<codeline lineno="3236"><highlight class="normal"></highlight><highlight class="preprocessor">#elif<sp/>defined<sp/>__GNUC__<sp/>||<sp/>defined<sp/>__clang__</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3237"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(mask)</highlight></codeline>
<codeline lineno="3238"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>63<sp/>-<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">uint8_t</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(__builtin_clzll(mask));</highlight></codeline>
<codeline lineno="3239"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3240"><highlight class="normal"><sp/><sp/><sp/><sp/>uint8_t<sp/>pos<sp/>=<sp/>63;</highlight></codeline>
<codeline lineno="3241"><highlight class="normal"><sp/><sp/><sp/><sp/>uint64_t<sp/>bit<sp/>=<sp/>1ULL<sp/>&lt;&lt;<sp/>63;</highlight></codeline>
<codeline lineno="3242"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3243"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3244"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(mask<sp/>&amp;<sp/>bit)</highlight></codeline>
<codeline lineno="3245"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>pos;</highlight></codeline>
<codeline lineno="3246"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bit<sp/>&gt;&gt;=<sp/>1;</highlight></codeline>
<codeline lineno="3247"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(pos--<sp/>&gt;<sp/>0);</highlight></codeline>
<codeline lineno="3248"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3249"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>UINT8_MAX;</highlight></codeline>
<codeline lineno="3250"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3251"><highlight class="normal"></highlight></codeline>
<codeline lineno="3252"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>uint8_t<sp/>VmaBitScanMSB(uint32_t<sp/>mask)</highlight></codeline>
<codeline lineno="3253"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3254"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>_MSC_VER</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3255"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/>pos;</highlight></codeline>
<codeline lineno="3256"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(_BitScanReverse(&amp;pos,<sp/>mask))</highlight></codeline>
<codeline lineno="3257"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">uint8_t</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(pos);</highlight></codeline>
<codeline lineno="3258"><highlight class="normal"></highlight><highlight class="preprocessor">#elif<sp/>defined<sp/>__GNUC__<sp/>||<sp/>defined<sp/>__clang__</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3259"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(mask)</highlight></codeline>
<codeline lineno="3260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>31<sp/>-<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">uint8_t</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(__builtin_clz(mask));</highlight></codeline>
<codeline lineno="3261"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3262"><highlight class="normal"><sp/><sp/><sp/><sp/>uint8_t<sp/>pos<sp/>=<sp/>31;</highlight></codeline>
<codeline lineno="3263"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>bit<sp/>=<sp/>1UL<sp/>&lt;&lt;<sp/>31;</highlight></codeline>
<codeline lineno="3264"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3265"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3266"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(mask<sp/>&amp;<sp/>bit)</highlight></codeline>
<codeline lineno="3267"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>pos;</highlight></codeline>
<codeline lineno="3268"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bit<sp/>&gt;&gt;=<sp/>1;</highlight></codeline>
<codeline lineno="3269"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(pos--<sp/>&gt;<sp/>0);</highlight></codeline>
<codeline lineno="3270"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3271"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>UINT8_MAX;</highlight></codeline>
<codeline lineno="3272"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3273"><highlight class="normal"></highlight></codeline>
<codeline lineno="3274"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="3275"><highlight class="comment">Returns<sp/>true<sp/>if<sp/>given<sp/>number<sp/>is<sp/>a<sp/>power<sp/>of<sp/>two.</highlight></codeline>
<codeline lineno="3276"><highlight class="comment">T<sp/>must<sp/>be<sp/>unsigned<sp/>integer<sp/>number<sp/>or<sp/>signed<sp/>integer<sp/>but<sp/>always<sp/>nonnegative.</highlight></codeline>
<codeline lineno="3277"><highlight class="comment">For<sp/>0<sp/>returns<sp/>true.</highlight></codeline>
<codeline lineno="3278"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3279"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="3280"><highlight class="normal"></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaIsPow2(T<sp/>x)</highlight></codeline>
<codeline lineno="3281"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3282"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(x<sp/>&amp;<sp/>(x<sp/>-<sp/>1))<sp/>==<sp/>0;</highlight></codeline>
<codeline lineno="3283"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3284"><highlight class="normal"></highlight></codeline>
<codeline lineno="3285"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Aligns<sp/>given<sp/>value<sp/>up<sp/>to<sp/>nearest<sp/>multiply<sp/>of<sp/>align<sp/>value.<sp/>For<sp/>example:<sp/>VmaAlignUp(11,<sp/>8)<sp/>=<sp/>16.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3286"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Use<sp/>types<sp/>like<sp/>uint32_t,<sp/>uint64_t<sp/>as<sp/>T.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3287"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="3288"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>T<sp/>VmaAlignUp(T<sp/>val,<sp/>T<sp/>alignment)</highlight></codeline>
<codeline lineno="3289"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3290"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(VmaIsPow2(alignment));</highlight></codeline>
<codeline lineno="3291"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(val<sp/>+<sp/>alignment<sp/>-<sp/>1)<sp/>&amp;<sp/>~(alignment<sp/>-<sp/>1);</highlight></codeline>
<codeline lineno="3292"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3293"><highlight class="normal"></highlight></codeline>
<codeline lineno="3294"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Aligns<sp/>given<sp/>value<sp/>down<sp/>to<sp/>nearest<sp/>multiply<sp/>of<sp/>align<sp/>value.<sp/>For<sp/>example:<sp/>VmaAlignUp(11,<sp/>8)<sp/>=<sp/>8.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3295"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Use<sp/>types<sp/>like<sp/>uint32_t,<sp/>uint64_t<sp/>as<sp/>T.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3296"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="3297"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>T<sp/>VmaAlignDown(T<sp/>val,<sp/>T<sp/>alignment)</highlight></codeline>
<codeline lineno="3298"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3299"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(VmaIsPow2(alignment));</highlight></codeline>
<codeline lineno="3300"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>val<sp/>&amp;<sp/>~(alignment<sp/>-<sp/>1);</highlight></codeline>
<codeline lineno="3301"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3302"><highlight class="normal"></highlight></codeline>
<codeline lineno="3303"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Division<sp/>with<sp/>mathematical<sp/>rounding<sp/>to<sp/>nearest<sp/>number.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3304"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="3305"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>T<sp/>VmaRoundDiv(T<sp/>x,<sp/>T<sp/>y)</highlight></codeline>
<codeline lineno="3306"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3307"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(x<sp/>+<sp/>(y<sp/>/<sp/>(T)2))<sp/>/<sp/>y;</highlight></codeline>
<codeline lineno="3308"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3309"><highlight class="normal"></highlight></codeline>
<codeline lineno="3310"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Divide<sp/>by<sp/>&apos;y&apos;<sp/>and<sp/>round<sp/>up<sp/>to<sp/>nearest<sp/>integer.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3311"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="3312"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>T<sp/>VmaDivideRoundingUp(T<sp/>x,<sp/>T<sp/>y)</highlight></codeline>
<codeline lineno="3313"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3314"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(x<sp/>+<sp/>y<sp/>-<sp/>(T)1)<sp/>/<sp/>y;</highlight></codeline>
<codeline lineno="3315"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3316"><highlight class="normal"></highlight></codeline>
<codeline lineno="3317"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>smallest<sp/>power<sp/>of<sp/>2<sp/>greater<sp/>or<sp/>equal<sp/>to<sp/>v.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3318"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>uint32_t<sp/>VmaNextPow2(uint32_t<sp/>v)</highlight></codeline>
<codeline lineno="3319"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3320"><highlight class="normal"><sp/><sp/><sp/><sp/>v--;</highlight></codeline>
<codeline lineno="3321"><highlight class="normal"><sp/><sp/><sp/><sp/>v<sp/>|=<sp/>v<sp/>&gt;&gt;<sp/>1;</highlight></codeline>
<codeline lineno="3322"><highlight class="normal"><sp/><sp/><sp/><sp/>v<sp/>|=<sp/>v<sp/>&gt;&gt;<sp/>2;</highlight></codeline>
<codeline lineno="3323"><highlight class="normal"><sp/><sp/><sp/><sp/>v<sp/>|=<sp/>v<sp/>&gt;&gt;<sp/>4;</highlight></codeline>
<codeline lineno="3324"><highlight class="normal"><sp/><sp/><sp/><sp/>v<sp/>|=<sp/>v<sp/>&gt;&gt;<sp/>8;</highlight></codeline>
<codeline lineno="3325"><highlight class="normal"><sp/><sp/><sp/><sp/>v<sp/>|=<sp/>v<sp/>&gt;&gt;<sp/>16;</highlight></codeline>
<codeline lineno="3326"><highlight class="normal"><sp/><sp/><sp/><sp/>v++;</highlight></codeline>
<codeline lineno="3327"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>v;</highlight></codeline>
<codeline lineno="3328"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3329"><highlight class="normal"></highlight></codeline>
<codeline lineno="3330"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>uint64_t<sp/>VmaNextPow2(uint64_t<sp/>v)</highlight></codeline>
<codeline lineno="3331"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3332"><highlight class="normal"><sp/><sp/><sp/><sp/>v--;</highlight></codeline>
<codeline lineno="3333"><highlight class="normal"><sp/><sp/><sp/><sp/>v<sp/>|=<sp/>v<sp/>&gt;&gt;<sp/>1;</highlight></codeline>
<codeline lineno="3334"><highlight class="normal"><sp/><sp/><sp/><sp/>v<sp/>|=<sp/>v<sp/>&gt;&gt;<sp/>2;</highlight></codeline>
<codeline lineno="3335"><highlight class="normal"><sp/><sp/><sp/><sp/>v<sp/>|=<sp/>v<sp/>&gt;&gt;<sp/>4;</highlight></codeline>
<codeline lineno="3336"><highlight class="normal"><sp/><sp/><sp/><sp/>v<sp/>|=<sp/>v<sp/>&gt;&gt;<sp/>8;</highlight></codeline>
<codeline lineno="3337"><highlight class="normal"><sp/><sp/><sp/><sp/>v<sp/>|=<sp/>v<sp/>&gt;&gt;<sp/>16;</highlight></codeline>
<codeline lineno="3338"><highlight class="normal"><sp/><sp/><sp/><sp/>v<sp/>|=<sp/>v<sp/>&gt;&gt;<sp/>32;</highlight></codeline>
<codeline lineno="3339"><highlight class="normal"><sp/><sp/><sp/><sp/>v++;</highlight></codeline>
<codeline lineno="3340"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>v;</highlight></codeline>
<codeline lineno="3341"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3342"><highlight class="normal"></highlight></codeline>
<codeline lineno="3343"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>largest<sp/>power<sp/>of<sp/>2<sp/>less<sp/>or<sp/>equal<sp/>to<sp/>v.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3344"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>uint32_t<sp/>VmaPrevPow2(uint32_t<sp/>v)</highlight></codeline>
<codeline lineno="3345"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3346"><highlight class="normal"><sp/><sp/><sp/><sp/>v<sp/>|=<sp/>v<sp/>&gt;&gt;<sp/>1;</highlight></codeline>
<codeline lineno="3347"><highlight class="normal"><sp/><sp/><sp/><sp/>v<sp/>|=<sp/>v<sp/>&gt;&gt;<sp/>2;</highlight></codeline>
<codeline lineno="3348"><highlight class="normal"><sp/><sp/><sp/><sp/>v<sp/>|=<sp/>v<sp/>&gt;&gt;<sp/>4;</highlight></codeline>
<codeline lineno="3349"><highlight class="normal"><sp/><sp/><sp/><sp/>v<sp/>|=<sp/>v<sp/>&gt;&gt;<sp/>8;</highlight></codeline>
<codeline lineno="3350"><highlight class="normal"><sp/><sp/><sp/><sp/>v<sp/>|=<sp/>v<sp/>&gt;&gt;<sp/>16;</highlight></codeline>
<codeline lineno="3351"><highlight class="normal"><sp/><sp/><sp/><sp/>v<sp/>=<sp/>v<sp/>^<sp/>(v<sp/>&gt;&gt;<sp/>1);</highlight></codeline>
<codeline lineno="3352"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>v;</highlight></codeline>
<codeline lineno="3353"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3354"><highlight class="normal"></highlight></codeline>
<codeline lineno="3355"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>uint64_t<sp/>VmaPrevPow2(uint64_t<sp/>v)</highlight></codeline>
<codeline lineno="3356"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3357"><highlight class="normal"><sp/><sp/><sp/><sp/>v<sp/>|=<sp/>v<sp/>&gt;&gt;<sp/>1;</highlight></codeline>
<codeline lineno="3358"><highlight class="normal"><sp/><sp/><sp/><sp/>v<sp/>|=<sp/>v<sp/>&gt;&gt;<sp/>2;</highlight></codeline>
<codeline lineno="3359"><highlight class="normal"><sp/><sp/><sp/><sp/>v<sp/>|=<sp/>v<sp/>&gt;&gt;<sp/>4;</highlight></codeline>
<codeline lineno="3360"><highlight class="normal"><sp/><sp/><sp/><sp/>v<sp/>|=<sp/>v<sp/>&gt;&gt;<sp/>8;</highlight></codeline>
<codeline lineno="3361"><highlight class="normal"><sp/><sp/><sp/><sp/>v<sp/>|=<sp/>v<sp/>&gt;&gt;<sp/>16;</highlight></codeline>
<codeline lineno="3362"><highlight class="normal"><sp/><sp/><sp/><sp/>v<sp/>|=<sp/>v<sp/>&gt;&gt;<sp/>32;</highlight></codeline>
<codeline lineno="3363"><highlight class="normal"><sp/><sp/><sp/><sp/>v<sp/>=<sp/>v<sp/>^<sp/>(v<sp/>&gt;&gt;<sp/>1);</highlight></codeline>
<codeline lineno="3364"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>v;</highlight></codeline>
<codeline lineno="3365"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3366"><highlight class="normal"></highlight></codeline>
<codeline lineno="3367"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaStrIsEmpty(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>pStr)</highlight></codeline>
<codeline lineno="3368"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3369"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>pStr<sp/>==<sp/>VMA_NULL<sp/>||<sp/>*pStr<sp/>==<sp/></highlight><highlight class="charliteral">&apos;\0&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="3370"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3371"><highlight class="normal"></highlight></codeline>
<codeline lineno="3372"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3373"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>VmaAlgorithmToStr(uint32_t<sp/>algorithm)</highlight></codeline>
<codeline lineno="3374"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3375"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(algorithm)</highlight></codeline>
<codeline lineno="3376"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3377"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726" kindref="member">VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</ref>:</highlight></codeline>
<codeline lineno="3378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="stringliteral">&quot;Linear&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="3379"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>0:</highlight></codeline>
<codeline lineno="3380"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="stringliteral">&quot;TLSF&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="3381"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="3382"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="3383"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="stringliteral">&quot;&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="3384"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3385"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3386"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3387"><highlight class="normal"></highlight></codeline>
<codeline lineno="3388"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>VMA_SORT</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3389"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Iterator,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Compare&gt;</highlight></codeline>
<codeline lineno="3390"><highlight class="normal">Iterator<sp/>VmaQuickSortPartition(Iterator<sp/>beg,<sp/>Iterator<sp/>end,<sp/>Compare<sp/>cmp)</highlight></codeline>
<codeline lineno="3391"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3392"><highlight class="normal"><sp/><sp/><sp/><sp/>Iterator<sp/>centerValue<sp/>=<sp/>end;<sp/>--centerValue;</highlight></codeline>
<codeline lineno="3393"><highlight class="normal"><sp/><sp/><sp/><sp/>Iterator<sp/>insertIndex<sp/>=<sp/>beg;</highlight></codeline>
<codeline lineno="3394"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(Iterator<sp/>memTypeIndex<sp/>=<sp/>beg;<sp/>memTypeIndex<sp/>&lt;<sp/>centerValue;<sp/>++memTypeIndex)</highlight></codeline>
<codeline lineno="3395"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3396"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(cmp(*memTypeIndex,<sp/>*centerValue))</highlight></codeline>
<codeline lineno="3397"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3398"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(insertIndex<sp/>!=<sp/>memTypeIndex)</highlight></codeline>
<codeline lineno="3399"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3400"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_SWAP(*memTypeIndex,<sp/>*insertIndex);</highlight></codeline>
<codeline lineno="3401"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3402"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++insertIndex;</highlight></codeline>
<codeline lineno="3403"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3404"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3405"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(insertIndex<sp/>!=<sp/>centerValue)</highlight></codeline>
<codeline lineno="3406"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3407"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_SWAP(*insertIndex,<sp/>*centerValue);</highlight></codeline>
<codeline lineno="3408"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3409"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>insertIndex;</highlight></codeline>
<codeline lineno="3410"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3411"><highlight class="normal"></highlight></codeline>
<codeline lineno="3412"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Iterator,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Compare&gt;</highlight></codeline>
<codeline lineno="3413"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaQuickSort(Iterator<sp/>beg,<sp/>Iterator<sp/>end,<sp/>Compare<sp/>cmp)</highlight></codeline>
<codeline lineno="3414"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3415"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(beg<sp/>&lt;<sp/>end)</highlight></codeline>
<codeline lineno="3416"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3417"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Iterator<sp/>it<sp/>=<sp/>VmaQuickSortPartition&lt;Iterator,<sp/>Compare&gt;(beg,<sp/>end,<sp/>cmp);</highlight></codeline>
<codeline lineno="3418"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaQuickSort&lt;Iterator,<sp/>Compare&gt;(beg,<sp/>it,<sp/>cmp);</highlight></codeline>
<codeline lineno="3419"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaQuickSort&lt;Iterator,<sp/>Compare&gt;(it<sp/>+<sp/>1,<sp/>end,<sp/>cmp);</highlight></codeline>
<codeline lineno="3420"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3421"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3422"><highlight class="normal"></highlight></codeline>
<codeline lineno="3423"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>VMA_SORT(beg,<sp/>end,<sp/>cmp)<sp/>VmaQuickSort(beg,<sp/>end,<sp/>cmp)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3424"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>VMA_SORT</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3425"><highlight class="normal"></highlight></codeline>
<codeline lineno="3426"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="3427"><highlight class="comment">Returns<sp/>true<sp/>if<sp/>two<sp/>memory<sp/>blocks<sp/>occupy<sp/>overlapping<sp/>pages.</highlight></codeline>
<codeline lineno="3428"><highlight class="comment">ResourceA<sp/>must<sp/>be<sp/>in<sp/>less<sp/>memory<sp/>offset<sp/>than<sp/>ResourceB.</highlight></codeline>
<codeline lineno="3429"><highlight class="comment"></highlight></codeline>
<codeline lineno="3430"><highlight class="comment">Algorithm<sp/>is<sp/>based<sp/>on<sp/>&quot;Vulkan<sp/>1.0.39<sp/>-<sp/>A<sp/>Specification<sp/>(with<sp/>all<sp/>registered<sp/>Vulkan<sp/>extensions)&quot;</highlight></codeline>
<codeline lineno="3431"><highlight class="comment">chapter<sp/>11.6<sp/>&quot;Resource<sp/>Memory<sp/>Association&quot;,<sp/>paragraph<sp/>&quot;Buffer-Image<sp/>Granularity&quot;.</highlight></codeline>
<codeline lineno="3432"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3433"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaBlocksOnSamePage(</highlight></codeline>
<codeline lineno="3434"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>resourceAOffset,</highlight></codeline>
<codeline lineno="3435"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>resourceASize,</highlight></codeline>
<codeline lineno="3436"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>resourceBOffset,</highlight></codeline>
<codeline lineno="3437"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>pageSize)</highlight></codeline>
<codeline lineno="3438"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3439"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(resourceAOffset<sp/>+<sp/>resourceASize<sp/>&lt;=<sp/>resourceBOffset<sp/>&amp;&amp;<sp/>resourceASize<sp/>&gt;<sp/>0<sp/>&amp;&amp;<sp/>pageSize<sp/>&gt;<sp/>0);</highlight></codeline>
<codeline lineno="3440"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>resourceAEnd<sp/>=<sp/>resourceAOffset<sp/>+<sp/>resourceASize<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="3441"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>resourceAEndPage<sp/>=<sp/>resourceAEnd<sp/>&amp;<sp/>~(pageSize<sp/>-<sp/>1);</highlight></codeline>
<codeline lineno="3442"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>resourceBStart<sp/>=<sp/>resourceBOffset;</highlight></codeline>
<codeline lineno="3443"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>resourceBStartPage<sp/>=<sp/>resourceBStart<sp/>&amp;<sp/>~(pageSize<sp/>-<sp/>1);</highlight></codeline>
<codeline lineno="3444"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>resourceAEndPage<sp/>==<sp/>resourceBStartPage;</highlight></codeline>
<codeline lineno="3445"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3446"><highlight class="normal"></highlight></codeline>
<codeline lineno="3447"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="3448"><highlight class="comment">Returns<sp/>true<sp/>if<sp/>given<sp/>suballocation<sp/>types<sp/>could<sp/>conflict<sp/>and<sp/>must<sp/>respect</highlight></codeline>
<codeline lineno="3449"><highlight class="comment">VkPhysicalDeviceLimits::bufferImageGranularity.<sp/>They<sp/>conflict<sp/>if<sp/>one<sp/>is<sp/>buffer</highlight></codeline>
<codeline lineno="3450"><highlight class="comment">or<sp/>linear<sp/>image<sp/>and<sp/>another<sp/>one<sp/>is<sp/>optimal<sp/>image.<sp/>If<sp/>type<sp/>is<sp/>unknown,<sp/>behave</highlight></codeline>
<codeline lineno="3451"><highlight class="comment">conservatively.</highlight></codeline>
<codeline lineno="3452"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3453"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaIsBufferImageGranularityConflict(</highlight></codeline>
<codeline lineno="3454"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>suballocType1,</highlight></codeline>
<codeline lineno="3455"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>suballocType2)</highlight></codeline>
<codeline lineno="3456"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3457"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(suballocType1<sp/>&gt;<sp/>suballocType2)</highlight></codeline>
<codeline lineno="3458"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3459"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_SWAP(suballocType1,<sp/>suballocType2);</highlight></codeline>
<codeline lineno="3460"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3461"><highlight class="normal"></highlight></codeline>
<codeline lineno="3462"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(suballocType1)</highlight></codeline>
<codeline lineno="3463"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3464"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VMA_SUBALLOCATION_TYPE_FREE:</highlight></codeline>
<codeline lineno="3465"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="3466"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VMA_SUBALLOCATION_TYPE_UNKNOWN:</highlight></codeline>
<codeline lineno="3467"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="3468"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VMA_SUBALLOCATION_TYPE_BUFFER:</highlight></codeline>
<codeline lineno="3469"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3470"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocType2<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_IMAGE_UNKNOWN<sp/>||</highlight></codeline>
<codeline lineno="3471"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocType2<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL;</highlight></codeline>
<codeline lineno="3472"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VMA_SUBALLOCATION_TYPE_IMAGE_UNKNOWN:</highlight></codeline>
<codeline lineno="3473"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3474"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocType2<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_IMAGE_UNKNOWN<sp/>||</highlight></codeline>
<codeline lineno="3475"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocType2<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_IMAGE_LINEAR<sp/>||</highlight></codeline>
<codeline lineno="3476"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocType2<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL;</highlight></codeline>
<codeline lineno="3477"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VMA_SUBALLOCATION_TYPE_IMAGE_LINEAR:</highlight></codeline>
<codeline lineno="3478"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3479"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocType2<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL;</highlight></codeline>
<codeline lineno="3480"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL:</highlight></codeline>
<codeline lineno="3481"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="3482"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="3483"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="3484"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="3485"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3486"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3487"><highlight class="normal"></highlight></codeline>
<codeline lineno="3488"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaWriteMagicValue(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pData,<sp/>VkDeviceSize<sp/>offset)</highlight></codeline>
<codeline lineno="3489"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3490"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_DEBUG_MARGIN<sp/>&gt;<sp/>0<sp/>&amp;&amp;<sp/>VMA_DEBUG_DETECT_CORRUPTION</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3491"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t*<sp/>pDst<sp/>=<sp/>(uint32_t*)((</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*)pData<sp/>+<sp/>offset);</highlight></codeline>
<codeline lineno="3492"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>numberCount<sp/>=<sp/>VMA_DEBUG_MARGIN<sp/>/<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(uint32_t);</highlight></codeline>
<codeline lineno="3493"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>numberCount;<sp/>++i,<sp/>++pDst)</highlight></codeline>
<codeline lineno="3494"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3495"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pDst<sp/>=<sp/>VMA_CORRUPTION_DETECTION_MAGIC_VALUE;</highlight></codeline>
<codeline lineno="3496"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3497"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3498"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>no-op</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3499"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3500"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3501"><highlight class="normal"></highlight></codeline>
<codeline lineno="3502"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaValidateMagicValue(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pData,<sp/>VkDeviceSize<sp/>offset)</highlight></codeline>
<codeline lineno="3503"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3504"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_DEBUG_MARGIN<sp/>&gt;<sp/>0<sp/>&amp;&amp;<sp/>VMA_DEBUG_DETECT_CORRUPTION</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3505"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t*<sp/>pSrc<sp/>=<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t*)((</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*)pData<sp/>+<sp/>offset);</highlight></codeline>
<codeline lineno="3506"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>numberCount<sp/>=<sp/>VMA_DEBUG_MARGIN<sp/>/<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(uint32_t);</highlight></codeline>
<codeline lineno="3507"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>numberCount;<sp/>++i,<sp/>++pSrc)</highlight></codeline>
<codeline lineno="3508"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3509"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(*pSrc<sp/>!=<sp/>VMA_CORRUPTION_DETECTION_MAGIC_VALUE)</highlight></codeline>
<codeline lineno="3510"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3511"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="3512"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3513"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3514"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3515"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="3516"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3517"><highlight class="normal"></highlight></codeline>
<codeline lineno="3518"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="3519"><highlight class="comment">Fills<sp/>structure<sp/>with<sp/>parameters<sp/>of<sp/>an<sp/>example<sp/>buffer<sp/>to<sp/>be<sp/>used<sp/>for<sp/>transfers</highlight></codeline>
<codeline lineno="3520"><highlight class="comment">during<sp/>GPU<sp/>memory<sp/>defragmentation.</highlight></codeline>
<codeline lineno="3521"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3522"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaFillGpuDefragmentationBufferCreateInfo(VkBufferCreateInfo&amp;<sp/>outBufCreateInfo)</highlight></codeline>
<codeline lineno="3523"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3524"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(&amp;outBufCreateInfo,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(outBufCreateInfo));</highlight></codeline>
<codeline lineno="3525"><highlight class="normal"><sp/><sp/><sp/><sp/>outBufCreateInfo.sType<sp/>=<sp/>VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;</highlight></codeline>
<codeline lineno="3526"><highlight class="normal"><sp/><sp/><sp/><sp/>outBufCreateInfo.usage<sp/>=<sp/>VK_BUFFER_USAGE_TRANSFER_SRC_BIT<sp/>|<sp/>VK_BUFFER_USAGE_TRANSFER_DST_BIT;</highlight></codeline>
<codeline lineno="3527"><highlight class="normal"><sp/><sp/><sp/><sp/>outBufCreateInfo.size<sp/>=<sp/>(VkDeviceSize)VMA_DEFAULT_LARGE_HEAP_BLOCK_SIZE;<sp/></highlight><highlight class="comment">//<sp/>Example<sp/>size.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3528"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3529"><highlight class="normal"></highlight></codeline>
<codeline lineno="3530"><highlight class="normal"></highlight></codeline>
<codeline lineno="3531"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="3532"><highlight class="comment">Performs<sp/>binary<sp/>search<sp/>and<sp/>returns<sp/>iterator<sp/>to<sp/>first<sp/>element<sp/>that<sp/>is<sp/>greater<sp/>or</highlight></codeline>
<codeline lineno="3533"><highlight class="comment">equal<sp/>to<sp/>(key),<sp/>according<sp/>to<sp/>comparison<sp/>(cmp).</highlight></codeline>
<codeline lineno="3534"><highlight class="comment"></highlight></codeline>
<codeline lineno="3535"><highlight class="comment">Cmp<sp/>should<sp/>return<sp/>true<sp/>if<sp/>first<sp/>argument<sp/>is<sp/>less<sp/>than<sp/>second<sp/>argument.</highlight></codeline>
<codeline lineno="3536"><highlight class="comment"></highlight></codeline>
<codeline lineno="3537"><highlight class="comment">Returned<sp/>value<sp/>is<sp/>the<sp/>found<sp/>element,<sp/>if<sp/>present<sp/>in<sp/>the<sp/>collection<sp/>or<sp/>place<sp/>where</highlight></codeline>
<codeline lineno="3538"><highlight class="comment">new<sp/>element<sp/>with<sp/>value<sp/>(key)<sp/>should<sp/>be<sp/>inserted.</highlight></codeline>
<codeline lineno="3539"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3540"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>CmpLess,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>IterT,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>KeyT&gt;</highlight></codeline>
<codeline lineno="3541"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>IterT<sp/>VmaBinaryFindFirstNotLess(IterT<sp/>beg,<sp/>IterT<sp/>end,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>KeyT&amp;<sp/>key,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>CmpLess&amp;<sp/>cmp)</highlight></codeline>
<codeline lineno="3542"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3543"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>down<sp/>=<sp/>0,<sp/>up<sp/>=<sp/>(end<sp/>-<sp/>beg);</highlight></codeline>
<codeline lineno="3544"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(down<sp/>&lt;<sp/>up)</highlight></codeline>
<codeline lineno="3545"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3546"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>mid<sp/>=<sp/>down<sp/>+<sp/>(up<sp/>-<sp/>down)<sp/>/<sp/>2;<sp/><sp/></highlight><highlight class="comment">//<sp/>Overflow-safe<sp/>midpoint<sp/>calculation</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3547"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(cmp(*(beg<sp/>+<sp/>mid),<sp/>key))</highlight></codeline>
<codeline lineno="3548"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3549"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>down<sp/>=<sp/>mid<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="3550"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3551"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3552"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3553"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>up<sp/>=<sp/>mid;</highlight></codeline>
<codeline lineno="3554"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3555"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3556"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>beg<sp/>+<sp/>down;</highlight></codeline>
<codeline lineno="3557"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3558"><highlight class="normal"></highlight></codeline>
<codeline lineno="3559"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>CmpLess,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>IterT,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>KeyT&gt;</highlight></codeline>
<codeline lineno="3560"><highlight class="normal">IterT<sp/>VmaBinaryFindSorted(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>IterT&amp;<sp/>beg,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>IterT&amp;<sp/>end,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>KeyT&amp;<sp/>value,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>CmpLess&amp;<sp/>cmp)</highlight></codeline>
<codeline lineno="3561"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3562"><highlight class="normal"><sp/><sp/><sp/><sp/>IterT<sp/>it<sp/>=<sp/>VmaBinaryFindFirstNotLess&lt;CmpLess,<sp/>IterT,<sp/>KeyT&gt;(</highlight></codeline>
<codeline lineno="3563"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>beg,<sp/>end,<sp/>value,<sp/>cmp);</highlight></codeline>
<codeline lineno="3564"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(it<sp/>==<sp/>end<sp/>||</highlight></codeline>
<codeline lineno="3565"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(!cmp(*it,<sp/>value)<sp/>&amp;&amp;<sp/>!cmp(value,<sp/>*it)))</highlight></codeline>
<codeline lineno="3566"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3567"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>it;</highlight></codeline>
<codeline lineno="3568"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3569"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>end;</highlight></codeline>
<codeline lineno="3570"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3571"><highlight class="normal"></highlight></codeline>
<codeline lineno="3572"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="3573"><highlight class="comment">Returns<sp/>true<sp/>if<sp/>all<sp/>pointers<sp/>in<sp/>the<sp/>array<sp/>are<sp/>not-null<sp/>and<sp/>unique.</highlight></codeline>
<codeline lineno="3574"><highlight class="comment">Warning!<sp/>O(n^2)<sp/>complexity.<sp/>Use<sp/>only<sp/>inside<sp/>VMA_HEAVY_ASSERT.</highlight></codeline>
<codeline lineno="3575"><highlight class="comment">T<sp/>must<sp/>be<sp/>pointer<sp/>type,<sp/>e.g.<sp/>VmaAllocation,<sp/>VmaPool.</highlight></codeline>
<codeline lineno="3576"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3577"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="3578"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaValidatePointerArray(uint32_t<sp/>count,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T*<sp/>arr)</highlight></codeline>
<codeline lineno="3579"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3580"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(uint32_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>count;<sp/>++i)</highlight></codeline>
<codeline lineno="3581"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3582"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T<sp/>iPtr<sp/>=<sp/>arr[i];</highlight></codeline>
<codeline lineno="3583"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iPtr<sp/>==<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="3584"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3585"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="3586"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3587"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(uint32_t<sp/>j<sp/>=<sp/>i<sp/>+<sp/>1;<sp/>j<sp/>&lt;<sp/>count;<sp/>++j)</highlight></codeline>
<codeline lineno="3588"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3589"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(iPtr<sp/>==<sp/>arr[j])</highlight></codeline>
<codeline lineno="3590"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3591"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="3592"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3593"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3594"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3595"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="3596"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3597"><highlight class="normal"></highlight></codeline>
<codeline lineno="3598"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>MainT,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>NewT&gt;</highlight></codeline>
<codeline lineno="3599"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaPnextChainPushFront(MainT*<sp/>mainStruct,<sp/>NewT*<sp/>newStruct)</highlight></codeline>
<codeline lineno="3600"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3601"><highlight class="normal"><sp/><sp/><sp/><sp/>newStruct-&gt;pNext<sp/>=<sp/>mainStruct-&gt;pNext;</highlight></codeline>
<codeline lineno="3602"><highlight class="normal"><sp/><sp/><sp/><sp/>mainStruct-&gt;pNext<sp/>=<sp/>newStruct;</highlight></codeline>
<codeline lineno="3603"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3604"><highlight class="normal"></highlight></codeline>
<codeline lineno="3605"><highlight class="normal"></highlight><highlight class="comment">//<sp/>This<sp/>is<sp/>the<sp/>main<sp/>algorithm<sp/>that<sp/>guides<sp/>the<sp/>selection<sp/>of<sp/>a<sp/>memory<sp/>type<sp/>best<sp/>for<sp/>an<sp/>allocation<sp/>-</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3606"><highlight class="normal"></highlight><highlight class="comment">//<sp/>converts<sp/>usage<sp/>to<sp/>required/preferred/not<sp/>preferred<sp/>flags.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3607"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>FindMemoryPreferences(</highlight></codeline>
<codeline lineno="3608"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isIntegratedGPU,</highlight></codeline>
<codeline lineno="3609"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>&amp;<sp/>allocCreateInfo,</highlight></codeline>
<codeline lineno="3610"><highlight class="normal"><sp/><sp/><sp/><sp/>VkFlags<sp/>bufImgUsage,<sp/></highlight><highlight class="comment">//<sp/>VkBufferCreateInfo::usage<sp/>or<sp/>VkImageCreateInfo::usage.<sp/>UINT32_MAX<sp/>if<sp/>unknown.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3611"><highlight class="normal"><sp/><sp/><sp/><sp/>VkMemoryPropertyFlags&amp;<sp/>outRequiredFlags,</highlight></codeline>
<codeline lineno="3612"><highlight class="normal"><sp/><sp/><sp/><sp/>VkMemoryPropertyFlags&amp;<sp/>outPreferredFlags,</highlight></codeline>
<codeline lineno="3613"><highlight class="normal"><sp/><sp/><sp/><sp/>VkMemoryPropertyFlags&amp;<sp/>outNotPreferredFlags)</highlight></codeline>
<codeline lineno="3614"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3615"><highlight class="normal"><sp/><sp/><sp/><sp/>outRequiredFlags<sp/>=<sp/>allocCreateInfo.<ref refid="struct_vma_allocation_create_info_1a9166390303ff42d783305bc31c2b6b90" kindref="member">requiredFlags</ref>;</highlight></codeline>
<codeline lineno="3616"><highlight class="normal"><sp/><sp/><sp/><sp/>outPreferredFlags<sp/>=<sp/>allocCreateInfo.<ref refid="struct_vma_allocation_create_info_1a7fe8d81a1ad10b2a2faacacee5b15d6d" kindref="member">preferredFlags</ref>;</highlight></codeline>
<codeline lineno="3617"><highlight class="normal"><sp/><sp/><sp/><sp/>outNotPreferredFlags<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="3618"><highlight class="normal"></highlight></codeline>
<codeline lineno="3619"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal">(allocCreateInfo.<ref refid="struct_vma_allocation_create_info_1accb8b06b1f677d858cb9af20705fa910" kindref="member">usage</ref>)</highlight></codeline>
<codeline lineno="3620"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3621"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305ccaf50d27e34e0925cf3a63db8c839121dd" kindref="member">VMA_MEMORY_USAGE_UNKNOWN</ref>:</highlight></codeline>
<codeline lineno="3622"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="3623"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305ccac6b5dc1432d88647aa4cd456246eadf7" kindref="member">VMA_MEMORY_USAGE_GPU_ONLY</ref>:</highlight></codeline>
<codeline lineno="3624"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!isIntegratedGPU<sp/>||<sp/>(outPreferredFlags<sp/>&amp;<sp/>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="3625"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3626"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outPreferredFlags<sp/>|=<sp/>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;</highlight></codeline>
<codeline lineno="3627"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3628"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="3629"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca40bdf4cddeffeb12f43d45ca1286e0a5" kindref="member">VMA_MEMORY_USAGE_CPU_ONLY</ref>:</highlight></codeline>
<codeline lineno="3630"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outRequiredFlags<sp/>|=<sp/>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT<sp/>|<sp/>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;</highlight></codeline>
<codeline lineno="3631"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="3632"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca9066b52c5a7079bb74a69aaf8b92ff67" kindref="member">VMA_MEMORY_USAGE_CPU_TO_GPU</ref>:</highlight></codeline>
<codeline lineno="3633"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outRequiredFlags<sp/>|=<sp/>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;</highlight></codeline>
<codeline lineno="3634"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!isIntegratedGPU<sp/>||<sp/>(outPreferredFlags<sp/>&amp;<sp/>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="3635"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3636"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outPreferredFlags<sp/>|=<sp/>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;</highlight></codeline>
<codeline lineno="3637"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3638"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="3639"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca7b586d2fdaf82a463b58f581ed72be27" kindref="member">VMA_MEMORY_USAGE_GPU_TO_CPU</ref>:</highlight></codeline>
<codeline lineno="3640"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outRequiredFlags<sp/>|=<sp/>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;</highlight></codeline>
<codeline lineno="3641"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outPreferredFlags<sp/>|=<sp/>VK_MEMORY_PROPERTY_HOST_CACHED_BIT;</highlight></codeline>
<codeline lineno="3642"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="3643"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca416a444d4d0fc20067c3f76f32ff2500" kindref="member">VMA_MEMORY_USAGE_CPU_COPY</ref>:</highlight></codeline>
<codeline lineno="3644"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outNotPreferredFlags<sp/>|=<sp/>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;</highlight></codeline>
<codeline lineno="3645"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="3646"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca835333d9072db63a653818030e17614d" kindref="member">VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED</ref>:</highlight></codeline>
<codeline lineno="3647"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outRequiredFlags<sp/>|=<sp/>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT;</highlight></codeline>
<codeline lineno="3648"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="3649"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e" kindref="member">VMA_MEMORY_USAGE_AUTO</ref>:</highlight></codeline>
<codeline lineno="3650"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305ccae2adb696d6a73c18bb20c23666661327" kindref="member">VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE</ref>:</highlight></codeline>
<codeline lineno="3651"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca9b422585242160b8ed3418310ee6664d" kindref="member">VMA_MEMORY_USAGE_AUTO_PREFER_HOST</ref>:</highlight></codeline>
<codeline lineno="3652"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3653"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(bufImgUsage<sp/>==<sp/>UINT32_MAX)</highlight></codeline>
<codeline lineno="3654"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3655"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;VMA_MEMORY_USAGE_AUTO*<sp/>values<sp/>can<sp/>only<sp/>be<sp/>used<sp/>with<sp/>functions<sp/>like<sp/>vmaCreateBuffer,<sp/>vmaCreateImage<sp/>so<sp/>that<sp/>the<sp/>details<sp/>of<sp/>the<sp/>created<sp/>resource<sp/>are<sp/>known.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="3656"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="3657"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3658"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>relies<sp/>on<sp/>values<sp/>of<sp/>VK_IMAGE_USAGE_TRANSFER*<sp/>being<sp/>the<sp/>same<sp/>VK_BUFFER_IMAGE_TRANSFER*.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3659"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>deviceAccess<sp/>=<sp/>(bufImgUsage<sp/>&amp;<sp/>~(VK_BUFFER_USAGE_TRANSFER_DST_BIT<sp/>|<sp/>VK_BUFFER_USAGE_TRANSFER_SRC_BIT))<sp/>!=<sp/>0;</highlight></codeline>
<codeline lineno="3660"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>hostAccessSequentialWrite<sp/>=<sp/>(allocCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</ref>)<sp/>!=<sp/>0;</highlight></codeline>
<codeline lineno="3661"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>hostAccessRandom<sp/>=<sp/>(allocCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</ref>)<sp/>!=<sp/>0;</highlight></codeline>
<codeline lineno="3662"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>hostAccessAllowTransferInstead<sp/>=<sp/>(allocCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11337f96eacf34c1016c339eac165cad" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</ref>)<sp/>!=<sp/>0;</highlight></codeline>
<codeline lineno="3663"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>preferDevice<sp/>=<sp/>allocCreateInfo.<ref refid="struct_vma_allocation_create_info_1accb8b06b1f677d858cb9af20705fa910" kindref="member">usage</ref><sp/>==<sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305ccae2adb696d6a73c18bb20c23666661327" kindref="member">VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE</ref>;</highlight></codeline>
<codeline lineno="3664"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>preferHost<sp/>=<sp/>allocCreateInfo.<ref refid="struct_vma_allocation_create_info_1accb8b06b1f677d858cb9af20705fa910" kindref="member">usage</ref><sp/>==<sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca9b422585242160b8ed3418310ee6664d" kindref="member">VMA_MEMORY_USAGE_AUTO_PREFER_HOST</ref>;</highlight></codeline>
<codeline lineno="3665"><highlight class="normal"></highlight></codeline>
<codeline lineno="3666"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>CPU<sp/>random<sp/>access<sp/>-<sp/>e.g.<sp/>a<sp/>buffer<sp/>written<sp/>to<sp/>or<sp/>transferred<sp/>from<sp/>GPU<sp/>to<sp/>read<sp/>back<sp/>on<sp/>CPU.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3667"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(hostAccessRandom)</highlight></codeline>
<codeline lineno="3668"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3669"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!isIntegratedGPU<sp/>&amp;&amp;<sp/>deviceAccess<sp/>&amp;&amp;<sp/>hostAccessAllowTransferInstead<sp/>&amp;&amp;<sp/>!preferHost)</highlight></codeline>
<codeline lineno="3670"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3671"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Nice<sp/>if<sp/>it<sp/>will<sp/>end<sp/>up<sp/>in<sp/>HOST_VISIBLE,<sp/>but<sp/>more<sp/>importantly<sp/>prefer<sp/>DEVICE_LOCAL.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3672"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Omitting<sp/>HOST_VISIBLE<sp/>here<sp/>is<sp/>intentional.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3673"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>In<sp/>case<sp/>there<sp/>is<sp/>DEVICE_LOCAL<sp/>|<sp/>HOST_VISIBLE<sp/>|<sp/>HOST_CACHED,<sp/>it<sp/>will<sp/>pick<sp/>that<sp/>one.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3674"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Otherwise,<sp/>this<sp/>will<sp/>give<sp/>same<sp/>weight<sp/>to<sp/>DEVICE_LOCAL<sp/>as<sp/>HOST_VISIBLE<sp/>|<sp/>HOST_CACHED<sp/>and<sp/>select<sp/>the<sp/>former<sp/>if<sp/>occurs<sp/>first<sp/>on<sp/>the<sp/>list.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3675"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outPreferredFlags<sp/>|=<sp/>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT<sp/>|<sp/>VK_MEMORY_PROPERTY_HOST_CACHED_BIT;</highlight></codeline>
<codeline lineno="3676"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3677"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3678"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3679"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Always<sp/>CPU<sp/>memory,<sp/>cached.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3680"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outRequiredFlags<sp/>|=<sp/>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT<sp/>|<sp/>VK_MEMORY_PROPERTY_HOST_CACHED_BIT;</highlight></codeline>
<codeline lineno="3681"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3682"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3683"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>CPU<sp/>sequential<sp/>write<sp/>-<sp/>may<sp/>be<sp/>CPU<sp/>or<sp/>host-visible<sp/>GPU<sp/>memory,<sp/>uncached<sp/>and<sp/>write-combined.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3684"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(hostAccessSequentialWrite)</highlight></codeline>
<codeline lineno="3685"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3686"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Want<sp/>uncached<sp/>and<sp/>write-combined.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3687"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outNotPreferredFlags<sp/>|=<sp/>VK_MEMORY_PROPERTY_HOST_CACHED_BIT;</highlight></codeline>
<codeline lineno="3688"><highlight class="normal"></highlight></codeline>
<codeline lineno="3689"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!isIntegratedGPU<sp/>&amp;&amp;<sp/>deviceAccess<sp/>&amp;&amp;<sp/>hostAccessAllowTransferInstead<sp/>&amp;&amp;<sp/>!preferHost)</highlight></codeline>
<codeline lineno="3690"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3691"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outPreferredFlags<sp/>|=<sp/>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT<sp/>|<sp/>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;</highlight></codeline>
<codeline lineno="3692"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3693"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3694"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3695"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outRequiredFlags<sp/>|=<sp/>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;</highlight></codeline>
<codeline lineno="3696"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Direct<sp/>GPU<sp/>access,<sp/>CPU<sp/>sequential<sp/>write<sp/>(e.g.<sp/>a<sp/>dynamic<sp/>uniform<sp/>buffer<sp/>updated<sp/>every<sp/>frame)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3697"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(deviceAccess)</highlight></codeline>
<codeline lineno="3698"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3699"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Could<sp/>go<sp/>to<sp/>CPU<sp/>memory<sp/>or<sp/>GPU<sp/>BAR/unified.<sp/>Up<sp/>to<sp/>the<sp/>user<sp/>to<sp/>decide.<sp/>If<sp/>no<sp/>preference,<sp/>choose<sp/>GPU<sp/>memory.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3700"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(preferHost)</highlight></codeline>
<codeline lineno="3701"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outNotPreferredFlags<sp/>|=<sp/>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;</highlight></codeline>
<codeline lineno="3702"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3703"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outPreferredFlags<sp/>|=<sp/>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;</highlight></codeline>
<codeline lineno="3704"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3705"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>GPU<sp/>no<sp/>direct<sp/>access,<sp/>CPU<sp/>sequential<sp/>write<sp/>(e.g.<sp/>an<sp/>upload<sp/>buffer<sp/>to<sp/>be<sp/>transferred<sp/>to<sp/>the<sp/>GPU)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3706"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3707"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3708"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Could<sp/>go<sp/>to<sp/>CPU<sp/>memory<sp/>or<sp/>GPU<sp/>BAR/unified.<sp/>Up<sp/>to<sp/>the<sp/>user<sp/>to<sp/>decide.<sp/>If<sp/>no<sp/>preference,<sp/>choose<sp/>CPU<sp/>memory.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3709"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(preferDevice)</highlight></codeline>
<codeline lineno="3710"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outPreferredFlags<sp/>|=<sp/>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;</highlight></codeline>
<codeline lineno="3711"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3712"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outNotPreferredFlags<sp/>|=<sp/>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;</highlight></codeline>
<codeline lineno="3713"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3714"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3715"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3716"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>No<sp/>CPU<sp/>access</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3717"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3718"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3719"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>GPU<sp/>access,<sp/>no<sp/>CPU<sp/>access<sp/>(e.g.<sp/>a<sp/>color<sp/>attachment<sp/>image)<sp/>-<sp/>prefer<sp/>GPU<sp/>memory</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3720"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(deviceAccess)</highlight></codeline>
<codeline lineno="3721"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3722"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>...unless<sp/>there<sp/>is<sp/>a<sp/>clear<sp/>preference<sp/>from<sp/>the<sp/>user<sp/>not<sp/>to<sp/>do<sp/>so.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3723"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(preferHost)</highlight></codeline>
<codeline lineno="3724"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outNotPreferredFlags<sp/>|=<sp/>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;</highlight></codeline>
<codeline lineno="3725"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3726"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outPreferredFlags<sp/>|=<sp/>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;</highlight></codeline>
<codeline lineno="3727"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3728"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>No<sp/>direct<sp/>GPU<sp/>access,<sp/>no<sp/>CPU<sp/>access,<sp/>just<sp/>transfers.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3729"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>It<sp/>may<sp/>be<sp/>staging<sp/>copy<sp/>intended<sp/>for<sp/>e.g.<sp/>preserving<sp/>image<sp/>for<sp/>next<sp/>frame<sp/>(then<sp/>better<sp/>GPU<sp/>memory)<sp/>or</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3730"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>a<sp/>&quot;swap<sp/>file&quot;<sp/>copy<sp/>to<sp/>free<sp/>some<sp/>GPU<sp/>memory<sp/>(then<sp/>better<sp/>CPU<sp/>memory).</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3731"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Up<sp/>to<sp/>the<sp/>user<sp/>to<sp/>decide.<sp/>If<sp/>no<sp/>preferece,<sp/>assume<sp/>the<sp/>former<sp/>and<sp/>choose<sp/>GPU<sp/>memory.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3732"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(preferHost)</highlight></codeline>
<codeline lineno="3733"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outNotPreferredFlags<sp/>|=<sp/>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;</highlight></codeline>
<codeline lineno="3734"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3735"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outPreferredFlags<sp/>|=<sp/>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;</highlight></codeline>
<codeline lineno="3736"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3737"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="3738"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3739"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="3740"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="3741"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3742"><highlight class="normal"></highlight></codeline>
<codeline lineno="3743"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Avoid<sp/>DEVICE_COHERENT<sp/>unless<sp/>explicitly<sp/>requested.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3744"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(((allocCreateInfo.<ref refid="struct_vma_allocation_create_info_1a9166390303ff42d783305bc31c2b6b90" kindref="member">requiredFlags</ref><sp/>|<sp/>allocCreateInfo.<ref refid="struct_vma_allocation_create_info_1a7fe8d81a1ad10b2a2faacacee5b15d6d" kindref="member">preferredFlags</ref>)<sp/>&amp;</highlight></codeline>
<codeline lineno="3745"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD_COPY<sp/>|<sp/>VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD_COPY))<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="3746"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3747"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outNotPreferredFlags<sp/>|=<sp/>VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD_COPY;</highlight></codeline>
<codeline lineno="3748"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3749"><highlight class="normal"></highlight></codeline>
<codeline lineno="3750"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="3751"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3752"><highlight class="normal"></highlight></codeline>
<codeline lineno="3754"><highlight class="comment">//<sp/>Memory<sp/>allocation</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3755"><highlight class="normal"></highlight></codeline>
<codeline lineno="3756"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>VmaMalloc(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>alignment)</highlight></codeline>
<codeline lineno="3757"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3758"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>result<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="3759"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((pAllocationCallbacks<sp/>!=<sp/>VMA_NULL)<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="3760"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(pAllocationCallbacks-&gt;pfnAllocation<sp/>!=<sp/>VMA_NULL))</highlight></codeline>
<codeline lineno="3761"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3762"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>(*pAllocationCallbacks-&gt;pfnAllocation)(</highlight></codeline>
<codeline lineno="3763"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocationCallbacks-&gt;pUserData,</highlight></codeline>
<codeline lineno="3764"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size,</highlight></codeline>
<codeline lineno="3765"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alignment,</highlight></codeline>
<codeline lineno="3766"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);</highlight></codeline>
<codeline lineno="3767"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3768"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3769"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3770"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>VMA_SYSTEM_ALIGNED_MALLOC(size,<sp/>alignment);</highlight></codeline>
<codeline lineno="3771"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3772"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(result<sp/>!=<sp/>VMA_NULL<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;CPU<sp/>memory<sp/>allocation<sp/>failed.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="3773"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>result;</highlight></codeline>
<codeline lineno="3774"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3775"><highlight class="normal"></highlight></codeline>
<codeline lineno="3776"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaFree(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>ptr)</highlight></codeline>
<codeline lineno="3777"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3778"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((pAllocationCallbacks<sp/>!=<sp/>VMA_NULL)<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="3779"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(pAllocationCallbacks-&gt;pfnFree<sp/>!=<sp/>VMA_NULL))</highlight></codeline>
<codeline lineno="3780"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3781"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*pAllocationCallbacks-&gt;pfnFree)(pAllocationCallbacks-&gt;pUserData,<sp/>ptr);</highlight></codeline>
<codeline lineno="3782"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3783"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3784"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3785"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_SYSTEM_ALIGNED_FREE(ptr);</highlight></codeline>
<codeline lineno="3786"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3787"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3788"><highlight class="normal"></highlight></codeline>
<codeline lineno="3789"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="3790"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>T*<sp/>VmaAllocate(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks)</highlight></codeline>
<codeline lineno="3791"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3792"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(T*)VmaMalloc(pAllocationCallbacks,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(T),<sp/>VMA_ALIGN_OF(T));</highlight></codeline>
<codeline lineno="3793"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3794"><highlight class="normal"></highlight></codeline>
<codeline lineno="3795"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="3796"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>T*<sp/>VmaAllocateArray(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>count)</highlight></codeline>
<codeline lineno="3797"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3798"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(T*)VmaMalloc(pAllocationCallbacks,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(T)<sp/>*<sp/>count,<sp/>VMA_ALIGN_OF(T));</highlight></codeline>
<codeline lineno="3799"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3800"><highlight class="normal"></highlight></codeline>
<codeline lineno="3801"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>vma_new(allocator,<sp/>type)<sp/><sp/><sp/>new(VmaAllocate&lt;type&gt;(allocator))(type)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3802"><highlight class="normal"></highlight></codeline>
<codeline lineno="3803"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>vma_new_array(allocator,<sp/>type,<sp/>count)<sp/><sp/><sp/>new(VmaAllocateArray&lt;type&gt;((allocator),<sp/>(count)))(type)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3804"><highlight class="normal"></highlight></codeline>
<codeline lineno="3805"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="3806"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>vma_delete(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks,<sp/>T*<sp/>ptr)</highlight></codeline>
<codeline lineno="3807"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3808"><highlight class="normal"><sp/><sp/><sp/><sp/>ptr-&gt;~T();</highlight></codeline>
<codeline lineno="3809"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaFree(pAllocationCallbacks,<sp/>ptr);</highlight></codeline>
<codeline lineno="3810"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3811"><highlight class="normal"></highlight></codeline>
<codeline lineno="3812"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="3813"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>vma_delete_array(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks,<sp/>T*<sp/>ptr,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>count)</highlight></codeline>
<codeline lineno="3814"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3815"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ptr<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="3816"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3817"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>count;<sp/>i--;<sp/>)</highlight></codeline>
<codeline lineno="3818"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3819"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ptr[i].~T();</highlight></codeline>
<codeline lineno="3820"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3821"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaFree(pAllocationCallbacks,<sp/>ptr);</highlight></codeline>
<codeline lineno="3822"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3823"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3824"><highlight class="normal"></highlight></codeline>
<codeline lineno="3825"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>VmaCreateStringCopy(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>allocs,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>srcStr)</highlight></codeline>
<codeline lineno="3826"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3827"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(srcStr<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="3828"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3829"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>len<sp/>=<sp/>strlen(srcStr);</highlight></codeline>
<codeline lineno="3830"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>result<sp/>=<sp/>vma_new_array(allocs,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">,<sp/>len<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="3831"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(result,<sp/>srcStr,<sp/>len<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="3832"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>result;</highlight></codeline>
<codeline lineno="3833"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3834"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="3835"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3836"><highlight class="normal"></highlight></codeline>
<codeline lineno="3837"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3838"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>VmaCreateStringCopy(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>allocs,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>srcStr,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>strLen)</highlight></codeline>
<codeline lineno="3839"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3840"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(srcStr<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="3841"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3842"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>result<sp/>=<sp/>vma_new_array(allocs,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">,<sp/>strLen<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="3843"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(result,<sp/>srcStr,<sp/>strLen);</highlight></codeline>
<codeline lineno="3844"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result[strLen]<sp/>=<sp/></highlight><highlight class="charliteral">&apos;\0&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="3845"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>result;</highlight></codeline>
<codeline lineno="3846"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3847"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="3848"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3849"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3850"><highlight class="normal"></highlight></codeline>
<codeline lineno="3851"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaFreeString(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>allocs,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>str)</highlight></codeline>
<codeline lineno="3852"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3853"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(str<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="3854"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3855"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>len<sp/>=<sp/>strlen(str);</highlight></codeline>
<codeline lineno="3856"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vma_delete_array(allocs,<sp/>str,<sp/>len<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="3857"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3858"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3859"><highlight class="normal"></highlight></codeline>
<codeline lineno="3860"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>CmpLess,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>VectorT&gt;</highlight></codeline>
<codeline lineno="3861"><highlight class="normal"></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>VmaVectorInsertSorted(VectorT&amp;<sp/>vector,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>VectorT::value_type&amp;<sp/>value)</highlight></codeline>
<codeline lineno="3862"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3863"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>indexToInsert<sp/>=<sp/>VmaBinaryFindFirstNotLess(</highlight></codeline>
<codeline lineno="3864"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vector.data(),</highlight></codeline>
<codeline lineno="3865"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vector.data()<sp/>+<sp/>vector.size(),</highlight></codeline>
<codeline lineno="3866"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>value,</highlight></codeline>
<codeline lineno="3867"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CmpLess())<sp/>-<sp/>vector.data();</highlight></codeline>
<codeline lineno="3868"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaVectorInsert(vector,<sp/>indexToInsert,<sp/>value);</highlight></codeline>
<codeline lineno="3869"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>indexToInsert;</highlight></codeline>
<codeline lineno="3870"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3871"><highlight class="normal"></highlight></codeline>
<codeline lineno="3872"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>CmpLess,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>VectorT&gt;</highlight></codeline>
<codeline lineno="3873"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaVectorRemoveSorted(VectorT&amp;<sp/>vector,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>VectorT::value_type&amp;<sp/>value)</highlight></codeline>
<codeline lineno="3874"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3875"><highlight class="normal"><sp/><sp/><sp/><sp/>CmpLess<sp/>comparator;</highlight></codeline>
<codeline lineno="3876"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>VectorT::iterator<sp/>it<sp/>=<sp/>VmaBinaryFindFirstNotLess(</highlight></codeline>
<codeline lineno="3877"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vector.begin(),</highlight></codeline>
<codeline lineno="3878"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vector.end(),</highlight></codeline>
<codeline lineno="3879"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>value,</highlight></codeline>
<codeline lineno="3880"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>comparator);</highlight></codeline>
<codeline lineno="3881"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((it<sp/>!=<sp/>vector.end())<sp/>&amp;&amp;<sp/>!comparator(*it,<sp/>value)<sp/>&amp;&amp;<sp/>!comparator(value,<sp/>*it))</highlight></codeline>
<codeline lineno="3882"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3883"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>indexToRemove<sp/>=<sp/>it<sp/>-<sp/>vector.begin();</highlight></codeline>
<codeline lineno="3884"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaVectorRemove(vector,<sp/>indexToRemove);</highlight></codeline>
<codeline lineno="3885"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="3886"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3887"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="3888"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3889"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3890"><highlight class="normal"></highlight></codeline>
<codeline lineno="3891"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_STATISTICS_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3892"><highlight class="normal"></highlight></codeline>
<codeline lineno="3893"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaClearStatistics(<ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref>&amp;<sp/>outStats)</highlight></codeline>
<codeline lineno="3894"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3895"><highlight class="normal"><sp/><sp/><sp/><sp/>outStats.<ref refid="struct_vma_statistics_1a309179d5853a6a7cd534df497ee43957" kindref="member">blockCount</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="3896"><highlight class="normal"><sp/><sp/><sp/><sp/>outStats.<ref refid="struct_vma_statistics_1ab0ff76e50f58f9f54b6f265e5bf5dde2" kindref="member">allocationCount</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="3897"><highlight class="normal"><sp/><sp/><sp/><sp/>outStats.<ref refid="struct_vma_statistics_1a2afbc1c7aa8ad7bbb8de06215ba7e5c4" kindref="member">blockBytes</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="3898"><highlight class="normal"><sp/><sp/><sp/><sp/>outStats.<ref refid="struct_vma_statistics_1a21db06eba3422f87a2b4b4703d879c16" kindref="member">allocationBytes</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="3899"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3900"><highlight class="normal"></highlight></codeline>
<codeline lineno="3901"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAddStatistics(<ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref>&amp;<sp/>inoutStats,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref>&amp;<sp/>src)</highlight></codeline>
<codeline lineno="3902"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3903"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_statistics_1a309179d5853a6a7cd534df497ee43957" kindref="member">blockCount</ref><sp/>+=<sp/>src.<ref refid="struct_vma_statistics_1a309179d5853a6a7cd534df497ee43957" kindref="member">blockCount</ref>;</highlight></codeline>
<codeline lineno="3904"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_statistics_1ab0ff76e50f58f9f54b6f265e5bf5dde2" kindref="member">allocationCount</ref><sp/>+=<sp/>src.<ref refid="struct_vma_statistics_1ab0ff76e50f58f9f54b6f265e5bf5dde2" kindref="member">allocationCount</ref>;</highlight></codeline>
<codeline lineno="3905"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_statistics_1a2afbc1c7aa8ad7bbb8de06215ba7e5c4" kindref="member">blockBytes</ref><sp/>+=<sp/>src.<ref refid="struct_vma_statistics_1a2afbc1c7aa8ad7bbb8de06215ba7e5c4" kindref="member">blockBytes</ref>;</highlight></codeline>
<codeline lineno="3906"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_statistics_1a21db06eba3422f87a2b4b4703d879c16" kindref="member">allocationBytes</ref><sp/>+=<sp/>src.<ref refid="struct_vma_statistics_1a21db06eba3422f87a2b4b4703d879c16" kindref="member">allocationBytes</ref>;</highlight></codeline>
<codeline lineno="3907"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3908"><highlight class="normal"></highlight></codeline>
<codeline lineno="3909"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaClearDetailedStatistics(<ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>&amp;<sp/>outStats)</highlight></codeline>
<codeline lineno="3910"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3911"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaClearStatistics(outStats.<ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>);</highlight></codeline>
<codeline lineno="3912"><highlight class="normal"><sp/><sp/><sp/><sp/>outStats.<ref refid="struct_vma_detailed_statistics_1ab721bf04892e8b67802d4ddb7734638a" kindref="member">unusedRangeCount</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="3913"><highlight class="normal"><sp/><sp/><sp/><sp/>outStats.<ref refid="struct_vma_detailed_statistics_1a6fb397e7487e10f2a52e241577d2a2b8" kindref="member">allocationSizeMin</ref><sp/>=<sp/>VK_WHOLE_SIZE;</highlight></codeline>
<codeline lineno="3914"><highlight class="normal"><sp/><sp/><sp/><sp/>outStats.<ref refid="struct_vma_detailed_statistics_1a06b2add24eed3449a66ff151979a0201" kindref="member">allocationSizeMax</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="3915"><highlight class="normal"><sp/><sp/><sp/><sp/>outStats.<ref refid="struct_vma_detailed_statistics_1a830eda847ed735d0e91da25cfcf797a4" kindref="member">unusedRangeSizeMin</ref><sp/>=<sp/>VK_WHOLE_SIZE;</highlight></codeline>
<codeline lineno="3916"><highlight class="normal"><sp/><sp/><sp/><sp/>outStats.<ref refid="struct_vma_detailed_statistics_1af98943b5da98cf441ffa04b67914c78c" kindref="member">unusedRangeSizeMax</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="3917"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3918"><highlight class="normal"></highlight></codeline>
<codeline lineno="3919"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAddDetailedStatisticsAllocation(<ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>&amp;<sp/>inoutStats,<sp/>VkDeviceSize<sp/>size)</highlight></codeline>
<codeline lineno="3920"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3921"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1ab0ff76e50f58f9f54b6f265e5bf5dde2" kindref="member">allocationCount</ref>++;</highlight></codeline>
<codeline lineno="3922"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1a21db06eba3422f87a2b4b4703d879c16" kindref="member">allocationBytes</ref><sp/>+=<sp/>size;</highlight></codeline>
<codeline lineno="3923"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_detailed_statistics_1a6fb397e7487e10f2a52e241577d2a2b8" kindref="member">allocationSizeMin</ref><sp/>=<sp/>VMA_MIN(inoutStats.<ref refid="struct_vma_detailed_statistics_1a6fb397e7487e10f2a52e241577d2a2b8" kindref="member">allocationSizeMin</ref>,<sp/>size);</highlight></codeline>
<codeline lineno="3924"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_detailed_statistics_1a06b2add24eed3449a66ff151979a0201" kindref="member">allocationSizeMax</ref><sp/>=<sp/>VMA_MAX(inoutStats.<ref refid="struct_vma_detailed_statistics_1a06b2add24eed3449a66ff151979a0201" kindref="member">allocationSizeMax</ref>,<sp/>size);</highlight></codeline>
<codeline lineno="3925"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3926"><highlight class="normal"></highlight></codeline>
<codeline lineno="3927"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAddDetailedStatisticsUnusedRange(<ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>&amp;<sp/>inoutStats,<sp/>VkDeviceSize<sp/>size)</highlight></codeline>
<codeline lineno="3928"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3929"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_detailed_statistics_1ab721bf04892e8b67802d4ddb7734638a" kindref="member">unusedRangeCount</ref>++;</highlight></codeline>
<codeline lineno="3930"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_detailed_statistics_1a830eda847ed735d0e91da25cfcf797a4" kindref="member">unusedRangeSizeMin</ref><sp/>=<sp/>VMA_MIN(inoutStats.<ref refid="struct_vma_detailed_statistics_1a830eda847ed735d0e91da25cfcf797a4" kindref="member">unusedRangeSizeMin</ref>,<sp/>size);</highlight></codeline>
<codeline lineno="3931"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_detailed_statistics_1af98943b5da98cf441ffa04b67914c78c" kindref="member">unusedRangeSizeMax</ref><sp/>=<sp/>VMA_MAX(inoutStats.<ref refid="struct_vma_detailed_statistics_1af98943b5da98cf441ffa04b67914c78c" kindref="member">unusedRangeSizeMax</ref>,<sp/>size);</highlight></codeline>
<codeline lineno="3932"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3933"><highlight class="normal"></highlight></codeline>
<codeline lineno="3934"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAddDetailedStatistics(<ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>&amp;<sp/>inoutStats,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>&amp;<sp/>src)</highlight></codeline>
<codeline lineno="3935"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3936"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAddStatistics(inoutStats.<ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>,<sp/>src.<ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>);</highlight></codeline>
<codeline lineno="3937"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_detailed_statistics_1ab721bf04892e8b67802d4ddb7734638a" kindref="member">unusedRangeCount</ref><sp/>+=<sp/>src.<ref refid="struct_vma_detailed_statistics_1ab721bf04892e8b67802d4ddb7734638a" kindref="member">unusedRangeCount</ref>;</highlight></codeline>
<codeline lineno="3938"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_detailed_statistics_1a6fb397e7487e10f2a52e241577d2a2b8" kindref="member">allocationSizeMin</ref><sp/>=<sp/>VMA_MIN(inoutStats.<ref refid="struct_vma_detailed_statistics_1a6fb397e7487e10f2a52e241577d2a2b8" kindref="member">allocationSizeMin</ref>,<sp/>src.<ref refid="struct_vma_detailed_statistics_1a6fb397e7487e10f2a52e241577d2a2b8" kindref="member">allocationSizeMin</ref>);</highlight></codeline>
<codeline lineno="3939"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_detailed_statistics_1a06b2add24eed3449a66ff151979a0201" kindref="member">allocationSizeMax</ref><sp/>=<sp/>VMA_MAX(inoutStats.<ref refid="struct_vma_detailed_statistics_1a06b2add24eed3449a66ff151979a0201" kindref="member">allocationSizeMax</ref>,<sp/>src.<ref refid="struct_vma_detailed_statistics_1a06b2add24eed3449a66ff151979a0201" kindref="member">allocationSizeMax</ref>);</highlight></codeline>
<codeline lineno="3940"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_detailed_statistics_1a830eda847ed735d0e91da25cfcf797a4" kindref="member">unusedRangeSizeMin</ref><sp/>=<sp/>VMA_MIN(inoutStats.<ref refid="struct_vma_detailed_statistics_1a830eda847ed735d0e91da25cfcf797a4" kindref="member">unusedRangeSizeMin</ref>,<sp/>src.<ref refid="struct_vma_detailed_statistics_1a830eda847ed735d0e91da25cfcf797a4" kindref="member">unusedRangeSizeMin</ref>);</highlight></codeline>
<codeline lineno="3941"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_detailed_statistics_1af98943b5da98cf441ffa04b67914c78c" kindref="member">unusedRangeSizeMax</ref><sp/>=<sp/>VMA_MAX(inoutStats.<ref refid="struct_vma_detailed_statistics_1af98943b5da98cf441ffa04b67914c78c" kindref="member">unusedRangeSizeMax</ref>,<sp/>src.<ref refid="struct_vma_detailed_statistics_1af98943b5da98cf441ffa04b67914c78c" kindref="member">unusedRangeSizeMax</ref>);</highlight></codeline>
<codeline lineno="3942"><highlight class="normal">}</highlight></codeline>
<codeline lineno="3943"><highlight class="normal"></highlight></codeline>
<codeline lineno="3944"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_STATISTICS_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3945"><highlight class="normal"></highlight></codeline>
<codeline lineno="3946"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_MUTEX_LOCK</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3947"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Helper<sp/>RAII<sp/>class<sp/>to<sp/>lock<sp/>a<sp/>mutex<sp/>in<sp/>constructor<sp/>and<sp/>unlock<sp/>it<sp/>in<sp/>destructor<sp/>(at<sp/>the<sp/>end<sp/>of<sp/>scope).</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3948"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaMutexLock</highlight></codeline>
<codeline lineno="3949"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3950"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_CLASS_NO_COPY(VmaMutexLock)</highlight></codeline>
<codeline lineno="3951"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="3952"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaMutexLock(VMA_MUTEX&amp;<sp/>mutex,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>useMutex<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">)<sp/>:</highlight></codeline>
<codeline lineno="3953"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pMutex(useMutex<sp/>?<sp/>&amp;mutex<sp/>:<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="3954"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3955"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_pMutex)<sp/>{<sp/>m_pMutex-&gt;Lock();<sp/>}</highlight></codeline>
<codeline lineno="3956"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3957"><highlight class="normal"><sp/><sp/><sp/><sp/>~VmaMutexLock()<sp/>{<sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_pMutex)<sp/>{<sp/>m_pMutex-&gt;Unlock();<sp/>}<sp/>}</highlight></codeline>
<codeline lineno="3958"><highlight class="normal"></highlight></codeline>
<codeline lineno="3959"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="3960"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_MUTEX*<sp/>m_pMutex;</highlight></codeline>
<codeline lineno="3961"><highlight class="normal">};</highlight></codeline>
<codeline lineno="3962"><highlight class="normal"></highlight></codeline>
<codeline lineno="3963"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Helper<sp/>RAII<sp/>class<sp/>to<sp/>lock<sp/>a<sp/>RW<sp/>mutex<sp/>in<sp/>constructor<sp/>and<sp/>unlock<sp/>it<sp/>in<sp/>destructor<sp/>(at<sp/>the<sp/>end<sp/>of<sp/>scope),<sp/>for<sp/>reading.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3964"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaMutexLockRead</highlight></codeline>
<codeline lineno="3965"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3966"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_CLASS_NO_COPY(VmaMutexLockRead)</highlight></codeline>
<codeline lineno="3967"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="3968"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaMutexLockRead(VMA_RW_MUTEX&amp;<sp/>mutex,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>useMutex)<sp/>:</highlight></codeline>
<codeline lineno="3969"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pMutex(useMutex<sp/>?<sp/>&amp;mutex<sp/>:<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="3970"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3971"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_pMutex)<sp/>{<sp/>m_pMutex-&gt;LockRead();<sp/>}</highlight></codeline>
<codeline lineno="3972"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3973"><highlight class="normal"><sp/><sp/><sp/><sp/>~VmaMutexLockRead()<sp/>{<sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_pMutex)<sp/>{<sp/>m_pMutex-&gt;UnlockRead();<sp/>}<sp/>}</highlight></codeline>
<codeline lineno="3974"><highlight class="normal"></highlight></codeline>
<codeline lineno="3975"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="3976"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_RW_MUTEX*<sp/>m_pMutex;</highlight></codeline>
<codeline lineno="3977"><highlight class="normal">};</highlight></codeline>
<codeline lineno="3978"><highlight class="normal"></highlight></codeline>
<codeline lineno="3979"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Helper<sp/>RAII<sp/>class<sp/>to<sp/>lock<sp/>a<sp/>RW<sp/>mutex<sp/>in<sp/>constructor<sp/>and<sp/>unlock<sp/>it<sp/>in<sp/>destructor<sp/>(at<sp/>the<sp/>end<sp/>of<sp/>scope),<sp/>for<sp/>writing.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3980"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaMutexLockWrite</highlight></codeline>
<codeline lineno="3981"><highlight class="normal">{</highlight></codeline>
<codeline lineno="3982"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_CLASS_NO_COPY(VmaMutexLockWrite)</highlight></codeline>
<codeline lineno="3983"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="3984"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaMutexLockWrite(VMA_RW_MUTEX&amp;<sp/>mutex,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>useMutex)</highlight></codeline>
<codeline lineno="3985"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>m_pMutex(useMutex<sp/>?<sp/>&amp;mutex<sp/>:<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="3986"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="3987"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_pMutex)<sp/>{<sp/>m_pMutex-&gt;LockWrite();<sp/>}</highlight></codeline>
<codeline lineno="3988"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3989"><highlight class="normal"><sp/><sp/><sp/><sp/>~VmaMutexLockWrite()<sp/>{<sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_pMutex)<sp/>{<sp/>m_pMutex-&gt;UnlockWrite();<sp/>}<sp/>}</highlight></codeline>
<codeline lineno="3990"><highlight class="normal"></highlight></codeline>
<codeline lineno="3991"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="3992"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_RW_MUTEX*<sp/>m_pMutex;</highlight></codeline>
<codeline lineno="3993"><highlight class="normal">};</highlight></codeline>
<codeline lineno="3994"><highlight class="normal"></highlight></codeline>
<codeline lineno="3995"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_DEBUG_GLOBAL_MUTEX</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3996"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>VMA_MUTEX<sp/>gDebugGlobalMutex;</highlight></codeline>
<codeline lineno="3997"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#define<sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK<sp/>VmaMutexLock<sp/>debugGlobalMutexLock(gDebugGlobalMutex,<sp/>true);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3998"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3999"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#define<sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4000"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4001"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_MUTEX_LOCK</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4002"><highlight class="normal"></highlight></codeline>
<codeline lineno="4003"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_ATOMIC_TRANSACTIONAL_INCREMENT</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4004"><highlight class="normal"></highlight><highlight class="comment">//<sp/>An<sp/>object<sp/>that<sp/>increments<sp/>given<sp/>atomic<sp/>but<sp/>decrements<sp/>it<sp/>back<sp/>in<sp/>the<sp/>destructor<sp/>unless<sp/>Commit()<sp/>is<sp/>called.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4005"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="4006"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">AtomicTransactionalIncrement</highlight></codeline>
<codeline lineno="4007"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4008"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="4009"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>std::atomic&lt;T&gt;<sp/>AtomicT;</highlight></codeline>
<codeline lineno="4010"><highlight class="normal"></highlight></codeline>
<codeline lineno="4011"><highlight class="normal"><sp/><sp/><sp/><sp/>~AtomicTransactionalIncrement()</highlight></codeline>
<codeline lineno="4012"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4013"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_Atomic)</highlight></codeline>
<codeline lineno="4014"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--(*m_Atomic);</highlight></codeline>
<codeline lineno="4015"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4016"><highlight class="normal"></highlight></codeline>
<codeline lineno="4017"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Commit()<sp/>{<sp/>m_Atomic<sp/>=<sp/></highlight><highlight class="keyword">nullptr</highlight><highlight class="normal">;<sp/>}</highlight></codeline>
<codeline lineno="4018"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>Increment(AtomicT*<sp/>atomic)</highlight></codeline>
<codeline lineno="4019"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4020"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Atomic<sp/>=<sp/>atomic;</highlight></codeline>
<codeline lineno="4021"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Atomic-&gt;fetch_add(1);</highlight></codeline>
<codeline lineno="4022"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4023"><highlight class="normal"></highlight></codeline>
<codeline lineno="4024"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="4025"><highlight class="normal"><sp/><sp/><sp/><sp/>AtomicT*<sp/>m_Atomic<sp/>=<sp/></highlight><highlight class="keyword">nullptr</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="4026"><highlight class="normal">};</highlight></codeline>
<codeline lineno="4027"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_ATOMIC_TRANSACTIONAL_INCREMENT</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4028"><highlight class="normal"></highlight></codeline>
<codeline lineno="4029"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_STL_ALLOCATOR</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4030"><highlight class="normal"></highlight><highlight class="comment">//<sp/>STL-compatible<sp/>allocator.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4031"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="4032"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaStlAllocator</highlight></codeline>
<codeline lineno="4033"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4034"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>m_pCallbacks;</highlight></codeline>
<codeline lineno="4035"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>T<sp/>value_type;</highlight></codeline>
<codeline lineno="4036"><highlight class="normal"></highlight></codeline>
<codeline lineno="4037"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaStlAllocator(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pCallbacks)<sp/>:<sp/>m_pCallbacks(pCallbacks)<sp/>{}</highlight></codeline>
<codeline lineno="4038"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>U&gt;</highlight></codeline>
<codeline lineno="4039"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaStlAllocator(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaStlAllocator&lt;U&gt;&amp;<sp/>src)<sp/>:<sp/>m_pCallbacks(src.m_pCallbacks)<sp/>{}</highlight></codeline>
<codeline lineno="4040"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaStlAllocator(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaStlAllocator&amp;)<sp/>=<sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="4041"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaStlAllocator&amp;<sp/>operator=(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaStlAllocator&amp;)<sp/>=<sp/></highlight><highlight class="keyword">delete</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="4042"><highlight class="normal"></highlight></codeline>
<codeline lineno="4043"><highlight class="normal"><sp/><sp/><sp/><sp/>T*<sp/>allocate(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>n)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VmaAllocateArray&lt;T&gt;(m_pCallbacks,<sp/>n);<sp/>}</highlight></codeline>
<codeline lineno="4044"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>deallocate(T*<sp/>p,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>n)<sp/>{<sp/>VmaFree(m_pCallbacks,<sp/>p);<sp/>}</highlight></codeline>
<codeline lineno="4045"><highlight class="normal"></highlight></codeline>
<codeline lineno="4046"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>U&gt;</highlight></codeline>
<codeline lineno="4047"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>operator==(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaStlAllocator&lt;U&gt;&amp;<sp/>rhs)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="4048"><highlight class="keyword"><sp/><sp/><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="4049"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pCallbacks<sp/>==<sp/>rhs.m_pCallbacks;</highlight></codeline>
<codeline lineno="4050"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4051"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>U&gt;</highlight></codeline>
<codeline lineno="4052"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>operator!=(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaStlAllocator&lt;U&gt;&amp;<sp/>rhs)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="4053"><highlight class="keyword"><sp/><sp/><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="4054"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pCallbacks<sp/>!=<sp/>rhs.m_pCallbacks;</highlight></codeline>
<codeline lineno="4055"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4056"><highlight class="normal">};</highlight></codeline>
<codeline lineno="4057"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_STL_ALLOCATOR</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4058"><highlight class="normal"></highlight></codeline>
<codeline lineno="4059"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_VECTOR</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4060"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Class<sp/>with<sp/>interface<sp/>compatible<sp/>with<sp/>subset<sp/>of<sp/>std::vector.</highlight></codeline>
<codeline lineno="4061"><highlight class="comment">T<sp/>must<sp/>be<sp/>POD<sp/>because<sp/>constructors<sp/>and<sp/>destructors<sp/>are<sp/>not<sp/>called<sp/>and<sp/>memcpy<sp/>is</highlight></codeline>
<codeline lineno="4062"><highlight class="comment">used<sp/>for<sp/>these<sp/>objects.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4063"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AllocatorT&gt;</highlight></codeline>
<codeline lineno="4064"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaVector</highlight></codeline>
<codeline lineno="4065"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4066"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="4067"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>T<sp/>value_type;</highlight></codeline>
<codeline lineno="4068"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>T*<sp/>iterator;</highlight></codeline>
<codeline lineno="4069"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T*<sp/>const_iterator;</highlight></codeline>
<codeline lineno="4070"><highlight class="normal"></highlight></codeline>
<codeline lineno="4071"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaVector(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>AllocatorT&amp;<sp/>allocator);</highlight></codeline>
<codeline lineno="4072"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaVector(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>count,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>AllocatorT&amp;<sp/>allocator);</highlight></codeline>
<codeline lineno="4073"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>version<sp/>of<sp/>the<sp/>constructor<sp/>is<sp/>here<sp/>for<sp/>compatibility<sp/>with<sp/>pre-C++14<sp/>std::vector.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4074"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>value<sp/>is<sp/>unused.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4075"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaVector(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>count,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>value,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>AllocatorT&amp;<sp/>allocator)<sp/>:<sp/>VmaVector(count,<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>)<sp/>{}</highlight></codeline>
<codeline lineno="4076"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaVector(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaVector&lt;T,<sp/>AllocatorT&gt;&amp;<sp/>src);</highlight></codeline>
<codeline lineno="4077"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaVector&amp;<sp/>operator=(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaVector&amp;<sp/>rhs);</highlight></codeline>
<codeline lineno="4078"><highlight class="normal"><sp/><sp/><sp/><sp/>~VmaVector()<sp/>{<sp/>VmaFree(m_Allocator.m_pCallbacks,<sp/>m_pArray);<sp/>}</highlight></codeline>
<codeline lineno="4079"><highlight class="normal"></highlight></codeline>
<codeline lineno="4080"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>empty()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Count<sp/>==<sp/>0;<sp/>}</highlight></codeline>
<codeline lineno="4081"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Count;<sp/>}</highlight></codeline>
<codeline lineno="4082"><highlight class="normal"><sp/><sp/><sp/><sp/>T*<sp/>data()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pArray;<sp/>}</highlight></codeline>
<codeline lineno="4083"><highlight class="normal"><sp/><sp/><sp/><sp/>T&amp;<sp/>front()<sp/>{<sp/>VMA_HEAVY_ASSERT(m_Count<sp/>&gt;<sp/>0);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pArray[0];<sp/>}</highlight></codeline>
<codeline lineno="4084"><highlight class="normal"><sp/><sp/><sp/><sp/>T&amp;<sp/>back()<sp/>{<sp/>VMA_HEAVY_ASSERT(m_Count<sp/>&gt;<sp/>0);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pArray[m_Count<sp/>-<sp/>1];<sp/>}</highlight></codeline>
<codeline lineno="4085"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T*<sp/>data()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pArray;<sp/>}</highlight></codeline>
<codeline lineno="4086"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>front()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/>VMA_HEAVY_ASSERT(m_Count<sp/>&gt;<sp/>0);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pArray[0];<sp/>}</highlight></codeline>
<codeline lineno="4087"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>back()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/>VMA_HEAVY_ASSERT(m_Count<sp/>&gt;<sp/>0);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pArray[m_Count<sp/>-<sp/>1];<sp/>}</highlight></codeline>
<codeline lineno="4088"><highlight class="normal"></highlight></codeline>
<codeline lineno="4089"><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>begin()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pArray;<sp/>}</highlight></codeline>
<codeline lineno="4090"><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>end()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pArray<sp/>+<sp/>m_Count;<sp/>}</highlight></codeline>
<codeline lineno="4091"><highlight class="normal"><sp/><sp/><sp/><sp/>const_iterator<sp/>cbegin()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pArray;<sp/>}</highlight></codeline>
<codeline lineno="4092"><highlight class="normal"><sp/><sp/><sp/><sp/>const_iterator<sp/>cend()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pArray<sp/>+<sp/>m_Count;<sp/>}</highlight></codeline>
<codeline lineno="4093"><highlight class="normal"><sp/><sp/><sp/><sp/>const_iterator<sp/>begin()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>cbegin();<sp/>}</highlight></codeline>
<codeline lineno="4094"><highlight class="normal"><sp/><sp/><sp/><sp/>const_iterator<sp/>end()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>cend();<sp/>}</highlight></codeline>
<codeline lineno="4095"><highlight class="normal"></highlight></codeline>
<codeline lineno="4096"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>pop_front()<sp/>{<sp/>VMA_HEAVY_ASSERT(m_Count<sp/>&gt;<sp/>0);<sp/>remove(0);<sp/>}</highlight></codeline>
<codeline lineno="4097"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>pop_back()<sp/>{<sp/>VMA_HEAVY_ASSERT(m_Count<sp/>&gt;<sp/>0);<sp/>resize(size()<sp/>-<sp/>1);<sp/>}</highlight></codeline>
<codeline lineno="4098"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>push_front(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>src)<sp/>{<sp/>insert(0,<sp/>src);<sp/>}</highlight></codeline>
<codeline lineno="4099"><highlight class="normal"></highlight></codeline>
<codeline lineno="4100"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>push_back(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>src);</highlight></codeline>
<codeline lineno="4101"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>reserve(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>newCapacity,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>freeMemory<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="4102"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>resize(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>newCount);</highlight></codeline>
<codeline lineno="4103"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>clear()<sp/>{<sp/>resize(0);<sp/>}</highlight></codeline>
<codeline lineno="4104"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>shrink_to_fit();</highlight></codeline>
<codeline lineno="4105"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>insert(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>src);</highlight></codeline>
<codeline lineno="4106"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>remove(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index);</highlight></codeline>
<codeline lineno="4107"><highlight class="normal"></highlight></codeline>
<codeline lineno="4108"><highlight class="normal"><sp/><sp/><sp/><sp/>T&amp;<sp/>operator[](</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index)<sp/>{<sp/>VMA_HEAVY_ASSERT(index<sp/>&lt;<sp/>m_Count);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pArray[index];<sp/>}</highlight></codeline>
<codeline lineno="4109"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>operator[](</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/>VMA_HEAVY_ASSERT(index<sp/>&lt;<sp/>m_Count);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pArray[index];<sp/>}</highlight></codeline>
<codeline lineno="4110"><highlight class="normal"></highlight></codeline>
<codeline lineno="4111"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="4112"><highlight class="normal"><sp/><sp/><sp/><sp/>AllocatorT<sp/>m_Allocator;</highlight></codeline>
<codeline lineno="4113"><highlight class="normal"><sp/><sp/><sp/><sp/>T*<sp/>m_pArray;</highlight></codeline>
<codeline lineno="4114"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>m_Count;</highlight></codeline>
<codeline lineno="4115"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>m_Capacity;</highlight></codeline>
<codeline lineno="4116"><highlight class="normal">};</highlight></codeline>
<codeline lineno="4117"><highlight class="normal"></highlight></codeline>
<codeline lineno="4118"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_VECTOR_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4119"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AllocatorT&gt;</highlight></codeline>
<codeline lineno="4120"><highlight class="normal">VmaVector&lt;T,<sp/>AllocatorT&gt;::VmaVector(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>AllocatorT&amp;<sp/>allocator)</highlight></codeline>
<codeline lineno="4121"><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>m_Allocator(<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>),</highlight></codeline>
<codeline lineno="4122"><highlight class="normal"><sp/><sp/><sp/><sp/>m_pArray(VMA_NULL),</highlight></codeline>
<codeline lineno="4123"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Count(0),</highlight></codeline>
<codeline lineno="4124"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Capacity(0)<sp/>{}</highlight></codeline>
<codeline lineno="4125"><highlight class="normal"></highlight></codeline>
<codeline lineno="4126"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AllocatorT&gt;</highlight></codeline>
<codeline lineno="4127"><highlight class="normal">VmaVector&lt;T,<sp/>AllocatorT&gt;::VmaVector(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>count,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>AllocatorT&amp;<sp/>allocator)</highlight></codeline>
<codeline lineno="4128"><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>m_Allocator(<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>),</highlight></codeline>
<codeline lineno="4129"><highlight class="normal"><sp/><sp/><sp/><sp/>m_pArray(count<sp/>?<sp/>(T*)VmaAllocateArray&lt;T&gt;(<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>.m_pCallbacks,<sp/>count)<sp/>:<sp/>VMA_NULL),</highlight></codeline>
<codeline lineno="4130"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Count(count),</highlight></codeline>
<codeline lineno="4131"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Capacity(count)<sp/>{}</highlight></codeline>
<codeline lineno="4132"><highlight class="normal"></highlight></codeline>
<codeline lineno="4133"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AllocatorT&gt;</highlight></codeline>
<codeline lineno="4134"><highlight class="normal">VmaVector&lt;T,<sp/>AllocatorT&gt;::VmaVector(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaVector&amp;<sp/>src)</highlight></codeline>
<codeline lineno="4135"><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>m_Allocator(src.m_Allocator),</highlight></codeline>
<codeline lineno="4136"><highlight class="normal"><sp/><sp/><sp/><sp/>m_pArray(src.m_Count<sp/>?<sp/>(T*)VmaAllocateArray&lt;T&gt;(src.m_Allocator.m_pCallbacks,<sp/>src.m_Count)<sp/>:<sp/>VMA_NULL),</highlight></codeline>
<codeline lineno="4137"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Count(src.m_Count),</highlight></codeline>
<codeline lineno="4138"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Capacity(src.m_Count)</highlight></codeline>
<codeline lineno="4139"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4140"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_Count<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="4141"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(m_pArray,<sp/>src.m_pArray,<sp/>m_Count<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(T));</highlight></codeline>
<codeline lineno="4143"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4144"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4145"><highlight class="normal"></highlight></codeline>
<codeline lineno="4146"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AllocatorT&gt;</highlight></codeline>
<codeline lineno="4147"><highlight class="normal">VmaVector&lt;T,<sp/>AllocatorT&gt;&amp;<sp/>VmaVector&lt;T,<sp/>AllocatorT&gt;::operator=(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaVector&amp;<sp/>rhs)</highlight></codeline>
<codeline lineno="4148"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4149"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(&amp;rhs<sp/>!=<sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="4150"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>resize(rhs.m_Count);</highlight></codeline>
<codeline lineno="4152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_Count<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="4153"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4154"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(m_pArray,<sp/>rhs.m_pArray,<sp/>m_Count<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(T));</highlight></codeline>
<codeline lineno="4155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4156"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4157"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="4158"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4159"><highlight class="normal"></highlight></codeline>
<codeline lineno="4160"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AllocatorT&gt;</highlight></codeline>
<codeline lineno="4161"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaVector&lt;T,<sp/>AllocatorT&gt;::push_back(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>src)</highlight></codeline>
<codeline lineno="4162"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4163"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>newIndex<sp/>=<sp/>size();</highlight></codeline>
<codeline lineno="4164"><highlight class="normal"><sp/><sp/><sp/><sp/>resize(newIndex<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="4165"><highlight class="normal"><sp/><sp/><sp/><sp/>m_pArray[newIndex]<sp/>=<sp/>src;</highlight></codeline>
<codeline lineno="4166"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4167"><highlight class="normal"></highlight></codeline>
<codeline lineno="4168"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AllocatorT&gt;</highlight></codeline>
<codeline lineno="4169"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaVector&lt;T,<sp/>AllocatorT&gt;::reserve(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>newCapacity,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>freeMemory)</highlight></codeline>
<codeline lineno="4170"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4171"><highlight class="normal"><sp/><sp/><sp/><sp/>newCapacity<sp/>=<sp/>VMA_MAX(newCapacity,<sp/>m_Count);</highlight></codeline>
<codeline lineno="4172"><highlight class="normal"></highlight></codeline>
<codeline lineno="4173"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((newCapacity<sp/>&lt;<sp/>m_Capacity)<sp/>&amp;&amp;<sp/>!freeMemory)</highlight></codeline>
<codeline lineno="4174"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newCapacity<sp/>=<sp/>m_Capacity;</highlight></codeline>
<codeline lineno="4176"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4177"><highlight class="normal"></highlight></codeline>
<codeline lineno="4178"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(newCapacity<sp/>!=<sp/>m_Capacity)</highlight></codeline>
<codeline lineno="4179"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>newArray<sp/>=<sp/>newCapacity<sp/>?<sp/>VmaAllocateArray&lt;T&gt;(m_Allocator,<sp/>newCapacity)<sp/>:<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="4181"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_Count<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="4182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(newArray,<sp/>m_pArray,<sp/>m_Count<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(T));</highlight></codeline>
<codeline lineno="4184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaFree(m_Allocator.m_pCallbacks,<sp/>m_pArray);</highlight></codeline>
<codeline lineno="4186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Capacity<sp/>=<sp/>newCapacity;</highlight></codeline>
<codeline lineno="4187"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pArray<sp/>=<sp/>newArray;</highlight></codeline>
<codeline lineno="4188"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4189"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4190"><highlight class="normal"></highlight></codeline>
<codeline lineno="4191"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AllocatorT&gt;</highlight></codeline>
<codeline lineno="4192"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaVector&lt;T,<sp/>AllocatorT&gt;::resize(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>newCount)</highlight></codeline>
<codeline lineno="4193"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4194"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>newCapacity<sp/>=<sp/>m_Capacity;</highlight></codeline>
<codeline lineno="4195"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(newCount<sp/>&gt;<sp/>m_Capacity)</highlight></codeline>
<codeline lineno="4196"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newCapacity<sp/>=<sp/>VMA_MAX(newCount,<sp/>VMA_MAX(m_Capacity<sp/>*<sp/>3<sp/>/<sp/>2,<sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal">)8));</highlight></codeline>
<codeline lineno="4198"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4199"><highlight class="normal"></highlight></codeline>
<codeline lineno="4200"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(newCapacity<sp/>!=<sp/>m_Capacity)</highlight></codeline>
<codeline lineno="4201"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>newArray<sp/>=<sp/>newCapacity<sp/>?<sp/>VmaAllocateArray&lt;T&gt;(m_Allocator.m_pCallbacks,<sp/>newCapacity)<sp/>:<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="4203"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>elementsToCopy<sp/>=<sp/>VMA_MIN(m_Count,<sp/>newCount);</highlight></codeline>
<codeline lineno="4204"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(elementsToCopy<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="4205"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4206"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(newArray,<sp/>m_pArray,<sp/>elementsToCopy<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(T));</highlight></codeline>
<codeline lineno="4207"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaFree(m_Allocator.m_pCallbacks,<sp/>m_pArray);</highlight></codeline>
<codeline lineno="4209"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Capacity<sp/>=<sp/>newCapacity;</highlight></codeline>
<codeline lineno="4210"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pArray<sp/>=<sp/>newArray;</highlight></codeline>
<codeline lineno="4211"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4212"><highlight class="normal"></highlight></codeline>
<codeline lineno="4213"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Count<sp/>=<sp/>newCount;</highlight></codeline>
<codeline lineno="4214"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4215"><highlight class="normal"></highlight></codeline>
<codeline lineno="4216"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AllocatorT&gt;</highlight></codeline>
<codeline lineno="4217"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaVector&lt;T,<sp/>AllocatorT&gt;::shrink_to_fit()</highlight></codeline>
<codeline lineno="4218"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4219"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_Capacity<sp/>&gt;<sp/>m_Count)</highlight></codeline>
<codeline lineno="4220"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4221"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T*<sp/>newArray<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="4222"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_Count<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="4223"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4224"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newArray<sp/>=<sp/>VmaAllocateArray&lt;T&gt;(m_Allocator.m_pCallbacks,<sp/>m_Count);</highlight></codeline>
<codeline lineno="4225"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(newArray,<sp/>m_pArray,<sp/>m_Count<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(T));</highlight></codeline>
<codeline lineno="4226"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4227"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaFree(m_Allocator.m_pCallbacks,<sp/>m_pArray);</highlight></codeline>
<codeline lineno="4228"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Capacity<sp/>=<sp/>m_Count;</highlight></codeline>
<codeline lineno="4229"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pArray<sp/>=<sp/>newArray;</highlight></codeline>
<codeline lineno="4230"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4231"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4232"><highlight class="normal"></highlight></codeline>
<codeline lineno="4233"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AllocatorT&gt;</highlight></codeline>
<codeline lineno="4234"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaVector&lt;T,<sp/>AllocatorT&gt;::insert(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>src)</highlight></codeline>
<codeline lineno="4235"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4236"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(index<sp/>&lt;=<sp/>m_Count);</highlight></codeline>
<codeline lineno="4237"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>oldCount<sp/>=<sp/>size();</highlight></codeline>
<codeline lineno="4238"><highlight class="normal"><sp/><sp/><sp/><sp/>resize(oldCount<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="4239"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(index<sp/>&lt;<sp/>oldCount)</highlight></codeline>
<codeline lineno="4240"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4241"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memmove(m_pArray<sp/>+<sp/>(index<sp/>+<sp/>1),<sp/>m_pArray<sp/>+<sp/>index,<sp/>(oldCount<sp/>-<sp/>index)<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(T));</highlight></codeline>
<codeline lineno="4242"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4243"><highlight class="normal"><sp/><sp/><sp/><sp/>m_pArray[index]<sp/>=<sp/>src;</highlight></codeline>
<codeline lineno="4244"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4245"><highlight class="normal"></highlight></codeline>
<codeline lineno="4246"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AllocatorT&gt;</highlight></codeline>
<codeline lineno="4247"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaVector&lt;T,<sp/>AllocatorT&gt;::remove(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index)</highlight></codeline>
<codeline lineno="4248"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4249"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(index<sp/>&lt;<sp/>m_Count);</highlight></codeline>
<codeline lineno="4250"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>oldCount<sp/>=<sp/>size();</highlight></codeline>
<codeline lineno="4251"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(index<sp/>&lt;<sp/>oldCount<sp/>-<sp/>1)</highlight></codeline>
<codeline lineno="4252"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4253"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memmove(m_pArray<sp/>+<sp/>index,<sp/>m_pArray<sp/>+<sp/>(index<sp/>+<sp/>1),<sp/>(oldCount<sp/>-<sp/>index<sp/>-<sp/>1)<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(T));</highlight></codeline>
<codeline lineno="4254"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4255"><highlight class="normal"><sp/><sp/><sp/><sp/>resize(oldCount<sp/>-<sp/>1);</highlight></codeline>
<codeline lineno="4256"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4257"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_VECTOR_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4258"><highlight class="normal"></highlight></codeline>
<codeline lineno="4259"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>allocatorT&gt;</highlight></codeline>
<codeline lineno="4260"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaVectorInsert(VmaVector&lt;T,<sp/>allocatorT&gt;&amp;<sp/>vec,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>item)</highlight></codeline>
<codeline lineno="4261"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4262"><highlight class="normal"><sp/><sp/><sp/><sp/>vec.insert(index,<sp/>item);</highlight></codeline>
<codeline lineno="4263"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4264"><highlight class="normal"></highlight></codeline>
<codeline lineno="4265"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>allocatorT&gt;</highlight></codeline>
<codeline lineno="4266"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaVectorRemove(VmaVector&lt;T,<sp/>allocatorT&gt;&amp;<sp/>vec,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index)</highlight></codeline>
<codeline lineno="4267"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4268"><highlight class="normal"><sp/><sp/><sp/><sp/>vec.remove(index);</highlight></codeline>
<codeline lineno="4269"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4270"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_VECTOR</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4271"><highlight class="normal"></highlight></codeline>
<codeline lineno="4272"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_SMALL_VECTOR</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4273"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="4274"><highlight class="comment">This<sp/>is<sp/>a<sp/>vector<sp/>(a<sp/>variable-sized<sp/>array),<sp/>optimized<sp/>for<sp/>the<sp/>case<sp/>when<sp/>the<sp/>array<sp/>is<sp/>small.</highlight></codeline>
<codeline lineno="4275"><highlight class="comment"></highlight></codeline>
<codeline lineno="4276"><highlight class="comment">It<sp/>contains<sp/>some<sp/>number<sp/>of<sp/>elements<sp/>in-place,<sp/>which<sp/>allows<sp/>it<sp/>to<sp/>avoid<sp/>heap<sp/>allocation</highlight></codeline>
<codeline lineno="4277"><highlight class="comment">when<sp/>the<sp/>actual<sp/>number<sp/>of<sp/>elements<sp/>is<sp/>below<sp/>that<sp/>threshold.<sp/>This<sp/>allows<sp/>normal<sp/>&quot;small&quot;</highlight></codeline>
<codeline lineno="4278"><highlight class="comment">cases<sp/>to<sp/>be<sp/>fast<sp/>without<sp/>losing<sp/>generality<sp/>for<sp/>large<sp/>inputs.</highlight></codeline>
<codeline lineno="4279"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4280"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AllocatorT,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>N&gt;</highlight></codeline>
<codeline lineno="4281"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaSmallVector</highlight></codeline>
<codeline lineno="4282"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4283"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="4284"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>T<sp/>value_type;</highlight></codeline>
<codeline lineno="4285"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>T*<sp/>iterator;</highlight></codeline>
<codeline lineno="4286"><highlight class="normal"></highlight></codeline>
<codeline lineno="4287"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSmallVector(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>AllocatorT&amp;<sp/>allocator);</highlight></codeline>
<codeline lineno="4288"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSmallVector(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>count,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>AllocatorT&amp;<sp/>allocator);</highlight></codeline>
<codeline lineno="4289"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>SrcT,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>SrcAllocatorT,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>SrcN&gt;</highlight></codeline>
<codeline lineno="4290"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSmallVector(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSmallVector&lt;SrcT,<sp/>SrcAllocatorT,<sp/>SrcN&gt;&amp;)<sp/>=<sp/></highlight><highlight class="keyword">delete</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="4291"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>SrcT,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>SrcAllocatorT,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>SrcN&gt;</highlight></codeline>
<codeline lineno="4292"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSmallVector&lt;T,<sp/>AllocatorT,<sp/>N&gt;&amp;<sp/>operator=(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSmallVector&lt;SrcT,<sp/>SrcAllocatorT,<sp/>SrcN&gt;&amp;)<sp/>=<sp/></highlight><highlight class="keyword">delete</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="4293"><highlight class="normal"><sp/><sp/><sp/><sp/>~VmaSmallVector()<sp/>=<sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="4294"><highlight class="normal"></highlight></codeline>
<codeline lineno="4295"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>empty()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Count<sp/>==<sp/>0;<sp/>}</highlight></codeline>
<codeline lineno="4296"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Count;<sp/>}</highlight></codeline>
<codeline lineno="4297"><highlight class="normal"><sp/><sp/><sp/><sp/>T*<sp/>data()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Count<sp/>&gt;<sp/>N<sp/>?<sp/>m_DynamicArray.data()<sp/>:<sp/>m_StaticArray;<sp/>}</highlight></codeline>
<codeline lineno="4298"><highlight class="normal"><sp/><sp/><sp/><sp/>T&amp;<sp/>front()<sp/>{<sp/>VMA_HEAVY_ASSERT(m_Count<sp/>&gt;<sp/>0);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>data()[0];<sp/>}</highlight></codeline>
<codeline lineno="4299"><highlight class="normal"><sp/><sp/><sp/><sp/>T&amp;<sp/>back()<sp/>{<sp/>VMA_HEAVY_ASSERT(m_Count<sp/>&gt;<sp/>0);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>data()[m_Count<sp/>-<sp/>1];<sp/>}</highlight></codeline>
<codeline lineno="4300"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T*<sp/>data()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Count<sp/>&gt;<sp/>N<sp/>?<sp/>m_DynamicArray.data()<sp/>:<sp/>m_StaticArray;<sp/>}</highlight></codeline>
<codeline lineno="4301"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>front()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/>VMA_HEAVY_ASSERT(m_Count<sp/>&gt;<sp/>0);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>data()[0];<sp/>}</highlight></codeline>
<codeline lineno="4302"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>back()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/>VMA_HEAVY_ASSERT(m_Count<sp/>&gt;<sp/>0);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>data()[m_Count<sp/>-<sp/>1];<sp/>}</highlight></codeline>
<codeline lineno="4303"><highlight class="normal"></highlight></codeline>
<codeline lineno="4304"><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>begin()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>data();<sp/>}</highlight></codeline>
<codeline lineno="4305"><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>end()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>data()<sp/>+<sp/>m_Count;<sp/>}</highlight></codeline>
<codeline lineno="4306"><highlight class="normal"></highlight></codeline>
<codeline lineno="4307"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>pop_front()<sp/>{<sp/>VMA_HEAVY_ASSERT(m_Count<sp/>&gt;<sp/>0);<sp/>remove(0);<sp/>}</highlight></codeline>
<codeline lineno="4308"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>pop_back()<sp/>{<sp/>VMA_HEAVY_ASSERT(m_Count<sp/>&gt;<sp/>0);<sp/>resize(size()<sp/>-<sp/>1);<sp/>}</highlight></codeline>
<codeline lineno="4309"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>push_front(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>src)<sp/>{<sp/>insert(0,<sp/>src);<sp/>}</highlight></codeline>
<codeline lineno="4310"><highlight class="normal"></highlight></codeline>
<codeline lineno="4311"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>push_back(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>src);</highlight></codeline>
<codeline lineno="4312"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>resize(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>newCount,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>freeMemory<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="4313"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>clear(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>freeMemory<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="4314"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>insert(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>src);</highlight></codeline>
<codeline lineno="4315"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>remove(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index);</highlight></codeline>
<codeline lineno="4316"><highlight class="normal"></highlight></codeline>
<codeline lineno="4317"><highlight class="normal"><sp/><sp/><sp/><sp/>T&amp;<sp/>operator[](</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index)<sp/>{<sp/>VMA_HEAVY_ASSERT(index<sp/>&lt;<sp/>m_Count);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>data()[index];<sp/>}</highlight></codeline>
<codeline lineno="4318"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>operator[](</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/>VMA_HEAVY_ASSERT(index<sp/>&lt;<sp/>m_Count);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>data()[index];<sp/>}</highlight></codeline>
<codeline lineno="4319"><highlight class="normal"></highlight></codeline>
<codeline lineno="4320"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="4321"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>m_Count;</highlight></codeline>
<codeline lineno="4322"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>m_StaticArray[N];<sp/></highlight><highlight class="comment">//<sp/>Used<sp/>when<sp/>m_Size<sp/>&lt;=<sp/>N</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4323"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaVector&lt;T,<sp/>AllocatorT&gt;<sp/>m_DynamicArray;<sp/></highlight><highlight class="comment">//<sp/>Used<sp/>when<sp/>m_Size<sp/>&gt;<sp/>N</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4324"><highlight class="normal">};</highlight></codeline>
<codeline lineno="4325"><highlight class="normal"></highlight></codeline>
<codeline lineno="4326"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_SMALL_VECTOR_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4327"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AllocatorT,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>N&gt;</highlight></codeline>
<codeline lineno="4328"><highlight class="normal">VmaSmallVector&lt;T,<sp/>AllocatorT,<sp/>N&gt;::VmaSmallVector(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>AllocatorT&amp;<sp/>allocator)</highlight></codeline>
<codeline lineno="4329"><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>m_Count(0),</highlight></codeline>
<codeline lineno="4330"><highlight class="normal"><sp/><sp/><sp/><sp/>m_DynamicArray(<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>)<sp/>{}</highlight></codeline>
<codeline lineno="4331"><highlight class="normal"></highlight></codeline>
<codeline lineno="4332"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AllocatorT,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>N&gt;</highlight></codeline>
<codeline lineno="4333"><highlight class="normal">VmaSmallVector&lt;T,<sp/>AllocatorT,<sp/>N&gt;::VmaSmallVector(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>count,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>AllocatorT&amp;<sp/>allocator)</highlight></codeline>
<codeline lineno="4334"><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>m_Count(count),</highlight></codeline>
<codeline lineno="4335"><highlight class="normal"><sp/><sp/><sp/><sp/>m_DynamicArray(count<sp/>&gt;<sp/>N<sp/>?<sp/>count<sp/>:<sp/>0,<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>)<sp/>{}</highlight></codeline>
<codeline lineno="4336"><highlight class="normal"></highlight></codeline>
<codeline lineno="4337"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AllocatorT,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>N&gt;</highlight></codeline>
<codeline lineno="4338"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaSmallVector&lt;T,<sp/>AllocatorT,<sp/>N&gt;::push_back(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>src)</highlight></codeline>
<codeline lineno="4339"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4340"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>newIndex<sp/>=<sp/>size();</highlight></codeline>
<codeline lineno="4341"><highlight class="normal"><sp/><sp/><sp/><sp/>resize(newIndex<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="4342"><highlight class="normal"><sp/><sp/><sp/><sp/>data()[newIndex]<sp/>=<sp/>src;</highlight></codeline>
<codeline lineno="4343"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4344"><highlight class="normal"></highlight></codeline>
<codeline lineno="4345"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AllocatorT,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>N&gt;</highlight></codeline>
<codeline lineno="4346"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaSmallVector&lt;T,<sp/>AllocatorT,<sp/>N&gt;::resize(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>newCount,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>freeMemory)</highlight></codeline>
<codeline lineno="4347"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4348"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(newCount<sp/>&gt;<sp/>N<sp/>&amp;&amp;<sp/>m_Count<sp/>&gt;<sp/>N)</highlight></codeline>
<codeline lineno="4349"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Any<sp/>direction,<sp/>staying<sp/>in<sp/>m_DynamicArray</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_DynamicArray.resize(newCount);</highlight></codeline>
<codeline lineno="4352"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(freeMemory)</highlight></codeline>
<codeline lineno="4353"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4354"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_DynamicArray.shrink_to_fit();</highlight></codeline>
<codeline lineno="4355"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4356"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4357"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(newCount<sp/>&gt;<sp/>N<sp/>&amp;&amp;<sp/>m_Count<sp/>&lt;=<sp/>N)</highlight></codeline>
<codeline lineno="4358"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4359"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Growing,<sp/>moving<sp/>from<sp/>m_StaticArray<sp/>to<sp/>m_DynamicArray</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4360"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_DynamicArray.resize(newCount);</highlight></codeline>
<codeline lineno="4361"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_Count<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="4362"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4363"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(m_DynamicArray.data(),<sp/>m_StaticArray,<sp/>m_Count<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(T));</highlight></codeline>
<codeline lineno="4364"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4365"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4366"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(newCount<sp/>&lt;=<sp/>N<sp/>&amp;&amp;<sp/>m_Count<sp/>&gt;<sp/>N)</highlight></codeline>
<codeline lineno="4367"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4368"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Shrinking,<sp/>moving<sp/>from<sp/>m_DynamicArray<sp/>to<sp/>m_StaticArray</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4369"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(newCount<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="4370"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4371"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(m_StaticArray,<sp/>m_DynamicArray.data(),<sp/>newCount<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(T));</highlight></codeline>
<codeline lineno="4372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4373"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_DynamicArray.resize(0);</highlight></codeline>
<codeline lineno="4374"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(freeMemory)</highlight></codeline>
<codeline lineno="4375"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4376"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_DynamicArray.shrink_to_fit();</highlight></codeline>
<codeline lineno="4377"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4378"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4379"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4380"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4381"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Any<sp/>direction,<sp/>staying<sp/>in<sp/>m_StaticArray<sp/>-<sp/>nothing<sp/>to<sp/>do<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4382"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4383"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Count<sp/>=<sp/>newCount;</highlight></codeline>
<codeline lineno="4384"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4385"><highlight class="normal"></highlight></codeline>
<codeline lineno="4386"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AllocatorT,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>N&gt;</highlight></codeline>
<codeline lineno="4387"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaSmallVector&lt;T,<sp/>AllocatorT,<sp/>N&gt;::clear(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>freeMemory)</highlight></codeline>
<codeline lineno="4388"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4389"><highlight class="normal"><sp/><sp/><sp/><sp/>m_DynamicArray.clear();</highlight></codeline>
<codeline lineno="4390"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(freeMemory)</highlight></codeline>
<codeline lineno="4391"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4392"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_DynamicArray.shrink_to_fit();</highlight></codeline>
<codeline lineno="4393"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4394"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Count<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="4395"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4396"><highlight class="normal"></highlight></codeline>
<codeline lineno="4397"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AllocatorT,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>N&gt;</highlight></codeline>
<codeline lineno="4398"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaSmallVector&lt;T,<sp/>AllocatorT,<sp/>N&gt;::insert(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>src)</highlight></codeline>
<codeline lineno="4399"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4400"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(index<sp/>&lt;=<sp/>m_Count);</highlight></codeline>
<codeline lineno="4401"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>oldCount<sp/>=<sp/>size();</highlight></codeline>
<codeline lineno="4402"><highlight class="normal"><sp/><sp/><sp/><sp/>resize(oldCount<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="4403"><highlight class="normal"><sp/><sp/><sp/><sp/>T*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>dataPtr<sp/>=<sp/>data();</highlight></codeline>
<codeline lineno="4404"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(index<sp/>&lt;<sp/>oldCount)</highlight></codeline>
<codeline lineno="4405"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4406"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>I<sp/>know,<sp/>this<sp/>could<sp/>be<sp/>more<sp/>optimal<sp/>for<sp/>case<sp/>where<sp/>memmove<sp/>can<sp/>be<sp/>memcpy<sp/>directly<sp/>from<sp/>m_StaticArray<sp/>to<sp/>m_DynamicArray.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4407"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memmove(dataPtr<sp/>+<sp/>(index<sp/>+<sp/>1),<sp/>dataPtr<sp/>+<sp/>index,<sp/>(oldCount<sp/>-<sp/>index)<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(T));</highlight></codeline>
<codeline lineno="4408"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4409"><highlight class="normal"><sp/><sp/><sp/><sp/>dataPtr[index]<sp/>=<sp/>src;</highlight></codeline>
<codeline lineno="4410"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4411"><highlight class="normal"></highlight></codeline>
<codeline lineno="4412"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AllocatorT,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>N&gt;</highlight></codeline>
<codeline lineno="4413"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaSmallVector&lt;T,<sp/>AllocatorT,<sp/>N&gt;::remove(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index)</highlight></codeline>
<codeline lineno="4414"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4415"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(index<sp/>&lt;<sp/>m_Count);</highlight></codeline>
<codeline lineno="4416"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>oldCount<sp/>=<sp/>size();</highlight></codeline>
<codeline lineno="4417"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(index<sp/>&lt;<sp/>oldCount<sp/>-<sp/>1)</highlight></codeline>
<codeline lineno="4418"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4419"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>I<sp/>know,<sp/>this<sp/>could<sp/>be<sp/>more<sp/>optimal<sp/>for<sp/>case<sp/>where<sp/>memmove<sp/>can<sp/>be<sp/>memcpy<sp/>directly<sp/>from<sp/>m_DynamicArray<sp/>to<sp/>m_StaticArray.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4420"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>dataPtr<sp/>=<sp/>data();</highlight></codeline>
<codeline lineno="4421"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memmove(dataPtr<sp/>+<sp/>index,<sp/>dataPtr<sp/>+<sp/>(index<sp/>+<sp/>1),<sp/>(oldCount<sp/>-<sp/>index<sp/>-<sp/>1)<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(T));</highlight></codeline>
<codeline lineno="4422"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4423"><highlight class="normal"><sp/><sp/><sp/><sp/>resize(oldCount<sp/>-<sp/>1);</highlight></codeline>
<codeline lineno="4424"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4425"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_SMALL_VECTOR_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4426"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_SMALL_VECTOR</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4427"><highlight class="normal"></highlight></codeline>
<codeline lineno="4428"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_POOL_ALLOCATOR</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4429"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="4430"><highlight class="comment">Allocator<sp/>for<sp/>objects<sp/>of<sp/>type<sp/>T<sp/>using<sp/>a<sp/>list<sp/>of<sp/>arrays<sp/>(pools)<sp/>to<sp/>speed<sp/>up</highlight></codeline>
<codeline lineno="4431"><highlight class="comment">allocation.<sp/>Number<sp/>of<sp/>elements<sp/>that<sp/>can<sp/>be<sp/>allocated<sp/>is<sp/>not<sp/>bounded<sp/>because</highlight></codeline>
<codeline lineno="4432"><highlight class="comment">allocator<sp/>can<sp/>create<sp/>multiple<sp/>blocks.</highlight></codeline>
<codeline lineno="4433"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4434"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="4435"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaPoolAllocator</highlight></codeline>
<codeline lineno="4436"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4437"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_CLASS_NO_COPY(VmaPoolAllocator)</highlight></codeline>
<codeline lineno="4438"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="4439"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaPoolAllocator(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks,<sp/>uint32_t<sp/>firstBlockCapacity);</highlight></codeline>
<codeline lineno="4440"><highlight class="normal"><sp/><sp/><sp/><sp/>~VmaPoolAllocator();</highlight></codeline>
<codeline lineno="4441"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal">...<sp/>Types&gt;<sp/>T*<sp/>Alloc(Types&amp;&amp;...<sp/>args);</highlight></codeline>
<codeline lineno="4442"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Free(T*<sp/>ptr);</highlight></codeline>
<codeline lineno="4443"><highlight class="normal"></highlight></codeline>
<codeline lineno="4444"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="4445"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">union<sp/></highlight><highlight class="normal">Item</highlight></codeline>
<codeline lineno="4446"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4447"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>NextFreeIndex;</highlight></codeline>
<codeline lineno="4448"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">alignas</highlight><highlight class="normal">(T)<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>Value[</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(T)];</highlight></codeline>
<codeline lineno="4449"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="4450"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">ItemBlock</highlight></codeline>
<codeline lineno="4451"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4452"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Item*<sp/>pItems;</highlight></codeline>
<codeline lineno="4453"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>Capacity;</highlight></codeline>
<codeline lineno="4454"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>FirstFreeIndex;</highlight></codeline>
<codeline lineno="4455"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="4456"><highlight class="normal"></highlight></codeline>
<codeline lineno="4457"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>m_pAllocationCallbacks;</highlight></codeline>
<codeline lineno="4458"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>m_FirstBlockCapacity;</highlight></codeline>
<codeline lineno="4459"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaVector&lt;ItemBlock,<sp/>VmaStlAllocator&lt;ItemBlock&gt;&gt;<sp/>m_ItemBlocks;</highlight></codeline>
<codeline lineno="4460"><highlight class="normal"></highlight></codeline>
<codeline lineno="4461"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemBlock&amp;<sp/>CreateNewBlock();</highlight></codeline>
<codeline lineno="4462"><highlight class="normal">};</highlight></codeline>
<codeline lineno="4463"><highlight class="normal"></highlight></codeline>
<codeline lineno="4464"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_POOL_ALLOCATOR_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4465"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="4466"><highlight class="normal">VmaPoolAllocator&lt;T&gt;::VmaPoolAllocator(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks,<sp/>uint32_t<sp/>firstBlockCapacity)</highlight></codeline>
<codeline lineno="4467"><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>m_pAllocationCallbacks(pAllocationCallbacks),</highlight></codeline>
<codeline lineno="4468"><highlight class="normal"><sp/><sp/><sp/><sp/>m_FirstBlockCapacity(firstBlockCapacity),</highlight></codeline>
<codeline lineno="4469"><highlight class="normal"><sp/><sp/><sp/><sp/>m_ItemBlocks(VmaStlAllocator&lt;ItemBlock&gt;(pAllocationCallbacks))</highlight></codeline>
<codeline lineno="4470"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4471"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_FirstBlockCapacity<sp/>&gt;<sp/>1);</highlight></codeline>
<codeline lineno="4472"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4473"><highlight class="normal"></highlight></codeline>
<codeline lineno="4474"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="4475"><highlight class="normal">VmaPoolAllocator&lt;T&gt;::~VmaPoolAllocator()</highlight></codeline>
<codeline lineno="4476"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4477"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>m_ItemBlocks.size();<sp/>i--;)</highlight></codeline>
<codeline lineno="4478"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vma_delete_array(m_pAllocationCallbacks,<sp/>m_ItemBlocks[i].pItems,<sp/>m_ItemBlocks[i].Capacity);</highlight></codeline>
<codeline lineno="4479"><highlight class="normal"><sp/><sp/><sp/><sp/>m_ItemBlocks.clear();</highlight></codeline>
<codeline lineno="4480"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4481"><highlight class="normal"></highlight></codeline>
<codeline lineno="4482"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="4483"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal">...<sp/>Types&gt;<sp/>T*<sp/>VmaPoolAllocator&lt;T&gt;::Alloc(Types&amp;&amp;...<sp/>args)</highlight></codeline>
<codeline lineno="4484"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4485"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>m_ItemBlocks.size();<sp/>i--;<sp/>)</highlight></codeline>
<codeline lineno="4486"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4487"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemBlock&amp;<sp/>block<sp/>=<sp/>m_ItemBlocks[i];</highlight></codeline>
<codeline lineno="4488"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>block<sp/>has<sp/>some<sp/>free<sp/>items:<sp/>Use<sp/>first<sp/>one.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4489"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(block.FirstFreeIndex<sp/>!=<sp/>UINT32_MAX)</highlight></codeline>
<codeline lineno="4490"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4491"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Item*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>pItem<sp/>=<sp/>&amp;block.pItems[block.FirstFreeIndex];</highlight></codeline>
<codeline lineno="4492"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block.FirstFreeIndex<sp/>=<sp/>pItem-&gt;NextFreeIndex;</highlight></codeline>
<codeline lineno="4493"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T*<sp/>result<sp/>=<sp/>(T*)&amp;pItem-&gt;Value;</highlight></codeline>
<codeline lineno="4494"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(result)T(std::forward&lt;Types&gt;(args)...);<sp/></highlight><highlight class="comment">//<sp/>Explicit<sp/>constructor<sp/>call.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4495"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>result;</highlight></codeline>
<codeline lineno="4496"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4497"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4498"><highlight class="normal"></highlight></codeline>
<codeline lineno="4499"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>No<sp/>block<sp/>has<sp/>free<sp/>item:<sp/>Create<sp/>new<sp/>one<sp/>and<sp/>use<sp/>it.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4500"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemBlock&amp;<sp/>newBlock<sp/>=<sp/>CreateNewBlock();</highlight></codeline>
<codeline lineno="4501"><highlight class="normal"><sp/><sp/><sp/><sp/>Item*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>pItem<sp/>=<sp/>&amp;newBlock.pItems[0];</highlight></codeline>
<codeline lineno="4502"><highlight class="normal"><sp/><sp/><sp/><sp/>newBlock.FirstFreeIndex<sp/>=<sp/>pItem-&gt;NextFreeIndex;</highlight></codeline>
<codeline lineno="4503"><highlight class="normal"><sp/><sp/><sp/><sp/>T*<sp/>result<sp/>=<sp/>(T*)&amp;pItem-&gt;Value;</highlight></codeline>
<codeline lineno="4504"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(result)<sp/>T(std::forward&lt;Types&gt;(args)...);<sp/></highlight><highlight class="comment">//<sp/>Explicit<sp/>constructor<sp/>call.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4505"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>result;</highlight></codeline>
<codeline lineno="4506"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4507"><highlight class="normal"></highlight></codeline>
<codeline lineno="4508"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="4509"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaPoolAllocator&lt;T&gt;::Free(T*<sp/>ptr)</highlight></codeline>
<codeline lineno="4510"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4511"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Search<sp/>all<sp/>memory<sp/>blocks<sp/>to<sp/>find<sp/>ptr.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4512"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>m_ItemBlocks.size();<sp/>i--;<sp/>)</highlight></codeline>
<codeline lineno="4513"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4514"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemBlock&amp;<sp/>block<sp/>=<sp/>m_ItemBlocks[i];</highlight></codeline>
<codeline lineno="4515"><highlight class="normal"></highlight></codeline>
<codeline lineno="4516"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Casting<sp/>to<sp/>union.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4517"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Item*<sp/>pItemPtr;</highlight></codeline>
<codeline lineno="4518"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(&amp;pItemPtr,<sp/>&amp;ptr,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(pItemPtr));</highlight></codeline>
<codeline lineno="4519"><highlight class="normal"></highlight></codeline>
<codeline lineno="4520"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>if<sp/>pItemPtr<sp/>is<sp/>in<sp/>address<sp/>range<sp/>of<sp/>this<sp/>block.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4521"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((pItemPtr<sp/>&gt;=<sp/>block.pItems)<sp/>&amp;&amp;<sp/>(pItemPtr<sp/>&lt;<sp/>block.pItems<sp/>+<sp/>block.Capacity))</highlight></codeline>
<codeline lineno="4522"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4523"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ptr-&gt;~T();<sp/></highlight><highlight class="comment">//<sp/>Explicit<sp/>destructor<sp/>call.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4524"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>index<sp/>=<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">uint32_t</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(pItemPtr<sp/>-<sp/>block.pItems);</highlight></codeline>
<codeline lineno="4525"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pItemPtr-&gt;NextFreeIndex<sp/>=<sp/>block.FirstFreeIndex;</highlight></codeline>
<codeline lineno="4526"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block.FirstFreeIndex<sp/>=<sp/>index;</highlight></codeline>
<codeline lineno="4527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="4528"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4529"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4530"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Pointer<sp/>doesn&apos;t<sp/>belong<sp/>to<sp/>this<sp/>memory<sp/>pool.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="4531"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4532"><highlight class="normal"></highlight></codeline>
<codeline lineno="4533"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="4534"><highlight class="normal"></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>VmaPoolAllocator&lt;T&gt;::ItemBlock&amp;<sp/>VmaPoolAllocator&lt;T&gt;::CreateNewBlock()</highlight></codeline>
<codeline lineno="4535"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4536"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>newBlockCapacity<sp/>=<sp/>m_ItemBlocks.empty()<sp/>?</highlight></codeline>
<codeline lineno="4537"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_FirstBlockCapacity<sp/>:<sp/>m_ItemBlocks.back().Capacity<sp/>*<sp/>3<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="4538"><highlight class="normal"></highlight></codeline>
<codeline lineno="4539"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ItemBlock<sp/>newBlock<sp/>=</highlight></codeline>
<codeline lineno="4540"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4541"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vma_new_array(m_pAllocationCallbacks,<sp/>Item,<sp/>newBlockCapacity),</highlight></codeline>
<codeline lineno="4542"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newBlockCapacity,</highlight></codeline>
<codeline lineno="4543"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0</highlight></codeline>
<codeline lineno="4544"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="4545"><highlight class="normal"></highlight></codeline>
<codeline lineno="4546"><highlight class="normal"><sp/><sp/><sp/><sp/>m_ItemBlocks.push_back(newBlock);</highlight></codeline>
<codeline lineno="4547"><highlight class="normal"></highlight></codeline>
<codeline lineno="4548"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Setup<sp/>singly-linked<sp/>list<sp/>of<sp/>all<sp/>free<sp/>items<sp/>in<sp/>this<sp/>block.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4549"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(uint32_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>newBlockCapacity<sp/>-<sp/>1;<sp/>++i)</highlight></codeline>
<codeline lineno="4550"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newBlock.pItems[i].NextFreeIndex<sp/>=<sp/>i<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="4551"><highlight class="normal"><sp/><sp/><sp/><sp/>newBlock.pItems[newBlockCapacity<sp/>-<sp/>1].NextFreeIndex<sp/>=<sp/>UINT32_MAX;</highlight></codeline>
<codeline lineno="4552"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_ItemBlocks.back();</highlight></codeline>
<codeline lineno="4553"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4554"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_POOL_ALLOCATOR_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4555"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_POOL_ALLOCATOR</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4556"><highlight class="normal"></highlight></codeline>
<codeline lineno="4557"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_RAW_LIST</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4558"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="4559"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaListItem</highlight></codeline>
<codeline lineno="4560"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4561"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaListItem*<sp/>pPrev;</highlight></codeline>
<codeline lineno="4562"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaListItem*<sp/>pNext;</highlight></codeline>
<codeline lineno="4563"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>Value;</highlight></codeline>
<codeline lineno="4564"><highlight class="normal">};</highlight></codeline>
<codeline lineno="4565"><highlight class="normal"></highlight></codeline>
<codeline lineno="4566"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Doubly<sp/>linked<sp/>list.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4567"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="4568"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaRawList</highlight></codeline>
<codeline lineno="4569"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4570"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_CLASS_NO_COPY(VmaRawList)</highlight></codeline>
<codeline lineno="4571"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="4572"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VmaListItem&lt;T&gt;<sp/>ItemType;</highlight></codeline>
<codeline lineno="4573"><highlight class="normal"></highlight></codeline>
<codeline lineno="4574"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaRawList(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks);</highlight></codeline>
<codeline lineno="4575"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Intentionally<sp/>not<sp/>calling<sp/>Clear,<sp/>because<sp/>that<sp/>would<sp/>be<sp/>unnecessary</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4576"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>computations<sp/>to<sp/>return<sp/>all<sp/>items<sp/>to<sp/>m_ItemAllocator<sp/>as<sp/>free.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4577"><highlight class="normal"><sp/><sp/><sp/><sp/>~VmaRawList()<sp/>=<sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="4578"><highlight class="normal"></highlight></codeline>
<codeline lineno="4579"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>GetCount()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Count;<sp/>}</highlight></codeline>
<codeline lineno="4580"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>IsEmpty()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Count<sp/>==<sp/>0;<sp/>}</highlight></codeline>
<codeline lineno="4581"><highlight class="normal"></highlight></codeline>
<codeline lineno="4582"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/>Front()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pFront;<sp/>}</highlight></codeline>
<codeline lineno="4583"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/>Back()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pBack;<sp/>}</highlight></codeline>
<codeline lineno="4584"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ItemType*<sp/>Front()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pFront;<sp/>}</highlight></codeline>
<codeline lineno="4585"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ItemType*<sp/>Back()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pBack;<sp/>}</highlight></codeline>
<codeline lineno="4586"><highlight class="normal"></highlight></codeline>
<codeline lineno="4587"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/>PushFront();</highlight></codeline>
<codeline lineno="4588"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/>PushBack();</highlight></codeline>
<codeline lineno="4589"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/>PushFront(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>value);</highlight></codeline>
<codeline lineno="4590"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/>PushBack(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>value);</highlight></codeline>
<codeline lineno="4591"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>PopFront();</highlight></codeline>
<codeline lineno="4592"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>PopBack();</highlight></codeline>
<codeline lineno="4593"><highlight class="normal"></highlight></codeline>
<codeline lineno="4594"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Item<sp/>can<sp/>be<sp/>null<sp/>-<sp/>it<sp/>means<sp/>PushBack.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4595"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/>InsertBefore(ItemType*<sp/>pItem);</highlight></codeline>
<codeline lineno="4596"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Item<sp/>can<sp/>be<sp/>null<sp/>-<sp/>it<sp/>means<sp/>PushFront.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4597"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/>InsertAfter(ItemType*<sp/>pItem);</highlight></codeline>
<codeline lineno="4598"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/>InsertBefore(ItemType*<sp/>pItem,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>value);</highlight></codeline>
<codeline lineno="4599"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/>InsertAfter(ItemType*<sp/>pItem,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>value);</highlight></codeline>
<codeline lineno="4600"><highlight class="normal"></highlight></codeline>
<codeline lineno="4601"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Clear();</highlight></codeline>
<codeline lineno="4602"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Remove(ItemType*<sp/>pItem);</highlight></codeline>
<codeline lineno="4603"><highlight class="normal"></highlight></codeline>
<codeline lineno="4604"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="4605"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>m_pAllocationCallbacks;</highlight></codeline>
<codeline lineno="4606"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaPoolAllocator&lt;ItemType&gt;<sp/>m_ItemAllocator;</highlight></codeline>
<codeline lineno="4607"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/>m_pFront;</highlight></codeline>
<codeline lineno="4608"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/>m_pBack;</highlight></codeline>
<codeline lineno="4609"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>m_Count;</highlight></codeline>
<codeline lineno="4610"><highlight class="normal">};</highlight></codeline>
<codeline lineno="4611"><highlight class="normal"></highlight></codeline>
<codeline lineno="4612"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_RAW_LIST_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4613"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="4614"><highlight class="normal">VmaRawList&lt;T&gt;::VmaRawList(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks)</highlight></codeline>
<codeline lineno="4615"><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>m_pAllocationCallbacks(pAllocationCallbacks),</highlight></codeline>
<codeline lineno="4616"><highlight class="normal"><sp/><sp/><sp/><sp/>m_ItemAllocator(pAllocationCallbacks,<sp/>128),</highlight></codeline>
<codeline lineno="4617"><highlight class="normal"><sp/><sp/><sp/><sp/>m_pFront(VMA_NULL),</highlight></codeline>
<codeline lineno="4618"><highlight class="normal"><sp/><sp/><sp/><sp/>m_pBack(VMA_NULL),</highlight></codeline>
<codeline lineno="4619"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Count(0)<sp/>{}</highlight></codeline>
<codeline lineno="4620"><highlight class="normal"></highlight></codeline>
<codeline lineno="4621"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="4622"><highlight class="normal">VmaListItem&lt;T&gt;*<sp/>VmaRawList&lt;T&gt;::PushFront()</highlight></codeline>
<codeline lineno="4623"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4624"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>pNewItem<sp/>=<sp/>m_ItemAllocator.Alloc();</highlight></codeline>
<codeline lineno="4625"><highlight class="normal"><sp/><sp/><sp/><sp/>pNewItem-&gt;pPrev<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="4626"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(IsEmpty())</highlight></codeline>
<codeline lineno="4627"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4628"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pNewItem-&gt;pNext<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="4629"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pFront<sp/>=<sp/>pNewItem;</highlight></codeline>
<codeline lineno="4630"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pBack<sp/>=<sp/>pNewItem;</highlight></codeline>
<codeline lineno="4631"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Count<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="4632"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4633"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4634"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4635"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pNewItem-&gt;pNext<sp/>=<sp/>m_pFront;</highlight></codeline>
<codeline lineno="4636"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pFront-&gt;pPrev<sp/>=<sp/>pNewItem;</highlight></codeline>
<codeline lineno="4637"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pFront<sp/>=<sp/>pNewItem;</highlight></codeline>
<codeline lineno="4638"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++m_Count;</highlight></codeline>
<codeline lineno="4639"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4640"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>pNewItem;</highlight></codeline>
<codeline lineno="4641"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4642"><highlight class="normal"></highlight></codeline>
<codeline lineno="4643"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="4644"><highlight class="normal">VmaListItem&lt;T&gt;*<sp/>VmaRawList&lt;T&gt;::PushBack()</highlight></codeline>
<codeline lineno="4645"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4646"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>pNewItem<sp/>=<sp/>m_ItemAllocator.Alloc();</highlight></codeline>
<codeline lineno="4647"><highlight class="normal"><sp/><sp/><sp/><sp/>pNewItem-&gt;pNext<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="4648"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(IsEmpty())</highlight></codeline>
<codeline lineno="4649"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4650"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pNewItem-&gt;pPrev<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="4651"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pFront<sp/>=<sp/>pNewItem;</highlight></codeline>
<codeline lineno="4652"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pBack<sp/>=<sp/>pNewItem;</highlight></codeline>
<codeline lineno="4653"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Count<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="4654"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4655"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4656"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4657"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pNewItem-&gt;pPrev<sp/>=<sp/>m_pBack;</highlight></codeline>
<codeline lineno="4658"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pBack-&gt;pNext<sp/>=<sp/>pNewItem;</highlight></codeline>
<codeline lineno="4659"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pBack<sp/>=<sp/>pNewItem;</highlight></codeline>
<codeline lineno="4660"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++m_Count;</highlight></codeline>
<codeline lineno="4661"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4662"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>pNewItem;</highlight></codeline>
<codeline lineno="4663"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4664"><highlight class="normal"></highlight></codeline>
<codeline lineno="4665"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="4666"><highlight class="normal">VmaListItem&lt;T&gt;*<sp/>VmaRawList&lt;T&gt;::PushFront(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>value)</highlight></codeline>
<codeline lineno="4667"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4668"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>pNewItem<sp/>=<sp/>PushFront();</highlight></codeline>
<codeline lineno="4669"><highlight class="normal"><sp/><sp/><sp/><sp/>pNewItem-&gt;Value<sp/>=<sp/><ref refid="namespace_catch_1_1_generators_1a3b2efc97978cf37951b75394aae1a3fb" kindref="member">value</ref>;</highlight></codeline>
<codeline lineno="4670"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>pNewItem;</highlight></codeline>
<codeline lineno="4671"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4672"><highlight class="normal"></highlight></codeline>
<codeline lineno="4673"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="4674"><highlight class="normal">VmaListItem&lt;T&gt;*<sp/>VmaRawList&lt;T&gt;::PushBack(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>value)</highlight></codeline>
<codeline lineno="4675"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4676"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>pNewItem<sp/>=<sp/>PushBack();</highlight></codeline>
<codeline lineno="4677"><highlight class="normal"><sp/><sp/><sp/><sp/>pNewItem-&gt;Value<sp/>=<sp/><ref refid="namespace_catch_1_1_generators_1a3b2efc97978cf37951b75394aae1a3fb" kindref="member">value</ref>;</highlight></codeline>
<codeline lineno="4678"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>pNewItem;</highlight></codeline>
<codeline lineno="4679"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4680"><highlight class="normal"></highlight></codeline>
<codeline lineno="4681"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="4682"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaRawList&lt;T&gt;::PopFront()</highlight></codeline>
<codeline lineno="4683"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4684"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(m_Count<sp/>&gt;<sp/>0);</highlight></codeline>
<codeline lineno="4685"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>pFrontItem<sp/>=<sp/>m_pFront;</highlight></codeline>
<codeline lineno="4686"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>pNextItem<sp/>=<sp/>pFrontItem-&gt;pNext;</highlight></codeline>
<codeline lineno="4687"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(pNextItem<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="4688"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4689"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pNextItem-&gt;pPrev<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="4690"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4691"><highlight class="normal"><sp/><sp/><sp/><sp/>m_pFront<sp/>=<sp/>pNextItem;</highlight></codeline>
<codeline lineno="4692"><highlight class="normal"><sp/><sp/><sp/><sp/>m_ItemAllocator.Free(pFrontItem);</highlight></codeline>
<codeline lineno="4693"><highlight class="normal"><sp/><sp/><sp/><sp/>--m_Count;</highlight></codeline>
<codeline lineno="4694"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4695"><highlight class="normal"></highlight></codeline>
<codeline lineno="4696"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="4697"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaRawList&lt;T&gt;::PopBack()</highlight></codeline>
<codeline lineno="4698"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4699"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(m_Count<sp/>&gt;<sp/>0);</highlight></codeline>
<codeline lineno="4700"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>pBackItem<sp/>=<sp/>m_pBack;</highlight></codeline>
<codeline lineno="4701"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>pPrevItem<sp/>=<sp/>pBackItem-&gt;pPrev;</highlight></codeline>
<codeline lineno="4702"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pPrevItem<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="4703"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4704"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pPrevItem-&gt;pNext<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="4705"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4706"><highlight class="normal"><sp/><sp/><sp/><sp/>m_pBack<sp/>=<sp/>pPrevItem;</highlight></codeline>
<codeline lineno="4707"><highlight class="normal"><sp/><sp/><sp/><sp/>m_ItemAllocator.Free(pBackItem);</highlight></codeline>
<codeline lineno="4708"><highlight class="normal"><sp/><sp/><sp/><sp/>--m_Count;</highlight></codeline>
<codeline lineno="4709"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4710"><highlight class="normal"></highlight></codeline>
<codeline lineno="4711"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="4712"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaRawList&lt;T&gt;::Clear()</highlight></codeline>
<codeline lineno="4713"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4714"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(IsEmpty()<sp/>==<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="4715"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4716"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemType*<sp/>pItem<sp/>=<sp/>m_pBack;</highlight></codeline>
<codeline lineno="4717"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(pItem<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="4718"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4719"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemType*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>pPrevItem<sp/>=<sp/>pItem-&gt;pPrev;</highlight></codeline>
<codeline lineno="4720"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_ItemAllocator.Free(pItem);</highlight></codeline>
<codeline lineno="4721"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pItem<sp/>=<sp/>pPrevItem;</highlight></codeline>
<codeline lineno="4722"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4723"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pFront<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="4724"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pBack<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="4725"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Count<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="4726"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4727"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4728"><highlight class="normal"></highlight></codeline>
<codeline lineno="4729"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="4730"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaRawList&lt;T&gt;::Remove(ItemType*<sp/>pItem)</highlight></codeline>
<codeline lineno="4731"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4732"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(pItem<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="4733"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(m_Count<sp/>&gt;<sp/>0);</highlight></codeline>
<codeline lineno="4734"><highlight class="normal"></highlight></codeline>
<codeline lineno="4735"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pItem-&gt;pPrev<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="4736"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4737"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pItem-&gt;pPrev-&gt;pNext<sp/>=<sp/>pItem-&gt;pNext;</highlight></codeline>
<codeline lineno="4738"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4739"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4740"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4741"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(m_pFront<sp/>==<sp/>pItem);</highlight></codeline>
<codeline lineno="4742"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pFront<sp/>=<sp/>pItem-&gt;pNext;</highlight></codeline>
<codeline lineno="4743"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4744"><highlight class="normal"></highlight></codeline>
<codeline lineno="4745"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pItem-&gt;pNext<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="4746"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4747"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pItem-&gt;pNext-&gt;pPrev<sp/>=<sp/>pItem-&gt;pPrev;</highlight></codeline>
<codeline lineno="4748"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4749"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4750"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4751"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(m_pBack<sp/>==<sp/>pItem);</highlight></codeline>
<codeline lineno="4752"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pBack<sp/>=<sp/>pItem-&gt;pPrev;</highlight></codeline>
<codeline lineno="4753"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4754"><highlight class="normal"></highlight></codeline>
<codeline lineno="4755"><highlight class="normal"><sp/><sp/><sp/><sp/>m_ItemAllocator.Free(pItem);</highlight></codeline>
<codeline lineno="4756"><highlight class="normal"><sp/><sp/><sp/><sp/>--m_Count;</highlight></codeline>
<codeline lineno="4757"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4758"><highlight class="normal"></highlight></codeline>
<codeline lineno="4759"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="4760"><highlight class="normal">VmaListItem&lt;T&gt;*<sp/>VmaRawList&lt;T&gt;::InsertBefore(ItemType*<sp/>pItem)</highlight></codeline>
<codeline lineno="4761"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4762"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pItem<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="4763"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4764"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemType*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>prevItem<sp/>=<sp/>pItem-&gt;pPrev;</highlight></codeline>
<codeline lineno="4765"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemType*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>newItem<sp/>=<sp/>m_ItemAllocator.Alloc();</highlight></codeline>
<codeline lineno="4766"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newItem-&gt;pPrev<sp/>=<sp/>prevItem;</highlight></codeline>
<codeline lineno="4767"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newItem-&gt;pNext<sp/>=<sp/>pItem;</highlight></codeline>
<codeline lineno="4768"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pItem-&gt;pPrev<sp/>=<sp/>newItem;</highlight></codeline>
<codeline lineno="4769"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(prevItem<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="4770"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4771"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prevItem-&gt;pNext<sp/>=<sp/>newItem;</highlight></codeline>
<codeline lineno="4772"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4773"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4774"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4775"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(m_pFront<sp/>==<sp/>pItem);</highlight></codeline>
<codeline lineno="4776"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pFront<sp/>=<sp/>newItem;</highlight></codeline>
<codeline lineno="4777"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4778"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++m_Count;</highlight></codeline>
<codeline lineno="4779"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>newItem;</highlight></codeline>
<codeline lineno="4780"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4781"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4782"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>PushBack();</highlight></codeline>
<codeline lineno="4783"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4784"><highlight class="normal"></highlight></codeline>
<codeline lineno="4785"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="4786"><highlight class="normal">VmaListItem&lt;T&gt;*<sp/>VmaRawList&lt;T&gt;::InsertAfter(ItemType*<sp/>pItem)</highlight></codeline>
<codeline lineno="4787"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4788"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pItem<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="4789"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4790"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemType*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>nextItem<sp/>=<sp/>pItem-&gt;pNext;</highlight></codeline>
<codeline lineno="4791"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemType*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>newItem<sp/>=<sp/>m_ItemAllocator.Alloc();</highlight></codeline>
<codeline lineno="4792"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newItem-&gt;pNext<sp/>=<sp/>nextItem;</highlight></codeline>
<codeline lineno="4793"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newItem-&gt;pPrev<sp/>=<sp/>pItem;</highlight></codeline>
<codeline lineno="4794"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pItem-&gt;pNext<sp/>=<sp/>newItem;</highlight></codeline>
<codeline lineno="4795"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(nextItem<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="4796"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4797"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nextItem-&gt;pPrev<sp/>=<sp/>newItem;</highlight></codeline>
<codeline lineno="4798"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4799"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4800"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4801"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(m_pBack<sp/>==<sp/>pItem);</highlight></codeline>
<codeline lineno="4802"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pBack<sp/>=<sp/>newItem;</highlight></codeline>
<codeline lineno="4803"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4804"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++m_Count;</highlight></codeline>
<codeline lineno="4805"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>newItem;</highlight></codeline>
<codeline lineno="4806"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4807"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4808"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>PushFront();</highlight></codeline>
<codeline lineno="4809"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4810"><highlight class="normal"></highlight></codeline>
<codeline lineno="4811"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="4812"><highlight class="normal">VmaListItem&lt;T&gt;*<sp/>VmaRawList&lt;T&gt;::InsertBefore(ItemType*<sp/>pItem,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>value)</highlight></codeline>
<codeline lineno="4813"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4814"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>newItem<sp/>=<sp/>InsertBefore(pItem);</highlight></codeline>
<codeline lineno="4815"><highlight class="normal"><sp/><sp/><sp/><sp/>newItem-&gt;Value<sp/>=<sp/><ref refid="namespace_catch_1_1_generators_1a3b2efc97978cf37951b75394aae1a3fb" kindref="member">value</ref>;</highlight></codeline>
<codeline lineno="4816"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>newItem;</highlight></codeline>
<codeline lineno="4817"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4818"><highlight class="normal"></highlight></codeline>
<codeline lineno="4819"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="4820"><highlight class="normal">VmaListItem&lt;T&gt;*<sp/>VmaRawList&lt;T&gt;::InsertAfter(ItemType*<sp/>pItem,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>value)</highlight></codeline>
<codeline lineno="4821"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4822"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>newItem<sp/>=<sp/>InsertAfter(pItem);</highlight></codeline>
<codeline lineno="4823"><highlight class="normal"><sp/><sp/><sp/><sp/>newItem-&gt;Value<sp/>=<sp/><ref refid="namespace_catch_1_1_generators_1a3b2efc97978cf37951b75394aae1a3fb" kindref="member">value</ref>;</highlight></codeline>
<codeline lineno="4824"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>newItem;</highlight></codeline>
<codeline lineno="4825"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4826"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_RAW_LIST_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4827"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_RAW_LIST</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4828"><highlight class="normal"></highlight></codeline>
<codeline lineno="4829"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_LIST</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4830"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AllocatorT&gt;</highlight></codeline>
<codeline lineno="4831"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaList</highlight></codeline>
<codeline lineno="4832"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4833"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_CLASS_NO_COPY(VmaList)</highlight></codeline>
<codeline lineno="4834"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="4835"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">reverse_iterator;</highlight></codeline>
<codeline lineno="4836"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">const_iterator;</highlight></codeline>
<codeline lineno="4837"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">const_reverse_iterator;</highlight></codeline>
<codeline lineno="4838"><highlight class="normal"></highlight></codeline>
<codeline lineno="4839"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">iterator</highlight></codeline>
<codeline lineno="4840"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4841"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">friend</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">const_iterator;</highlight></codeline>
<codeline lineno="4842"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">friend</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaList&lt;T,<sp/>AllocatorT&gt;;</highlight></codeline>
<codeline lineno="4843"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="4844"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator()<sp/>:<sp/><sp/>m_pList(VMA_NULL),<sp/>m_pItem(VMA_NULL)<sp/>{}</highlight></codeline>
<codeline lineno="4845"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>reverse_iterator&amp;<sp/>src)<sp/>:<sp/>m_pList(src.m_pList),<sp/>m_pItem(src.m_pItem)<sp/>{}</highlight></codeline>
<codeline lineno="4846"><highlight class="normal"></highlight></codeline>
<codeline lineno="4847"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T&amp;<sp/>operator*()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/>VMA_HEAVY_ASSERT(m_pItem<sp/>!=<sp/>VMA_NULL);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pItem-&gt;Value;<sp/>}</highlight></codeline>
<codeline lineno="4848"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T*<sp/>operator-&gt;()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/>VMA_HEAVY_ASSERT(m_pItem<sp/>!=<sp/>VMA_NULL);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>&amp;m_pItem-&gt;Value;<sp/>}</highlight></codeline>
<codeline lineno="4849"><highlight class="normal"></highlight></codeline>
<codeline lineno="4850"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>operator==(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>iterator&amp;<sp/>rhs)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/>VMA_HEAVY_ASSERT(m_pList<sp/>==<sp/>rhs.m_pList);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pItem<sp/>==<sp/>rhs.m_pItem;<sp/>}</highlight></codeline>
<codeline lineno="4851"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>operator!=(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>iterator&amp;<sp/>rhs)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/>VMA_HEAVY_ASSERT(m_pList<sp/>==<sp/>rhs.m_pList);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pItem<sp/>!=<sp/>rhs.m_pItem;<sp/>}</highlight></codeline>
<codeline lineno="4852"><highlight class="normal"></highlight></codeline>
<codeline lineno="4853"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>operator++(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">)<sp/>{<sp/>iterator<sp/>result<sp/>=<sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;<sp/>++*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>result;<sp/>}</highlight></codeline>
<codeline lineno="4854"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>operator--(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">)<sp/>{<sp/>iterator<sp/>result<sp/>=<sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;<sp/>--*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>result;<sp/>}</highlight></codeline>
<codeline lineno="4855"><highlight class="normal"></highlight></codeline>
<codeline lineno="4856"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator&amp;<sp/>operator++()<sp/>{<sp/>VMA_HEAVY_ASSERT(m_pItem<sp/>!=<sp/>VMA_NULL);<sp/>m_pItem<sp/>=<sp/>m_pItem-&gt;pNext;<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;<sp/>}</highlight></codeline>
<codeline lineno="4857"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator&amp;<sp/>operator--();</highlight></codeline>
<codeline lineno="4858"><highlight class="normal"></highlight></codeline>
<codeline lineno="4859"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="4860"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaRawList&lt;T&gt;*<sp/>m_pList;</highlight></codeline>
<codeline lineno="4861"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaListItem&lt;T&gt;*<sp/>m_pItem;</highlight></codeline>
<codeline lineno="4862"><highlight class="normal"></highlight></codeline>
<codeline lineno="4863"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator(VmaRawList&lt;T&gt;*<sp/>pList,<sp/>VmaListItem&lt;T&gt;*<sp/>pItem)<sp/>:<sp/>m_pList(pList),<sp/><sp/>m_pItem(pItem)<sp/>{}</highlight></codeline>
<codeline lineno="4864"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="4865"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">reverse_iterator</highlight></codeline>
<codeline lineno="4866"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4867"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">friend</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">const_reverse_iterator;</highlight></codeline>
<codeline lineno="4868"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">friend</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaList&lt;T,<sp/>AllocatorT&gt;;</highlight></codeline>
<codeline lineno="4869"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="4870"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reverse_iterator()<sp/>:<sp/>m_pList(VMA_NULL),<sp/>m_pItem(VMA_NULL)<sp/>{}</highlight></codeline>
<codeline lineno="4871"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reverse_iterator(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>iterator&amp;<sp/>src)<sp/>:<sp/>m_pList(src.m_pList),<sp/>m_pItem(src.m_pItem)<sp/>{}</highlight></codeline>
<codeline lineno="4872"><highlight class="normal"></highlight></codeline>
<codeline lineno="4873"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T&amp;<sp/>operator*()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/>VMA_HEAVY_ASSERT(m_pItem<sp/>!=<sp/>VMA_NULL);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pItem-&gt;Value;<sp/>}</highlight></codeline>
<codeline lineno="4874"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T*<sp/>operator-&gt;()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/>VMA_HEAVY_ASSERT(m_pItem<sp/>!=<sp/>VMA_NULL);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>&amp;m_pItem-&gt;Value;<sp/>}</highlight></codeline>
<codeline lineno="4875"><highlight class="normal"></highlight></codeline>
<codeline lineno="4876"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>operator==(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>reverse_iterator&amp;<sp/>rhs)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/>VMA_HEAVY_ASSERT(m_pList<sp/>==<sp/>rhs.m_pList);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pItem<sp/>==<sp/>rhs.m_pItem;<sp/>}</highlight></codeline>
<codeline lineno="4877"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>operator!=(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>reverse_iterator&amp;<sp/>rhs)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/>VMA_HEAVY_ASSERT(m_pList<sp/>==<sp/>rhs.m_pList);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pItem<sp/>!=<sp/>rhs.m_pItem;<sp/>}</highlight></codeline>
<codeline lineno="4878"><highlight class="normal"></highlight></codeline>
<codeline lineno="4879"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reverse_iterator<sp/>operator++(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">)<sp/>{<sp/>reverse_iterator<sp/>result<sp/>=<sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;<sp/>++*<sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">;<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>result;<sp/>}</highlight></codeline>
<codeline lineno="4880"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reverse_iterator<sp/>operator--(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">)<sp/>{<sp/>reverse_iterator<sp/>result<sp/>=<sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;<sp/>--*<sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">;<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>result;<sp/>}</highlight></codeline>
<codeline lineno="4881"><highlight class="normal"></highlight></codeline>
<codeline lineno="4882"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reverse_iterator&amp;<sp/>operator++()<sp/>{<sp/>VMA_HEAVY_ASSERT(m_pItem<sp/>!=<sp/>VMA_NULL);<sp/>m_pItem<sp/>=<sp/>m_pItem-&gt;pPrev;<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;<sp/>}</highlight></codeline>
<codeline lineno="4883"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reverse_iterator&amp;<sp/>operator--();</highlight></codeline>
<codeline lineno="4884"><highlight class="normal"></highlight></codeline>
<codeline lineno="4885"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="4886"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaRawList&lt;T&gt;*<sp/>m_pList;</highlight></codeline>
<codeline lineno="4887"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaListItem&lt;T&gt;*<sp/>m_pItem;</highlight></codeline>
<codeline lineno="4888"><highlight class="normal"></highlight></codeline>
<codeline lineno="4889"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reverse_iterator(VmaRawList&lt;T&gt;*<sp/>pList,<sp/>VmaListItem&lt;T&gt;*<sp/>pItem)<sp/>:<sp/>m_pList(pList),<sp/><sp/>m_pItem(pItem)<sp/>{}</highlight></codeline>
<codeline lineno="4890"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="4891"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">const_iterator</highlight></codeline>
<codeline lineno="4892"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4893"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">friend</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaList&lt;T,<sp/>AllocatorT&gt;;</highlight></codeline>
<codeline lineno="4894"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="4895"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator()<sp/>:<sp/>m_pList(VMA_NULL),<sp/>m_pItem(VMA_NULL)<sp/>{}</highlight></codeline>
<codeline lineno="4896"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>iterator&amp;<sp/>src)<sp/>:<sp/>m_pList(src.m_pList),<sp/>m_pItem(src.m_pItem)<sp/>{}</highlight></codeline>
<codeline lineno="4897"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>reverse_iterator&amp;<sp/>src)<sp/>:<sp/>m_pList(src.m_pList),<sp/>m_pItem(src.m_pItem)<sp/>{}</highlight></codeline>
<codeline lineno="4898"><highlight class="normal"></highlight></codeline>
<codeline lineno="4899"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>iterator<sp/>drop_const()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>{<sp/></highlight><highlight class="keyword">const_cast&lt;</highlight><highlight class="normal">VmaRawList&lt;T&gt;*</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(m_pList),<sp/></highlight><highlight class="keyword">const_cast&lt;</highlight><highlight class="normal">VmaListItem&lt;T&gt;*</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(m_pItem)<sp/>};<sp/>}</highlight></codeline>
<codeline lineno="4900"><highlight class="normal"></highlight></codeline>
<codeline lineno="4901"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>operator*()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/>VMA_HEAVY_ASSERT(m_pItem<sp/>!=<sp/>VMA_NULL);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pItem-&gt;Value;<sp/>}</highlight></codeline>
<codeline lineno="4902"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T*<sp/>operator-&gt;()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/>VMA_HEAVY_ASSERT(m_pItem<sp/>!=<sp/>VMA_NULL);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>&amp;m_pItem-&gt;Value;<sp/>}</highlight></codeline>
<codeline lineno="4903"><highlight class="normal"></highlight></codeline>
<codeline lineno="4904"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>operator==(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>const_iterator&amp;<sp/>rhs)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/>VMA_HEAVY_ASSERT(m_pList<sp/>==<sp/>rhs.m_pList);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pItem<sp/>==<sp/>rhs.m_pItem;<sp/>}</highlight></codeline>
<codeline lineno="4905"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>operator!=(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>const_iterator&amp;<sp/>rhs)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/>VMA_HEAVY_ASSERT(m_pList<sp/>==<sp/>rhs.m_pList);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pItem<sp/>!=<sp/>rhs.m_pItem;<sp/>}</highlight></codeline>
<codeline lineno="4906"><highlight class="normal"></highlight></codeline>
<codeline lineno="4907"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator<sp/>operator++(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">)<sp/>{<sp/>const_iterator<sp/>result<sp/>=<sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;<sp/>++*<sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">;<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>result;<sp/>}</highlight></codeline>
<codeline lineno="4908"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator<sp/>operator--(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">)<sp/>{<sp/>const_iterator<sp/>result<sp/>=<sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;<sp/>--*<sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">;<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>result;<sp/>}</highlight></codeline>
<codeline lineno="4909"><highlight class="normal"></highlight></codeline>
<codeline lineno="4910"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator&amp;<sp/>operator++()<sp/>{<sp/>VMA_HEAVY_ASSERT(m_pItem<sp/>!=<sp/>VMA_NULL);<sp/>m_pItem<sp/>=<sp/>m_pItem-&gt;pNext;<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;<sp/>}</highlight></codeline>
<codeline lineno="4911"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator&amp;<sp/>operator--();</highlight></codeline>
<codeline lineno="4912"><highlight class="normal"></highlight></codeline>
<codeline lineno="4913"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="4914"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaRawList&lt;T&gt;*<sp/>m_pList;</highlight></codeline>
<codeline lineno="4915"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaListItem&lt;T&gt;*<sp/>m_pItem;</highlight></codeline>
<codeline lineno="4916"><highlight class="normal"></highlight></codeline>
<codeline lineno="4917"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_iterator(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaRawList&lt;T&gt;*<sp/>pList,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaListItem&lt;T&gt;*<sp/>pItem)<sp/>:<sp/>m_pList(pList),<sp/>m_pItem(pItem)<sp/>{}</highlight></codeline>
<codeline lineno="4918"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="4919"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">const_reverse_iterator</highlight></codeline>
<codeline lineno="4920"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4921"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">friend</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaList&lt;T,<sp/>AllocatorT&gt;;</highlight></codeline>
<codeline lineno="4922"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="4923"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_reverse_iterator()<sp/>:<sp/>m_pList(VMA_NULL),<sp/>m_pItem(VMA_NULL)<sp/>{}</highlight></codeline>
<codeline lineno="4924"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_reverse_iterator(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>reverse_iterator&amp;<sp/>src)<sp/>:<sp/>m_pList(src.m_pList),<sp/>m_pItem(src.m_pItem)<sp/>{}</highlight></codeline>
<codeline lineno="4925"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_reverse_iterator(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>iterator&amp;<sp/>src)<sp/>:<sp/>m_pList(src.m_pList),<sp/>m_pItem(src.m_pItem)<sp/>{}</highlight></codeline>
<codeline lineno="4926"><highlight class="normal"></highlight></codeline>
<codeline lineno="4927"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reverse_iterator<sp/>drop_const()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>{<sp/></highlight><highlight class="keyword">const_cast&lt;</highlight><highlight class="normal">VmaRawList&lt;T&gt;*</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(m_pList),<sp/></highlight><highlight class="keyword">const_cast&lt;</highlight><highlight class="normal">VmaListItem&lt;T&gt;*</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(m_pItem)<sp/>};<sp/>}</highlight></codeline>
<codeline lineno="4928"><highlight class="normal"></highlight></codeline>
<codeline lineno="4929"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>operator*()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/>VMA_HEAVY_ASSERT(m_pItem<sp/>!=<sp/>VMA_NULL);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pItem-&gt;Value;<sp/>}</highlight></codeline>
<codeline lineno="4930"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T*<sp/>operator-&gt;()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/>VMA_HEAVY_ASSERT(m_pItem<sp/>!=<sp/>VMA_NULL);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>&amp;m_pItem-&gt;Value;<sp/>}</highlight></codeline>
<codeline lineno="4931"><highlight class="normal"></highlight></codeline>
<codeline lineno="4932"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>operator==(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>const_reverse_iterator&amp;<sp/>rhs)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/>VMA_HEAVY_ASSERT(m_pList<sp/>==<sp/>rhs.m_pList);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pItem<sp/>==<sp/>rhs.m_pItem;<sp/>}</highlight></codeline>
<codeline lineno="4933"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>operator!=(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>const_reverse_iterator&amp;<sp/>rhs)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/>VMA_HEAVY_ASSERT(m_pList<sp/>==<sp/>rhs.m_pList);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pItem<sp/>!=<sp/>rhs.m_pItem;<sp/>}</highlight></codeline>
<codeline lineno="4934"><highlight class="normal"></highlight></codeline>
<codeline lineno="4935"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_reverse_iterator<sp/>operator++(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">)<sp/>{<sp/>const_reverse_iterator<sp/>result<sp/>=<sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;<sp/>++*<sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">;<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>result;<sp/>}</highlight></codeline>
<codeline lineno="4936"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_reverse_iterator<sp/>operator--(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">)<sp/>{<sp/>const_reverse_iterator<sp/>result<sp/>=<sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;<sp/>--*<sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">;<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>result;<sp/>}</highlight></codeline>
<codeline lineno="4937"><highlight class="normal"></highlight></codeline>
<codeline lineno="4938"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_reverse_iterator&amp;<sp/>operator++()<sp/>{<sp/>VMA_HEAVY_ASSERT(m_pItem<sp/>!=<sp/>VMA_NULL);<sp/>m_pItem<sp/>=<sp/>m_pItem-&gt;pPrev;<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;<sp/>}</highlight></codeline>
<codeline lineno="4939"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_reverse_iterator&amp;<sp/>operator--();</highlight></codeline>
<codeline lineno="4940"><highlight class="normal"></highlight></codeline>
<codeline lineno="4941"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="4942"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaRawList&lt;T&gt;*<sp/>m_pList;</highlight></codeline>
<codeline lineno="4943"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaListItem&lt;T&gt;*<sp/>m_pItem;</highlight></codeline>
<codeline lineno="4944"><highlight class="normal"></highlight></codeline>
<codeline lineno="4945"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const_reverse_iterator(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaRawList&lt;T&gt;*<sp/>pList,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaListItem&lt;T&gt;*<sp/>pItem)<sp/>:<sp/>m_pList(pList),<sp/>m_pItem(pItem)<sp/>{}</highlight></codeline>
<codeline lineno="4946"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="4947"><highlight class="normal"></highlight></codeline>
<codeline lineno="4948"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaList(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>AllocatorT&amp;<sp/>allocator)<sp/>:<sp/>m_RawList(<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>.m_pCallbacks)<sp/>{}</highlight></codeline>
<codeline lineno="4949"><highlight class="normal"></highlight></codeline>
<codeline lineno="4950"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>empty()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_RawList.IsEmpty();<sp/>}</highlight></codeline>
<codeline lineno="4951"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_RawList.GetCount();<sp/>}</highlight></codeline>
<codeline lineno="4952"><highlight class="normal"></highlight></codeline>
<codeline lineno="4953"><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>begin()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>iterator(&amp;m_RawList,<sp/>m_RawList.Front());<sp/>}</highlight></codeline>
<codeline lineno="4954"><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>end()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>iterator(&amp;m_RawList,<sp/>VMA_NULL);<sp/>}</highlight></codeline>
<codeline lineno="4955"><highlight class="normal"></highlight></codeline>
<codeline lineno="4956"><highlight class="normal"><sp/><sp/><sp/><sp/>const_iterator<sp/>cbegin()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>const_iterator(&amp;m_RawList,<sp/>m_RawList.Front());<sp/>}</highlight></codeline>
<codeline lineno="4957"><highlight class="normal"><sp/><sp/><sp/><sp/>const_iterator<sp/>cend()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>const_iterator(&amp;m_RawList,<sp/>VMA_NULL);<sp/>}</highlight></codeline>
<codeline lineno="4958"><highlight class="normal"></highlight></codeline>
<codeline lineno="4959"><highlight class="normal"><sp/><sp/><sp/><sp/>const_iterator<sp/>begin()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>cbegin();<sp/>}</highlight></codeline>
<codeline lineno="4960"><highlight class="normal"><sp/><sp/><sp/><sp/>const_iterator<sp/>end()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>cend();<sp/>}</highlight></codeline>
<codeline lineno="4961"><highlight class="normal"></highlight></codeline>
<codeline lineno="4962"><highlight class="normal"><sp/><sp/><sp/><sp/>reverse_iterator<sp/>rbegin()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>reverse_iterator(&amp;m_RawList,<sp/>m_RawList.Back());<sp/>}</highlight></codeline>
<codeline lineno="4963"><highlight class="normal"><sp/><sp/><sp/><sp/>reverse_iterator<sp/>rend()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>reverse_iterator(&amp;m_RawList,<sp/>VMA_NULL);<sp/>}</highlight></codeline>
<codeline lineno="4964"><highlight class="normal"></highlight></codeline>
<codeline lineno="4965"><highlight class="normal"><sp/><sp/><sp/><sp/>const_reverse_iterator<sp/>crbegin()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>const_reverse_iterator(&amp;m_RawList,<sp/>m_RawList.Back());<sp/>}</highlight></codeline>
<codeline lineno="4966"><highlight class="normal"><sp/><sp/><sp/><sp/>const_reverse_iterator<sp/>crend()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>const_reverse_iterator(&amp;m_RawList,<sp/>VMA_NULL);<sp/>}</highlight></codeline>
<codeline lineno="4967"><highlight class="normal"></highlight></codeline>
<codeline lineno="4968"><highlight class="normal"><sp/><sp/><sp/><sp/>const_reverse_iterator<sp/>rbegin()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>crbegin();<sp/>}</highlight></codeline>
<codeline lineno="4969"><highlight class="normal"><sp/><sp/><sp/><sp/>const_reverse_iterator<sp/>rend()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>crend();<sp/>}</highlight></codeline>
<codeline lineno="4970"><highlight class="normal"></highlight></codeline>
<codeline lineno="4971"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>push_back(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>value)<sp/>{<sp/>m_RawList.PushBack(value);<sp/>}</highlight></codeline>
<codeline lineno="4972"><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>insert(iterator<sp/>it,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T&amp;<sp/>value)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>iterator(&amp;m_RawList,<sp/>m_RawList.InsertBefore(it.m_pItem,<sp/>value));<sp/>}</highlight></codeline>
<codeline lineno="4973"><highlight class="normal"></highlight></codeline>
<codeline lineno="4974"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>clear()<sp/>{<sp/>m_RawList.Clear();<sp/>}</highlight></codeline>
<codeline lineno="4975"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>erase(iterator<sp/>it)<sp/>{<sp/>m_RawList.Remove(it.m_pItem);<sp/>}</highlight></codeline>
<codeline lineno="4976"><highlight class="normal"></highlight></codeline>
<codeline lineno="4977"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="4978"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaRawList&lt;T&gt;<sp/>m_RawList;</highlight></codeline>
<codeline lineno="4979"><highlight class="normal">};</highlight></codeline>
<codeline lineno="4980"><highlight class="normal"></highlight></codeline>
<codeline lineno="4981"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_LIST_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4982"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AllocatorT&gt;</highlight></codeline>
<codeline lineno="4983"><highlight class="normal"></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>VmaList&lt;T,<sp/>AllocatorT&gt;::iterator&amp;<sp/>VmaList&lt;T,<sp/>AllocatorT&gt;::iterator::operator--()</highlight></codeline>
<codeline lineno="4984"><highlight class="normal">{</highlight></codeline>
<codeline lineno="4985"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_pItem<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="4986"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4987"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pItem<sp/>=<sp/>m_pItem-&gt;pPrev;</highlight></codeline>
<codeline lineno="4988"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4989"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4990"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="4991"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(!m_pList-&gt;IsEmpty());</highlight></codeline>
<codeline lineno="4992"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pItem<sp/>=<sp/>m_pList-&gt;Back();</highlight></codeline>
<codeline lineno="4993"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="4994"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="4995"><highlight class="normal">}</highlight></codeline>
<codeline lineno="4996"><highlight class="normal"></highlight></codeline>
<codeline lineno="4997"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AllocatorT&gt;</highlight></codeline>
<codeline lineno="4998"><highlight class="normal"></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>VmaList&lt;T,<sp/>AllocatorT&gt;::reverse_iterator&amp;<sp/>VmaList&lt;T,<sp/>AllocatorT&gt;::reverse_iterator::operator--()</highlight></codeline>
<codeline lineno="4999"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5000"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_pItem<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="5001"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5002"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pItem<sp/>=<sp/>m_pItem-&gt;pNext;</highlight></codeline>
<codeline lineno="5003"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5004"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5005"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5006"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(!m_pList-&gt;IsEmpty());</highlight></codeline>
<codeline lineno="5007"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pItem<sp/>=<sp/>m_pList-&gt;Front();</highlight></codeline>
<codeline lineno="5008"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5009"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="5010"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5011"><highlight class="normal"></highlight></codeline>
<codeline lineno="5012"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AllocatorT&gt;</highlight></codeline>
<codeline lineno="5013"><highlight class="normal"></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>VmaList&lt;T,<sp/>AllocatorT&gt;::const_iterator&amp;<sp/>VmaList&lt;T,<sp/>AllocatorT&gt;::const_iterator::operator--()</highlight></codeline>
<codeline lineno="5014"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5015"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_pItem<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="5016"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5017"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pItem<sp/>=<sp/>m_pItem-&gt;pPrev;</highlight></codeline>
<codeline lineno="5018"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5019"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5020"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5021"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(!m_pList-&gt;IsEmpty());</highlight></codeline>
<codeline lineno="5022"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pItem<sp/>=<sp/>m_pList-&gt;Back();</highlight></codeline>
<codeline lineno="5023"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5024"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="5025"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5026"><highlight class="normal"></highlight></codeline>
<codeline lineno="5027"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AllocatorT&gt;</highlight></codeline>
<codeline lineno="5028"><highlight class="normal"></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>VmaList&lt;T,<sp/>AllocatorT&gt;::const_reverse_iterator&amp;<sp/>VmaList&lt;T,<sp/>AllocatorT&gt;::const_reverse_iterator::operator--()</highlight></codeline>
<codeline lineno="5029"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5030"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_pItem<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="5031"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5032"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pItem<sp/>=<sp/>m_pItem-&gt;pNext;</highlight></codeline>
<codeline lineno="5033"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5034"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5035"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5036"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(!m_pList-&gt;IsEmpty());</highlight></codeline>
<codeline lineno="5037"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pItem<sp/>=<sp/>m_pList-&gt;Back();</highlight></codeline>
<codeline lineno="5038"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5039"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="5040"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5041"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_LIST_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5042"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_LIST</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5043"><highlight class="normal"></highlight></codeline>
<codeline lineno="5044"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_INTRUSIVE_LINKED_LIST</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5045"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="5046"><highlight class="comment">Expected<sp/>interface<sp/>of<sp/>ItemTypeTraits:</highlight></codeline>
<codeline lineno="5047"><highlight class="comment">struct<sp/>MyItemTypeTraits</highlight></codeline>
<codeline lineno="5048"><highlight class="comment">{</highlight></codeline>
<codeline lineno="5049"><highlight class="comment"><sp/><sp/><sp/><sp/>typedef<sp/>MyItem<sp/>ItemType;</highlight></codeline>
<codeline lineno="5050"><highlight class="comment"><sp/><sp/><sp/><sp/>static<sp/>ItemType*<sp/>GetPrev(const<sp/>ItemType*<sp/>item)<sp/>{<sp/>return<sp/>item-&gt;myPrevPtr;<sp/>}</highlight></codeline>
<codeline lineno="5051"><highlight class="comment"><sp/><sp/><sp/><sp/>static<sp/>ItemType*<sp/>GetNext(const<sp/>ItemType*<sp/>item)<sp/>{<sp/>return<sp/>item-&gt;myNextPtr;<sp/>}</highlight></codeline>
<codeline lineno="5052"><highlight class="comment"><sp/><sp/><sp/><sp/>static<sp/>ItemType*&amp;<sp/>AccessPrev(ItemType*<sp/>item)<sp/>{<sp/>return<sp/>item-&gt;myPrevPtr;<sp/>}</highlight></codeline>
<codeline lineno="5053"><highlight class="comment"><sp/><sp/><sp/><sp/>static<sp/>ItemType*&amp;<sp/>AccessNext(ItemType*<sp/>item)<sp/>{<sp/>return<sp/>item-&gt;myNextPtr;<sp/>}</highlight></codeline>
<codeline lineno="5054"><highlight class="comment">};</highlight></codeline>
<codeline lineno="5055"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5056"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>ItemTypeTraits&gt;</highlight></codeline>
<codeline lineno="5057"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaIntrusiveLinkedList</highlight></codeline>
<codeline lineno="5058"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5059"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="5060"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>ItemTypeTraits::ItemType<sp/>ItemType;</highlight></codeline>
<codeline lineno="5061"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>ItemType*<sp/>GetPrev(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ItemType*<sp/>item)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ItemTypeTraits::GetPrev(item);<sp/>}</highlight></codeline>
<codeline lineno="5062"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>ItemType*<sp/>GetNext(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ItemType*<sp/>item)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ItemTypeTraits::GetNext(item);<sp/>}</highlight></codeline>
<codeline lineno="5063"><highlight class="normal"></highlight></codeline>
<codeline lineno="5064"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Movable,<sp/>not<sp/>copyable.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5065"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaIntrusiveLinkedList()<sp/>=<sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="5066"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaIntrusiveLinkedList(VmaIntrusiveLinkedList<sp/>&amp;&amp;<sp/>src);</highlight></codeline>
<codeline lineno="5067"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaIntrusiveLinkedList(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaIntrusiveLinkedList&amp;)<sp/>=<sp/></highlight><highlight class="keyword">delete</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="5068"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaIntrusiveLinkedList&amp;<sp/>operator=(VmaIntrusiveLinkedList&amp;&amp;<sp/>src);</highlight></codeline>
<codeline lineno="5069"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaIntrusiveLinkedList&amp;<sp/>operator=(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaIntrusiveLinkedList&amp;)<sp/>=<sp/></highlight><highlight class="keyword">delete</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="5070"><highlight class="normal"><sp/><sp/><sp/><sp/>~VmaIntrusiveLinkedList()<sp/>{<sp/>VMA_HEAVY_ASSERT(IsEmpty());<sp/>}</highlight></codeline>
<codeline lineno="5071"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="5072"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>GetCount()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Count;<sp/>}</highlight></codeline>
<codeline lineno="5073"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>IsEmpty()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Count<sp/>==<sp/>0;<sp/>}</highlight></codeline>
<codeline lineno="5074"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/>Front()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Front;<sp/>}</highlight></codeline>
<codeline lineno="5075"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/>Back()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Back;<sp/>}</highlight></codeline>
<codeline lineno="5076"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ItemType*<sp/>Front()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Front;<sp/>}</highlight></codeline>
<codeline lineno="5077"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ItemType*<sp/>Back()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Back;<sp/>}</highlight></codeline>
<codeline lineno="5078"><highlight class="normal"></highlight></codeline>
<codeline lineno="5079"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>PushBack(ItemType*<sp/>item);</highlight></codeline>
<codeline lineno="5080"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>PushFront(ItemType*<sp/>item);</highlight></codeline>
<codeline lineno="5081"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/>PopBack();</highlight></codeline>
<codeline lineno="5082"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/>PopFront();</highlight></codeline>
<codeline lineno="5083"><highlight class="normal"></highlight></codeline>
<codeline lineno="5084"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>MyItem<sp/>can<sp/>be<sp/>null<sp/>-<sp/>it<sp/>means<sp/>PushBack.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5085"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>InsertBefore(ItemType*<sp/>existingItem,<sp/>ItemType*<sp/>newItem);</highlight></codeline>
<codeline lineno="5086"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>MyItem<sp/>can<sp/>be<sp/>null<sp/>-<sp/>it<sp/>means<sp/>PushFront.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5087"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>InsertAfter(ItemType*<sp/>existingItem,<sp/>ItemType*<sp/>newItem);</highlight></codeline>
<codeline lineno="5088"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Remove(ItemType*<sp/>item);</highlight></codeline>
<codeline lineno="5089"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>RemoveAll();</highlight></codeline>
<codeline lineno="5090"><highlight class="normal"></highlight></codeline>
<codeline lineno="5091"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="5092"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/>m_Front<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="5093"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/>m_Back<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="5094"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>m_Count<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="5095"><highlight class="normal">};</highlight></codeline>
<codeline lineno="5096"><highlight class="normal"></highlight></codeline>
<codeline lineno="5097"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_INTRUSIVE_LINKED_LIST_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5098"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>ItemTypeTraits&gt;</highlight></codeline>
<codeline lineno="5099"><highlight class="normal">VmaIntrusiveLinkedList&lt;ItemTypeTraits&gt;::VmaIntrusiveLinkedList(VmaIntrusiveLinkedList&amp;&amp;<sp/>src)</highlight></codeline>
<codeline lineno="5100"><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>m_Front(src.m_Front),<sp/>m_Back(src.m_Back),<sp/>m_Count(src.m_Count)</highlight></codeline>
<codeline lineno="5101"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5102"><highlight class="normal"><sp/><sp/><sp/><sp/>src.m_Front<sp/>=<sp/>src.m_Back<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="5103"><highlight class="normal"><sp/><sp/><sp/><sp/>src.m_Count<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="5104"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5105"><highlight class="normal"></highlight></codeline>
<codeline lineno="5106"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>ItemTypeTraits&gt;</highlight></codeline>
<codeline lineno="5107"><highlight class="normal">VmaIntrusiveLinkedList&lt;ItemTypeTraits&gt;&amp;<sp/>VmaIntrusiveLinkedList&lt;ItemTypeTraits&gt;::operator=(VmaIntrusiveLinkedList&amp;&amp;<sp/>src)</highlight></codeline>
<codeline lineno="5108"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5109"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(&amp;src<sp/>!=<sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="5110"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5111"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(IsEmpty());</highlight></codeline>
<codeline lineno="5112"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Front<sp/>=<sp/>src.m_Front;</highlight></codeline>
<codeline lineno="5113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Back<sp/>=<sp/>src.m_Back;</highlight></codeline>
<codeline lineno="5114"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Count<sp/>=<sp/>src.m_Count;</highlight></codeline>
<codeline lineno="5115"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>src.m_Front<sp/>=<sp/>src.m_Back<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="5116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>src.m_Count<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="5117"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5118"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>*</highlight><highlight class="keyword">this</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="5119"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5120"><highlight class="normal"></highlight></codeline>
<codeline lineno="5121"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>ItemTypeTraits&gt;</highlight></codeline>
<codeline lineno="5122"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaIntrusiveLinkedList&lt;ItemTypeTraits&gt;::PushBack(ItemType*<sp/>item)</highlight></codeline>
<codeline lineno="5123"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5124"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(ItemTypeTraits::GetPrev(item)<sp/>==<sp/>VMA_NULL<sp/>&amp;&amp;<sp/>ItemTypeTraits::GetNext(item)<sp/>==<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="5125"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(IsEmpty())</highlight></codeline>
<codeline lineno="5126"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5127"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Front<sp/>=<sp/>item;</highlight></codeline>
<codeline lineno="5128"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Back<sp/>=<sp/>item;</highlight></codeline>
<codeline lineno="5129"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Count<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="5130"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5131"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5132"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5133"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemTypeTraits::AccessPrev(item)<sp/>=<sp/>m_Back;</highlight></codeline>
<codeline lineno="5134"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemTypeTraits::AccessNext(m_Back)<sp/>=<sp/>item;</highlight></codeline>
<codeline lineno="5135"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Back<sp/>=<sp/>item;</highlight></codeline>
<codeline lineno="5136"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++m_Count;</highlight></codeline>
<codeline lineno="5137"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5138"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5139"><highlight class="normal"></highlight></codeline>
<codeline lineno="5140"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>ItemTypeTraits&gt;</highlight></codeline>
<codeline lineno="5141"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaIntrusiveLinkedList&lt;ItemTypeTraits&gt;::PushFront(ItemType*<sp/>item)</highlight></codeline>
<codeline lineno="5142"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5143"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(ItemTypeTraits::GetPrev(item)<sp/>==<sp/>VMA_NULL<sp/>&amp;&amp;<sp/>ItemTypeTraits::GetNext(item)<sp/>==<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="5144"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(IsEmpty())</highlight></codeline>
<codeline lineno="5145"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Front<sp/>=<sp/>item;</highlight></codeline>
<codeline lineno="5147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Back<sp/>=<sp/>item;</highlight></codeline>
<codeline lineno="5148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Count<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="5149"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5150"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5151"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemTypeTraits::AccessNext(item)<sp/>=<sp/>m_Front;</highlight></codeline>
<codeline lineno="5153"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemTypeTraits::AccessPrev(m_Front)<sp/>=<sp/>item;</highlight></codeline>
<codeline lineno="5154"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Front<sp/>=<sp/>item;</highlight></codeline>
<codeline lineno="5155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++m_Count;</highlight></codeline>
<codeline lineno="5156"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5157"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5158"><highlight class="normal"></highlight></codeline>
<codeline lineno="5159"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>ItemTypeTraits&gt;</highlight></codeline>
<codeline lineno="5160"><highlight class="normal"></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>VmaIntrusiveLinkedList&lt;ItemTypeTraits&gt;::ItemType*<sp/>VmaIntrusiveLinkedList&lt;ItemTypeTraits&gt;::PopBack()</highlight></codeline>
<codeline lineno="5161"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5162"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(m_Count<sp/>&gt;<sp/>0);</highlight></codeline>
<codeline lineno="5163"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>backItem<sp/>=<sp/>m_Back;</highlight></codeline>
<codeline lineno="5164"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>prevItem<sp/>=<sp/>ItemTypeTraits::GetPrev(backItem);</highlight></codeline>
<codeline lineno="5165"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(prevItem<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="5166"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemTypeTraits::AccessNext(prevItem)<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="5168"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5169"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Back<sp/>=<sp/>prevItem;</highlight></codeline>
<codeline lineno="5170"><highlight class="normal"><sp/><sp/><sp/><sp/>--m_Count;</highlight></codeline>
<codeline lineno="5171"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemTypeTraits::AccessPrev(backItem)<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="5172"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemTypeTraits::AccessNext(backItem)<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="5173"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>backItem;</highlight></codeline>
<codeline lineno="5174"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5175"><highlight class="normal"></highlight></codeline>
<codeline lineno="5176"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>ItemTypeTraits&gt;</highlight></codeline>
<codeline lineno="5177"><highlight class="normal"></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>VmaIntrusiveLinkedList&lt;ItemTypeTraits&gt;::ItemType*<sp/>VmaIntrusiveLinkedList&lt;ItemTypeTraits&gt;::PopFront()</highlight></codeline>
<codeline lineno="5178"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5179"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(m_Count<sp/>&gt;<sp/>0);</highlight></codeline>
<codeline lineno="5180"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>frontItem<sp/>=<sp/>m_Front;</highlight></codeline>
<codeline lineno="5181"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemType*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>nextItem<sp/>=<sp/>ItemTypeTraits::GetNext(frontItem);</highlight></codeline>
<codeline lineno="5182"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nextItem<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="5183"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemTypeTraits::AccessPrev(nextItem)<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="5185"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5186"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Front<sp/>=<sp/>nextItem;</highlight></codeline>
<codeline lineno="5187"><highlight class="normal"><sp/><sp/><sp/><sp/>--m_Count;</highlight></codeline>
<codeline lineno="5188"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemTypeTraits::AccessPrev(frontItem)<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="5189"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemTypeTraits::AccessNext(frontItem)<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="5190"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>frontItem;</highlight></codeline>
<codeline lineno="5191"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5192"><highlight class="normal"></highlight></codeline>
<codeline lineno="5193"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>ItemTypeTraits&gt;</highlight></codeline>
<codeline lineno="5194"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaIntrusiveLinkedList&lt;ItemTypeTraits&gt;::InsertBefore(ItemType*<sp/>existingItem,<sp/>ItemType*<sp/>newItem)</highlight></codeline>
<codeline lineno="5195"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5196"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(newItem<sp/>!=<sp/>VMA_NULL<sp/>&amp;&amp;<sp/>ItemTypeTraits::GetPrev(newItem)<sp/>==<sp/>VMA_NULL<sp/>&amp;&amp;<sp/>ItemTypeTraits::GetNext(newItem)<sp/>==<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="5197"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(existingItem<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="5198"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemType*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>prevItem<sp/>=<sp/>ItemTypeTraits::GetPrev(existingItem);</highlight></codeline>
<codeline lineno="5200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemTypeTraits::AccessPrev(newItem)<sp/>=<sp/>prevItem;</highlight></codeline>
<codeline lineno="5201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemTypeTraits::AccessNext(newItem)<sp/>=<sp/>existingItem;</highlight></codeline>
<codeline lineno="5202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemTypeTraits::AccessPrev(existingItem)<sp/>=<sp/>newItem;</highlight></codeline>
<codeline lineno="5203"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(prevItem<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="5204"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5205"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemTypeTraits::AccessNext(prevItem)<sp/>=<sp/>newItem;</highlight></codeline>
<codeline lineno="5206"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5207"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5209"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(m_Front<sp/>==<sp/>existingItem);</highlight></codeline>
<codeline lineno="5210"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Front<sp/>=<sp/>newItem;</highlight></codeline>
<codeline lineno="5211"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5212"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++m_Count;</highlight></codeline>
<codeline lineno="5213"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5214"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5215"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PushBack(newItem);</highlight></codeline>
<codeline lineno="5216"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5217"><highlight class="normal"></highlight></codeline>
<codeline lineno="5218"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>ItemTypeTraits&gt;</highlight></codeline>
<codeline lineno="5219"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaIntrusiveLinkedList&lt;ItemTypeTraits&gt;::InsertAfter(ItemType*<sp/>existingItem,<sp/>ItemType*<sp/>newItem)</highlight></codeline>
<codeline lineno="5220"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5221"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(newItem<sp/>!=<sp/>VMA_NULL<sp/>&amp;&amp;<sp/>ItemTypeTraits::GetPrev(newItem)<sp/>==<sp/>VMA_NULL<sp/>&amp;&amp;<sp/>ItemTypeTraits::GetNext(newItem)<sp/>==<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="5222"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(existingItem<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="5223"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5224"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemType*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>nextItem<sp/>=<sp/>ItemTypeTraits::GetNext(existingItem);</highlight></codeline>
<codeline lineno="5225"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemTypeTraits::AccessNext(newItem)<sp/>=<sp/>nextItem;</highlight></codeline>
<codeline lineno="5226"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemTypeTraits::AccessPrev(newItem)<sp/>=<sp/>existingItem;</highlight></codeline>
<codeline lineno="5227"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemTypeTraits::AccessNext(existingItem)<sp/>=<sp/>newItem;</highlight></codeline>
<codeline lineno="5228"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nextItem<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="5229"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5230"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemTypeTraits::AccessPrev(nextItem)<sp/>=<sp/>newItem;</highlight></codeline>
<codeline lineno="5231"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5232"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5233"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5234"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(m_Back<sp/>==<sp/>existingItem);</highlight></codeline>
<codeline lineno="5235"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Back<sp/>=<sp/>newItem;</highlight></codeline>
<codeline lineno="5236"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5237"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++m_Count;</highlight></codeline>
<codeline lineno="5238"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5239"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5240"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>PushFront(newItem);</highlight></codeline>
<codeline lineno="5241"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5242"><highlight class="normal"></highlight></codeline>
<codeline lineno="5243"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>ItemTypeTraits&gt;</highlight></codeline>
<codeline lineno="5244"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaIntrusiveLinkedList&lt;ItemTypeTraits&gt;::Remove(ItemType*<sp/>item)</highlight></codeline>
<codeline lineno="5245"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5246"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(item<sp/>!=<sp/>VMA_NULL<sp/>&amp;&amp;<sp/>m_Count<sp/>&gt;<sp/>0);</highlight></codeline>
<codeline lineno="5247"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ItemTypeTraits::GetPrev(item)<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="5248"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5249"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemTypeTraits::AccessNext(ItemTypeTraits::AccessPrev(item))<sp/>=<sp/>ItemTypeTraits::GetNext(item);</highlight></codeline>
<codeline lineno="5250"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5251"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5252"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5253"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(m_Front<sp/>==<sp/>item);</highlight></codeline>
<codeline lineno="5254"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Front<sp/>=<sp/>ItemTypeTraits::GetNext(item);</highlight></codeline>
<codeline lineno="5255"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5256"><highlight class="normal"></highlight></codeline>
<codeline lineno="5257"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ItemTypeTraits::GetNext(item)<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="5258"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5259"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemTypeTraits::AccessPrev(ItemTypeTraits::AccessNext(item))<sp/>=<sp/>ItemTypeTraits::GetPrev(item);</highlight></codeline>
<codeline lineno="5260"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5261"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5262"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(m_Back<sp/>==<sp/>item);</highlight></codeline>
<codeline lineno="5264"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Back<sp/>=<sp/>ItemTypeTraits::GetPrev(item);</highlight></codeline>
<codeline lineno="5265"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5266"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemTypeTraits::AccessPrev(item)<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="5267"><highlight class="normal"><sp/><sp/><sp/><sp/>ItemTypeTraits::AccessNext(item)<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="5268"><highlight class="normal"><sp/><sp/><sp/><sp/>--m_Count;</highlight></codeline>
<codeline lineno="5269"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5270"><highlight class="normal"></highlight></codeline>
<codeline lineno="5271"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>ItemTypeTraits&gt;</highlight></codeline>
<codeline lineno="5272"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaIntrusiveLinkedList&lt;ItemTypeTraits&gt;::RemoveAll()</highlight></codeline>
<codeline lineno="5273"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5274"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!IsEmpty())</highlight></codeline>
<codeline lineno="5275"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5276"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemType*<sp/>item<sp/>=<sp/>m_Back;</highlight></codeline>
<codeline lineno="5277"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(item<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="5278"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5279"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemType*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>prevItem<sp/>=<sp/>ItemTypeTraits::AccessPrev(item);</highlight></codeline>
<codeline lineno="5280"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemTypeTraits::AccessPrev(item)<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="5281"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ItemTypeTraits::AccessNext(item)<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="5282"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>item<sp/>=<sp/>prevItem;</highlight></codeline>
<codeline lineno="5283"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5284"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Front<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="5285"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Back<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="5286"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Count<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="5287"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5288"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5289"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_INTRUSIVE_LINKED_LIST_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5290"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_INTRUSIVE_LINKED_LIST</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5291"><highlight class="normal"></highlight></codeline>
<codeline lineno="5292"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Unused<sp/>in<sp/>this<sp/>version.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5293"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5294"><highlight class="normal"></highlight></codeline>
<codeline lineno="5295"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_PAIR</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5296"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T1,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T2&gt;</highlight></codeline>
<codeline lineno="5297"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaPair</highlight></codeline>
<codeline lineno="5298"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5299"><highlight class="normal"><sp/><sp/><sp/><sp/>T1<sp/>first;</highlight></codeline>
<codeline lineno="5300"><highlight class="normal"><sp/><sp/><sp/><sp/>T2<sp/>second;</highlight></codeline>
<codeline lineno="5301"><highlight class="normal"></highlight></codeline>
<codeline lineno="5302"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaPair()<sp/>:<sp/>first(),<sp/>second()<sp/>{}</highlight></codeline>
<codeline lineno="5303"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaPair(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T1&amp;<sp/>firstSrc,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T2&amp;<sp/>secondSrc)<sp/>:<sp/>first(firstSrc),<sp/>second(secondSrc)<sp/>{}</highlight></codeline>
<codeline lineno="5304"><highlight class="normal">};</highlight></codeline>
<codeline lineno="5305"><highlight class="normal"></highlight></codeline>
<codeline lineno="5306"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>FirstT,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>SecondT&gt;</highlight></codeline>
<codeline lineno="5307"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaPairFirstLess</highlight></codeline>
<codeline lineno="5308"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5309"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>operator()(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaPair&lt;FirstT,<sp/>SecondT&gt;&amp;<sp/>lhs,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaPair&lt;FirstT,<sp/>SecondT&gt;&amp;<sp/>rhs)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="5310"><highlight class="keyword"><sp/><sp/><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="5311"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>lhs.first<sp/>&lt;<sp/>rhs.first;</highlight></codeline>
<codeline lineno="5312"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5313"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>operator()(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaPair&lt;FirstT,<sp/>SecondT&gt;&amp;<sp/>lhs,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FirstT&amp;<sp/>rhsFirst)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="5314"><highlight class="keyword"><sp/><sp/><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="5315"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>lhs.first<sp/>&lt;<sp/>rhsFirst;</highlight></codeline>
<codeline lineno="5316"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5317"><highlight class="normal">};</highlight></codeline>
<codeline lineno="5318"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_PAIR</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5319"><highlight class="normal"></highlight></codeline>
<codeline lineno="5320"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_MAP</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5321"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Class<sp/>compatible<sp/>with<sp/>subset<sp/>of<sp/>interface<sp/>of<sp/>std::unordered_map.</highlight></codeline>
<codeline lineno="5322"><highlight class="comment">KeyT,<sp/>ValueT<sp/>must<sp/>be<sp/>POD<sp/>because<sp/>they<sp/>will<sp/>be<sp/>stored<sp/>in<sp/>VmaVector.</highlight></codeline>
<codeline lineno="5323"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5324"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>KeyT,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>ValueT&gt;</highlight></codeline>
<codeline lineno="5325"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaMap</highlight></codeline>
<codeline lineno="5326"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5327"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="5328"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VmaPair&lt;KeyT,<sp/>ValueT&gt;<sp/>PairType;</highlight></codeline>
<codeline lineno="5329"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>PairType*<sp/>iterator;</highlight></codeline>
<codeline lineno="5330"><highlight class="normal"></highlight></codeline>
<codeline lineno="5331"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaMap(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaStlAllocator&lt;PairType&gt;&amp;<sp/>allocator)<sp/>:<sp/>m_Vector(<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>)<sp/>{}</highlight></codeline>
<codeline lineno="5332"><highlight class="normal"></highlight></codeline>
<codeline lineno="5333"><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>begin()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Vector.begin();<sp/>}</highlight></codeline>
<codeline lineno="5334"><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>end()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Vector.end();<sp/>}</highlight></codeline>
<codeline lineno="5335"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Vector.size();<sp/>}</highlight></codeline>
<codeline lineno="5336"><highlight class="normal"></highlight></codeline>
<codeline lineno="5337"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>insert(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>PairType&amp;<sp/>pair);</highlight></codeline>
<codeline lineno="5338"><highlight class="normal"><sp/><sp/><sp/><sp/>iterator<sp/>find(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>KeyT&amp;<sp/>key);</highlight></codeline>
<codeline lineno="5339"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>erase(iterator<sp/>it);</highlight></codeline>
<codeline lineno="5340"><highlight class="normal"></highlight></codeline>
<codeline lineno="5341"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="5342"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaVector&lt;<sp/>PairType,<sp/>VmaStlAllocator&lt;PairType&gt;&gt;<sp/>m_Vector;</highlight></codeline>
<codeline lineno="5343"><highlight class="normal">};</highlight></codeline>
<codeline lineno="5344"><highlight class="normal"></highlight></codeline>
<codeline lineno="5345"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_MAP_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5346"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>KeyT,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>ValueT&gt;</highlight></codeline>
<codeline lineno="5347"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaMap&lt;KeyT,<sp/>ValueT&gt;::insert(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>PairType&amp;<sp/>pair)</highlight></codeline>
<codeline lineno="5348"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5349"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>indexToInsert<sp/>=<sp/>VmaBinaryFindFirstNotLess(</highlight></codeline>
<codeline lineno="5350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Vector.data(),</highlight></codeline>
<codeline lineno="5351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Vector.data()<sp/>+<sp/>m_Vector.size(),</highlight></codeline>
<codeline lineno="5352"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pair,</highlight></codeline>
<codeline lineno="5353"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaPairFirstLess&lt;KeyT,<sp/>ValueT&gt;())<sp/>-<sp/>m_Vector.data();</highlight></codeline>
<codeline lineno="5354"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaVectorInsert(m_Vector,<sp/>indexToInsert,<sp/>pair);</highlight></codeline>
<codeline lineno="5355"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5356"><highlight class="normal"></highlight></codeline>
<codeline lineno="5357"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>KeyT,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>ValueT&gt;</highlight></codeline>
<codeline lineno="5358"><highlight class="normal">VmaPair&lt;KeyT,<sp/>ValueT&gt;*<sp/>VmaMap&lt;KeyT,<sp/>ValueT&gt;::find(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>KeyT&amp;<sp/>key)</highlight></codeline>
<codeline lineno="5359"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5360"><highlight class="normal"><sp/><sp/><sp/><sp/>PairType*<sp/>it<sp/>=<sp/>VmaBinaryFindFirstNotLess(</highlight></codeline>
<codeline lineno="5361"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Vector.data(),</highlight></codeline>
<codeline lineno="5362"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Vector.data()<sp/>+<sp/>m_Vector.size(),</highlight></codeline>
<codeline lineno="5363"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>key,</highlight></codeline>
<codeline lineno="5364"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaPairFirstLess&lt;KeyT,<sp/>ValueT&gt;());</highlight></codeline>
<codeline lineno="5365"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((it<sp/>!=<sp/>m_Vector.end())<sp/>&amp;&amp;<sp/>(it-&gt;first<sp/>==<sp/>key))</highlight></codeline>
<codeline lineno="5366"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5367"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>it;</highlight></codeline>
<codeline lineno="5368"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5369"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5370"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5371"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Vector.end();</highlight></codeline>
<codeline lineno="5372"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5373"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5374"><highlight class="normal"></highlight></codeline>
<codeline lineno="5375"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>KeyT,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>ValueT&gt;</highlight></codeline>
<codeline lineno="5376"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaMap&lt;KeyT,<sp/>ValueT&gt;::erase(iterator<sp/>it)</highlight></codeline>
<codeline lineno="5377"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5378"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaVectorRemove(m_Vector,<sp/>it<sp/>-<sp/>m_Vector.begin());</highlight></codeline>
<codeline lineno="5379"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5380"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_MAP_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5381"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_MAP</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5382"><highlight class="normal"></highlight></codeline>
<codeline lineno="5383"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5384"><highlight class="normal"></highlight></codeline>
<codeline lineno="5385"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>!defined(_VMA_STRING_BUILDER)<sp/>&amp;&amp;<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5386"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaStringBuilder</highlight></codeline>
<codeline lineno="5387"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5388"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="5389"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaStringBuilder(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>allocationCallbacks)<sp/>:<sp/>m_Data(VmaStlAllocator&lt;char&gt;(allocationCallbacks))<sp/>{}</highlight></codeline>
<codeline lineno="5390"><highlight class="normal"><sp/><sp/><sp/><sp/>~VmaStringBuilder()<sp/>=<sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="5391"><highlight class="normal"></highlight></codeline>
<codeline lineno="5392"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>GetLength()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Data.size();<sp/>}</highlight></codeline>
<codeline lineno="5393"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>GetData()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Data.data();<sp/>}</highlight></codeline>
<codeline lineno="5394"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>AddNewLine()<sp/>{<sp/>Add(</highlight><highlight class="charliteral">&apos;\n&apos;</highlight><highlight class="normal">);<sp/>}</highlight></codeline>
<codeline lineno="5395"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Add(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>ch)<sp/>{<sp/>m_Data.push_back(ch);<sp/>}</highlight></codeline>
<codeline lineno="5396"><highlight class="normal"></highlight></codeline>
<codeline lineno="5397"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Add(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>pStr);</highlight></codeline>
<codeline lineno="5398"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>AddNumber(uint32_t<sp/>num);</highlight></codeline>
<codeline lineno="5399"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>AddNumber(uint64_t<sp/>num);</highlight></codeline>
<codeline lineno="5400"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>AddPointer(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>ptr);</highlight></codeline>
<codeline lineno="5401"><highlight class="normal"></highlight></codeline>
<codeline lineno="5402"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="5403"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaVector&lt;char,<sp/>VmaStlAllocator&lt;char&gt;&gt;<sp/>m_Data;</highlight></codeline>
<codeline lineno="5404"><highlight class="normal">};</highlight></codeline>
<codeline lineno="5405"><highlight class="normal"></highlight></codeline>
<codeline lineno="5406"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_STRING_BUILDER_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5407"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaStringBuilder::Add(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>pStr)</highlight></codeline>
<codeline lineno="5408"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5409"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>strLen<sp/>=<sp/>strlen(pStr);</highlight></codeline>
<codeline lineno="5410"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(strLen<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="5411"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5412"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>oldCount<sp/>=<sp/>m_Data.size();</highlight></codeline>
<codeline lineno="5413"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Data.resize(oldCount<sp/>+<sp/>strLen);</highlight></codeline>
<codeline lineno="5414"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(m_Data.data()<sp/>+<sp/>oldCount,<sp/>pStr,<sp/>strLen);</highlight></codeline>
<codeline lineno="5415"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5416"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5417"><highlight class="normal"></highlight></codeline>
<codeline lineno="5418"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaStringBuilder::AddNumber(uint32_t<sp/>num)</highlight></codeline>
<codeline lineno="5419"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5420"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>buf[11];</highlight></codeline>
<codeline lineno="5421"><highlight class="normal"><sp/><sp/><sp/><sp/>buf[10]<sp/>=<sp/></highlight><highlight class="charliteral">&apos;\0&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="5422"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>p<sp/>=<sp/>&amp;buf[10];</highlight></codeline>
<codeline lineno="5423"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5424"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5425"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*--p<sp/>=<sp/></highlight><highlight class="charliteral">&apos;0&apos;</highlight><highlight class="normal"><sp/>+<sp/>(num<sp/>%<sp/>10);</highlight></codeline>
<codeline lineno="5426"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>num<sp/>/=<sp/>10;</highlight></codeline>
<codeline lineno="5427"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(num);</highlight></codeline>
<codeline lineno="5428"><highlight class="normal"><sp/><sp/><sp/><sp/>Add(p);</highlight></codeline>
<codeline lineno="5429"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5430"><highlight class="normal"></highlight></codeline>
<codeline lineno="5431"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaStringBuilder::AddNumber(uint64_t<sp/>num)</highlight></codeline>
<codeline lineno="5432"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5433"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>buf[21];</highlight></codeline>
<codeline lineno="5434"><highlight class="normal"><sp/><sp/><sp/><sp/>buf[20]<sp/>=<sp/></highlight><highlight class="charliteral">&apos;\0&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="5435"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>p<sp/>=<sp/>&amp;buf[20];</highlight></codeline>
<codeline lineno="5436"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5437"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5438"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*--p<sp/>=<sp/></highlight><highlight class="charliteral">&apos;0&apos;</highlight><highlight class="normal"><sp/>+<sp/>(num<sp/>%<sp/>10);</highlight></codeline>
<codeline lineno="5439"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>num<sp/>/=<sp/>10;</highlight></codeline>
<codeline lineno="5440"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(num);</highlight></codeline>
<codeline lineno="5441"><highlight class="normal"><sp/><sp/><sp/><sp/>Add(p);</highlight></codeline>
<codeline lineno="5442"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5443"><highlight class="normal"></highlight></codeline>
<codeline lineno="5444"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaStringBuilder::AddPointer(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>ptr)</highlight></codeline>
<codeline lineno="5445"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5446"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>buf[21];</highlight></codeline>
<codeline lineno="5447"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaPtrToStr(buf,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(buf),<sp/>ptr);</highlight></codeline>
<codeline lineno="5448"><highlight class="normal"><sp/><sp/><sp/><sp/>Add(buf);</highlight></codeline>
<codeline lineno="5449"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5450"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//_VMA_STRING_BUILDER_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5451"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_STRING_BUILDER</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5452"><highlight class="normal"></highlight></codeline>
<codeline lineno="5453"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>!defined(_VMA_JSON_WRITER)<sp/>&amp;&amp;<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5454"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="5455"><highlight class="comment">Allows<sp/>to<sp/>conveniently<sp/>build<sp/>a<sp/>correct<sp/>JSON<sp/>document<sp/>to<sp/>be<sp/>written<sp/>to<sp/>the</highlight></codeline>
<codeline lineno="5456"><highlight class="comment">VmaStringBuilder<sp/>passed<sp/>to<sp/>the<sp/>constructor.</highlight></codeline>
<codeline lineno="5457"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5458"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaJsonWriter</highlight></codeline>
<codeline lineno="5459"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5460"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_CLASS_NO_COPY(VmaJsonWriter)</highlight></codeline>
<codeline lineno="5461"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="5462"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>sb<sp/>-<sp/>string<sp/>builder<sp/>to<sp/>write<sp/>the<sp/>document<sp/>to.<sp/>Must<sp/>remain<sp/>alive<sp/>for<sp/>the<sp/>whole<sp/>lifetime<sp/>of<sp/>this<sp/>object.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5463"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaJsonWriter(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks,<sp/>VmaStringBuilder&amp;<sp/>sb);</highlight></codeline>
<codeline lineno="5464"><highlight class="normal"><sp/><sp/><sp/><sp/>~VmaJsonWriter();</highlight></codeline>
<codeline lineno="5465"><highlight class="normal"></highlight></codeline>
<codeline lineno="5466"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Begins<sp/>object<sp/>by<sp/>writing<sp/>&quot;{&quot;.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5467"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Inside<sp/>an<sp/>object,<sp/>you<sp/>must<sp/>call<sp/>pairs<sp/>of<sp/>WriteString<sp/>and<sp/>a<sp/>value,<sp/>e.g.:</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5468"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>j.BeginObject(true);<sp/>j.WriteString(&quot;A&quot;);<sp/>j.WriteNumber(1);<sp/>j.WriteString(&quot;B&quot;);<sp/>j.WriteNumber(2);<sp/>j.EndObject();</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5469"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Will<sp/>write:<sp/>{<sp/>&quot;A&quot;:<sp/>1,<sp/>&quot;B&quot;:<sp/>2<sp/>}</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5470"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>BeginObject(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>singleLine<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5471"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Ends<sp/>object<sp/>by<sp/>writing<sp/>&quot;}&quot;.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5472"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>EndObject();</highlight></codeline>
<codeline lineno="5473"><highlight class="normal"></highlight></codeline>
<codeline lineno="5474"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Begins<sp/>array<sp/>by<sp/>writing<sp/>&quot;[&quot;.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5475"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Inside<sp/>an<sp/>array,<sp/>you<sp/>can<sp/>write<sp/>a<sp/>sequence<sp/>of<sp/>any<sp/>values.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5476"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>BeginArray(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>singleLine<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5477"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Ends<sp/>array<sp/>by<sp/>writing<sp/>&quot;[&quot;.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5478"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>EndArray();</highlight></codeline>
<codeline lineno="5479"><highlight class="normal"></highlight></codeline>
<codeline lineno="5480"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Writes<sp/>a<sp/>string<sp/>value<sp/>inside<sp/>&quot;&quot;.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5481"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>pStr<sp/>can<sp/>contain<sp/>any<sp/>ANSI<sp/>characters,<sp/>including<sp/>&apos;&quot;&apos;,<sp/>new<sp/>line<sp/>etc.<sp/>-<sp/>they<sp/>will<sp/>be<sp/>properly<sp/>escaped.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5482"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>WriteString(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>pStr);</highlight></codeline>
<codeline lineno="5483"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="5484"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Begins<sp/>writing<sp/>a<sp/>string<sp/>value.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5485"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Call<sp/>BeginString,<sp/>ContinueString,<sp/>ContinueString,<sp/>...,<sp/>EndString<sp/>instead<sp/>of</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5486"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>WriteString<sp/>to<sp/>conveniently<sp/>build<sp/>the<sp/>string<sp/>content<sp/>incrementally,<sp/>made<sp/>of</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5487"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>parts<sp/>including<sp/>numbers.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5488"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>BeginString(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>pStr<sp/>=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="5489"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Posts<sp/>next<sp/>part<sp/>of<sp/>an<sp/>open<sp/>string.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5490"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ContinueString(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>pStr);</highlight></codeline>
<codeline lineno="5491"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Posts<sp/>next<sp/>part<sp/>of<sp/>an<sp/>open<sp/>string.<sp/>The<sp/>number<sp/>is<sp/>converted<sp/>to<sp/>decimal<sp/>characters.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5492"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ContinueString(uint64_t<sp/>n);</highlight></codeline>
<codeline lineno="5493"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Posts<sp/>next<sp/>part<sp/>of<sp/>an<sp/>open<sp/>string.<sp/>Pointer<sp/>value<sp/>is<sp/>converted<sp/>to<sp/>characters</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5494"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>using<sp/>&quot;%p&quot;<sp/>formatting<sp/>-<sp/>shown<sp/>as<sp/>hexadecimal<sp/>number,<sp/>e.g.:<sp/>000000081276Ad00</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5495"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ContinueString_Pointer(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>ptr);</highlight></codeline>
<codeline lineno="5496"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Ends<sp/>writing<sp/>a<sp/>string<sp/>value<sp/>by<sp/>writing<sp/>&apos;&quot;&apos;.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5497"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>EndString(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>pStr<sp/>=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="5498"><highlight class="normal"></highlight></codeline>
<codeline lineno="5499"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Writes<sp/>a<sp/>number<sp/>value.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5500"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>WriteNumber(uint64_t<sp/>n);</highlight></codeline>
<codeline lineno="5501"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Writes<sp/>a<sp/>boolean<sp/>value<sp/>-<sp/>false<sp/>or<sp/>true.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5502"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>WriteBool(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>b);</highlight></codeline>
<codeline lineno="5503"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Writes<sp/>a<sp/>null<sp/>value.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5504"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>WriteNull();</highlight></codeline>
<codeline lineno="5505"><highlight class="normal"></highlight></codeline>
<codeline lineno="5506"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="5507"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/>COLLECTION_TYPE</highlight></codeline>
<codeline lineno="5508"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5509"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>COLLECTION_TYPE_OBJECT,</highlight></codeline>
<codeline lineno="5510"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>COLLECTION_TYPE_ARRAY,</highlight></codeline>
<codeline lineno="5511"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="5512"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">StackItem</highlight></codeline>
<codeline lineno="5513"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5514"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>COLLECTION_TYPE<sp/>type;</highlight></codeline>
<codeline lineno="5515"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>valueCount;</highlight></codeline>
<codeline lineno="5516"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>singleLineMode;</highlight></codeline>
<codeline lineno="5517"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="5518"><highlight class="normal"></highlight></codeline>
<codeline lineno="5519"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>INDENT;</highlight></codeline>
<codeline lineno="5520"><highlight class="normal"></highlight></codeline>
<codeline lineno="5521"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaStringBuilder&amp;<sp/>m_SB;</highlight></codeline>
<codeline lineno="5522"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaVector&lt;<sp/>StackItem,<sp/>VmaStlAllocator&lt;StackItem&gt;<sp/>&gt;<sp/>m_Stack;</highlight></codeline>
<codeline lineno="5523"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>m_InsideString;</highlight></codeline>
<codeline lineno="5524"><highlight class="normal"></highlight></codeline>
<codeline lineno="5525"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>BeginValue(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isString);</highlight></codeline>
<codeline lineno="5526"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>WriteIndent(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>oneLess<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5527"><highlight class="normal">};</highlight></codeline>
<codeline lineno="5528"><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaJsonWriter::INDENT<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;<sp/><sp/>&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="5529"><highlight class="normal"></highlight></codeline>
<codeline lineno="5530"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_JSON_WRITER_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5531"><highlight class="normal">VmaJsonWriter::VmaJsonWriter(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks,<sp/>VmaStringBuilder&amp;<sp/>sb)</highlight></codeline>
<codeline lineno="5532"><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>m_SB(sb),</highlight></codeline>
<codeline lineno="5533"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Stack(VmaStlAllocator&lt;StackItem&gt;(pAllocationCallbacks)),</highlight></codeline>
<codeline lineno="5534"><highlight class="normal"><sp/><sp/><sp/><sp/>m_InsideString(false)<sp/>{}</highlight></codeline>
<codeline lineno="5535"><highlight class="normal"></highlight></codeline>
<codeline lineno="5536"><highlight class="normal">VmaJsonWriter::~VmaJsonWriter()</highlight></codeline>
<codeline lineno="5537"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5538"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(!m_InsideString);</highlight></codeline>
<codeline lineno="5539"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_Stack.empty());</highlight></codeline>
<codeline lineno="5540"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5541"><highlight class="normal"></highlight></codeline>
<codeline lineno="5542"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaJsonWriter::BeginObject(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>singleLine)</highlight></codeline>
<codeline lineno="5543"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5544"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(!m_InsideString);</highlight></codeline>
<codeline lineno="5545"><highlight class="normal"></highlight></codeline>
<codeline lineno="5546"><highlight class="normal"><sp/><sp/><sp/><sp/>BeginValue(</highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5547"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SB.Add(</highlight><highlight class="charliteral">&apos;{&apos;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5548"><highlight class="normal"></highlight></codeline>
<codeline lineno="5549"><highlight class="normal"><sp/><sp/><sp/><sp/>StackItem<sp/>item;</highlight></codeline>
<codeline lineno="5550"><highlight class="normal"><sp/><sp/><sp/><sp/>item.type<sp/>=<sp/>COLLECTION_TYPE_OBJECT;</highlight></codeline>
<codeline lineno="5551"><highlight class="normal"><sp/><sp/><sp/><sp/>item.valueCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="5552"><highlight class="normal"><sp/><sp/><sp/><sp/>item.singleLineMode<sp/>=<sp/>singleLine;</highlight></codeline>
<codeline lineno="5553"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Stack.push_back(item);</highlight></codeline>
<codeline lineno="5554"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5555"><highlight class="normal"></highlight></codeline>
<codeline lineno="5556"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaJsonWriter::EndObject()</highlight></codeline>
<codeline lineno="5557"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5558"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(!m_InsideString);</highlight></codeline>
<codeline lineno="5559"><highlight class="normal"></highlight></codeline>
<codeline lineno="5560"><highlight class="normal"><sp/><sp/><sp/><sp/>WriteIndent(</highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5561"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SB.Add(</highlight><highlight class="charliteral">&apos;}&apos;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5562"><highlight class="normal"></highlight></codeline>
<codeline lineno="5563"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(!m_Stack.empty()<sp/>&amp;&amp;<sp/>m_Stack.back().type<sp/>==<sp/>COLLECTION_TYPE_OBJECT);</highlight></codeline>
<codeline lineno="5564"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Stack.pop_back();</highlight></codeline>
<codeline lineno="5565"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5566"><highlight class="normal"></highlight></codeline>
<codeline lineno="5567"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaJsonWriter::BeginArray(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>singleLine)</highlight></codeline>
<codeline lineno="5568"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5569"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(!m_InsideString);</highlight></codeline>
<codeline lineno="5570"><highlight class="normal"></highlight></codeline>
<codeline lineno="5571"><highlight class="normal"><sp/><sp/><sp/><sp/>BeginValue(</highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5572"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SB.Add(</highlight><highlight class="charliteral">&apos;[&apos;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5573"><highlight class="normal"></highlight></codeline>
<codeline lineno="5574"><highlight class="normal"><sp/><sp/><sp/><sp/>StackItem<sp/>item;</highlight></codeline>
<codeline lineno="5575"><highlight class="normal"><sp/><sp/><sp/><sp/>item.type<sp/>=<sp/>COLLECTION_TYPE_ARRAY;</highlight></codeline>
<codeline lineno="5576"><highlight class="normal"><sp/><sp/><sp/><sp/>item.valueCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="5577"><highlight class="normal"><sp/><sp/><sp/><sp/>item.singleLineMode<sp/>=<sp/>singleLine;</highlight></codeline>
<codeline lineno="5578"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Stack.push_back(item);</highlight></codeline>
<codeline lineno="5579"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5580"><highlight class="normal"></highlight></codeline>
<codeline lineno="5581"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaJsonWriter::EndArray()</highlight></codeline>
<codeline lineno="5582"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5583"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(!m_InsideString);</highlight></codeline>
<codeline lineno="5584"><highlight class="normal"></highlight></codeline>
<codeline lineno="5585"><highlight class="normal"><sp/><sp/><sp/><sp/>WriteIndent(</highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5586"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SB.Add(</highlight><highlight class="charliteral">&apos;]&apos;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5587"><highlight class="normal"></highlight></codeline>
<codeline lineno="5588"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(!m_Stack.empty()<sp/>&amp;&amp;<sp/>m_Stack.back().type<sp/>==<sp/>COLLECTION_TYPE_ARRAY);</highlight></codeline>
<codeline lineno="5589"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Stack.pop_back();</highlight></codeline>
<codeline lineno="5590"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5591"><highlight class="normal"></highlight></codeline>
<codeline lineno="5592"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaJsonWriter::WriteString(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>pStr)</highlight></codeline>
<codeline lineno="5593"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5594"><highlight class="normal"><sp/><sp/><sp/><sp/>BeginString(pStr);</highlight></codeline>
<codeline lineno="5595"><highlight class="normal"><sp/><sp/><sp/><sp/>EndString();</highlight></codeline>
<codeline lineno="5596"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5597"><highlight class="normal"></highlight></codeline>
<codeline lineno="5598"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaJsonWriter::BeginString(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>pStr)</highlight></codeline>
<codeline lineno="5599"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5600"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(!m_InsideString);</highlight></codeline>
<codeline lineno="5601"><highlight class="normal"></highlight></codeline>
<codeline lineno="5602"><highlight class="normal"><sp/><sp/><sp/><sp/>BeginValue(</highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5603"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SB.Add(</highlight><highlight class="charliteral">&apos;&quot;&apos;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5604"><highlight class="normal"><sp/><sp/><sp/><sp/>m_InsideString<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="5605"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(pStr<sp/>!=<sp/>VMA_NULL<sp/>&amp;&amp;<sp/>pStr[0]<sp/>!=<sp/></highlight><highlight class="charliteral">&apos;\0&apos;</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="5606"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5607"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ContinueString(pStr);</highlight></codeline>
<codeline lineno="5608"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5609"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5610"><highlight class="normal"></highlight></codeline>
<codeline lineno="5611"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaJsonWriter::ContinueString(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>pStr)</highlight></codeline>
<codeline lineno="5612"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5613"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_InsideString);</highlight></codeline>
<codeline lineno="5614"><highlight class="normal"></highlight></codeline>
<codeline lineno="5615"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>strLen<sp/>=<sp/>strlen(pStr);</highlight></codeline>
<codeline lineno="5616"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>strLen;<sp/>++i)</highlight></codeline>
<codeline lineno="5617"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5618"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>ch<sp/>=<sp/>pStr[i];</highlight></codeline>
<codeline lineno="5619"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ch<sp/>==<sp/></highlight><highlight class="charliteral">&apos;\\&apos;</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="5620"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5621"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_SB.Add(</highlight><highlight class="stringliteral">&quot;\\\\&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5622"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5623"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ch<sp/>==<sp/></highlight><highlight class="charliteral">&apos;&quot;&apos;</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="5624"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5625"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_SB.Add(</highlight><highlight class="stringliteral">&quot;\\\&quot;&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5626"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5627"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ch<sp/>&gt;=<sp/>32)</highlight></codeline>
<codeline lineno="5628"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5629"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_SB.Add(ch);</highlight></codeline>
<codeline lineno="5630"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5631"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(ch)</highlight></codeline>
<codeline lineno="5632"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5633"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/></highlight><highlight class="charliteral">&apos;\b&apos;</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="5634"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_SB.Add(</highlight><highlight class="stringliteral">&quot;\\b&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5635"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="5636"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/></highlight><highlight class="charliteral">&apos;\f&apos;</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="5637"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_SB.Add(</highlight><highlight class="stringliteral">&quot;\\f&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5638"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="5639"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/></highlight><highlight class="charliteral">&apos;\n&apos;</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="5640"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_SB.Add(</highlight><highlight class="stringliteral">&quot;\\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5641"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="5642"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/></highlight><highlight class="charliteral">&apos;\r&apos;</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="5643"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_SB.Add(</highlight><highlight class="stringliteral">&quot;\\r&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5644"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="5645"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/></highlight><highlight class="charliteral">&apos;\t&apos;</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="5646"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_SB.Add(</highlight><highlight class="stringliteral">&quot;\\t&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5647"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="5648"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="5649"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Character<sp/>not<sp/>currently<sp/>supported.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5650"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="5651"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5652"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5653"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5654"><highlight class="normal"></highlight></codeline>
<codeline lineno="5655"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaJsonWriter::ContinueString(uint64_t<sp/>n)</highlight></codeline>
<codeline lineno="5656"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5657"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_InsideString);</highlight></codeline>
<codeline lineno="5658"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SB.AddNumber(n);</highlight></codeline>
<codeline lineno="5659"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5660"><highlight class="normal"></highlight></codeline>
<codeline lineno="5661"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaJsonWriter::ContinueString_Pointer(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>ptr)</highlight></codeline>
<codeline lineno="5662"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5663"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_InsideString);</highlight></codeline>
<codeline lineno="5664"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SB.AddPointer(ptr);</highlight></codeline>
<codeline lineno="5665"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5666"><highlight class="normal"></highlight></codeline>
<codeline lineno="5667"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaJsonWriter::EndString(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>pStr)</highlight></codeline>
<codeline lineno="5668"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5669"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_InsideString);</highlight></codeline>
<codeline lineno="5670"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(pStr<sp/>!=<sp/>VMA_NULL<sp/>&amp;&amp;<sp/>pStr[0]<sp/>!=<sp/></highlight><highlight class="charliteral">&apos;\0&apos;</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="5671"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5672"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ContinueString(pStr);</highlight></codeline>
<codeline lineno="5673"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5674"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SB.Add(</highlight><highlight class="charliteral">&apos;&quot;&apos;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5675"><highlight class="normal"><sp/><sp/><sp/><sp/>m_InsideString<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="5676"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5677"><highlight class="normal"></highlight></codeline>
<codeline lineno="5678"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaJsonWriter::WriteNumber(uint64_t<sp/>n)</highlight></codeline>
<codeline lineno="5679"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5680"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(!m_InsideString);</highlight></codeline>
<codeline lineno="5681"><highlight class="normal"><sp/><sp/><sp/><sp/>BeginValue(</highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5682"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SB.AddNumber(n);</highlight></codeline>
<codeline lineno="5683"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5684"><highlight class="normal"></highlight></codeline>
<codeline lineno="5685"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaJsonWriter::WriteBool(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>b)</highlight></codeline>
<codeline lineno="5686"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5687"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(!m_InsideString);</highlight></codeline>
<codeline lineno="5688"><highlight class="normal"><sp/><sp/><sp/><sp/>BeginValue(</highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5689"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SB.Add(b<sp/>?<sp/></highlight><highlight class="stringliteral">&quot;true&quot;</highlight><highlight class="normal"><sp/>:<sp/></highlight><highlight class="stringliteral">&quot;false&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5690"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5691"><highlight class="normal"></highlight></codeline>
<codeline lineno="5692"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaJsonWriter::WriteNull()</highlight></codeline>
<codeline lineno="5693"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5694"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(!m_InsideString);</highlight></codeline>
<codeline lineno="5695"><highlight class="normal"><sp/><sp/><sp/><sp/>BeginValue(</highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5696"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SB.Add(</highlight><highlight class="stringliteral">&quot;null&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5697"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5698"><highlight class="normal"></highlight></codeline>
<codeline lineno="5699"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaJsonWriter::BeginValue(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isString)</highlight></codeline>
<codeline lineno="5700"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5701"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!m_Stack.empty())</highlight></codeline>
<codeline lineno="5702"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5703"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>StackItem&amp;<sp/>currItem<sp/>=<sp/>m_Stack.back();</highlight></codeline>
<codeline lineno="5704"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(currItem.type<sp/>==<sp/>COLLECTION_TYPE_OBJECT<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="5705"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>currItem.valueCount<sp/>%<sp/>2<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="5706"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5707"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(isString);</highlight></codeline>
<codeline lineno="5708"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5709"><highlight class="normal"></highlight></codeline>
<codeline lineno="5710"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(currItem.type<sp/>==<sp/>COLLECTION_TYPE_OBJECT<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="5711"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>currItem.valueCount<sp/>%<sp/>2<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="5712"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5713"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_SB.Add(</highlight><highlight class="stringliteral">&quot;:<sp/>&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5714"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5715"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(currItem.valueCount<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="5716"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5717"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_SB.Add(</highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5718"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>WriteIndent();</highlight></codeline>
<codeline lineno="5719"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5720"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5721"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5722"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>WriteIndent();</highlight></codeline>
<codeline lineno="5723"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5724"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++currItem.valueCount;</highlight></codeline>
<codeline lineno="5725"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5726"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5727"><highlight class="normal"></highlight></codeline>
<codeline lineno="5728"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaJsonWriter::WriteIndent(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>oneLess)</highlight></codeline>
<codeline lineno="5729"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5730"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!m_Stack.empty()<sp/>&amp;&amp;<sp/>!m_Stack.back().singleLineMode)</highlight></codeline>
<codeline lineno="5731"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5732"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_SB.AddNewLine();</highlight></codeline>
<codeline lineno="5733"><highlight class="normal"></highlight></codeline>
<codeline lineno="5734"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>count<sp/>=<sp/>m_Stack.size();</highlight></codeline>
<codeline lineno="5735"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(count<sp/>&gt;<sp/>0<sp/>&amp;&amp;<sp/>oneLess)</highlight></codeline>
<codeline lineno="5736"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5737"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--count;</highlight></codeline>
<codeline lineno="5738"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5739"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>count;<sp/>++i)</highlight></codeline>
<codeline lineno="5740"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5741"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_SB.Add(INDENT);</highlight></codeline>
<codeline lineno="5742"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5743"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5744"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5745"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_JSON_WRITER_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5746"><highlight class="normal"></highlight></codeline>
<codeline lineno="5747"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaPrintDetailedStatistics(VmaJsonWriter&amp;<sp/>json,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>&amp;<sp/>stat)</highlight></codeline>
<codeline lineno="5748"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5749"><highlight class="normal"><sp/><sp/><sp/><sp/>json.BeginObject();</highlight></codeline>
<codeline lineno="5750"><highlight class="normal"></highlight></codeline>
<codeline lineno="5751"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;BlockCount&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5752"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteNumber(stat.<ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1a309179d5853a6a7cd534df497ee43957" kindref="member">blockCount</ref>);</highlight></codeline>
<codeline lineno="5753"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;BlockBytes&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5754"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteNumber(stat.<ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1a2afbc1c7aa8ad7bbb8de06215ba7e5c4" kindref="member">blockBytes</ref>);</highlight></codeline>
<codeline lineno="5755"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;AllocationCount&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5756"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteNumber(stat.<ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1ab0ff76e50f58f9f54b6f265e5bf5dde2" kindref="member">allocationCount</ref>);</highlight></codeline>
<codeline lineno="5757"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;AllocationBytes&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5758"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteNumber(stat.<ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1a21db06eba3422f87a2b4b4703d879c16" kindref="member">allocationBytes</ref>);</highlight></codeline>
<codeline lineno="5759"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;UnusedRangeCount&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5760"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteNumber(stat.<ref refid="struct_vma_detailed_statistics_1ab721bf04892e8b67802d4ddb7734638a" kindref="member">unusedRangeCount</ref>);</highlight></codeline>
<codeline lineno="5761"><highlight class="normal"></highlight></codeline>
<codeline lineno="5762"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(stat.<ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1ab0ff76e50f58f9f54b6f265e5bf5dde2" kindref="member">allocationCount</ref><sp/>&gt;<sp/>1)</highlight></codeline>
<codeline lineno="5763"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5764"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;AllocationSizeMin&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5765"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteNumber(stat.<ref refid="struct_vma_detailed_statistics_1a6fb397e7487e10f2a52e241577d2a2b8" kindref="member">allocationSizeMin</ref>);</highlight></codeline>
<codeline lineno="5766"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;AllocationSizeMax&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5767"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteNumber(stat.<ref refid="struct_vma_detailed_statistics_1a06b2add24eed3449a66ff151979a0201" kindref="member">allocationSizeMax</ref>);</highlight></codeline>
<codeline lineno="5768"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5769"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(stat.<ref refid="struct_vma_detailed_statistics_1ab721bf04892e8b67802d4ddb7734638a" kindref="member">unusedRangeCount</ref><sp/>&gt;<sp/>1)</highlight></codeline>
<codeline lineno="5770"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5771"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;UnusedRangeSizeMin&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5772"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteNumber(stat.<ref refid="struct_vma_detailed_statistics_1a830eda847ed735d0e91da25cfcf797a4" kindref="member">unusedRangeSizeMin</ref>);</highlight></codeline>
<codeline lineno="5773"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;UnusedRangeSizeMax&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="5774"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteNumber(stat.<ref refid="struct_vma_detailed_statistics_1af98943b5da98cf441ffa04b67914c78c" kindref="member">unusedRangeSizeMax</ref>);</highlight></codeline>
<codeline lineno="5775"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5776"><highlight class="normal"><sp/><sp/><sp/><sp/>json.EndObject();</highlight></codeline>
<codeline lineno="5777"><highlight class="normal">}</highlight></codeline>
<codeline lineno="5778"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_JSON_WRITER</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5779"><highlight class="normal"></highlight></codeline>
<codeline lineno="5780"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_MAPPING_HYSTERESIS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5781"><highlight class="normal"></highlight></codeline>
<codeline lineno="5782"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaMappingHysteresis</highlight></codeline>
<codeline lineno="5783"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5784"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_CLASS_NO_COPY(VmaMappingHysteresis)</highlight></codeline>
<codeline lineno="5785"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="5786"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaMappingHysteresis()<sp/>=<sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="5787"><highlight class="normal"></highlight></codeline>
<codeline lineno="5788"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>GetExtraMapping()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_ExtraMapping;<sp/>}</highlight></codeline>
<codeline lineno="5789"><highlight class="normal"></highlight></codeline>
<codeline lineno="5790"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Call<sp/>when<sp/>Map<sp/>was<sp/>called.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5791"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Returns<sp/>true<sp/>if<sp/>switched<sp/>to<sp/>extra<sp/>+1<sp/>mapping<sp/>reference<sp/>count.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5792"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>PostMap()</highlight></codeline>
<codeline lineno="5793"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5794"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_MAPPING_HYSTERESIS_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5795"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_ExtraMapping<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="5796"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5797"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++m_MajorCounter;</highlight></codeline>
<codeline lineno="5798"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_MajorCounter<sp/>&gt;=<sp/>COUNTER_MIN_EXTRA_MAPPING)</highlight></codeline>
<codeline lineno="5799"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5800"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_ExtraMapping<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="5801"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_MajorCounter<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="5802"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_MinorCounter<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="5803"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="5804"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5805"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5806"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>m_ExtraMapping<sp/>==<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5807"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PostMinorCounter();</highlight></codeline>
<codeline lineno="5808"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>VMA_MAPPING_HYSTERESIS_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5809"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="5810"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5811"><highlight class="normal"></highlight></codeline>
<codeline lineno="5812"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Call<sp/>when<sp/>Unmap<sp/>was<sp/>called.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5813"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>PostUnmap()</highlight></codeline>
<codeline lineno="5814"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5815"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_MAPPING_HYSTERESIS_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5816"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_ExtraMapping<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="5817"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++m_MajorCounter;</highlight></codeline>
<codeline lineno="5818"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>m_ExtraMapping<sp/>==<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5819"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PostMinorCounter();</highlight></codeline>
<codeline lineno="5820"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>VMA_MAPPING_HYSTERESIS_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5821"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5822"><highlight class="normal"></highlight></codeline>
<codeline lineno="5823"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Call<sp/>when<sp/>allocation<sp/>was<sp/>made<sp/>from<sp/>the<sp/>memory<sp/>block.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5824"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>PostAlloc()</highlight></codeline>
<codeline lineno="5825"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5826"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_MAPPING_HYSTERESIS_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5827"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_ExtraMapping<sp/>==<sp/>1)</highlight></codeline>
<codeline lineno="5828"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++m_MajorCounter;</highlight></codeline>
<codeline lineno="5829"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>m_ExtraMapping<sp/>==<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5830"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PostMinorCounter();</highlight></codeline>
<codeline lineno="5831"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>VMA_MAPPING_HYSTERESIS_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5832"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5833"><highlight class="normal"></highlight></codeline>
<codeline lineno="5834"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Call<sp/>when<sp/>allocation<sp/>was<sp/>freed<sp/>from<sp/>the<sp/>memory<sp/>block.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5835"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Returns<sp/>true<sp/>if<sp/>switched<sp/>to<sp/>extra<sp/>-1<sp/>mapping<sp/>reference<sp/>count.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5836"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>PostFree()</highlight></codeline>
<codeline lineno="5837"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5838"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_MAPPING_HYSTERESIS_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5839"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_ExtraMapping<sp/>==<sp/>1)</highlight></codeline>
<codeline lineno="5840"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5841"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++m_MajorCounter;</highlight></codeline>
<codeline lineno="5842"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_MajorCounter<sp/>&gt;=<sp/>COUNTER_MIN_EXTRA_MAPPING<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="5843"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_MajorCounter<sp/>&gt;<sp/>m_MinorCounter<sp/>+<sp/>1)</highlight></codeline>
<codeline lineno="5844"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5845"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_ExtraMapping<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="5846"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_MajorCounter<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="5847"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_MinorCounter<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="5848"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="5849"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5850"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5851"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>m_ExtraMapping<sp/>==<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5852"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PostMinorCounter();</highlight></codeline>
<codeline lineno="5853"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>VMA_MAPPING_HYSTERESIS_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5854"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="5855"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5856"><highlight class="normal"></highlight></codeline>
<codeline lineno="5857"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="5858"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>int32_t<sp/>COUNTER_MIN_EXTRA_MAPPING<sp/>=<sp/>7;</highlight></codeline>
<codeline lineno="5859"><highlight class="normal"></highlight></codeline>
<codeline lineno="5860"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>m_MinorCounter<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="5861"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>m_MajorCounter<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="5862"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>m_ExtraMapping<sp/>=<sp/>0;<sp/></highlight><highlight class="comment">//<sp/>0<sp/>or<sp/>1.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5863"><highlight class="normal"></highlight></codeline>
<codeline lineno="5864"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>PostMinorCounter()</highlight></codeline>
<codeline lineno="5865"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5866"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_MinorCounter<sp/>&lt;<sp/>m_MajorCounter)</highlight></codeline>
<codeline lineno="5867"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++m_MinorCounter;</highlight></codeline>
<codeline lineno="5868"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_MajorCounter<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="5869"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--m_MajorCounter,<sp/>--m_MinorCounter;</highlight></codeline>
<codeline lineno="5870"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="5871"><highlight class="normal">};</highlight></codeline>
<codeline lineno="5872"><highlight class="normal"></highlight></codeline>
<codeline lineno="5873"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_MAPPING_HYSTERESIS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5874"><highlight class="normal"></highlight></codeline>
<codeline lineno="5875"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_DEVICE_MEMORY_BLOCK</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5876"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="5877"><highlight class="comment">Represents<sp/>a<sp/>single<sp/>block<sp/>of<sp/>device<sp/>memory<sp/>(`VkDeviceMemory`)<sp/>with<sp/>all<sp/>the</highlight></codeline>
<codeline lineno="5878"><highlight class="comment">data<sp/>about<sp/>its<sp/>regions<sp/>(aka<sp/>suballocations,<sp/>#VmaAllocation),<sp/>assigned<sp/>and<sp/>free.</highlight></codeline>
<codeline lineno="5879"><highlight class="comment"></highlight></codeline>
<codeline lineno="5880"><highlight class="comment">Thread-safety:</highlight></codeline>
<codeline lineno="5881"><highlight class="comment">-<sp/>Access<sp/>to<sp/>m_pMetadata<sp/>must<sp/>be<sp/>externally<sp/>synchronized.</highlight></codeline>
<codeline lineno="5882"><highlight class="comment">-<sp/>Map,<sp/>Unmap,<sp/>Bind*<sp/>are<sp/>synchronized<sp/>internally.</highlight></codeline>
<codeline lineno="5883"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5884"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaDeviceMemoryBlock</highlight></codeline>
<codeline lineno="5885"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5886"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_CLASS_NO_COPY(VmaDeviceMemoryBlock)</highlight></codeline>
<codeline lineno="5887"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="5888"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaBlockMetadata*<sp/>m_pMetadata;</highlight></codeline>
<codeline lineno="5889"><highlight class="normal"></highlight></codeline>
<codeline lineno="5890"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator);</highlight></codeline>
<codeline lineno="5891"><highlight class="normal"><sp/><sp/><sp/><sp/>~VmaDeviceMemoryBlock();</highlight></codeline>
<codeline lineno="5892"><highlight class="normal"></highlight></codeline>
<codeline lineno="5893"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Always<sp/>call<sp/>after<sp/>construction.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5894"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Init(</highlight></codeline>
<codeline lineno="5895"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,</highlight></codeline>
<codeline lineno="5896"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>hParentPool,</highlight></codeline>
<codeline lineno="5897"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>newMemoryTypeIndex,</highlight></codeline>
<codeline lineno="5898"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceMemory<sp/>newMemory,</highlight></codeline>
<codeline lineno="5899"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>newSize,</highlight></codeline>
<codeline lineno="5900"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="5901"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>algorithm,</highlight></codeline>
<codeline lineno="5902"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>bufferImageGranularity);</highlight></codeline>
<codeline lineno="5903"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Always<sp/>call<sp/>before<sp/>destruction.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5904"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Destroy(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator);</highlight></codeline>
<codeline lineno="5905"><highlight class="normal"></highlight></codeline>
<codeline lineno="5906"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>GetParentPool()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_hParentPool;<sp/>}</highlight></codeline>
<codeline lineno="5907"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceMemory<sp/>GetDeviceMemory()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_hMemory;<sp/>}</highlight></codeline>
<codeline lineno="5908"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>GetMemoryTypeIndex()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_MemoryTypeIndex;<sp/>}</highlight></codeline>
<codeline lineno="5909"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>GetId()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Id;<sp/>}</highlight></codeline>
<codeline lineno="5910"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>GetMappedData()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pMappedData;<sp/>}</highlight></codeline>
<codeline lineno="5911"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>GetMapRefCount()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_MapCount;<sp/>}</highlight></codeline>
<codeline lineno="5912"><highlight class="normal"></highlight></codeline>
<codeline lineno="5913"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Call<sp/>when<sp/>allocation/free<sp/>was<sp/>made<sp/>from<sp/>m_pMetadata.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5914"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Used<sp/>for<sp/>m_MappingHysteresis.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5915"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>PostAlloc()<sp/>{<sp/>m_MappingHysteresis.PostAlloc();<sp/>}</highlight></codeline>
<codeline lineno="5916"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>PostFree(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator);</highlight></codeline>
<codeline lineno="5917"><highlight class="normal"></highlight></codeline>
<codeline lineno="5918"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Validates<sp/>all<sp/>data<sp/>structures<sp/>inside<sp/>this<sp/>object.<sp/>If<sp/>not<sp/>valid,<sp/>returns<sp/>false.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5919"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>Validate()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="5920"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>CheckCorruption(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator);</highlight></codeline>
<codeline lineno="5921"><highlight class="normal"></highlight></codeline>
<codeline lineno="5922"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>ppData<sp/>can<sp/>be<sp/>null.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5923"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>Map(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,<sp/>uint32_t<sp/>count,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">**<sp/>ppData);</highlight></codeline>
<codeline lineno="5924"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Unmap(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,<sp/>uint32_t<sp/>count);</highlight></codeline>
<codeline lineno="5925"><highlight class="normal"></highlight></codeline>
<codeline lineno="5926"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>WriteMagicValueAfterAllocation(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,<sp/>VkDeviceSize<sp/>allocOffset,<sp/>VkDeviceSize<sp/>allocSize);</highlight></codeline>
<codeline lineno="5927"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>ValidateMagicValueAfterAllocation(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,<sp/>VkDeviceSize<sp/>allocOffset,<sp/>VkDeviceSize<sp/>allocSize);</highlight></codeline>
<codeline lineno="5928"><highlight class="normal"></highlight></codeline>
<codeline lineno="5929"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>BindBufferMemory(</highlight></codeline>
<codeline lineno="5930"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,</highlight></codeline>
<codeline lineno="5931"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>hAllocation,</highlight></codeline>
<codeline lineno="5932"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocationLocalOffset,</highlight></codeline>
<codeline lineno="5933"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkBuffer<sp/>hBuffer,</highlight></codeline>
<codeline lineno="5934"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pNext);</highlight></codeline>
<codeline lineno="5935"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>BindImageMemory(</highlight></codeline>
<codeline lineno="5936"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,</highlight></codeline>
<codeline lineno="5937"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>hAllocation,</highlight></codeline>
<codeline lineno="5938"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocationLocalOffset,</highlight></codeline>
<codeline lineno="5939"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkImage<sp/>hImage,</highlight></codeline>
<codeline lineno="5940"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pNext);</highlight></codeline>
<codeline lineno="5941"><highlight class="normal"></highlight></codeline>
<codeline lineno="5942"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="5943"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>m_hParentPool;<sp/></highlight><highlight class="comment">//<sp/>VK_NULL_HANDLE<sp/>if<sp/>not<sp/>belongs<sp/>to<sp/>custom<sp/>pool.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5944"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>m_MemoryTypeIndex;</highlight></codeline>
<codeline lineno="5945"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>m_Id;</highlight></codeline>
<codeline lineno="5946"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceMemory<sp/>m_hMemory;</highlight></codeline>
<codeline lineno="5947"><highlight class="normal"></highlight></codeline>
<codeline lineno="5948"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="5949"><highlight class="comment"><sp/><sp/><sp/><sp/>Protects<sp/>access<sp/>to<sp/>m_hMemory<sp/>so<sp/>it<sp/>is<sp/>not<sp/>used<sp/>by<sp/>multiple<sp/>threads<sp/>simultaneously,<sp/>e.g.<sp/>vkMapMemory,<sp/>vkBindBufferMemory.</highlight></codeline>
<codeline lineno="5950"><highlight class="comment"><sp/><sp/><sp/><sp/>Also<sp/>protects<sp/>m_MapCount,<sp/>m_pMappedData.</highlight></codeline>
<codeline lineno="5951"><highlight class="comment"><sp/><sp/><sp/><sp/>Allocations,<sp/>deallocations,<sp/>any<sp/>change<sp/>in<sp/>m_pMetadata<sp/>is<sp/>protected<sp/>by<sp/>parent&apos;s<sp/>VmaBlockVector::m_Mutex.</highlight></codeline>
<codeline lineno="5952"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5953"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_MUTEX<sp/>m_MapAndBindMutex;</highlight></codeline>
<codeline lineno="5954"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaMappingHysteresis<sp/>m_MappingHysteresis;</highlight></codeline>
<codeline lineno="5955"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>m_MapCount;</highlight></codeline>
<codeline lineno="5956"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>m_pMappedData;</highlight></codeline>
<codeline lineno="5957"><highlight class="normal">};</highlight></codeline>
<codeline lineno="5958"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_DEVICE_MEMORY_BLOCK</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5959"><highlight class="normal"></highlight></codeline>
<codeline lineno="5960"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_ALLOCATION_T</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5961"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaAllocation_T</highlight></codeline>
<codeline lineno="5962"><highlight class="normal">{</highlight></codeline>
<codeline lineno="5963"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">friend</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaDedicatedAllocationListItemTraits;</highlight></codeline>
<codeline lineno="5964"><highlight class="normal"></highlight></codeline>
<codeline lineno="5965"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/>FLAGS</highlight></codeline>
<codeline lineno="5966"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5967"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FLAG_PERSISTENT_MAP<sp/><sp/><sp/>=<sp/>0x01,</highlight></codeline>
<codeline lineno="5968"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FLAG_MAPPING_ALLOWED<sp/><sp/>=<sp/>0x02,</highlight></codeline>
<codeline lineno="5969"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="5970"><highlight class="normal"></highlight></codeline>
<codeline lineno="5971"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="5972"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/>ALLOCATION_TYPE</highlight></codeline>
<codeline lineno="5973"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="5974"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ALLOCATION_TYPE_NONE,</highlight></codeline>
<codeline lineno="5975"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ALLOCATION_TYPE_BLOCK,</highlight></codeline>
<codeline lineno="5976"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ALLOCATION_TYPE_DEDICATED,</highlight></codeline>
<codeline lineno="5977"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="5978"><highlight class="normal"></highlight></codeline>
<codeline lineno="5979"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>struct<sp/>is<sp/>allocated<sp/>using<sp/>VmaPoolAllocator.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5980"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocation_T(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>mappingAllowed);</highlight></codeline>
<codeline lineno="5981"><highlight class="normal"><sp/><sp/><sp/><sp/>~VmaAllocation_T();</highlight></codeline>
<codeline lineno="5982"><highlight class="normal"></highlight></codeline>
<codeline lineno="5983"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>InitBlockAllocation(</highlight></codeline>
<codeline lineno="5984"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/>block,</highlight></codeline>
<codeline lineno="5985"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAllocHandle<sp/>allocHandle,</highlight></codeline>
<codeline lineno="5986"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>alignment,</highlight></codeline>
<codeline lineno="5987"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size,</highlight></codeline>
<codeline lineno="5988"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>memoryTypeIndex,</highlight></codeline>
<codeline lineno="5989"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>suballocationType,</highlight></codeline>
<codeline lineno="5990"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>mapped);</highlight></codeline>
<codeline lineno="5991"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>pMappedData<sp/>not<sp/>null<sp/>means<sp/>allocation<sp/>is<sp/>created<sp/>with<sp/>MAPPED<sp/>flag.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5992"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>InitDedicatedAllocation(</highlight></codeline>
<codeline lineno="5993"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>hParentPool,</highlight></codeline>
<codeline lineno="5994"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>memoryTypeIndex,</highlight></codeline>
<codeline lineno="5995"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceMemory<sp/>hMemory,</highlight></codeline>
<codeline lineno="5996"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>suballocationType,</highlight></codeline>
<codeline lineno="5997"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pMappedData,</highlight></codeline>
<codeline lineno="5998"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size);</highlight></codeline>
<codeline lineno="5999"><highlight class="normal"></highlight></codeline>
<codeline lineno="6000"><highlight class="normal"><sp/><sp/><sp/><sp/>ALLOCATION_TYPE<sp/>GetType()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(ALLOCATION_TYPE)m_Type;<sp/>}</highlight></codeline>
<codeline lineno="6001"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>GetAlignment()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Alignment;<sp/>}</highlight></codeline>
<codeline lineno="6002"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>GetSize()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Size;<sp/>}</highlight></codeline>
<codeline lineno="6003"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>GetUserData()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pUserData;<sp/>}</highlight></codeline>
<codeline lineno="6004"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>GetName()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pName;<sp/>}</highlight></codeline>
<codeline lineno="6005"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>GetSuballocationType()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(VmaSuballocationType)m_SuballocationType;<sp/>}</highlight></codeline>
<codeline lineno="6006"><highlight class="normal"></highlight></codeline>
<codeline lineno="6007"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/>GetBlock()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/>VMA_ASSERT(m_Type<sp/>==<sp/>ALLOCATION_TYPE_BLOCK);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_BlockAllocation.m_Block;<sp/>}</highlight></codeline>
<codeline lineno="6008"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>GetMemoryTypeIndex()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_MemoryTypeIndex;<sp/>}</highlight></codeline>
<codeline lineno="6009"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>IsPersistentMap()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(m_Flags<sp/>&amp;<sp/>FLAG_PERSISTENT_MAP)<sp/>!=<sp/>0;<sp/>}</highlight></codeline>
<codeline lineno="6010"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>IsMappingAllowed()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(m_Flags<sp/>&amp;<sp/>FLAG_MAPPING_ALLOWED)<sp/>!=<sp/>0;<sp/>}</highlight></codeline>
<codeline lineno="6011"><highlight class="normal"></highlight></codeline>
<codeline lineno="6012"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>SetUserData(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pUserData)<sp/>{<sp/>m_pUserData<sp/>=<sp/>pUserData;<sp/>}</highlight></codeline>
<codeline lineno="6013"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>SetName(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>pName);</highlight></codeline>
<codeline lineno="6014"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>FreeName(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator);</highlight></codeline>
<codeline lineno="6015"><highlight class="normal"><sp/><sp/><sp/><sp/>uint8_t<sp/>SwapBlockAllocation(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,<sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>allocation);</highlight></codeline>
<codeline lineno="6016"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocHandle<sp/>GetAllocHandle()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6017"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>GetOffset()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6018"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>GetParentPool()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6019"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceMemory<sp/>GetMemory()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6020"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>GetMappedData()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6021"><highlight class="normal"></highlight></codeline>
<codeline lineno="6022"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>BlockAllocMap();</highlight></codeline>
<codeline lineno="6023"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>BlockAllocUnmap();</highlight></codeline>
<codeline lineno="6024"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>DedicatedAllocMap(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">**<sp/>ppData);</highlight></codeline>
<codeline lineno="6025"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DedicatedAllocUnmap(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator);</highlight></codeline>
<codeline lineno="6026"><highlight class="normal"></highlight></codeline>
<codeline lineno="6027"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6028"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>GetBufferImageUsage()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_BufferImageUsage;<sp/>}</highlight></codeline>
<codeline lineno="6029"><highlight class="normal"></highlight></codeline>
<codeline lineno="6030"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>InitBufferImageUsage(uint32_t<sp/>bufferImageUsage);</highlight></codeline>
<codeline lineno="6031"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>PrintParameters(</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>VmaJsonWriter&amp;<sp/>json)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6032"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6033"><highlight class="normal"></highlight></codeline>
<codeline lineno="6034"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="6035"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Allocation<sp/>out<sp/>of<sp/>VmaDeviceMemoryBlock.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6036"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">BlockAllocation</highlight></codeline>
<codeline lineno="6037"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6038"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/>m_Block;</highlight></codeline>
<codeline lineno="6039"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAllocHandle<sp/>m_AllocHandle;</highlight></codeline>
<codeline lineno="6040"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="6041"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Allocation<sp/>for<sp/>an<sp/>object<sp/>that<sp/>has<sp/>its<sp/>own<sp/>private<sp/>VkDeviceMemory.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6042"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">DedicatedAllocation</highlight></codeline>
<codeline lineno="6043"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6044"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>m_hParentPool;<sp/></highlight><highlight class="comment">//<sp/>VK_NULL_HANDLE<sp/>if<sp/>not<sp/>belongs<sp/>to<sp/>custom<sp/>pool.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6045"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceMemory<sp/>m_hMemory;</highlight></codeline>
<codeline lineno="6046"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>m_pMappedData;<sp/></highlight><highlight class="comment">//<sp/>Not<sp/>null<sp/>means<sp/>memory<sp/>is<sp/>mapped.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6047"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAllocation_T*<sp/>m_Prev;</highlight></codeline>
<codeline lineno="6048"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAllocation_T*<sp/>m_Next;</highlight></codeline>
<codeline lineno="6049"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="6050"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">union</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6051"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6052"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Allocation<sp/>out<sp/>of<sp/>VmaDeviceMemoryBlock.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6053"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>BlockAllocation<sp/>m_BlockAllocation;</highlight></codeline>
<codeline lineno="6054"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Allocation<sp/>for<sp/>an<sp/>object<sp/>that<sp/>has<sp/>its<sp/>own<sp/>private<sp/>VkDeviceMemory.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6055"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>DedicatedAllocation<sp/>m_DedicatedAllocation;</highlight></codeline>
<codeline lineno="6056"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="6057"><highlight class="normal"></highlight></codeline>
<codeline lineno="6058"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>m_Alignment;</highlight></codeline>
<codeline lineno="6059"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>m_Size;</highlight></codeline>
<codeline lineno="6060"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>m_pUserData;</highlight></codeline>
<codeline lineno="6061"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>m_pName;</highlight></codeline>
<codeline lineno="6062"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>m_MemoryTypeIndex;</highlight></codeline>
<codeline lineno="6063"><highlight class="normal"><sp/><sp/><sp/><sp/>uint8_t<sp/>m_Type;<sp/></highlight><highlight class="comment">//<sp/>ALLOCATION_TYPE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6064"><highlight class="normal"><sp/><sp/><sp/><sp/>uint8_t<sp/>m_SuballocationType;<sp/></highlight><highlight class="comment">//<sp/>VmaSuballocationType</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6065"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Reference<sp/>counter<sp/>for<sp/>vmaMapMemory()/vmaUnmapMemory().</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6066"><highlight class="normal"><sp/><sp/><sp/><sp/>uint8_t<sp/>m_MapCount;</highlight></codeline>
<codeline lineno="6067"><highlight class="normal"><sp/><sp/><sp/><sp/>uint8_t<sp/>m_Flags;<sp/></highlight><highlight class="comment">//<sp/>enum<sp/>FLAGS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6068"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6069"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>m_BufferImageUsage;<sp/></highlight><highlight class="comment">//<sp/>0<sp/>if<sp/>unknown.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6070"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6071"><highlight class="normal">};</highlight></codeline>
<codeline lineno="6072"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_ALLOCATION_T</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6073"><highlight class="normal"></highlight></codeline>
<codeline lineno="6074"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_DEDICATED_ALLOCATION_LIST_ITEM_TRAITS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6075"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaDedicatedAllocationListItemTraits</highlight></codeline>
<codeline lineno="6076"><highlight class="normal">{</highlight></codeline>
<codeline lineno="6077"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VmaAllocation_T<sp/>ItemType;</highlight></codeline>
<codeline lineno="6078"><highlight class="normal"></highlight></codeline>
<codeline lineno="6079"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>ItemType*<sp/>GetPrev(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ItemType*<sp/>item)</highlight></codeline>
<codeline lineno="6080"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6081"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(item-&gt;GetType()<sp/>==<sp/>VmaAllocation_T::ALLOCATION_TYPE_DEDICATED);</highlight></codeline>
<codeline lineno="6082"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>item-&gt;m_DedicatedAllocation.m_Prev;</highlight></codeline>
<codeline lineno="6083"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6084"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>ItemType*<sp/>GetNext(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ItemType*<sp/>item)</highlight></codeline>
<codeline lineno="6085"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6086"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(item-&gt;GetType()<sp/>==<sp/>VmaAllocation_T::ALLOCATION_TYPE_DEDICATED);</highlight></codeline>
<codeline lineno="6087"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>item-&gt;m_DedicatedAllocation.m_Next;</highlight></codeline>
<codeline lineno="6088"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6089"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>ItemType*&amp;<sp/>AccessPrev(ItemType*<sp/>item)</highlight></codeline>
<codeline lineno="6090"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6091"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(item-&gt;GetType()<sp/>==<sp/>VmaAllocation_T::ALLOCATION_TYPE_DEDICATED);</highlight></codeline>
<codeline lineno="6092"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>item-&gt;m_DedicatedAllocation.m_Prev;</highlight></codeline>
<codeline lineno="6093"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6094"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>ItemType*&amp;<sp/>AccessNext(ItemType*<sp/>item)</highlight></codeline>
<codeline lineno="6095"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6096"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(item-&gt;GetType()<sp/>==<sp/>VmaAllocation_T::ALLOCATION_TYPE_DEDICATED);</highlight></codeline>
<codeline lineno="6097"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>item-&gt;m_DedicatedAllocation.m_Next;</highlight></codeline>
<codeline lineno="6098"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6099"><highlight class="normal">};</highlight></codeline>
<codeline lineno="6100"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_DEDICATED_ALLOCATION_LIST_ITEM_TRAITS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6101"><highlight class="normal"></highlight></codeline>
<codeline lineno="6102"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_DEDICATED_ALLOCATION_LIST</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6103"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="6104"><highlight class="comment">Stores<sp/>linked<sp/>list<sp/>of<sp/>VmaAllocation_T<sp/>objects.</highlight></codeline>
<codeline lineno="6105"><highlight class="comment">Thread-safe,<sp/>synchronized<sp/>internally.</highlight></codeline>
<codeline lineno="6106"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6107"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaDedicatedAllocationList</highlight></codeline>
<codeline lineno="6108"><highlight class="normal">{</highlight></codeline>
<codeline lineno="6109"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="6110"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaDedicatedAllocationList()<sp/>{}</highlight></codeline>
<codeline lineno="6111"><highlight class="normal"><sp/><sp/><sp/><sp/>~VmaDedicatedAllocationList();</highlight></codeline>
<codeline lineno="6112"><highlight class="normal"></highlight></codeline>
<codeline lineno="6113"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Init(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>useMutex)<sp/>{<sp/>m_UseMutex<sp/>=<sp/>useMutex;<sp/>}</highlight></codeline>
<codeline lineno="6114"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>Validate();</highlight></codeline>
<codeline lineno="6115"><highlight class="normal"></highlight></codeline>
<codeline lineno="6116"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>AddDetailedStatistics(<ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>&amp;<sp/>inoutStats);</highlight></codeline>
<codeline lineno="6117"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>AddStatistics(<ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref>&amp;<sp/>inoutStats);</highlight></codeline>
<codeline lineno="6118"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6119"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Writes<sp/>JSON<sp/>array<sp/>with<sp/>the<sp/>list<sp/>of<sp/>allocations.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6120"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>BuildStatsString(VmaJsonWriter&amp;<sp/>json);</highlight></codeline>
<codeline lineno="6121"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6122"><highlight class="normal"></highlight></codeline>
<codeline lineno="6123"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>IsEmpty();</highlight></codeline>
<codeline lineno="6124"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Register(<ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>alloc);</highlight></codeline>
<codeline lineno="6125"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Unregister(<ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>alloc);</highlight></codeline>
<codeline lineno="6126"><highlight class="normal"></highlight></codeline>
<codeline lineno="6127"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="6128"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VmaIntrusiveLinkedList&lt;VmaDedicatedAllocationListItemTraits&gt;<sp/>DedicatedAllocationLinkedList;</highlight></codeline>
<codeline lineno="6129"><highlight class="normal"></highlight></codeline>
<codeline lineno="6130"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>m_UseMutex<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6131"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_RW_MUTEX<sp/>m_Mutex;</highlight></codeline>
<codeline lineno="6132"><highlight class="normal"><sp/><sp/><sp/><sp/>DedicatedAllocationLinkedList<sp/>m_AllocationList;</highlight></codeline>
<codeline lineno="6133"><highlight class="normal">};</highlight></codeline>
<codeline lineno="6134"><highlight class="normal"></highlight></codeline>
<codeline lineno="6135"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_DEDICATED_ALLOCATION_LIST_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6136"><highlight class="normal"></highlight></codeline>
<codeline lineno="6137"><highlight class="normal">VmaDedicatedAllocationList::~VmaDedicatedAllocationList()</highlight></codeline>
<codeline lineno="6138"><highlight class="normal">{</highlight></codeline>
<codeline lineno="6139"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(Validate());</highlight></codeline>
<codeline lineno="6140"><highlight class="normal"></highlight></codeline>
<codeline lineno="6141"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!m_AllocationList.IsEmpty())</highlight></codeline>
<codeline lineno="6142"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6143"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(</highlight><highlight class="keyword">false</highlight><highlight class="normal"><sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Unfreed<sp/>dedicated<sp/>allocations<sp/>found!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="6144"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6145"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6146"><highlight class="normal"></highlight></codeline>
<codeline lineno="6147"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaDedicatedAllocationList::Validate()</highlight></codeline>
<codeline lineno="6148"><highlight class="normal">{</highlight></codeline>
<codeline lineno="6149"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>declaredCount<sp/>=<sp/>m_AllocationList.GetCount();</highlight></codeline>
<codeline lineno="6150"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>actualCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6151"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaMutexLockRead<sp/>lock(m_Mutex,<sp/>m_UseMutex);</highlight></codeline>
<codeline lineno="6152"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>alloc<sp/>=<sp/>m_AllocationList.Front();</highlight></codeline>
<codeline lineno="6153"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc<sp/>!=<sp/>VMA_NULL;<sp/>alloc<sp/>=<sp/>m_AllocationList.GetNext(alloc))</highlight></codeline>
<codeline lineno="6154"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++actualCount;</highlight></codeline>
<codeline lineno="6156"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6157"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE(actualCount<sp/>==<sp/>declaredCount);</highlight></codeline>
<codeline lineno="6158"><highlight class="normal"></highlight></codeline>
<codeline lineno="6159"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6160"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6161"><highlight class="normal"></highlight></codeline>
<codeline lineno="6162"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaDedicatedAllocationList::AddDetailedStatistics(<ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>&amp;<sp/>inoutStats)</highlight></codeline>
<codeline lineno="6163"><highlight class="normal">{</highlight></codeline>
<codeline lineno="6164"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keyword">auto</highlight><highlight class="normal">*<sp/>item<sp/>=<sp/>m_AllocationList.Front();<sp/>item<sp/>!=<sp/></highlight><highlight class="keyword">nullptr</highlight><highlight class="normal">;<sp/>item<sp/>=<sp/>DedicatedAllocationLinkedList::GetNext(item))</highlight></codeline>
<codeline lineno="6165"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6166"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>size<sp/>=<sp/>item-&gt;GetSize();</highlight></codeline>
<codeline lineno="6167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1a309179d5853a6a7cd534df497ee43957" kindref="member">blockCount</ref>++;</highlight></codeline>
<codeline lineno="6168"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1a2afbc1c7aa8ad7bbb8de06215ba7e5c4" kindref="member">blockBytes</ref><sp/>+=<sp/>size;</highlight></codeline>
<codeline lineno="6169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAddDetailedStatisticsAllocation(inoutStats,<sp/>item-&gt;GetSize());</highlight></codeline>
<codeline lineno="6170"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6171"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6172"><highlight class="normal"></highlight></codeline>
<codeline lineno="6173"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaDedicatedAllocationList::AddStatistics(<ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref>&amp;<sp/>inoutStats)</highlight></codeline>
<codeline lineno="6174"><highlight class="normal">{</highlight></codeline>
<codeline lineno="6175"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaMutexLockRead<sp/>lock(m_Mutex,<sp/>m_UseMutex);</highlight></codeline>
<codeline lineno="6176"><highlight class="normal"></highlight></codeline>
<codeline lineno="6177"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>allocCount<sp/>=<sp/>(uint32_t)m_AllocationList.GetCount();</highlight></codeline>
<codeline lineno="6178"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_statistics_1a309179d5853a6a7cd534df497ee43957" kindref="member">blockCount</ref><sp/>+=<sp/>allocCount;</highlight></codeline>
<codeline lineno="6179"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_statistics_1ab0ff76e50f58f9f54b6f265e5bf5dde2" kindref="member">allocationCount</ref><sp/>+=<sp/>allocCount;</highlight></codeline>
<codeline lineno="6180"><highlight class="normal"></highlight></codeline>
<codeline lineno="6181"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keyword">auto</highlight><highlight class="normal">*<sp/>item<sp/>=<sp/>m_AllocationList.Front();<sp/>item<sp/>!=<sp/></highlight><highlight class="keyword">nullptr</highlight><highlight class="normal">;<sp/>item<sp/>=<sp/>DedicatedAllocationLinkedList::GetNext(item))</highlight></codeline>
<codeline lineno="6182"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>size<sp/>=<sp/>item-&gt;GetSize();</highlight></codeline>
<codeline lineno="6184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_statistics_1a2afbc1c7aa8ad7bbb8de06215ba7e5c4" kindref="member">blockBytes</ref><sp/>+=<sp/>size;</highlight></codeline>
<codeline lineno="6185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_statistics_1a21db06eba3422f87a2b4b4703d879c16" kindref="member">allocationBytes</ref><sp/>+=<sp/>size;</highlight></codeline>
<codeline lineno="6186"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6187"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6188"><highlight class="normal"></highlight></codeline>
<codeline lineno="6189"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6190"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaDedicatedAllocationList::BuildStatsString(VmaJsonWriter&amp;<sp/>json)</highlight></codeline>
<codeline lineno="6191"><highlight class="normal">{</highlight></codeline>
<codeline lineno="6192"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaMutexLockRead<sp/>lock(m_Mutex,<sp/>m_UseMutex);</highlight></codeline>
<codeline lineno="6193"><highlight class="normal"><sp/><sp/><sp/><sp/>json.BeginArray();</highlight></codeline>
<codeline lineno="6194"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>alloc<sp/>=<sp/>m_AllocationList.Front();</highlight></codeline>
<codeline lineno="6195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc<sp/>!=<sp/>VMA_NULL;<sp/>alloc<sp/>=<sp/>m_AllocationList.GetNext(alloc))</highlight></codeline>
<codeline lineno="6196"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.BeginObject(</highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="6198"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alloc-&gt;PrintParameters(json);</highlight></codeline>
<codeline lineno="6199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.EndObject();</highlight></codeline>
<codeline lineno="6200"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6201"><highlight class="normal"><sp/><sp/><sp/><sp/>json.EndArray();</highlight></codeline>
<codeline lineno="6202"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6203"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6204"><highlight class="normal"></highlight></codeline>
<codeline lineno="6205"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaDedicatedAllocationList::IsEmpty()</highlight></codeline>
<codeline lineno="6206"><highlight class="normal">{</highlight></codeline>
<codeline lineno="6207"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaMutexLockRead<sp/>lock(m_Mutex,<sp/>m_UseMutex);</highlight></codeline>
<codeline lineno="6208"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_AllocationList.IsEmpty();</highlight></codeline>
<codeline lineno="6209"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6210"><highlight class="normal"></highlight></codeline>
<codeline lineno="6211"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaDedicatedAllocationList::Register(<ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>alloc)</highlight></codeline>
<codeline lineno="6212"><highlight class="normal">{</highlight></codeline>
<codeline lineno="6213"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaMutexLockWrite<sp/>lock(m_Mutex,<sp/>m_UseMutex);</highlight></codeline>
<codeline lineno="6214"><highlight class="normal"><sp/><sp/><sp/><sp/>m_AllocationList.PushBack(alloc);</highlight></codeline>
<codeline lineno="6215"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6216"><highlight class="normal"></highlight></codeline>
<codeline lineno="6217"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaDedicatedAllocationList::Unregister(<ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>alloc)</highlight></codeline>
<codeline lineno="6218"><highlight class="normal">{</highlight></codeline>
<codeline lineno="6219"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaMutexLockWrite<sp/>lock(m_Mutex,<sp/>m_UseMutex);</highlight></codeline>
<codeline lineno="6220"><highlight class="normal"><sp/><sp/><sp/><sp/>m_AllocationList.Remove(alloc);</highlight></codeline>
<codeline lineno="6221"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6222"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_DEDICATED_ALLOCATION_LIST_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6223"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_DEDICATED_ALLOCATION_LIST</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6224"><highlight class="normal"></highlight></codeline>
<codeline lineno="6225"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_SUBALLOCATION</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6226"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="6227"><highlight class="comment">Represents<sp/>a<sp/>region<sp/>of<sp/>VmaDeviceMemoryBlock<sp/>that<sp/>is<sp/>either<sp/>assigned<sp/>and<sp/>returned<sp/>as</highlight></codeline>
<codeline lineno="6228"><highlight class="comment">allocated<sp/>memory<sp/>block<sp/>or<sp/>free.</highlight></codeline>
<codeline lineno="6229"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6230"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaSuballocation</highlight></codeline>
<codeline lineno="6231"><highlight class="normal">{</highlight></codeline>
<codeline lineno="6232"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>offset;</highlight></codeline>
<codeline lineno="6233"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size;</highlight></codeline>
<codeline lineno="6234"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>userData;</highlight></codeline>
<codeline lineno="6235"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>type;</highlight></codeline>
<codeline lineno="6236"><highlight class="normal">};</highlight></codeline>
<codeline lineno="6237"><highlight class="normal"></highlight></codeline>
<codeline lineno="6238"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Comparator<sp/>for<sp/>offsets.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6239"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaSuballocationOffsetLess</highlight></codeline>
<codeline lineno="6240"><highlight class="normal">{</highlight></codeline>
<codeline lineno="6241"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>operator()(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>lhs,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>rhs)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="6242"><highlight class="keyword"><sp/><sp/><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="6243"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>lhs.offset<sp/>&lt;<sp/>rhs.offset;</highlight></codeline>
<codeline lineno="6244"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6245"><highlight class="normal">};</highlight></codeline>
<codeline lineno="6246"><highlight class="normal"></highlight></codeline>
<codeline lineno="6247"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaSuballocationOffsetGreater</highlight></codeline>
<codeline lineno="6248"><highlight class="normal">{</highlight></codeline>
<codeline lineno="6249"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>operator()(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>lhs,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>rhs)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="6250"><highlight class="keyword"><sp/><sp/><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="6251"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>lhs.offset<sp/>&gt;<sp/>rhs.offset;</highlight></codeline>
<codeline lineno="6252"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6253"><highlight class="normal">};</highlight></codeline>
<codeline lineno="6254"><highlight class="normal"></highlight></codeline>
<codeline lineno="6255"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaSuballocationItemSizeLess</highlight></codeline>
<codeline lineno="6256"><highlight class="normal">{</highlight></codeline>
<codeline lineno="6257"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>operator()(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocationList::iterator<sp/>lhs,</highlight></codeline>
<codeline lineno="6258"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocationList::iterator<sp/>rhs)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="6259"><highlight class="keyword"><sp/><sp/><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="6260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>lhs-&gt;size<sp/>&lt;<sp/>rhs-&gt;size;</highlight></codeline>
<codeline lineno="6261"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6262"><highlight class="normal"></highlight></codeline>
<codeline lineno="6263"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>operator()(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocationList::iterator<sp/>lhs,</highlight></codeline>
<codeline lineno="6264"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>rhsSize)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="6265"><highlight class="keyword"><sp/><sp/><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="6266"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>lhs-&gt;size<sp/>&lt;<sp/>rhsSize;</highlight></codeline>
<codeline lineno="6267"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6268"><highlight class="normal">};</highlight></codeline>
<codeline lineno="6269"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_SUBALLOCATION</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6270"><highlight class="normal"></highlight></codeline>
<codeline lineno="6271"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_ALLOCATION_REQUEST</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6272"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="6273"><highlight class="comment">Parameters<sp/>of<sp/>planned<sp/>allocation<sp/>inside<sp/>a<sp/>VmaDeviceMemoryBlock.</highlight></codeline>
<codeline lineno="6274"><highlight class="comment">item<sp/>points<sp/>to<sp/>a<sp/>FREE<sp/>suballocation.</highlight></codeline>
<codeline lineno="6275"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6276"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaAllocationRequest</highlight></codeline>
<codeline lineno="6277"><highlight class="normal">{</highlight></codeline>
<codeline lineno="6278"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocHandle<sp/>allocHandle;</highlight></codeline>
<codeline lineno="6279"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size;</highlight></codeline>
<codeline lineno="6280"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationList::iterator<sp/>item;</highlight></codeline>
<codeline lineno="6281"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>customData;</highlight></codeline>
<codeline lineno="6282"><highlight class="normal"><sp/><sp/><sp/><sp/>uint64_t<sp/>algorithmData;</highlight></codeline>
<codeline lineno="6283"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocationRequestType<sp/>type;</highlight></codeline>
<codeline lineno="6284"><highlight class="normal">};</highlight></codeline>
<codeline lineno="6285"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_ALLOCATION_REQUEST</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6286"><highlight class="normal"></highlight></codeline>
<codeline lineno="6287"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_BLOCK_METADATA</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6288"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="6289"><highlight class="comment">Data<sp/>structure<sp/>used<sp/>for<sp/>bookkeeping<sp/>of<sp/>allocations<sp/>and<sp/>unused<sp/>ranges<sp/>of<sp/>memory</highlight></codeline>
<codeline lineno="6290"><highlight class="comment">in<sp/>a<sp/>single<sp/>VkDeviceMemory<sp/>block.</highlight></codeline>
<codeline lineno="6291"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6292"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaBlockMetadata</highlight></codeline>
<codeline lineno="6293"><highlight class="normal">{</highlight></codeline>
<codeline lineno="6294"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="6295"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>pAllocationCallbacks,<sp/>if<sp/>not<sp/>null,<sp/>must<sp/>be<sp/>owned<sp/>externally<sp/>-<sp/>alive<sp/>and<sp/>unchanged<sp/>for<sp/>the<sp/>whole<sp/>lifetime<sp/>of<sp/>this<sp/>object.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6296"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaBlockMetadata(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks,</highlight></codeline>
<codeline lineno="6297"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>bufferImageGranularity,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isVirtual);</highlight></codeline>
<codeline lineno="6298"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>~VmaBlockMetadata()<sp/>=<sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6299"><highlight class="normal"></highlight></codeline>
<codeline lineno="6300"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Init(VkDeviceSize<sp/>size)<sp/>{<sp/>m_Size<sp/>=<sp/>size;<sp/>}</highlight></codeline>
<codeline lineno="6301"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>IsVirtual()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_IsVirtual;<sp/>}</highlight></codeline>
<codeline lineno="6302"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>GetSize()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Size;<sp/>}</highlight></codeline>
<codeline lineno="6303"><highlight class="normal"></highlight></codeline>
<codeline lineno="6304"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Validates<sp/>all<sp/>data<sp/>structures<sp/>inside<sp/>this<sp/>object.<sp/>If<sp/>not<sp/>valid,<sp/>returns<sp/>false.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6305"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>Validate()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6306"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>GetAllocationCount()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6307"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>GetFreeRegionsCount()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6308"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>GetSumFreeSize()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6309"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Returns<sp/>true<sp/>if<sp/>this<sp/>block<sp/>is<sp/>empty<sp/>-<sp/>contains<sp/>only<sp/>single<sp/>free<sp/>suballocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6310"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>IsEmpty()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6311"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GetAllocationInfo(VmaAllocHandle<sp/>allocHandle,<sp/><ref refid="struct_vma_virtual_allocation_info" kindref="compound">VmaVirtualAllocationInfo</ref>&amp;<sp/>outInfo)<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6312"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>GetAllocationOffset(VmaAllocHandle<sp/>allocHandle)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6313"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>GetAllocationUserData(VmaAllocHandle<sp/>allocHandle)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6314"><highlight class="normal"></highlight></codeline>
<codeline lineno="6315"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>VmaAllocHandle<sp/>GetAllocationListBegin()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6316"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>VmaAllocHandle<sp/>GetNextAllocation(VmaAllocHandle<sp/>prevAlloc)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6317"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>GetNextFreeRegionSize(VmaAllocHandle<sp/>alloc)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6318"><highlight class="normal"></highlight></codeline>
<codeline lineno="6319"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Shouldn&apos;t<sp/>modify<sp/>blockCount.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6320"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>AddDetailedStatistics(<ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>&amp;<sp/>inoutStats)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6321"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>AddStatistics(<ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref>&amp;<sp/>inoutStats)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6322"><highlight class="normal"></highlight></codeline>
<codeline lineno="6323"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6324"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>PrintDetailedMap(</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>VmaJsonWriter&amp;<sp/>json)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6325"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6326"><highlight class="normal"></highlight></codeline>
<codeline lineno="6327"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Tries<sp/>to<sp/>find<sp/>a<sp/>place<sp/>for<sp/>suballocation<sp/>with<sp/>given<sp/>parameters<sp/>inside<sp/>this<sp/>block.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6328"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>succeeded,<sp/>fills<sp/>pAllocationRequest<sp/>and<sp/>returns<sp/>true.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6329"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>failed,<sp/>returns<sp/>false.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6330"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>CreateAllocationRequest(</highlight></codeline>
<codeline lineno="6331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocSize,</highlight></codeline>
<codeline lineno="6332"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocAlignment,</highlight></codeline>
<codeline lineno="6333"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>upperAddress,</highlight></codeline>
<codeline lineno="6334"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>allocType,</highlight></codeline>
<codeline lineno="6335"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Always<sp/>one<sp/>of<sp/>VMA_ALLOCATION_CREATE_STRATEGY_*<sp/>or<sp/>VMA_ALLOCATION_INTERNAL_STRATEGY_*<sp/>flags.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6336"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>strategy,</highlight></codeline>
<codeline lineno="6337"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAllocationRequest*<sp/>pAllocationRequest)<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6338"><highlight class="normal"></highlight></codeline>
<codeline lineno="6339"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>VkResult<sp/>CheckCorruption(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pBlockData)<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6340"><highlight class="normal"></highlight></codeline>
<codeline lineno="6341"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Makes<sp/>actual<sp/>allocation<sp/>based<sp/>on<sp/>request.<sp/>Request<sp/>must<sp/>already<sp/>be<sp/>checked<sp/>and<sp/>valid.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6342"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Alloc(</highlight></codeline>
<codeline lineno="6343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaAllocationRequest&amp;<sp/>request,</highlight></codeline>
<codeline lineno="6344"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>type,</highlight></codeline>
<codeline lineno="6345"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>userData)<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6346"><highlight class="normal"></highlight></codeline>
<codeline lineno="6347"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Frees<sp/>suballocation<sp/>assigned<sp/>to<sp/>given<sp/>memory<sp/>region.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6348"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Free(VmaAllocHandle<sp/>allocHandle)<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6349"><highlight class="normal"></highlight></codeline>
<codeline lineno="6350"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Frees<sp/>all<sp/>allocations.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6351"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Careful!<sp/>Don&apos;t<sp/>call<sp/>it<sp/>if<sp/>there<sp/>are<sp/>VmaAllocation<sp/>objects<sp/>owned<sp/>by<sp/>userData<sp/>of<sp/>cleared<sp/>allocations!</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6352"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Clear()<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6353"><highlight class="normal"></highlight></codeline>
<codeline lineno="6354"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>SetAllocationUserData(VmaAllocHandle<sp/>allocHandle,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>userData)<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6355"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DebugLogAllAllocations()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6356"><highlight class="normal"></highlight></codeline>
<codeline lineno="6357"><highlight class="normal"></highlight><highlight class="keyword">protected</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="6358"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>GetAllocationCallbacks()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pAllocationCallbacks;<sp/>}</highlight></codeline>
<codeline lineno="6359"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>GetBufferImageGranularity()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_BufferImageGranularity;<sp/>}</highlight></codeline>
<codeline lineno="6360"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>GetDebugMargin()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>IsVirtual()<sp/>?<sp/>0<sp/>:<sp/>VMA_DEBUG_MARGIN;<sp/>}</highlight></codeline>
<codeline lineno="6361"><highlight class="normal"></highlight></codeline>
<codeline lineno="6362"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DebugLogAllocation(VkDeviceSize<sp/>offset,<sp/>VkDeviceSize<sp/>size,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>userData)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6363"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6364"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>mapRefCount<sp/>==<sp/>UINT32_MAX<sp/>means<sp/>unspecified.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6365"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>PrintDetailedMap_Begin(</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>VmaJsonWriter&amp;<sp/>json,</highlight></codeline>
<codeline lineno="6366"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>unusedBytes,</highlight></codeline>
<codeline lineno="6367"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>allocationCount,</highlight></codeline>
<codeline lineno="6368"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>unusedRangeCount)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6369"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>PrintDetailedMap_Allocation(</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>VmaJsonWriter&amp;<sp/>json,</highlight></codeline>
<codeline lineno="6370"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>offset,<sp/>VkDeviceSize<sp/>size,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>userData)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6371"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>PrintDetailedMap_UnusedRange(</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>VmaJsonWriter&amp;<sp/>json,</highlight></codeline>
<codeline lineno="6372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>offset,</highlight></codeline>
<codeline lineno="6373"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6374"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>PrintDetailedMap_End(</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>VmaJsonWriter&amp;<sp/>json)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6375"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6376"><highlight class="normal"></highlight></codeline>
<codeline lineno="6377"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="6378"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>m_Size;</highlight></codeline>
<codeline lineno="6379"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>m_pAllocationCallbacks;</highlight></codeline>
<codeline lineno="6380"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>m_BufferImageGranularity;</highlight></codeline>
<codeline lineno="6381"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>m_IsVirtual;</highlight></codeline>
<codeline lineno="6382"><highlight class="normal">};</highlight></codeline>
<codeline lineno="6383"><highlight class="normal"></highlight></codeline>
<codeline lineno="6384"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_BLOCK_METADATA_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6385"><highlight class="normal">VmaBlockMetadata::VmaBlockMetadata(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks,</highlight></codeline>
<codeline lineno="6386"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>bufferImageGranularity,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isVirtual)</highlight></codeline>
<codeline lineno="6387"><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>m_Size(0),</highlight></codeline>
<codeline lineno="6388"><highlight class="normal"><sp/><sp/><sp/><sp/>m_pAllocationCallbacks(pAllocationCallbacks),</highlight></codeline>
<codeline lineno="6389"><highlight class="normal"><sp/><sp/><sp/><sp/>m_BufferImageGranularity(bufferImageGranularity),</highlight></codeline>
<codeline lineno="6390"><highlight class="normal"><sp/><sp/><sp/><sp/>m_IsVirtual(isVirtual)<sp/>{}</highlight></codeline>
<codeline lineno="6391"><highlight class="normal"></highlight></codeline>
<codeline lineno="6392"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata::DebugLogAllocation(VkDeviceSize<sp/>offset,<sp/>VkDeviceSize<sp/>size,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>userData)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="6393"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="6394"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(IsVirtual())</highlight></codeline>
<codeline lineno="6395"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6396"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;UNFREED<sp/>VIRTUAL<sp/>ALLOCATION;<sp/>Offset:<sp/>%llu;<sp/>Size:<sp/>%llu;<sp/>UserData:<sp/>%p&quot;</highlight><highlight class="normal">,<sp/>offset,<sp/>size,<sp/>userData);</highlight></codeline>
<codeline lineno="6397"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6398"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6399"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6400"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(userData<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="6401"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>allocation<sp/>=<sp/></highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal"><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(userData);</highlight></codeline>
<codeline lineno="6402"><highlight class="normal"></highlight></codeline>
<codeline lineno="6403"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>userData<sp/>=<sp/>allocation-&gt;GetUserData();</highlight></codeline>
<codeline lineno="6404"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>name<sp/>=<sp/>allocation-&gt;GetName();</highlight></codeline>
<codeline lineno="6405"><highlight class="normal"></highlight></codeline>
<codeline lineno="6406"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6407"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;UNFREED<sp/>ALLOCATION;<sp/>Offset:<sp/>%llu;<sp/>Size:<sp/>%llu;<sp/>UserData:<sp/>%p;<sp/>Name:<sp/>%s;<sp/>Type:<sp/>%s;<sp/>Usage:<sp/>%u&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="6408"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset,<sp/>size,<sp/>userData,<sp/>name<sp/>?<sp/>name<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;vma_empty&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="6409"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_SUBALLOCATION_TYPE_NAMES[allocation-&gt;GetSuballocationType()],</highlight></codeline>
<codeline lineno="6410"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocation-&gt;GetBufferImageUsage());</highlight></codeline>
<codeline lineno="6411"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6412"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;UNFREED<sp/>ALLOCATION;<sp/>Offset:<sp/>%llu;<sp/>Size:<sp/>%llu;<sp/>UserData:<sp/>%p;<sp/>Name:<sp/>%s;<sp/>Type:<sp/>%u&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="6413"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset,<sp/>size,<sp/>userData,<sp/>name<sp/>?<sp/>name<sp/>:<sp/></highlight><highlight class="stringliteral">&quot;vma_empty&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="6414"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(uint32_t)allocation-&gt;GetSuballocationType());</highlight></codeline>
<codeline lineno="6415"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6416"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6417"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="6418"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6419"><highlight class="normal"></highlight></codeline>
<codeline lineno="6420"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6421"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata::PrintDetailedMap_Begin(</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>VmaJsonWriter&amp;<sp/>json,</highlight></codeline>
<codeline lineno="6422"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>unusedBytes,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>allocationCount,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>unusedRangeCount)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="6423"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="6424"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;TotalBytes&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="6425"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteNumber(GetSize());</highlight></codeline>
<codeline lineno="6426"><highlight class="normal"></highlight></codeline>
<codeline lineno="6427"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;UnusedBytes&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="6428"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteNumber(unusedBytes);</highlight></codeline>
<codeline lineno="6429"><highlight class="normal"></highlight></codeline>
<codeline lineno="6430"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;Allocations&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="6431"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteNumber(allocationCount);</highlight></codeline>
<codeline lineno="6432"><highlight class="normal"></highlight></codeline>
<codeline lineno="6433"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;UnusedRanges&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="6434"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteNumber(unusedRangeCount);</highlight></codeline>
<codeline lineno="6435"><highlight class="normal"></highlight></codeline>
<codeline lineno="6436"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;Suballocations&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="6437"><highlight class="normal"><sp/><sp/><sp/><sp/>json.BeginArray();</highlight></codeline>
<codeline lineno="6438"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6439"><highlight class="normal"></highlight></codeline>
<codeline lineno="6440"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata::PrintDetailedMap_Allocation(</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>VmaJsonWriter&amp;<sp/>json,</highlight></codeline>
<codeline lineno="6441"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>offset,<sp/>VkDeviceSize<sp/>size,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>userData)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="6442"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="6443"><highlight class="normal"><sp/><sp/><sp/><sp/>json.BeginObject(</highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="6444"><highlight class="normal"></highlight></codeline>
<codeline lineno="6445"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;Offset&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="6446"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteNumber(offset);</highlight></codeline>
<codeline lineno="6447"><highlight class="normal"></highlight></codeline>
<codeline lineno="6448"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(IsVirtual())</highlight></codeline>
<codeline lineno="6449"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6450"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;Size&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="6451"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteNumber(size);</highlight></codeline>
<codeline lineno="6452"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(userData)</highlight></codeline>
<codeline lineno="6453"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6454"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;CustomData&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="6455"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.BeginString();</highlight></codeline>
<codeline lineno="6456"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.ContinueString_Pointer(userData);</highlight></codeline>
<codeline lineno="6457"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.EndString();</highlight></codeline>
<codeline lineno="6458"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6459"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6460"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6461"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6462"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>((<ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>)userData)-&gt;PrintParameters(json);</highlight></codeline>
<codeline lineno="6463"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6464"><highlight class="normal"></highlight></codeline>
<codeline lineno="6465"><highlight class="normal"><sp/><sp/><sp/><sp/>json.EndObject();</highlight></codeline>
<codeline lineno="6466"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6467"><highlight class="normal"></highlight></codeline>
<codeline lineno="6468"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata::PrintDetailedMap_UnusedRange(</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>VmaJsonWriter&amp;<sp/>json,</highlight></codeline>
<codeline lineno="6469"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>offset,<sp/>VkDeviceSize<sp/>size)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="6470"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="6471"><highlight class="normal"><sp/><sp/><sp/><sp/>json.BeginObject(</highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="6472"><highlight class="normal"></highlight></codeline>
<codeline lineno="6473"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;Offset&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="6474"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteNumber(offset);</highlight></codeline>
<codeline lineno="6475"><highlight class="normal"></highlight></codeline>
<codeline lineno="6476"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;Type&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="6477"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteString(VMA_SUBALLOCATION_TYPE_NAMES[VMA_SUBALLOCATION_TYPE_FREE]);</highlight></codeline>
<codeline lineno="6478"><highlight class="normal"></highlight></codeline>
<codeline lineno="6479"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;Size&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="6480"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteNumber(size);</highlight></codeline>
<codeline lineno="6481"><highlight class="normal"></highlight></codeline>
<codeline lineno="6482"><highlight class="normal"><sp/><sp/><sp/><sp/>json.EndObject();</highlight></codeline>
<codeline lineno="6483"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6484"><highlight class="normal"></highlight></codeline>
<codeline lineno="6485"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata::PrintDetailedMap_End(</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>VmaJsonWriter&amp;<sp/>json)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="6486"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="6487"><highlight class="normal"><sp/><sp/><sp/><sp/>json.EndArray();</highlight></codeline>
<codeline lineno="6488"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6489"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6490"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_BLOCK_METADATA_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6491"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_BLOCK_METADATA</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6492"><highlight class="normal"></highlight></codeline>
<codeline lineno="6493"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_BLOCK_BUFFER_IMAGE_GRANULARITY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6494"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Before<sp/>deleting<sp/>object<sp/>of<sp/>this<sp/>class<sp/>remember<sp/>to<sp/>call<sp/>&apos;Destroy()&apos;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6495"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaBlockBufferImageGranularity<sp/>final</highlight></codeline>
<codeline lineno="6496"><highlight class="normal">{</highlight></codeline>
<codeline lineno="6497"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="6498"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">ValidationContext</highlight></codeline>
<codeline lineno="6499"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6500"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>allocCallbacks;</highlight></codeline>
<codeline lineno="6501"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint16_t*<sp/>pageAllocs;</highlight></codeline>
<codeline lineno="6502"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="6503"><highlight class="normal"></highlight></codeline>
<codeline lineno="6504"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaBlockBufferImageGranularity(VkDeviceSize<sp/>bufferImageGranularity);</highlight></codeline>
<codeline lineno="6505"><highlight class="normal"><sp/><sp/><sp/><sp/>~VmaBlockBufferImageGranularity();</highlight></codeline>
<codeline lineno="6506"><highlight class="normal"></highlight></codeline>
<codeline lineno="6507"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>IsEnabled()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_BufferImageGranularity<sp/>&gt;<sp/>MAX_LOW_BUFFER_IMAGE_GRANULARITY;<sp/>}</highlight></codeline>
<codeline lineno="6508"><highlight class="normal"></highlight></codeline>
<codeline lineno="6509"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Init(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks,<sp/>VkDeviceSize<sp/>size);</highlight></codeline>
<codeline lineno="6510"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Before<sp/>destroying<sp/>object<sp/>you<sp/>must<sp/>call<sp/>free<sp/>it&apos;s<sp/>memory</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6511"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Destroy(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks);</highlight></codeline>
<codeline lineno="6512"><highlight class="normal"></highlight></codeline>
<codeline lineno="6513"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>RoundupAllocRequest(VmaSuballocationType<sp/>allocType,</highlight></codeline>
<codeline lineno="6514"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize&amp;<sp/>inOutAllocSize,</highlight></codeline>
<codeline lineno="6515"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize&amp;<sp/>inOutAllocAlignment)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6516"><highlight class="normal"></highlight></codeline>
<codeline lineno="6517"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>CheckConflictAndAlignUp(VkDeviceSize&amp;<sp/>inOutAllocOffset,</highlight></codeline>
<codeline lineno="6518"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocSize,</highlight></codeline>
<codeline lineno="6519"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>blockOffset,</highlight></codeline>
<codeline lineno="6520"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>blockSize,</highlight></codeline>
<codeline lineno="6521"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>allocType)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6522"><highlight class="normal"></highlight></codeline>
<codeline lineno="6523"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>AllocPages(uint8_t<sp/>allocType,<sp/>VkDeviceSize<sp/>offset,<sp/>VkDeviceSize<sp/>size);</highlight></codeline>
<codeline lineno="6524"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>FreePages(VkDeviceSize<sp/>offset,<sp/>VkDeviceSize<sp/>size);</highlight></codeline>
<codeline lineno="6525"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Clear();</highlight></codeline>
<codeline lineno="6526"><highlight class="normal"></highlight></codeline>
<codeline lineno="6527"><highlight class="normal"><sp/><sp/><sp/><sp/>ValidationContext<sp/>StartValidation(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks,</highlight></codeline>
<codeline lineno="6528"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isVirutal)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6529"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>Validate(ValidationContext&amp;<sp/>ctx,<sp/>VkDeviceSize<sp/>offset,<sp/>VkDeviceSize<sp/>size)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6530"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>FinishValidation(ValidationContext&amp;<sp/>ctx)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6531"><highlight class="normal"></highlight></codeline>
<codeline lineno="6532"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="6533"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint16_t<sp/>MAX_LOW_BUFFER_IMAGE_GRANULARITY<sp/>=<sp/>256;</highlight></codeline>
<codeline lineno="6534"><highlight class="normal"></highlight></codeline>
<codeline lineno="6535"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">RegionInfo</highlight></codeline>
<codeline lineno="6536"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6537"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint8_t<sp/>allocType;</highlight></codeline>
<codeline lineno="6538"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint16_t<sp/>allocCount;</highlight></codeline>
<codeline lineno="6539"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="6540"><highlight class="normal"></highlight></codeline>
<codeline lineno="6541"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>m_BufferImageGranularity;</highlight></codeline>
<codeline lineno="6542"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>m_RegionCount;</highlight></codeline>
<codeline lineno="6543"><highlight class="normal"><sp/><sp/><sp/><sp/>RegionInfo*<sp/>m_RegionInfo;</highlight></codeline>
<codeline lineno="6544"><highlight class="normal"></highlight></codeline>
<codeline lineno="6545"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>GetStartPage(VkDeviceSize<sp/>offset)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>OffsetToPageIndex(offset<sp/>&amp;<sp/>~(m_BufferImageGranularity<sp/>-<sp/>1));<sp/>}</highlight></codeline>
<codeline lineno="6546"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>GetEndPage(VkDeviceSize<sp/>offset,<sp/>VkDeviceSize<sp/>size)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>OffsetToPageIndex((offset<sp/>+<sp/>size<sp/>-<sp/>1)<sp/>&amp;<sp/>~(m_BufferImageGranularity<sp/>-<sp/>1));<sp/>}</highlight></codeline>
<codeline lineno="6547"><highlight class="normal"></highlight></codeline>
<codeline lineno="6548"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>OffsetToPageIndex(VkDeviceSize<sp/>offset)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6549"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>AllocPage(RegionInfo&amp;<sp/>page,<sp/>uint8_t<sp/>allocType);</highlight></codeline>
<codeline lineno="6550"><highlight class="normal">};</highlight></codeline>
<codeline lineno="6551"><highlight class="normal"></highlight></codeline>
<codeline lineno="6552"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_BLOCK_BUFFER_IMAGE_GRANULARITY_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6553"><highlight class="normal">VmaBlockBufferImageGranularity::VmaBlockBufferImageGranularity(VkDeviceSize<sp/>bufferImageGranularity)</highlight></codeline>
<codeline lineno="6554"><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>m_BufferImageGranularity(bufferImageGranularity),</highlight></codeline>
<codeline lineno="6555"><highlight class="normal"><sp/><sp/><sp/><sp/>m_RegionCount(0),</highlight></codeline>
<codeline lineno="6556"><highlight class="normal"><sp/><sp/><sp/><sp/>m_RegionInfo(VMA_NULL)<sp/>{}</highlight></codeline>
<codeline lineno="6557"><highlight class="normal"></highlight></codeline>
<codeline lineno="6558"><highlight class="normal">VmaBlockBufferImageGranularity::~VmaBlockBufferImageGranularity()</highlight></codeline>
<codeline lineno="6559"><highlight class="normal">{</highlight></codeline>
<codeline lineno="6560"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_RegionInfo<sp/>==<sp/>VMA_NULL<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Free<sp/>not<sp/>called<sp/>before<sp/>destroying<sp/>object!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="6561"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6562"><highlight class="normal"></highlight></codeline>
<codeline lineno="6563"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockBufferImageGranularity::Init(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks,<sp/>VkDeviceSize<sp/>size)</highlight></codeline>
<codeline lineno="6564"><highlight class="normal">{</highlight></codeline>
<codeline lineno="6565"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(IsEnabled())</highlight></codeline>
<codeline lineno="6566"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6567"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_RegionCount<sp/>=<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">uint32_t</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(VmaDivideRoundingUp(size,<sp/>m_BufferImageGranularity));</highlight></codeline>
<codeline lineno="6568"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_RegionInfo<sp/>=<sp/>vma_new_array(pAllocationCallbacks,<sp/>RegionInfo,<sp/>m_RegionCount);</highlight></codeline>
<codeline lineno="6569"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memset(m_RegionInfo,<sp/>0,<sp/>m_RegionCount<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(RegionInfo));</highlight></codeline>
<codeline lineno="6570"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6571"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6572"><highlight class="normal"></highlight></codeline>
<codeline lineno="6573"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockBufferImageGranularity::Destroy(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks)</highlight></codeline>
<codeline lineno="6574"><highlight class="normal">{</highlight></codeline>
<codeline lineno="6575"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_RegionInfo)</highlight></codeline>
<codeline lineno="6576"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6577"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vma_delete_array(pAllocationCallbacks,<sp/>m_RegionInfo,<sp/>m_RegionCount);</highlight></codeline>
<codeline lineno="6578"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_RegionInfo<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="6579"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6580"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6581"><highlight class="normal"></highlight></codeline>
<codeline lineno="6582"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockBufferImageGranularity::RoundupAllocRequest(VmaSuballocationType<sp/>allocType,</highlight></codeline>
<codeline lineno="6583"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize&amp;<sp/>inOutAllocSize,</highlight></codeline>
<codeline lineno="6584"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize&amp;<sp/>inOutAllocAlignment)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="6585"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="6586"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_BufferImageGranularity<sp/>&gt;<sp/>1<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="6587"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_BufferImageGranularity<sp/>&lt;=<sp/>MAX_LOW_BUFFER_IMAGE_GRANULARITY)</highlight></codeline>
<codeline lineno="6588"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6589"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(allocType<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_UNKNOWN<sp/>||</highlight></codeline>
<codeline lineno="6590"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocType<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_IMAGE_UNKNOWN<sp/>||</highlight></codeline>
<codeline lineno="6591"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocType<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL)</highlight></codeline>
<codeline lineno="6592"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6593"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inOutAllocAlignment<sp/>=<sp/>VMA_MAX(inOutAllocAlignment,<sp/>m_BufferImageGranularity);</highlight></codeline>
<codeline lineno="6594"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inOutAllocSize<sp/>=<sp/>VmaAlignUp(inOutAllocSize,<sp/>m_BufferImageGranularity);</highlight></codeline>
<codeline lineno="6595"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6596"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6597"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6598"><highlight class="normal"></highlight></codeline>
<codeline lineno="6599"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaBlockBufferImageGranularity::CheckConflictAndAlignUp(VkDeviceSize&amp;<sp/>inOutAllocOffset,</highlight></codeline>
<codeline lineno="6600"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocSize,</highlight></codeline>
<codeline lineno="6601"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>blockOffset,</highlight></codeline>
<codeline lineno="6602"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>blockSize,</highlight></codeline>
<codeline lineno="6603"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>allocType)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="6604"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="6605"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(IsEnabled())</highlight></codeline>
<codeline lineno="6606"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6607"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>startPage<sp/>=<sp/>GetStartPage(inOutAllocOffset);</highlight></codeline>
<codeline lineno="6608"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_RegionInfo[startPage].allocCount<sp/>&gt;<sp/>0<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="6609"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaIsBufferImageGranularityConflict(</highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">VmaSuballocationType</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(m_RegionInfo[startPage].allocType),<sp/>allocType))</highlight></codeline>
<codeline lineno="6610"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6611"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inOutAllocOffset<sp/>=<sp/>VmaAlignUp(inOutAllocOffset,<sp/>m_BufferImageGranularity);</highlight></codeline>
<codeline lineno="6612"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(blockSize<sp/>&lt;<sp/>allocSize<sp/>+<sp/>inOutAllocOffset<sp/>-<sp/>blockOffset)</highlight></codeline>
<codeline lineno="6613"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6614"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++startPage;</highlight></codeline>
<codeline lineno="6615"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6616"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>endPage<sp/>=<sp/>GetEndPage(inOutAllocOffset,<sp/>allocSize);</highlight></codeline>
<codeline lineno="6617"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(endPage<sp/>!=<sp/>startPage<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="6618"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_RegionInfo[endPage].allocCount<sp/>&gt;<sp/>0<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="6619"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaIsBufferImageGranularityConflict(</highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">VmaSuballocationType</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(m_RegionInfo[endPage].allocType),<sp/>allocType))</highlight></codeline>
<codeline lineno="6620"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6621"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6622"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6623"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6624"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6625"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6626"><highlight class="normal"></highlight></codeline>
<codeline lineno="6627"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockBufferImageGranularity::AllocPages(uint8_t<sp/>allocType,<sp/>VkDeviceSize<sp/>offset,<sp/>VkDeviceSize<sp/>size)</highlight></codeline>
<codeline lineno="6628"><highlight class="normal">{</highlight></codeline>
<codeline lineno="6629"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(IsEnabled())</highlight></codeline>
<codeline lineno="6630"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6631"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>startPage<sp/>=<sp/>GetStartPage(offset);</highlight></codeline>
<codeline lineno="6632"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AllocPage(m_RegionInfo[startPage],<sp/>allocType);</highlight></codeline>
<codeline lineno="6633"><highlight class="normal"></highlight></codeline>
<codeline lineno="6634"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>endPage<sp/>=<sp/>GetEndPage(offset,<sp/>size);</highlight></codeline>
<codeline lineno="6635"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(startPage<sp/>!=<sp/>endPage)</highlight></codeline>
<codeline lineno="6636"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AllocPage(m_RegionInfo[endPage],<sp/>allocType);</highlight></codeline>
<codeline lineno="6637"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6638"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6639"><highlight class="normal"></highlight></codeline>
<codeline lineno="6640"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockBufferImageGranularity::FreePages(VkDeviceSize<sp/>offset,<sp/>VkDeviceSize<sp/>size)</highlight></codeline>
<codeline lineno="6641"><highlight class="normal">{</highlight></codeline>
<codeline lineno="6642"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(IsEnabled())</highlight></codeline>
<codeline lineno="6643"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6644"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>startPage<sp/>=<sp/>GetStartPage(offset);</highlight></codeline>
<codeline lineno="6645"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--m_RegionInfo[startPage].allocCount;</highlight></codeline>
<codeline lineno="6646"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_RegionInfo[startPage].allocCount<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="6647"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_RegionInfo[startPage].allocType<sp/>=<sp/>VMA_SUBALLOCATION_TYPE_FREE;</highlight></codeline>
<codeline lineno="6648"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>endPage<sp/>=<sp/>GetEndPage(offset,<sp/>size);</highlight></codeline>
<codeline lineno="6649"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(startPage<sp/>!=<sp/>endPage)</highlight></codeline>
<codeline lineno="6650"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6651"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--m_RegionInfo[endPage].allocCount;</highlight></codeline>
<codeline lineno="6652"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_RegionInfo[endPage].allocCount<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="6653"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_RegionInfo[endPage].allocType<sp/>=<sp/>VMA_SUBALLOCATION_TYPE_FREE;</highlight></codeline>
<codeline lineno="6654"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6655"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6656"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6657"><highlight class="normal"></highlight></codeline>
<codeline lineno="6658"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockBufferImageGranularity::Clear()</highlight></codeline>
<codeline lineno="6659"><highlight class="normal">{</highlight></codeline>
<codeline lineno="6660"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_RegionInfo)</highlight></codeline>
<codeline lineno="6661"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memset(m_RegionInfo,<sp/>0,<sp/>m_RegionCount<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(RegionInfo));</highlight></codeline>
<codeline lineno="6662"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6663"><highlight class="normal"></highlight></codeline>
<codeline lineno="6664"><highlight class="normal">VmaBlockBufferImageGranularity::ValidationContext<sp/>VmaBlockBufferImageGranularity::StartValidation(</highlight></codeline>
<codeline lineno="6665"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isVirutal)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="6666"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="6667"><highlight class="normal"><sp/><sp/><sp/><sp/>ValidationContext<sp/>ctx{<sp/>pAllocationCallbacks,<sp/>VMA_NULL<sp/>};</highlight></codeline>
<codeline lineno="6668"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!isVirutal<sp/>&amp;&amp;<sp/>IsEnabled())</highlight></codeline>
<codeline lineno="6669"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6670"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ctx.pageAllocs<sp/>=<sp/>vma_new_array(pAllocationCallbacks,<sp/>uint16_t,<sp/>m_RegionCount);</highlight></codeline>
<codeline lineno="6671"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memset(ctx.pageAllocs,<sp/>0,<sp/>m_RegionCount<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(uint16_t));</highlight></codeline>
<codeline lineno="6672"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6673"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ctx;</highlight></codeline>
<codeline lineno="6674"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6675"><highlight class="normal"></highlight></codeline>
<codeline lineno="6676"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaBlockBufferImageGranularity::Validate(ValidationContext&amp;<sp/>ctx,</highlight></codeline>
<codeline lineno="6677"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>offset,<sp/>VkDeviceSize<sp/>size)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="6678"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="6679"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(IsEnabled())</highlight></codeline>
<codeline lineno="6680"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6681"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>start<sp/>=<sp/>GetStartPage(offset);</highlight></codeline>
<codeline lineno="6682"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++ctx.pageAllocs[start];</highlight></codeline>
<codeline lineno="6683"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(m_RegionInfo[start].allocCount<sp/>&gt;<sp/>0);</highlight></codeline>
<codeline lineno="6684"><highlight class="normal"></highlight></codeline>
<codeline lineno="6685"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>end<sp/>=<sp/>GetEndPage(offset,<sp/>size);</highlight></codeline>
<codeline lineno="6686"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(start<sp/>!=<sp/>end)</highlight></codeline>
<codeline lineno="6687"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6688"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++ctx.pageAllocs[end];</highlight></codeline>
<codeline lineno="6689"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(m_RegionInfo[end].allocCount<sp/>&gt;<sp/>0);</highlight></codeline>
<codeline lineno="6690"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6691"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6692"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6693"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6694"><highlight class="normal"></highlight></codeline>
<codeline lineno="6695"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaBlockBufferImageGranularity::FinishValidation(ValidationContext&amp;<sp/>ctx)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="6696"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="6697"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>proper<sp/>page<sp/>structure</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6698"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(IsEnabled())</highlight></codeline>
<codeline lineno="6699"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6700"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(ctx.pageAllocs<sp/>!=<sp/>VMA_NULL<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Validation<sp/>context<sp/>not<sp/>initialized!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="6701"><highlight class="normal"></highlight></codeline>
<codeline lineno="6702"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(uint32_t<sp/>page<sp/>=<sp/>0;<sp/>page<sp/>&lt;<sp/>m_RegionCount;<sp/>++page)</highlight></codeline>
<codeline lineno="6703"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6704"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(ctx.pageAllocs[page]<sp/>==<sp/>m_RegionInfo[page].allocCount);</highlight></codeline>
<codeline lineno="6705"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6706"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vma_delete_array(ctx.allocCallbacks,<sp/>ctx.pageAllocs,<sp/>m_RegionCount);</highlight></codeline>
<codeline lineno="6707"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ctx.pageAllocs<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="6708"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6709"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6710"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6711"><highlight class="normal"></highlight></codeline>
<codeline lineno="6712"><highlight class="normal">uint32_t<sp/>VmaBlockBufferImageGranularity::OffsetToPageIndex(VkDeviceSize<sp/>offset)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="6713"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="6714"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">uint32_t</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(offset<sp/>&gt;&gt;<sp/>VMA_BITSCAN_MSB(m_BufferImageGranularity));</highlight></codeline>
<codeline lineno="6715"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6716"><highlight class="normal"></highlight></codeline>
<codeline lineno="6717"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockBufferImageGranularity::AllocPage(RegionInfo&amp;<sp/>page,<sp/>uint8_t<sp/>allocType)</highlight></codeline>
<codeline lineno="6718"><highlight class="normal">{</highlight></codeline>
<codeline lineno="6719"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>When<sp/>current<sp/>alloc<sp/>type<sp/>is<sp/>free<sp/>then<sp/>it<sp/>can<sp/>be<sp/>overriden<sp/>by<sp/>new<sp/>type</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6720"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(page.allocCount<sp/>==<sp/>0<sp/>||<sp/>(page.allocCount<sp/>&gt;<sp/>0<sp/>&amp;&amp;<sp/>page.allocType<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_FREE))</highlight></codeline>
<codeline lineno="6721"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>page.allocType<sp/>=<sp/>allocType;</highlight></codeline>
<codeline lineno="6722"><highlight class="normal"></highlight></codeline>
<codeline lineno="6723"><highlight class="normal"><sp/><sp/><sp/><sp/>++page.allocCount;</highlight></codeline>
<codeline lineno="6724"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6725"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_BLOCK_BUFFER_IMAGE_GRANULARITY_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6726"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_BLOCK_BUFFER_IMAGE_GRANULARITY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6727"><highlight class="normal"></highlight></codeline>
<codeline lineno="6728"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6729"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_BLOCK_METADATA_GENERIC</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6730"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaBlockMetadata_Generic<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>VmaBlockMetadata</highlight></codeline>
<codeline lineno="6731"><highlight class="normal">{</highlight></codeline>
<codeline lineno="6732"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">friend</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaDefragmentationAlgorithm_Generic;</highlight></codeline>
<codeline lineno="6733"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">friend</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaDefragmentationAlgorithm_Fast;</highlight></codeline>
<codeline lineno="6734"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_CLASS_NO_COPY(VmaBlockMetadata_Generic)</highlight></codeline>
<codeline lineno="6735"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="6736"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaBlockMetadata_Generic(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks,</highlight></codeline>
<codeline lineno="6737"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>bufferImageGranularity,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isVirtual);</highlight></codeline>
<codeline lineno="6738"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>~VmaBlockMetadata_Generic()<sp/>=<sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6739"><highlight class="normal"></highlight></codeline>
<codeline lineno="6740"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>GetAllocationCount()</highlight><highlight class="keyword"><sp/>const<sp/>override<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Suballocations.size()<sp/>-<sp/>m_FreeCount;<sp/>}</highlight></codeline>
<codeline lineno="6741"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>GetSumFreeSize()</highlight><highlight class="keyword"><sp/>const<sp/>override<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_SumFreeSize;<sp/>}</highlight></codeline>
<codeline lineno="6742"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>IsEmpty()</highlight><highlight class="keyword"><sp/>const<sp/>override<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(m_Suballocations.size()<sp/>==<sp/>1)<sp/>&amp;&amp;<sp/>(m_FreeCount<sp/>==<sp/>1);<sp/>}</highlight></codeline>
<codeline lineno="6743"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Free(VmaAllocHandle<sp/>allocHandle)</highlight><highlight class="keyword"><sp/>override<sp/></highlight><highlight class="normal">{<sp/>FreeSuballocation(FindAtOffset((VkDeviceSize)allocHandle<sp/>-<sp/>1));<sp/>}</highlight></codeline>
<codeline lineno="6744"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>GetAllocationOffset(VmaAllocHandle<sp/>allocHandle)</highlight><highlight class="keyword"><sp/>const<sp/>override<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(VkDeviceSize)allocHandle<sp/>-<sp/>1;<sp/>};</highlight></codeline>
<codeline lineno="6745"><highlight class="normal"></highlight></codeline>
<codeline lineno="6746"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Init(VkDeviceSize<sp/>size)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6747"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>Validate()<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6748"><highlight class="normal"></highlight></codeline>
<codeline lineno="6749"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>AddDetailedStatistics(<ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>&amp;<sp/>inoutStats)<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6750"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>AddStatistics(<ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref>&amp;<sp/>inoutStats)<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6751"><highlight class="normal"></highlight></codeline>
<codeline lineno="6752"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6753"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>PrintDetailedMap(</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>VmaJsonWriter&amp;<sp/>json,<sp/>uint32_t<sp/>mapRefCount)<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6754"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6755"><highlight class="normal"></highlight></codeline>
<codeline lineno="6756"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>CreateAllocationRequest(</highlight></codeline>
<codeline lineno="6757"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocSize,</highlight></codeline>
<codeline lineno="6758"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocAlignment,</highlight></codeline>
<codeline lineno="6759"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>upperAddress,</highlight></codeline>
<codeline lineno="6760"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>allocType,</highlight></codeline>
<codeline lineno="6761"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>strategy,</highlight></codeline>
<codeline lineno="6762"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAllocationRequest*<sp/>pAllocationRequest)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6763"><highlight class="normal"></highlight></codeline>
<codeline lineno="6764"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>CheckCorruption(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pBlockData)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6765"><highlight class="normal"></highlight></codeline>
<codeline lineno="6766"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Alloc(</highlight></codeline>
<codeline lineno="6767"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaAllocationRequest&amp;<sp/>request,</highlight></codeline>
<codeline lineno="6768"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>type,</highlight></codeline>
<codeline lineno="6769"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>userData)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6770"><highlight class="normal"></highlight></codeline>
<codeline lineno="6771"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GetAllocationInfo(VmaAllocHandle<sp/>allocHandle,<sp/><ref refid="struct_vma_virtual_allocation_info" kindref="compound">VmaVirtualAllocationInfo</ref>&amp;<sp/>outInfo)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6772"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>GetAllocationUserData(VmaAllocHandle<sp/>allocHandle)<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6773"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocHandle<sp/>GetAllocationListBegin()<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6774"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocHandle<sp/>GetNextAllocation(VmaAllocHandle<sp/>prevAlloc)<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6775"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Clear()<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6776"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>SetAllocationUserData(VmaAllocHandle<sp/>allocHandle,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>userData)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6777"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DebugLogAllAllocations()<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6778"><highlight class="normal"></highlight></codeline>
<codeline lineno="6779"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="6780"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>m_FreeCount;</highlight></codeline>
<codeline lineno="6781"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>m_SumFreeSize;</highlight></codeline>
<codeline lineno="6782"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationList<sp/>m_Suballocations;</highlight></codeline>
<codeline lineno="6783"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Suballocations<sp/>that<sp/>are<sp/>free.<sp/>Sorted<sp/>by<sp/>size,<sp/>ascending.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6784"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaVector&lt;VmaSuballocationList::iterator,<sp/>VmaStlAllocator&lt;VmaSuballocationList::iterator&gt;&gt;<sp/>m_FreeSuballocationsBySize;</highlight></codeline>
<codeline lineno="6785"><highlight class="normal"></highlight></codeline>
<codeline lineno="6786"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>AlignAllocationSize(VkDeviceSize<sp/>size)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>IsVirtual()<sp/>?<sp/>size<sp/>:<sp/>VmaAlignUp(size,<sp/>(VkDeviceSize)16);<sp/>}</highlight></codeline>
<codeline lineno="6787"><highlight class="normal"></highlight></codeline>
<codeline lineno="6788"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationList::iterator<sp/>FindAtOffset(VkDeviceSize<sp/>offset)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6789"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>ValidateFreeSuballocationList()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6790"><highlight class="normal"></highlight></codeline>
<codeline lineno="6791"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Checks<sp/>if<sp/>requested<sp/>suballocation<sp/>with<sp/>given<sp/>parameters<sp/>can<sp/>be<sp/>placed<sp/>in<sp/>given<sp/>pFreeSuballocItem.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6792"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>yes,<sp/>fills<sp/>pOffset<sp/>and<sp/>returns<sp/>true.<sp/>If<sp/>no,<sp/>returns<sp/>false.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6793"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>CheckAllocation(</highlight></codeline>
<codeline lineno="6794"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocSize,</highlight></codeline>
<codeline lineno="6795"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocAlignment,</highlight></codeline>
<codeline lineno="6796"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>allocType,</highlight></codeline>
<codeline lineno="6797"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationList::const_iterator<sp/>suballocItem,</highlight></codeline>
<codeline lineno="6798"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAllocHandle*<sp/>pAllocHandle)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6799"><highlight class="normal"></highlight></codeline>
<codeline lineno="6800"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Given<sp/>free<sp/>suballocation,<sp/>it<sp/>merges<sp/>it<sp/>with<sp/>following<sp/>one,<sp/>which<sp/>must<sp/>also<sp/>be<sp/>free.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6801"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>MergeFreeWithNext(VmaSuballocationList::iterator<sp/>item);</highlight></codeline>
<codeline lineno="6802"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Releases<sp/>given<sp/>suballocation,<sp/>making<sp/>it<sp/>free.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6803"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Merges<sp/>it<sp/>with<sp/>adjacent<sp/>free<sp/>suballocations<sp/>if<sp/>applicable.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6804"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Returns<sp/>iterator<sp/>to<sp/>new<sp/>free<sp/>suballocation<sp/>at<sp/>this<sp/>place.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6805"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationList::iterator<sp/>FreeSuballocation(VmaSuballocationList::iterator<sp/>suballocItem);</highlight></codeline>
<codeline lineno="6806"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Given<sp/>free<sp/>suballocation,<sp/>it<sp/>inserts<sp/>it<sp/>into<sp/>sorted<sp/>list<sp/>of</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6807"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>m_FreeSuballocationsBySize<sp/>if<sp/>it<sp/>is<sp/>suitable.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6808"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>RegisterFreeSuballocation(VmaSuballocationList::iterator<sp/>item);</highlight></codeline>
<codeline lineno="6809"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Given<sp/>free<sp/>suballocation,<sp/>it<sp/>removes<sp/>it<sp/>from<sp/>sorted<sp/>list<sp/>of</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6810"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>m_FreeSuballocationsBySize<sp/>if<sp/>it<sp/>is<sp/>suitable.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6811"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>UnregisterFreeSuballocation(VmaSuballocationList::iterator<sp/>item);</highlight></codeline>
<codeline lineno="6812"><highlight class="normal">};</highlight></codeline>
<codeline lineno="6813"><highlight class="normal"></highlight></codeline>
<codeline lineno="6814"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_BLOCK_METADATA_GENERIC_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6815"><highlight class="normal">VmaBlockMetadata_Generic::VmaBlockMetadata_Generic(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks,</highlight></codeline>
<codeline lineno="6816"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>bufferImageGranularity,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isVirtual)</highlight></codeline>
<codeline lineno="6817"><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>VmaBlockMetadata(pAllocationCallbacks,<sp/>bufferImageGranularity,<sp/>isVirtual),</highlight></codeline>
<codeline lineno="6818"><highlight class="normal"><sp/><sp/><sp/><sp/>m_FreeCount(0),</highlight></codeline>
<codeline lineno="6819"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SumFreeSize(0),</highlight></codeline>
<codeline lineno="6820"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Suballocations(VmaStlAllocator&lt;VmaSuballocation&gt;(pAllocationCallbacks)),</highlight></codeline>
<codeline lineno="6821"><highlight class="normal"><sp/><sp/><sp/><sp/>m_FreeSuballocationsBySize(VmaStlAllocator&lt;VmaSuballocationList::iterator&gt;(pAllocationCallbacks))<sp/>{}</highlight></codeline>
<codeline lineno="6822"><highlight class="normal"></highlight></codeline>
<codeline lineno="6823"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Generic::Init(VkDeviceSize<sp/>size)</highlight></codeline>
<codeline lineno="6824"><highlight class="normal">{</highlight></codeline>
<codeline lineno="6825"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaBlockMetadata::Init(size);</highlight></codeline>
<codeline lineno="6826"><highlight class="normal"></highlight></codeline>
<codeline lineno="6827"><highlight class="normal"><sp/><sp/><sp/><sp/>m_FreeCount<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="6828"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SumFreeSize<sp/>=<sp/>size;</highlight></codeline>
<codeline lineno="6829"><highlight class="normal"></highlight></codeline>
<codeline lineno="6830"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocation<sp/>suballoc<sp/>=<sp/>{};</highlight></codeline>
<codeline lineno="6831"><highlight class="normal"><sp/><sp/><sp/><sp/>suballoc.offset<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6832"><highlight class="normal"><sp/><sp/><sp/><sp/>suballoc.size<sp/>=<sp/>size;</highlight></codeline>
<codeline lineno="6833"><highlight class="normal"><sp/><sp/><sp/><sp/>suballoc.type<sp/>=<sp/>VMA_SUBALLOCATION_TYPE_FREE;</highlight></codeline>
<codeline lineno="6834"><highlight class="normal"></highlight></codeline>
<codeline lineno="6835"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Suballocations.push_back(suballoc);</highlight></codeline>
<codeline lineno="6836"><highlight class="normal"><sp/><sp/><sp/><sp/>m_FreeSuballocationsBySize.push_back(m_Suballocations.begin());</highlight></codeline>
<codeline lineno="6837"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6838"><highlight class="normal"></highlight></codeline>
<codeline lineno="6839"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Generic::Validate()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="6840"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="6841"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE(!m_Suballocations.empty());</highlight></codeline>
<codeline lineno="6842"><highlight class="normal"></highlight></codeline>
<codeline lineno="6843"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Expected<sp/>offset<sp/>of<sp/>new<sp/>suballocation<sp/>as<sp/>calculated<sp/>from<sp/>previous<sp/>ones.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6844"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>calculatedOffset<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6845"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Expected<sp/>number<sp/>of<sp/>free<sp/>suballocations<sp/>as<sp/>calculated<sp/>from<sp/>traversing<sp/>their<sp/>list.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6846"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>calculatedFreeCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6847"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Expected<sp/>sum<sp/>size<sp/>of<sp/>free<sp/>suballocations<sp/>as<sp/>calculated<sp/>from<sp/>traversing<sp/>their<sp/>list.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6848"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>calculatedSumFreeSize<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6849"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Expected<sp/>number<sp/>of<sp/>free<sp/>suballocations<sp/>that<sp/>should<sp/>be<sp/>registered<sp/>in</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6850"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>m_FreeSuballocationsBySize<sp/>calculated<sp/>from<sp/>traversing<sp/>their<sp/>list.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6851"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>freeSuballocationsToRegister<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6852"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>True<sp/>if<sp/>previous<sp/>visited<sp/>suballocation<sp/>was<sp/>free.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6853"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>prevFree<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6854"><highlight class="normal"></highlight></codeline>
<codeline lineno="6855"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>debugMargin<sp/>=<sp/>GetDebugMargin();</highlight></codeline>
<codeline lineno="6856"><highlight class="normal"></highlight></codeline>
<codeline lineno="6857"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>subAlloc<sp/>:<sp/>m_Suballocations)</highlight></codeline>
<codeline lineno="6858"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6859"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Actual<sp/>offset<sp/>of<sp/>this<sp/>suballocation<sp/>doesn&apos;t<sp/>match<sp/>expected<sp/>one.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6860"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(subAlloc.offset<sp/>==<sp/>calculatedOffset);</highlight></codeline>
<codeline lineno="6861"><highlight class="normal"></highlight></codeline>
<codeline lineno="6862"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>currFree<sp/>=<sp/>(subAlloc.type<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_FREE);</highlight></codeline>
<codeline lineno="6863"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Two<sp/>adjacent<sp/>free<sp/>suballocations<sp/>are<sp/>invalid.<sp/>They<sp/>should<sp/>be<sp/>merged.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6864"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(!prevFree<sp/>||<sp/>!currFree);</highlight></codeline>
<codeline lineno="6865"><highlight class="normal"></highlight></codeline>
<codeline lineno="6866"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>alloc<sp/>=<sp/>(<ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>)subAlloc.userData;</highlight></codeline>
<codeline lineno="6867"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!IsVirtual())</highlight></codeline>
<codeline lineno="6868"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6869"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(currFree<sp/>==<sp/>(alloc<sp/>==<sp/>VK_NULL_HANDLE));</highlight></codeline>
<codeline lineno="6870"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6871"><highlight class="normal"></highlight></codeline>
<codeline lineno="6872"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(currFree)</highlight></codeline>
<codeline lineno="6873"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6874"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>calculatedSumFreeSize<sp/>+=<sp/>subAlloc.size;</highlight></codeline>
<codeline lineno="6875"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++calculatedFreeCount;</highlight></codeline>
<codeline lineno="6876"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++freeSuballocationsToRegister;</highlight></codeline>
<codeline lineno="6877"><highlight class="normal"></highlight></codeline>
<codeline lineno="6878"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Margin<sp/>required<sp/>between<sp/>allocations<sp/>-<sp/>every<sp/>free<sp/>space<sp/>must<sp/>be<sp/>at<sp/>least<sp/>that<sp/>large.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6879"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(subAlloc.size<sp/>&gt;=<sp/>debugMargin);</highlight></codeline>
<codeline lineno="6880"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6881"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6882"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6883"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!IsVirtual())</highlight></codeline>
<codeline lineno="6884"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6885"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE((VkDeviceSize)alloc-&gt;GetAllocHandle()<sp/>==<sp/>subAlloc.offset<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="6886"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(alloc-&gt;GetSize()<sp/>==<sp/>subAlloc.size);</highlight></codeline>
<codeline lineno="6887"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6888"><highlight class="normal"></highlight></codeline>
<codeline lineno="6889"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Margin<sp/>required<sp/>between<sp/>allocations<sp/>-<sp/>previous<sp/>allocation<sp/>must<sp/>be<sp/>free.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6890"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(debugMargin<sp/>==<sp/>0<sp/>||<sp/>prevFree);</highlight></codeline>
<codeline lineno="6891"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6892"><highlight class="normal"></highlight></codeline>
<codeline lineno="6893"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>calculatedOffset<sp/>+=<sp/>subAlloc.size;</highlight></codeline>
<codeline lineno="6894"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prevFree<sp/>=<sp/>currFree;</highlight></codeline>
<codeline lineno="6895"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6896"><highlight class="normal"></highlight></codeline>
<codeline lineno="6897"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Number<sp/>of<sp/>free<sp/>suballocations<sp/>registered<sp/>in<sp/>m_FreeSuballocationsBySize<sp/>doesn&apos;t</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6898"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>match<sp/>expected<sp/>one.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6899"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE(m_FreeSuballocationsBySize.size()<sp/>==<sp/>freeSuballocationsToRegister);</highlight></codeline>
<codeline lineno="6900"><highlight class="normal"></highlight></codeline>
<codeline lineno="6901"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>lastSize<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="6902"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>m_FreeSuballocationsBySize.size();<sp/>++i)</highlight></codeline>
<codeline lineno="6903"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6904"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationList::iterator<sp/>suballocItem<sp/>=<sp/>m_FreeSuballocationsBySize[i];</highlight></codeline>
<codeline lineno="6905"><highlight class="normal"></highlight></codeline>
<codeline lineno="6906"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Only<sp/>free<sp/>suballocations<sp/>can<sp/>be<sp/>registered<sp/>in<sp/>m_FreeSuballocationsBySize.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6907"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(suballocItem-&gt;type<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_FREE);</highlight></codeline>
<codeline lineno="6908"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>They<sp/>must<sp/>be<sp/>sorted<sp/>by<sp/>size<sp/>ascending.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6909"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(suballocItem-&gt;size<sp/>&gt;=<sp/>lastSize);</highlight></codeline>
<codeline lineno="6910"><highlight class="normal"></highlight></codeline>
<codeline lineno="6911"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lastSize<sp/>=<sp/>suballocItem-&gt;size;</highlight></codeline>
<codeline lineno="6912"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6913"><highlight class="normal"></highlight></codeline>
<codeline lineno="6914"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>if<sp/>totals<sp/>match<sp/>calculated<sp/>values.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6915"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE(ValidateFreeSuballocationList());</highlight></codeline>
<codeline lineno="6916"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE(calculatedOffset<sp/>==<sp/>GetSize());</highlight></codeline>
<codeline lineno="6917"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE(calculatedSumFreeSize<sp/>==<sp/>m_SumFreeSize);</highlight></codeline>
<codeline lineno="6918"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE(calculatedFreeCount<sp/>==<sp/>m_FreeCount);</highlight></codeline>
<codeline lineno="6919"><highlight class="normal"></highlight></codeline>
<codeline lineno="6920"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6921"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6922"><highlight class="normal"></highlight></codeline>
<codeline lineno="6923"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Generic::AddDetailedStatistics(<ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>&amp;<sp/>inoutStats)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="6924"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="6925"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>rangeCount<sp/>=<sp/>(uint32_t)m_Suballocations.size();</highlight></codeline>
<codeline lineno="6926"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1a309179d5853a6a7cd534df497ee43957" kindref="member">blockCount</ref>++;</highlight></codeline>
<codeline lineno="6927"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1a2afbc1c7aa8ad7bbb8de06215ba7e5c4" kindref="member">blockBytes</ref><sp/>+=<sp/>GetSize();</highlight></codeline>
<codeline lineno="6928"><highlight class="normal"></highlight></codeline>
<codeline lineno="6929"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>suballoc<sp/>:<sp/>m_Suballocations)</highlight></codeline>
<codeline lineno="6930"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6931"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(suballoc.type<sp/>!=<sp/>VMA_SUBALLOCATION_TYPE_FREE)</highlight></codeline>
<codeline lineno="6932"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAddDetailedStatisticsAllocation(inoutStats,<sp/>suballoc.size);</highlight></codeline>
<codeline lineno="6933"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6934"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAddDetailedStatisticsUnusedRange(inoutStats,<sp/>suballoc.size);</highlight></codeline>
<codeline lineno="6935"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6936"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6937"><highlight class="normal"></highlight></codeline>
<codeline lineno="6938"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Generic::AddStatistics(<ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref>&amp;<sp/>inoutStats)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="6939"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="6940"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_statistics_1a309179d5853a6a7cd534df497ee43957" kindref="member">blockCount</ref>++;</highlight></codeline>
<codeline lineno="6941"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_statistics_1ab0ff76e50f58f9f54b6f265e5bf5dde2" kindref="member">allocationCount</ref><sp/>+=<sp/>(uint32_t)m_Suballocations.size()<sp/>-<sp/>m_FreeCount;</highlight></codeline>
<codeline lineno="6942"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_statistics_1a2afbc1c7aa8ad7bbb8de06215ba7e5c4" kindref="member">blockBytes</ref><sp/>+=<sp/>GetSize();</highlight></codeline>
<codeline lineno="6943"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_statistics_1a21db06eba3422f87a2b4b4703d879c16" kindref="member">allocationBytes</ref><sp/>+=<sp/>GetSize()<sp/>-<sp/>m_SumFreeSize;</highlight></codeline>
<codeline lineno="6944"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6945"><highlight class="normal"></highlight></codeline>
<codeline lineno="6946"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6947"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Generic::PrintDetailedMap(</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>VmaJsonWriter&amp;<sp/>json,<sp/>uint32_t<sp/>mapRefCount)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="6948"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="6949"><highlight class="normal"><sp/><sp/><sp/><sp/>PrintDetailedMap_Begin(json,</highlight></codeline>
<codeline lineno="6950"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_SumFreeSize,<sp/></highlight><highlight class="comment">//<sp/>unusedBytes</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6951"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Suballocations.size()<sp/>-<sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal">)m_FreeCount,<sp/></highlight><highlight class="comment">//<sp/>allocationCount</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6952"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_FreeCount,<sp/></highlight><highlight class="comment">//<sp/>unusedRangeCount</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6953"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mapRefCount);</highlight></codeline>
<codeline lineno="6954"><highlight class="normal"></highlight></codeline>
<codeline lineno="6955"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>suballoc<sp/>:<sp/>m_Suballocations)</highlight></codeline>
<codeline lineno="6956"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6957"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(suballoc.type<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_FREE)</highlight></codeline>
<codeline lineno="6958"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6959"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrintDetailedMap_UnusedRange(json,<sp/>suballoc.offset,<sp/>suballoc.size);</highlight></codeline>
<codeline lineno="6960"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6961"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6962"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6963"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrintDetailedMap_Allocation(json,<sp/>suballoc.offset,<sp/>suballoc.size,<sp/>suballoc.userData);</highlight></codeline>
<codeline lineno="6964"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6965"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6966"><highlight class="normal"></highlight></codeline>
<codeline lineno="6967"><highlight class="normal"><sp/><sp/><sp/><sp/>PrintDetailedMap_End(json);</highlight></codeline>
<codeline lineno="6968"><highlight class="normal">}</highlight></codeline>
<codeline lineno="6969"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6970"><highlight class="normal"></highlight></codeline>
<codeline lineno="6971"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Generic::CreateAllocationRequest(</highlight></codeline>
<codeline lineno="6972"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocSize,</highlight></codeline>
<codeline lineno="6973"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocAlignment,</highlight></codeline>
<codeline lineno="6974"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>upperAddress,</highlight></codeline>
<codeline lineno="6975"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>allocType,</highlight></codeline>
<codeline lineno="6976"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>strategy,</highlight></codeline>
<codeline lineno="6977"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocationRequest*<sp/>pAllocationRequest)</highlight></codeline>
<codeline lineno="6978"><highlight class="normal">{</highlight></codeline>
<codeline lineno="6979"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocSize<sp/>&gt;<sp/>0);</highlight></codeline>
<codeline lineno="6980"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(!upperAddress);</highlight></codeline>
<codeline lineno="6981"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocType<sp/>!=<sp/>VMA_SUBALLOCATION_TYPE_FREE);</highlight></codeline>
<codeline lineno="6982"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(pAllocationRequest<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="6983"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(Validate());</highlight></codeline>
<codeline lineno="6984"><highlight class="normal"></highlight></codeline>
<codeline lineno="6985"><highlight class="normal"><sp/><sp/><sp/><sp/>allocSize<sp/>=<sp/>AlignAllocationSize(allocSize);</highlight></codeline>
<codeline lineno="6986"><highlight class="normal"></highlight></codeline>
<codeline lineno="6987"><highlight class="normal"><sp/><sp/><sp/><sp/>pAllocationRequest-&gt;type<sp/>=<sp/>VmaAllocationRequestType::Normal;</highlight></codeline>
<codeline lineno="6988"><highlight class="normal"><sp/><sp/><sp/><sp/>pAllocationRequest-&gt;size<sp/>=<sp/>allocSize;</highlight></codeline>
<codeline lineno="6989"><highlight class="normal"></highlight></codeline>
<codeline lineno="6990"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>debugMargin<sp/>=<sp/>GetDebugMargin();</highlight></codeline>
<codeline lineno="6991"><highlight class="normal"></highlight></codeline>
<codeline lineno="6992"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>not<sp/>enough<sp/>total<sp/>free<sp/>space<sp/>in<sp/>this<sp/>block<sp/>to<sp/>fulfill<sp/>the<sp/>request:<sp/>Early<sp/>return.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6993"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_SumFreeSize<sp/>&lt;<sp/>allocSize<sp/>+<sp/>debugMargin)</highlight></codeline>
<codeline lineno="6994"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="6995"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="6996"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="6997"><highlight class="normal"></highlight></codeline>
<codeline lineno="6998"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>New<sp/>algorithm,<sp/>efficiently<sp/>searching<sp/>freeSuballocationsBySize.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6999"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>freeSuballocCount<sp/>=<sp/>m_FreeSuballocationsBySize.size();</highlight></codeline>
<codeline lineno="7000"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(freeSuballocCount<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="7001"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7002"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(strategy<sp/>==<sp/>0<sp/>||</highlight></codeline>
<codeline lineno="7003"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>strategy<sp/>==<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8af1210cf591784afa026d94998f735d" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</ref>)</highlight></codeline>
<codeline lineno="7004"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7005"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>first<sp/>free<sp/>suballocation<sp/>with<sp/>size<sp/>not<sp/>less<sp/>than<sp/>allocSize<sp/>+<sp/>debugMargin.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7006"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationList::iterator*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>it<sp/>=<sp/>VmaBinaryFindFirstNotLess(</highlight></codeline>
<codeline lineno="7007"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_FreeSuballocationsBySize.data(),</highlight></codeline>
<codeline lineno="7008"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_FreeSuballocationsBySize.data()<sp/>+<sp/>freeSuballocCount,</highlight></codeline>
<codeline lineno="7009"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocSize<sp/>+<sp/>debugMargin,</highlight></codeline>
<codeline lineno="7010"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationItemSizeLess());</highlight></codeline>
<codeline lineno="7011"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index<sp/>=<sp/>it<sp/>-<sp/>m_FreeSuballocationsBySize.data();</highlight></codeline>
<codeline lineno="7012"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(;<sp/>index<sp/>&lt;<sp/>freeSuballocCount;<sp/>++index)</highlight></codeline>
<codeline lineno="7013"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7014"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(CheckAllocation(</highlight></codeline>
<codeline lineno="7015"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocSize,</highlight></codeline>
<codeline lineno="7016"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocAlignment,</highlight></codeline>
<codeline lineno="7017"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocType,</highlight></codeline>
<codeline lineno="7018"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_FreeSuballocationsBySize[index],</highlight></codeline>
<codeline lineno="7019"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;pAllocationRequest-&gt;allocHandle))</highlight></codeline>
<codeline lineno="7020"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7021"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocationRequest-&gt;item<sp/>=<sp/>m_FreeSuballocationsBySize[index];</highlight></codeline>
<codeline lineno="7022"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7023"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7024"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7025"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7026"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(strategy<sp/>==<sp/>VMA_ALLOCATION_INTERNAL_STRATEGY_MIN_OFFSET)</highlight></codeline>
<codeline lineno="7027"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7028"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(VmaSuballocationList::iterator<sp/>it<sp/>=<sp/>m_Suballocations.begin();</highlight></codeline>
<codeline lineno="7029"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it<sp/>!=<sp/>m_Suballocations.end();</highlight></codeline>
<codeline lineno="7030"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++it)</highlight></codeline>
<codeline lineno="7031"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7032"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(it-&gt;type<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_FREE<sp/>&amp;&amp;<sp/>CheckAllocation(</highlight></codeline>
<codeline lineno="7033"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocSize,</highlight></codeline>
<codeline lineno="7034"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocAlignment,</highlight></codeline>
<codeline lineno="7035"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocType,</highlight></codeline>
<codeline lineno="7036"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it,</highlight></codeline>
<codeline lineno="7037"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;pAllocationRequest-&gt;allocHandle))</highlight></codeline>
<codeline lineno="7038"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7039"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocationRequest-&gt;item<sp/>=<sp/>it;</highlight></codeline>
<codeline lineno="7040"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7041"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7042"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7043"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7044"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7045"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7046"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(strategy<sp/>&amp;<sp/>(<ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a0729e932b7ea170e3a128cad96c5cf6d" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</ref><sp/>|<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8099acedc0d04cdccaaddcfe37fd227d" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</ref><sp/>));</highlight></codeline>
<codeline lineno="7047"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Search<sp/>staring<sp/>from<sp/>biggest<sp/>suballocations.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7048"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index<sp/>=<sp/>freeSuballocCount;<sp/>index--;<sp/>)</highlight></codeline>
<codeline lineno="7049"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7050"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(CheckAllocation(</highlight></codeline>
<codeline lineno="7051"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocSize,</highlight></codeline>
<codeline lineno="7052"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocAlignment,</highlight></codeline>
<codeline lineno="7053"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocType,</highlight></codeline>
<codeline lineno="7054"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_FreeSuballocationsBySize[index],</highlight></codeline>
<codeline lineno="7055"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;pAllocationRequest-&gt;allocHandle))</highlight></codeline>
<codeline lineno="7056"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7057"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocationRequest-&gt;item<sp/>=<sp/>m_FreeSuballocationsBySize[index];</highlight></codeline>
<codeline lineno="7058"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7059"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7060"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7061"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7062"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7063"><highlight class="normal"></highlight></codeline>
<codeline lineno="7064"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7065"><highlight class="normal">}</highlight></codeline>
<codeline lineno="7066"><highlight class="normal"></highlight></codeline>
<codeline lineno="7067"><highlight class="normal">VkResult<sp/>VmaBlockMetadata_Generic::CheckCorruption(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pBlockData)</highlight></codeline>
<codeline lineno="7068"><highlight class="normal">{</highlight></codeline>
<codeline lineno="7069"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>suballoc<sp/>:<sp/>m_Suballocations)</highlight></codeline>
<codeline lineno="7070"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7071"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(suballoc.type<sp/>!=<sp/>VMA_SUBALLOCATION_TYPE_FREE)</highlight></codeline>
<codeline lineno="7072"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7073"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!VmaValidateMagicValue(pBlockData,<sp/>suballoc.offset<sp/>+<sp/>suballoc.size))</highlight></codeline>
<codeline lineno="7074"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7075"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;MEMORY<sp/>CORRUPTION<sp/>DETECTED<sp/>AFTER<sp/>VALIDATED<sp/>ALLOCATION!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="7076"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_UNKNOWN_COPY;</highlight></codeline>
<codeline lineno="7077"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7078"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7079"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7080"><highlight class="normal"></highlight></codeline>
<codeline lineno="7081"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="7082"><highlight class="normal">}</highlight></codeline>
<codeline lineno="7083"><highlight class="normal"></highlight></codeline>
<codeline lineno="7084"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Generic::Alloc(</highlight></codeline>
<codeline lineno="7085"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaAllocationRequest&amp;<sp/>request,</highlight></codeline>
<codeline lineno="7086"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>type,</highlight></codeline>
<codeline lineno="7087"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>userData)</highlight></codeline>
<codeline lineno="7088"><highlight class="normal">{</highlight></codeline>
<codeline lineno="7089"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(request.type<sp/>==<sp/>VmaAllocationRequestType::Normal);</highlight></codeline>
<codeline lineno="7090"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(request.item<sp/>!=<sp/>m_Suballocations.end());</highlight></codeline>
<codeline lineno="7091"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocation&amp;<sp/>suballoc<sp/>=<sp/>*request.item;</highlight></codeline>
<codeline lineno="7092"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Given<sp/>suballocation<sp/>is<sp/>a<sp/>free<sp/>block.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7093"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(suballoc.type<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_FREE);</highlight></codeline>
<codeline lineno="7094"><highlight class="normal"></highlight></codeline>
<codeline lineno="7095"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Given<sp/>offset<sp/>is<sp/>inside<sp/>this<sp/>suballocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7096"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT((VkDeviceSize)request.allocHandle<sp/>-<sp/>1<sp/>&gt;=<sp/>suballoc.offset);</highlight></codeline>
<codeline lineno="7097"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>paddingBegin<sp/>=<sp/>(VkDeviceSize)request.allocHandle<sp/>-<sp/>suballoc.offset<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="7098"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(suballoc.size<sp/>&gt;=<sp/>paddingBegin<sp/>+<sp/>request.size);</highlight></codeline>
<codeline lineno="7099"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>paddingEnd<sp/>=<sp/>suballoc.size<sp/>-<sp/>paddingBegin<sp/>-<sp/>request.size;</highlight></codeline>
<codeline lineno="7100"><highlight class="normal"></highlight></codeline>
<codeline lineno="7101"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Unregister<sp/>this<sp/>free<sp/>suballocation<sp/>from<sp/>m_FreeSuballocationsBySize<sp/>and<sp/>update</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7102"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>it<sp/>to<sp/>become<sp/>used.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7103"><highlight class="normal"><sp/><sp/><sp/><sp/>UnregisterFreeSuballocation(request.item);</highlight></codeline>
<codeline lineno="7104"><highlight class="normal"></highlight></codeline>
<codeline lineno="7105"><highlight class="normal"><sp/><sp/><sp/><sp/>suballoc.offset<sp/>=<sp/>(VkDeviceSize)request.allocHandle<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="7106"><highlight class="normal"><sp/><sp/><sp/><sp/>suballoc.size<sp/>=<sp/>request.size;</highlight></codeline>
<codeline lineno="7107"><highlight class="normal"><sp/><sp/><sp/><sp/>suballoc.type<sp/>=<sp/>type;</highlight></codeline>
<codeline lineno="7108"><highlight class="normal"><sp/><sp/><sp/><sp/>suballoc.userData<sp/>=<sp/>userData;</highlight></codeline>
<codeline lineno="7109"><highlight class="normal"></highlight></codeline>
<codeline lineno="7110"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>there<sp/>are<sp/>any<sp/>free<sp/>bytes<sp/>remaining<sp/>at<sp/>the<sp/>end,<sp/>insert<sp/>new<sp/>free<sp/>suballocation<sp/>after<sp/>current<sp/>one.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7111"><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(paddingEnd)</highlight></codeline>
<codeline lineno="7112"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocation<sp/>paddingSuballoc<sp/>=<sp/>{};</highlight></codeline>
<codeline lineno="7114"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>paddingSuballoc.offset<sp/>=<sp/>suballoc.offset<sp/>+<sp/>suballoc.size;</highlight></codeline>
<codeline lineno="7115"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>paddingSuballoc.size<sp/>=<sp/>paddingEnd;</highlight></codeline>
<codeline lineno="7116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>paddingSuballoc.type<sp/>=<sp/>VMA_SUBALLOCATION_TYPE_FREE;</highlight></codeline>
<codeline lineno="7117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationList::iterator<sp/>next<sp/>=<sp/>request.item;</highlight></codeline>
<codeline lineno="7118"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++next;</highlight></codeline>
<codeline lineno="7119"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocationList::iterator<sp/>paddingEndItem<sp/>=</highlight></codeline>
<codeline lineno="7120"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Suballocations.insert(next,<sp/>paddingSuballoc);</highlight></codeline>
<codeline lineno="7121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>RegisterFreeSuballocation(paddingEndItem);</highlight></codeline>
<codeline lineno="7122"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7123"><highlight class="normal"></highlight></codeline>
<codeline lineno="7124"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>there<sp/>are<sp/>any<sp/>free<sp/>bytes<sp/>remaining<sp/>at<sp/>the<sp/>beginning,<sp/>insert<sp/>new<sp/>free<sp/>suballocation<sp/>before<sp/>current<sp/>one.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7125"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(paddingBegin)</highlight></codeline>
<codeline lineno="7126"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7127"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocation<sp/>paddingSuballoc<sp/>=<sp/>{};</highlight></codeline>
<codeline lineno="7128"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>paddingSuballoc.offset<sp/>=<sp/>suballoc.offset<sp/>-<sp/>paddingBegin;</highlight></codeline>
<codeline lineno="7129"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>paddingSuballoc.size<sp/>=<sp/>paddingBegin;</highlight></codeline>
<codeline lineno="7130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>paddingSuballoc.type<sp/>=<sp/>VMA_SUBALLOCATION_TYPE_FREE;</highlight></codeline>
<codeline lineno="7131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocationList::iterator<sp/>paddingBeginItem<sp/>=</highlight></codeline>
<codeline lineno="7132"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Suballocations.insert(request.item,<sp/>paddingSuballoc);</highlight></codeline>
<codeline lineno="7133"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>RegisterFreeSuballocation(paddingBeginItem);</highlight></codeline>
<codeline lineno="7134"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7135"><highlight class="normal"></highlight></codeline>
<codeline lineno="7136"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Update<sp/>totals.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7137"><highlight class="normal"><sp/><sp/><sp/><sp/>m_FreeCount<sp/>=<sp/>m_FreeCount<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="7138"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(paddingBegin<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="7139"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7140"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++m_FreeCount;</highlight></codeline>
<codeline lineno="7141"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7142"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(paddingEnd<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="7143"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7144"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++m_FreeCount;</highlight></codeline>
<codeline lineno="7145"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7146"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SumFreeSize<sp/>-=<sp/>request.size;</highlight></codeline>
<codeline lineno="7147"><highlight class="normal">}</highlight></codeline>
<codeline lineno="7148"><highlight class="normal"></highlight></codeline>
<codeline lineno="7149"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Generic::GetAllocationInfo(VmaAllocHandle<sp/>allocHandle,<sp/><ref refid="struct_vma_virtual_allocation_info" kindref="compound">VmaVirtualAllocationInfo</ref>&amp;<sp/>outInfo)</highlight></codeline>
<codeline lineno="7150"><highlight class="normal">{</highlight></codeline>
<codeline lineno="7151"><highlight class="normal"><sp/><sp/><sp/><sp/>outInfo.<ref refid="struct_vma_virtual_allocation_info_1accb40a8205f49ccca3de975da7d1a2b5" kindref="member">offset</ref><sp/>=<sp/>(VkDeviceSize)allocHandle<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="7152"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>suballoc<sp/>=<sp/>*FindAtOffset(outInfo.<ref refid="struct_vma_virtual_allocation_info_1accb40a8205f49ccca3de975da7d1a2b5" kindref="member">offset</ref>);</highlight></codeline>
<codeline lineno="7153"><highlight class="normal"><sp/><sp/><sp/><sp/>outInfo.<ref refid="struct_vma_virtual_allocation_info_1afb6d6bd0a6813869ea0842048d40aa2b" kindref="member">size</ref><sp/>=<sp/>suballoc.size;</highlight></codeline>
<codeline lineno="7154"><highlight class="normal"><sp/><sp/><sp/><sp/>outInfo.<ref refid="struct_vma_virtual_allocation_info_1a224aa08739618d27066a16b7f60a2bbc" kindref="member">pUserData</ref><sp/>=<sp/>suballoc.userData;</highlight></codeline>
<codeline lineno="7155"><highlight class="normal">}</highlight></codeline>
<codeline lineno="7156"><highlight class="normal"></highlight></codeline>
<codeline lineno="7157"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>VmaBlockMetadata_Generic::GetAllocationUserData(VmaAllocHandle<sp/>allocHandle)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="7158"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="7159"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>FindAtOffset((VkDeviceSize)allocHandle<sp/>-<sp/>1)-&gt;userData;</highlight></codeline>
<codeline lineno="7160"><highlight class="normal">}</highlight></codeline>
<codeline lineno="7161"><highlight class="normal"></highlight></codeline>
<codeline lineno="7162"><highlight class="normal">VmaAllocHandle<sp/>VmaBlockMetadata_Generic::GetAllocationListBegin()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="7163"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="7164"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(IsEmpty())</highlight></codeline>
<codeline lineno="7165"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="7166"><highlight class="normal"></highlight></codeline>
<codeline lineno="7167"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>suballoc<sp/>:<sp/>m_Suballocations)</highlight></codeline>
<codeline lineno="7168"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(suballoc.type<sp/>!=<sp/>VMA_SUBALLOCATION_TYPE_FREE)</highlight></codeline>
<codeline lineno="7170"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(VmaAllocHandle)(suballoc.offset<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="7171"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7172"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(</highlight><highlight class="keyword">false</highlight><highlight class="normal"><sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Should<sp/>contain<sp/>at<sp/>least<sp/>1<sp/>allocation!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="7173"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="7174"><highlight class="normal">}</highlight></codeline>
<codeline lineno="7175"><highlight class="normal"></highlight></codeline>
<codeline lineno="7176"><highlight class="normal">VmaAllocHandle<sp/>VmaBlockMetadata_Generic::GetNextAllocation(VmaAllocHandle<sp/>prevAlloc)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="7177"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="7178"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationList::const_iterator<sp/>prev<sp/>=<sp/>FindAtOffset((VkDeviceSize)prevAlloc<sp/>-<sp/>1);</highlight></codeline>
<codeline lineno="7179"><highlight class="normal"></highlight></codeline>
<codeline lineno="7180"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(VmaSuballocationList::const_iterator<sp/>it<sp/>=<sp/>++prev;<sp/>it<sp/>!=<sp/>m_Suballocations.end();<sp/>++it)</highlight></codeline>
<codeline lineno="7181"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(it-&gt;type<sp/>!=<sp/>VMA_SUBALLOCATION_TYPE_FREE)</highlight></codeline>
<codeline lineno="7183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(VmaAllocHandle)(it-&gt;offset<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="7184"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7185"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="7186"><highlight class="normal">}</highlight></codeline>
<codeline lineno="7187"><highlight class="normal"></highlight></codeline>
<codeline lineno="7188"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Generic::Clear()</highlight></codeline>
<codeline lineno="7189"><highlight class="normal">{</highlight></codeline>
<codeline lineno="7190"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>size<sp/>=<sp/>GetSize();</highlight></codeline>
<codeline lineno="7191"><highlight class="normal"></highlight></codeline>
<codeline lineno="7192"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(IsVirtual());</highlight></codeline>
<codeline lineno="7193"><highlight class="normal"><sp/><sp/><sp/><sp/>m_FreeCount<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="7194"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SumFreeSize<sp/>=<sp/>size;</highlight></codeline>
<codeline lineno="7195"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Suballocations.clear();</highlight></codeline>
<codeline lineno="7196"><highlight class="normal"><sp/><sp/><sp/><sp/>m_FreeSuballocationsBySize.clear();</highlight></codeline>
<codeline lineno="7197"><highlight class="normal"></highlight></codeline>
<codeline lineno="7198"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocation<sp/>suballoc<sp/>=<sp/>{};</highlight></codeline>
<codeline lineno="7199"><highlight class="normal"><sp/><sp/><sp/><sp/>suballoc.offset<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="7200"><highlight class="normal"><sp/><sp/><sp/><sp/>suballoc.size<sp/>=<sp/>size;</highlight></codeline>
<codeline lineno="7201"><highlight class="normal"><sp/><sp/><sp/><sp/>suballoc.type<sp/>=<sp/>VMA_SUBALLOCATION_TYPE_FREE;</highlight></codeline>
<codeline lineno="7202"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Suballocations.push_back(suballoc);</highlight></codeline>
<codeline lineno="7203"><highlight class="normal"></highlight></codeline>
<codeline lineno="7204"><highlight class="normal"><sp/><sp/><sp/><sp/>m_FreeSuballocationsBySize.push_back(m_Suballocations.begin());</highlight></codeline>
<codeline lineno="7205"><highlight class="normal">}</highlight></codeline>
<codeline lineno="7206"><highlight class="normal"></highlight></codeline>
<codeline lineno="7207"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Generic::SetAllocationUserData(VmaAllocHandle<sp/>allocHandle,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>userData)</highlight></codeline>
<codeline lineno="7208"><highlight class="normal">{</highlight></codeline>
<codeline lineno="7209"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocation&amp;<sp/>suballoc<sp/>=<sp/>*FindAtOffset((VkDeviceSize)allocHandle<sp/>-<sp/>1);</highlight></codeline>
<codeline lineno="7210"><highlight class="normal"><sp/><sp/><sp/><sp/>suballoc.userData<sp/>=<sp/>userData;</highlight></codeline>
<codeline lineno="7211"><highlight class="normal">}</highlight></codeline>
<codeline lineno="7212"><highlight class="normal"></highlight></codeline>
<codeline lineno="7213"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Generic::DebugLogAllAllocations()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="7214"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="7215"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>suballoc<sp/>:<sp/>m_Suballocations)</highlight></codeline>
<codeline lineno="7216"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7217"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(suballoc.type<sp/>!=<sp/>VMA_SUBALLOCATION_TYPE_FREE)</highlight></codeline>
<codeline lineno="7218"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>DebugLogAllocation(suballoc.offset,<sp/>suballoc.size,<sp/>suballoc.userData);</highlight></codeline>
<codeline lineno="7219"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7220"><highlight class="normal">}</highlight></codeline>
<codeline lineno="7221"><highlight class="normal"></highlight></codeline>
<codeline lineno="7222"><highlight class="normal">VmaSuballocationList::iterator<sp/>VmaBlockMetadata_Generic::FindAtOffset(VkDeviceSize<sp/>offset)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="7223"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="7224"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(!m_Suballocations.empty());</highlight></codeline>
<codeline lineno="7225"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>last<sp/>=<sp/>m_Suballocations.rbegin()-&gt;offset;</highlight></codeline>
<codeline lineno="7226"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(last<sp/>==<sp/>offset)</highlight></codeline>
<codeline lineno="7227"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Suballocations.rbegin().drop_const();</highlight></codeline>
<codeline lineno="7228"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>first<sp/>=<sp/>m_Suballocations.begin()-&gt;offset;</highlight></codeline>
<codeline lineno="7229"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(first<sp/>==<sp/>offset)</highlight></codeline>
<codeline lineno="7230"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Suballocations.begin().drop_const();</highlight></codeline>
<codeline lineno="7231"><highlight class="normal"></highlight></codeline>
<codeline lineno="7232"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>suballocCount<sp/>=<sp/>m_Suballocations.size();</highlight></codeline>
<codeline lineno="7233"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>step<sp/>=<sp/>(last<sp/>-<sp/>first<sp/>+<sp/>m_Suballocations.begin()-&gt;size)<sp/>/<sp/>suballocCount;</highlight></codeline>
<codeline lineno="7234"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>findSuballocation<sp/>=<sp/>[&amp;](</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>begin,<sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>end)<sp/>-&gt;<sp/>VmaSuballocationList::iterator</highlight></codeline>
<codeline lineno="7235"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7236"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>suballocItem<sp/>=<sp/>begin;</highlight></codeline>
<codeline lineno="7237"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocItem<sp/>!=<sp/>end;</highlight></codeline>
<codeline lineno="7238"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++suballocItem)</highlight></codeline>
<codeline lineno="7239"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7240"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(suballocItem-&gt;offset<sp/>==<sp/>offset)</highlight></codeline>
<codeline lineno="7241"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>suballocItem.drop_const();</highlight></codeline>
<codeline lineno="7242"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7243"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(</highlight><highlight class="keyword">false</highlight><highlight class="normal"><sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Not<sp/>found!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="7244"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Suballocations.end().drop_const();</highlight></codeline>
<codeline lineno="7245"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="7246"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>requested<sp/>offset<sp/>is<sp/>closer<sp/>to<sp/>the<sp/>end<sp/>of<sp/>range,<sp/>search<sp/>from<sp/>the<sp/>end</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7247"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(offset<sp/>-<sp/>first<sp/>&gt;<sp/>suballocCount<sp/>*<sp/>step<sp/>/<sp/>2)</highlight></codeline>
<codeline lineno="7248"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7249"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>findSuballocation(m_Suballocations.rbegin(),<sp/>m_Suballocations.rend());</highlight></codeline>
<codeline lineno="7250"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7251"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>findSuballocation(m_Suballocations.begin(),<sp/>m_Suballocations.end());</highlight></codeline>
<codeline lineno="7252"><highlight class="normal">}</highlight></codeline>
<codeline lineno="7253"><highlight class="normal"></highlight></codeline>
<codeline lineno="7254"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Generic::ValidateFreeSuballocationList()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="7255"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="7256"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>lastSize<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="7257"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0,<sp/>count<sp/>=<sp/>m_FreeSuballocationsBySize.size();<sp/>i<sp/>&lt;<sp/>count;<sp/>++i)</highlight></codeline>
<codeline lineno="7258"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7259"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocationList::iterator<sp/>it<sp/>=<sp/>m_FreeSuballocationsBySize[i];</highlight></codeline>
<codeline lineno="7260"><highlight class="normal"></highlight></codeline>
<codeline lineno="7261"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(it-&gt;type<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_FREE);</highlight></codeline>
<codeline lineno="7262"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(it-&gt;size<sp/>&gt;=<sp/>lastSize);</highlight></codeline>
<codeline lineno="7263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lastSize<sp/>=<sp/>it-&gt;size;</highlight></codeline>
<codeline lineno="7264"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7265"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7266"><highlight class="normal">}</highlight></codeline>
<codeline lineno="7267"><highlight class="normal"></highlight></codeline>
<codeline lineno="7268"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Generic::CheckAllocation(</highlight></codeline>
<codeline lineno="7269"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocSize,</highlight></codeline>
<codeline lineno="7270"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocAlignment,</highlight></codeline>
<codeline lineno="7271"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>allocType,</highlight></codeline>
<codeline lineno="7272"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationList::const_iterator<sp/>suballocItem,</highlight></codeline>
<codeline lineno="7273"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocHandle*<sp/>pAllocHandle)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="7274"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="7275"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocSize<sp/>&gt;<sp/>0);</highlight></codeline>
<codeline lineno="7276"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocType<sp/>!=<sp/>VMA_SUBALLOCATION_TYPE_FREE);</highlight></codeline>
<codeline lineno="7277"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(suballocItem<sp/>!=<sp/>m_Suballocations.cend());</highlight></codeline>
<codeline lineno="7278"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(pAllocHandle<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="7279"><highlight class="normal"></highlight></codeline>
<codeline lineno="7280"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>debugMargin<sp/>=<sp/>GetDebugMargin();</highlight></codeline>
<codeline lineno="7281"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>bufferImageGranularity<sp/>=<sp/>GetBufferImageGranularity();</highlight></codeline>
<codeline lineno="7282"><highlight class="normal"></highlight></codeline>
<codeline lineno="7283"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>suballoc<sp/>=<sp/>*suballocItem;</highlight></codeline>
<codeline lineno="7284"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(suballoc.type<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_FREE);</highlight></codeline>
<codeline lineno="7285"><highlight class="normal"></highlight></codeline>
<codeline lineno="7286"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Size<sp/>of<sp/>this<sp/>suballocation<sp/>is<sp/>too<sp/>small<sp/>for<sp/>this<sp/>request:<sp/>Early<sp/>return.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7287"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(suballoc.size<sp/>&lt;<sp/>allocSize)</highlight></codeline>
<codeline lineno="7288"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7289"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7290"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7291"><highlight class="normal"></highlight></codeline>
<codeline lineno="7292"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Start<sp/>from<sp/>offset<sp/>equal<sp/>to<sp/>beginning<sp/>of<sp/>this<sp/>suballocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7293"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>offset<sp/>=<sp/>suballoc.offset<sp/>+<sp/>(suballocItem<sp/>==<sp/>m_Suballocations.cbegin()<sp/>?<sp/>0<sp/>:<sp/>GetDebugMargin());</highlight></codeline>
<codeline lineno="7294"><highlight class="normal"></highlight></codeline>
<codeline lineno="7295"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Apply<sp/>debugMargin<sp/>from<sp/>the<sp/>end<sp/>of<sp/>previous<sp/>alloc.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7296"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(debugMargin<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="7297"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7298"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset<sp/>+=<sp/>debugMargin;</highlight></codeline>
<codeline lineno="7299"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7300"><highlight class="normal"></highlight></codeline>
<codeline lineno="7301"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Apply<sp/>alignment.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7302"><highlight class="normal"><sp/><sp/><sp/><sp/>offset<sp/>=<sp/>VmaAlignUp(offset,<sp/>allocAlignment);</highlight></codeline>
<codeline lineno="7303"><highlight class="normal"></highlight></codeline>
<codeline lineno="7304"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>previous<sp/>suballocations<sp/>for<sp/>BufferImageGranularity<sp/>conflicts.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7305"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Make<sp/>bigger<sp/>alignment<sp/>if<sp/>necessary.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7306"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(bufferImageGranularity<sp/>&gt;<sp/>1<sp/>&amp;&amp;<sp/>bufferImageGranularity<sp/>!=<sp/>allocAlignment)</highlight></codeline>
<codeline lineno="7307"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7308"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>bufferImageGranularityConflict<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7309"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationList::const_iterator<sp/>prevSuballocItem<sp/>=<sp/>suballocItem;</highlight></codeline>
<codeline lineno="7310"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(prevSuballocItem<sp/>!=<sp/>m_Suballocations.cbegin())</highlight></codeline>
<codeline lineno="7311"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--prevSuballocItem;</highlight></codeline>
<codeline lineno="7313"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>prevSuballoc<sp/>=<sp/>*prevSuballocItem;</highlight></codeline>
<codeline lineno="7314"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(VmaBlocksOnSamePage(prevSuballoc.offset,<sp/>prevSuballoc.size,<sp/>offset,<sp/>bufferImageGranularity))</highlight></codeline>
<codeline lineno="7315"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7316"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(VmaIsBufferImageGranularityConflict(prevSuballoc.type,<sp/>allocType))</highlight></codeline>
<codeline lineno="7317"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7318"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bufferImageGranularityConflict<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7319"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7320"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7321"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7322"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7323"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Already<sp/>on<sp/>previous<sp/>page.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7324"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7325"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(bufferImageGranularityConflict)</highlight></codeline>
<codeline lineno="7327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7328"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset<sp/>=<sp/>VmaAlignUp(offset,<sp/>bufferImageGranularity);</highlight></codeline>
<codeline lineno="7329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7330"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7331"><highlight class="normal"></highlight></codeline>
<codeline lineno="7332"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Calculate<sp/>padding<sp/>at<sp/>the<sp/>beginning<sp/>based<sp/>on<sp/>current<sp/>offset.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7333"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>paddingBegin<sp/>=<sp/>offset<sp/>-<sp/>suballoc.offset;</highlight></codeline>
<codeline lineno="7334"><highlight class="normal"></highlight></codeline>
<codeline lineno="7335"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Fail<sp/>if<sp/>requested<sp/>size<sp/>plus<sp/>margin<sp/>after<sp/>is<sp/>bigger<sp/>than<sp/>size<sp/>of<sp/>this<sp/>suballocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7336"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(paddingBegin<sp/>+<sp/>allocSize<sp/>+<sp/>debugMargin<sp/>&gt;<sp/>suballoc.size)</highlight></codeline>
<codeline lineno="7337"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7338"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7339"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7340"><highlight class="normal"></highlight></codeline>
<codeline lineno="7341"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>next<sp/>suballocations<sp/>for<sp/>BufferImageGranularity<sp/>conflicts.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7342"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>conflict<sp/>exists,<sp/>allocation<sp/>cannot<sp/>be<sp/>made<sp/>here.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7343"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(allocSize<sp/>%<sp/>bufferImageGranularity<sp/>||<sp/>offset<sp/>%<sp/>bufferImageGranularity)</highlight></codeline>
<codeline lineno="7344"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7345"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationList::const_iterator<sp/>nextSuballocItem<sp/>=<sp/>suballocItem;</highlight></codeline>
<codeline lineno="7346"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++nextSuballocItem;</highlight></codeline>
<codeline lineno="7347"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(nextSuballocItem<sp/>!=<sp/>m_Suballocations.cend())</highlight></codeline>
<codeline lineno="7348"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7349"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>nextSuballoc<sp/>=<sp/>*nextSuballocItem;</highlight></codeline>
<codeline lineno="7350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(VmaBlocksOnSamePage(offset,<sp/>allocSize,<sp/>nextSuballoc.offset,<sp/>bufferImageGranularity))</highlight></codeline>
<codeline lineno="7351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7352"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(VmaIsBufferImageGranularityConflict(allocType,<sp/>nextSuballoc.type))</highlight></codeline>
<codeline lineno="7353"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7354"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7355"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7356"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7357"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7358"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7359"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Already<sp/>on<sp/>next<sp/>page.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7360"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7361"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7362"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++nextSuballocItem;</highlight></codeline>
<codeline lineno="7363"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7364"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7365"><highlight class="normal"></highlight></codeline>
<codeline lineno="7366"><highlight class="normal"><sp/><sp/><sp/><sp/>*pAllocHandle<sp/>=<sp/>(VmaAllocHandle)(offset<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="7367"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>All<sp/>tests<sp/>passed:<sp/>Success.<sp/>pAllocHandle<sp/>is<sp/>already<sp/>filled.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7368"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7369"><highlight class="normal">}</highlight></codeline>
<codeline lineno="7370"><highlight class="normal"></highlight></codeline>
<codeline lineno="7371"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Generic::MergeFreeWithNext(VmaSuballocationList::iterator<sp/>item)</highlight></codeline>
<codeline lineno="7372"><highlight class="normal">{</highlight></codeline>
<codeline lineno="7373"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(item<sp/>!=<sp/>m_Suballocations.end());</highlight></codeline>
<codeline lineno="7374"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(item-&gt;type<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_FREE);</highlight></codeline>
<codeline lineno="7375"><highlight class="normal"></highlight></codeline>
<codeline lineno="7376"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationList::iterator<sp/>nextItem<sp/>=<sp/>item;</highlight></codeline>
<codeline lineno="7377"><highlight class="normal"><sp/><sp/><sp/><sp/>++nextItem;</highlight></codeline>
<codeline lineno="7378"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(nextItem<sp/>!=<sp/>m_Suballocations.end());</highlight></codeline>
<codeline lineno="7379"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(nextItem-&gt;type<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_FREE);</highlight></codeline>
<codeline lineno="7380"><highlight class="normal"></highlight></codeline>
<codeline lineno="7381"><highlight class="normal"><sp/><sp/><sp/><sp/>item-&gt;size<sp/>+=<sp/>nextItem-&gt;size;</highlight></codeline>
<codeline lineno="7382"><highlight class="normal"><sp/><sp/><sp/><sp/>--m_FreeCount;</highlight></codeline>
<codeline lineno="7383"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Suballocations.erase(nextItem);</highlight></codeline>
<codeline lineno="7384"><highlight class="normal">}</highlight></codeline>
<codeline lineno="7385"><highlight class="normal"></highlight></codeline>
<codeline lineno="7386"><highlight class="normal">VmaSuballocationList::iterator<sp/>VmaBlockMetadata_Generic::FreeSuballocation(VmaSuballocationList::iterator<sp/>suballocItem)</highlight></codeline>
<codeline lineno="7387"><highlight class="normal">{</highlight></codeline>
<codeline lineno="7388"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Change<sp/>this<sp/>suballocation<sp/>to<sp/>be<sp/>marked<sp/>as<sp/>free.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7389"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocation&amp;<sp/>suballoc<sp/>=<sp/>*suballocItem;</highlight></codeline>
<codeline lineno="7390"><highlight class="normal"><sp/><sp/><sp/><sp/>suballoc.type<sp/>=<sp/>VMA_SUBALLOCATION_TYPE_FREE;</highlight></codeline>
<codeline lineno="7391"><highlight class="normal"><sp/><sp/><sp/><sp/>suballoc.userData<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="7392"><highlight class="normal"></highlight></codeline>
<codeline lineno="7393"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Update<sp/>totals.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7394"><highlight class="normal"><sp/><sp/><sp/><sp/>++m_FreeCount;</highlight></codeline>
<codeline lineno="7395"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SumFreeSize<sp/>+=<sp/>suballoc.size;</highlight></codeline>
<codeline lineno="7396"><highlight class="normal"></highlight></codeline>
<codeline lineno="7397"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Merge<sp/>with<sp/>previous<sp/>and/or<sp/>next<sp/>suballocation<sp/>if<sp/>it&apos;s<sp/>also<sp/>free.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7398"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>mergeWithNext<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7399"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>mergeWithPrev<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7400"><highlight class="normal"></highlight></codeline>
<codeline lineno="7401"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationList::iterator<sp/>nextItem<sp/>=<sp/>suballocItem;</highlight></codeline>
<codeline lineno="7402"><highlight class="normal"><sp/><sp/><sp/><sp/>++nextItem;</highlight></codeline>
<codeline lineno="7403"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((nextItem<sp/>!=<sp/>m_Suballocations.end())<sp/>&amp;&amp;<sp/>(nextItem-&gt;type<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_FREE))</highlight></codeline>
<codeline lineno="7404"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7405"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mergeWithNext<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7406"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7407"><highlight class="normal"></highlight></codeline>
<codeline lineno="7408"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationList::iterator<sp/>prevItem<sp/>=<sp/>suballocItem;</highlight></codeline>
<codeline lineno="7409"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(suballocItem<sp/>!=<sp/>m_Suballocations.begin())</highlight></codeline>
<codeline lineno="7410"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7411"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--prevItem;</highlight></codeline>
<codeline lineno="7412"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(prevItem-&gt;type<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_FREE)</highlight></codeline>
<codeline lineno="7413"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7414"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mergeWithPrev<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7415"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7416"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7417"><highlight class="normal"></highlight></codeline>
<codeline lineno="7418"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(mergeWithNext)</highlight></codeline>
<codeline lineno="7419"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7420"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UnregisterFreeSuballocation(nextItem);</highlight></codeline>
<codeline lineno="7421"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MergeFreeWithNext(suballocItem);</highlight></codeline>
<codeline lineno="7422"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7423"><highlight class="normal"></highlight></codeline>
<codeline lineno="7424"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(mergeWithPrev)</highlight></codeline>
<codeline lineno="7425"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7426"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UnregisterFreeSuballocation(prevItem);</highlight></codeline>
<codeline lineno="7427"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MergeFreeWithNext(prevItem);</highlight></codeline>
<codeline lineno="7428"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>RegisterFreeSuballocation(prevItem);</highlight></codeline>
<codeline lineno="7429"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>prevItem;</highlight></codeline>
<codeline lineno="7430"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7431"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7432"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7433"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>RegisterFreeSuballocation(suballocItem);</highlight></codeline>
<codeline lineno="7434"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>suballocItem;</highlight></codeline>
<codeline lineno="7435"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7436"><highlight class="normal">}</highlight></codeline>
<codeline lineno="7437"><highlight class="normal"></highlight></codeline>
<codeline lineno="7438"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Generic::RegisterFreeSuballocation(VmaSuballocationList::iterator<sp/>item)</highlight></codeline>
<codeline lineno="7439"><highlight class="normal">{</highlight></codeline>
<codeline lineno="7440"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(item-&gt;type<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_FREE);</highlight></codeline>
<codeline lineno="7441"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(item-&gt;size<sp/>&gt;<sp/>0);</highlight></codeline>
<codeline lineno="7442"><highlight class="normal"></highlight></codeline>
<codeline lineno="7443"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>You<sp/>may<sp/>want<sp/>to<sp/>enable<sp/>this<sp/>validation<sp/>at<sp/>the<sp/>beginning<sp/>or<sp/>at<sp/>the<sp/>end<sp/>of</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7444"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>this<sp/>function,<sp/>depending<sp/>on<sp/>what<sp/>do<sp/>you<sp/>want<sp/>to<sp/>check.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7445"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(ValidateFreeSuballocationList());</highlight></codeline>
<codeline lineno="7446"><highlight class="normal"></highlight></codeline>
<codeline lineno="7447"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_FreeSuballocationsBySize.empty())</highlight></codeline>
<codeline lineno="7448"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7449"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_FreeSuballocationsBySize.push_back(item);</highlight></codeline>
<codeline lineno="7450"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7451"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7452"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7453"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaVectorInsertSorted&lt;VmaSuballocationItemSizeLess&gt;(m_FreeSuballocationsBySize,<sp/>item);</highlight></codeline>
<codeline lineno="7454"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7455"><highlight class="normal"></highlight></codeline>
<codeline lineno="7456"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//VMA_HEAVY_ASSERT(ValidateFreeSuballocationList());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7457"><highlight class="normal">}</highlight></codeline>
<codeline lineno="7458"><highlight class="normal"></highlight></codeline>
<codeline lineno="7459"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Generic::UnregisterFreeSuballocation(VmaSuballocationList::iterator<sp/>item)</highlight></codeline>
<codeline lineno="7460"><highlight class="normal">{</highlight></codeline>
<codeline lineno="7461"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(item-&gt;type<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_FREE);</highlight></codeline>
<codeline lineno="7462"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(item-&gt;size<sp/>&gt;<sp/>0);</highlight></codeline>
<codeline lineno="7463"><highlight class="normal"></highlight></codeline>
<codeline lineno="7464"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>You<sp/>may<sp/>want<sp/>to<sp/>enable<sp/>this<sp/>validation<sp/>at<sp/>the<sp/>beginning<sp/>or<sp/>at<sp/>the<sp/>end<sp/>of</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7465"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>this<sp/>function,<sp/>depending<sp/>on<sp/>what<sp/>do<sp/>you<sp/>want<sp/>to<sp/>check.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7466"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(ValidateFreeSuballocationList());</highlight></codeline>
<codeline lineno="7467"><highlight class="normal"></highlight></codeline>
<codeline lineno="7468"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationList::iterator*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>it<sp/>=<sp/>VmaBinaryFindFirstNotLess(</highlight></codeline>
<codeline lineno="7469"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_FreeSuballocationsBySize.data(),</highlight></codeline>
<codeline lineno="7470"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_FreeSuballocationsBySize.data()<sp/>+<sp/>m_FreeSuballocationsBySize.size(),</highlight></codeline>
<codeline lineno="7471"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>item,</highlight></codeline>
<codeline lineno="7472"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationItemSizeLess());</highlight></codeline>
<codeline lineno="7473"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index<sp/>=<sp/>it<sp/>-<sp/>m_FreeSuballocationsBySize.data();</highlight></codeline>
<codeline lineno="7474"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>index<sp/>&lt;<sp/>m_FreeSuballocationsBySize.size();</highlight></codeline>
<codeline lineno="7475"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++index)</highlight></codeline>
<codeline lineno="7476"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7477"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_FreeSuballocationsBySize[index]<sp/>==<sp/>item)</highlight></codeline>
<codeline lineno="7478"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7479"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaVectorRemove(m_FreeSuballocationsBySize,<sp/>index);</highlight></codeline>
<codeline lineno="7480"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7481"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7482"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT((m_FreeSuballocationsBySize[index]-&gt;size<sp/>==<sp/>item-&gt;size)<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Not<sp/>found.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="7483"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7484"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Not<sp/>found.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="7485"><highlight class="normal"></highlight></codeline>
<codeline lineno="7486"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//VMA_HEAVY_ASSERT(ValidateFreeSuballocationList());</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7487"><highlight class="normal">}</highlight></codeline>
<codeline lineno="7488"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_BLOCK_METADATA_GENERIC_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7489"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_BLOCK_METADATA_GENERIC</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7490"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7491"><highlight class="normal"></highlight></codeline>
<codeline lineno="7492"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_BLOCK_METADATA_LINEAR</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7493"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="7494"><highlight class="comment">Allocations<sp/>and<sp/>their<sp/>references<sp/>in<sp/>internal<sp/>data<sp/>structure<sp/>look<sp/>like<sp/>this:</highlight></codeline>
<codeline lineno="7495"><highlight class="comment"></highlight></codeline>
<codeline lineno="7496"><highlight class="comment">if(m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_EMPTY):</highlight></codeline>
<codeline lineno="7497"><highlight class="comment"></highlight></codeline>
<codeline lineno="7498"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0<sp/>+-------+</highlight></codeline>
<codeline lineno="7499"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline lineno="7500"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline lineno="7501"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline lineno="7502"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+-------+</highlight></codeline>
<codeline lineno="7503"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>Alloc<sp/>|<sp/><sp/>1st[m_1stNullItemsBeginCount]</highlight></codeline>
<codeline lineno="7504"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+-------+</highlight></codeline>
<codeline lineno="7505"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>Alloc<sp/>|<sp/><sp/>1st[m_1stNullItemsBeginCount<sp/>+<sp/>1]</highlight></codeline>
<codeline lineno="7506"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+-------+</highlight></codeline>
<codeline lineno="7507"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/>...<sp/><sp/>|</highlight></codeline>
<codeline lineno="7508"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+-------+</highlight></codeline>
<codeline lineno="7509"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>Alloc<sp/>|<sp/><sp/>1st[1st.size()<sp/>-<sp/>1]</highlight></codeline>
<codeline lineno="7510"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+-------+</highlight></codeline>
<codeline lineno="7511"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline lineno="7512"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline lineno="7513"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline lineno="7514"><highlight class="comment">GetSize()<sp/>+-------+</highlight></codeline>
<codeline lineno="7515"><highlight class="comment"></highlight></codeline>
<codeline lineno="7516"><highlight class="comment">if(m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_RING_BUFFER):</highlight></codeline>
<codeline lineno="7517"><highlight class="comment"></highlight></codeline>
<codeline lineno="7518"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0<sp/>+-------+</highlight></codeline>
<codeline lineno="7519"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>Alloc<sp/>|<sp/><sp/>2nd[0]</highlight></codeline>
<codeline lineno="7520"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+-------+</highlight></codeline>
<codeline lineno="7521"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>Alloc<sp/>|<sp/><sp/>2nd[1]</highlight></codeline>
<codeline lineno="7522"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+-------+</highlight></codeline>
<codeline lineno="7523"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/>...<sp/><sp/>|</highlight></codeline>
<codeline lineno="7524"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+-------+</highlight></codeline>
<codeline lineno="7525"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>Alloc<sp/>|<sp/><sp/>2nd[2nd.size()<sp/>-<sp/>1]</highlight></codeline>
<codeline lineno="7526"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+-------+</highlight></codeline>
<codeline lineno="7527"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline lineno="7528"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline lineno="7529"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline lineno="7530"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+-------+</highlight></codeline>
<codeline lineno="7531"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>Alloc<sp/>|<sp/><sp/>1st[m_1stNullItemsBeginCount]</highlight></codeline>
<codeline lineno="7532"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+-------+</highlight></codeline>
<codeline lineno="7533"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>Alloc<sp/>|<sp/><sp/>1st[m_1stNullItemsBeginCount<sp/>+<sp/>1]</highlight></codeline>
<codeline lineno="7534"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+-------+</highlight></codeline>
<codeline lineno="7535"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/>...<sp/><sp/>|</highlight></codeline>
<codeline lineno="7536"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+-------+</highlight></codeline>
<codeline lineno="7537"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>Alloc<sp/>|<sp/><sp/>1st[1st.size()<sp/>-<sp/>1]</highlight></codeline>
<codeline lineno="7538"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+-------+</highlight></codeline>
<codeline lineno="7539"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline lineno="7540"><highlight class="comment">GetSize()<sp/>+-------+</highlight></codeline>
<codeline lineno="7541"><highlight class="comment"></highlight></codeline>
<codeline lineno="7542"><highlight class="comment">if(m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_DOUBLE_STACK):</highlight></codeline>
<codeline lineno="7543"><highlight class="comment"></highlight></codeline>
<codeline lineno="7544"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0<sp/>+-------+</highlight></codeline>
<codeline lineno="7545"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline lineno="7546"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline lineno="7547"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline lineno="7548"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+-------+</highlight></codeline>
<codeline lineno="7549"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>Alloc<sp/>|<sp/><sp/>1st[m_1stNullItemsBeginCount]</highlight></codeline>
<codeline lineno="7550"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+-------+</highlight></codeline>
<codeline lineno="7551"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>Alloc<sp/>|<sp/><sp/>1st[m_1stNullItemsBeginCount<sp/>+<sp/>1]</highlight></codeline>
<codeline lineno="7552"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+-------+</highlight></codeline>
<codeline lineno="7553"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/>...<sp/><sp/>|</highlight></codeline>
<codeline lineno="7554"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+-------+</highlight></codeline>
<codeline lineno="7555"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>Alloc<sp/>|<sp/><sp/>1st[1st.size()<sp/>-<sp/>1]</highlight></codeline>
<codeline lineno="7556"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+-------+</highlight></codeline>
<codeline lineno="7557"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline lineno="7558"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline lineno="7559"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/><sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline lineno="7560"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+-------+</highlight></codeline>
<codeline lineno="7561"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>Alloc<sp/>|<sp/><sp/>2nd[2nd.size()<sp/>-<sp/>1]</highlight></codeline>
<codeline lineno="7562"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+-------+</highlight></codeline>
<codeline lineno="7563"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/>...<sp/><sp/>|</highlight></codeline>
<codeline lineno="7564"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+-------+</highlight></codeline>
<codeline lineno="7565"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>Alloc<sp/>|<sp/><sp/>2nd[1]</highlight></codeline>
<codeline lineno="7566"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+-------+</highlight></codeline>
<codeline lineno="7567"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>Alloc<sp/>|<sp/><sp/>2nd[0]</highlight></codeline>
<codeline lineno="7568"><highlight class="comment">GetSize()<sp/>+-------+</highlight></codeline>
<codeline lineno="7569"><highlight class="comment"></highlight></codeline>
<codeline lineno="7570"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7571"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaBlockMetadata_Linear<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>VmaBlockMetadata</highlight></codeline>
<codeline lineno="7572"><highlight class="normal">{</highlight></codeline>
<codeline lineno="7573"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_CLASS_NO_COPY(VmaBlockMetadata_Linear)</highlight></codeline>
<codeline lineno="7574"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="7575"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaBlockMetadata_Linear(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks,</highlight></codeline>
<codeline lineno="7576"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>bufferImageGranularity,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isVirtual);</highlight></codeline>
<codeline lineno="7577"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>~VmaBlockMetadata_Linear()<sp/>=<sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7578"><highlight class="normal"></highlight></codeline>
<codeline lineno="7579"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>GetSumFreeSize()</highlight><highlight class="keyword"><sp/>const<sp/>override<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_SumFreeSize;<sp/>}</highlight></codeline>
<codeline lineno="7580"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>IsEmpty()</highlight><highlight class="keyword"><sp/>const<sp/>override<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>GetAllocationCount()<sp/>==<sp/>0;<sp/>}</highlight></codeline>
<codeline lineno="7581"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>GetAllocationOffset(VmaAllocHandle<sp/>allocHandle)</highlight><highlight class="keyword"><sp/>const<sp/>override<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(VkDeviceSize)allocHandle<sp/>-<sp/>1;<sp/>};</highlight></codeline>
<codeline lineno="7582"><highlight class="normal"></highlight></codeline>
<codeline lineno="7583"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Init(VkDeviceSize<sp/>size)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7584"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>Validate()<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7585"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>GetAllocationCount()<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7586"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>GetFreeRegionsCount()<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7587"><highlight class="normal"></highlight></codeline>
<codeline lineno="7588"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>AddDetailedStatistics(<ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>&amp;<sp/>inoutStats)<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7589"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>AddStatistics(<ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref>&amp;<sp/>inoutStats)<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7590"><highlight class="normal"></highlight></codeline>
<codeline lineno="7591"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7592"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>PrintDetailedMap(</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>VmaJsonWriter&amp;<sp/>json)<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7593"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7594"><highlight class="normal"></highlight></codeline>
<codeline lineno="7595"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>CreateAllocationRequest(</highlight></codeline>
<codeline lineno="7596"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocSize,</highlight></codeline>
<codeline lineno="7597"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocAlignment,</highlight></codeline>
<codeline lineno="7598"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>upperAddress,</highlight></codeline>
<codeline lineno="7599"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>allocType,</highlight></codeline>
<codeline lineno="7600"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>strategy,</highlight></codeline>
<codeline lineno="7601"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAllocationRequest*<sp/>pAllocationRequest)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7602"><highlight class="normal"></highlight></codeline>
<codeline lineno="7603"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>CheckCorruption(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pBlockData)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7604"><highlight class="normal"></highlight></codeline>
<codeline lineno="7605"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Alloc(</highlight></codeline>
<codeline lineno="7606"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaAllocationRequest&amp;<sp/>request,</highlight></codeline>
<codeline lineno="7607"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>type,</highlight></codeline>
<codeline lineno="7608"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>userData)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7609"><highlight class="normal"></highlight></codeline>
<codeline lineno="7610"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Free(VmaAllocHandle<sp/>allocHandle)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7611"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GetAllocationInfo(VmaAllocHandle<sp/>allocHandle,<sp/><ref refid="struct_vma_virtual_allocation_info" kindref="compound">VmaVirtualAllocationInfo</ref>&amp;<sp/>outInfo)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7612"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>GetAllocationUserData(VmaAllocHandle<sp/>allocHandle)<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7613"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocHandle<sp/>GetAllocationListBegin()<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7614"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocHandle<sp/>GetNextAllocation(VmaAllocHandle<sp/>prevAlloc)<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7615"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>GetNextFreeRegionSize(VmaAllocHandle<sp/>alloc)<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7616"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Clear()<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7617"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>SetAllocationUserData(VmaAllocHandle<sp/>allocHandle,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>userData)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7618"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DebugLogAllAllocations()<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7619"><highlight class="normal"></highlight></codeline>
<codeline lineno="7620"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="7621"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="7622"><highlight class="comment"><sp/><sp/><sp/><sp/>There<sp/>are<sp/>two<sp/>suballocation<sp/>vectors,<sp/>used<sp/>in<sp/>ping-pong<sp/>way.</highlight></codeline>
<codeline lineno="7623"><highlight class="comment"><sp/><sp/><sp/><sp/>The<sp/>one<sp/>with<sp/>index<sp/>m_1stVectorIndex<sp/>is<sp/>called<sp/>1st.</highlight></codeline>
<codeline lineno="7624"><highlight class="comment"><sp/><sp/><sp/><sp/>The<sp/>one<sp/>with<sp/>index<sp/>(m_1stVectorIndex<sp/>^<sp/>1)<sp/>is<sp/>called<sp/>2nd.</highlight></codeline>
<codeline lineno="7625"><highlight class="comment"><sp/><sp/><sp/><sp/>2nd<sp/>can<sp/>be<sp/>non-empty<sp/>only<sp/>when<sp/>1st<sp/>is<sp/>not<sp/>empty.</highlight></codeline>
<codeline lineno="7626"><highlight class="comment"><sp/><sp/><sp/><sp/>When<sp/>2nd<sp/>is<sp/>not<sp/>empty,<sp/>m_2ndVectorMode<sp/>indicates<sp/>its<sp/>mode<sp/>of<sp/>operation.</highlight></codeline>
<codeline lineno="7627"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7628"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VmaVector&lt;VmaSuballocation,<sp/>VmaStlAllocator&lt;VmaSuballocation&gt;&gt;<sp/>SuballocationVectorType;</highlight></codeline>
<codeline lineno="7629"><highlight class="normal"></highlight></codeline>
<codeline lineno="7630"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/>SECOND_VECTOR_MODE</highlight></codeline>
<codeline lineno="7631"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7632"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SECOND_VECTOR_EMPTY,</highlight></codeline>
<codeline lineno="7633"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="7634"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Suballocations<sp/>in<sp/>2nd<sp/>vector<sp/>are<sp/>created<sp/>later<sp/>than<sp/>the<sp/>ones<sp/>in<sp/>1st,<sp/>but<sp/>they</highlight></codeline>
<codeline lineno="7635"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>all<sp/>have<sp/>smaller<sp/>offset.</highlight></codeline>
<codeline lineno="7636"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7637"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SECOND_VECTOR_RING_BUFFER,</highlight></codeline>
<codeline lineno="7638"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="7639"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Suballocations<sp/>in<sp/>2nd<sp/>vector<sp/>are<sp/>upper<sp/>side<sp/>of<sp/>double<sp/>stack.</highlight></codeline>
<codeline lineno="7640"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>They<sp/>all<sp/>have<sp/>offsets<sp/>higher<sp/>than<sp/>those<sp/>in<sp/>1st<sp/>vector.</highlight></codeline>
<codeline lineno="7641"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Top<sp/>of<sp/>this<sp/>stack<sp/>means<sp/>smaller<sp/>offsets,<sp/>but<sp/>higher<sp/>indices<sp/>in<sp/>this<sp/>vector.</highlight></codeline>
<codeline lineno="7642"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7643"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SECOND_VECTOR_DOUBLE_STACK,</highlight></codeline>
<codeline lineno="7644"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="7645"><highlight class="normal"></highlight></codeline>
<codeline lineno="7646"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>m_SumFreeSize;</highlight></codeline>
<codeline lineno="7647"><highlight class="normal"><sp/><sp/><sp/><sp/>SuballocationVectorType<sp/>m_Suballocations0,<sp/>m_Suballocations1;</highlight></codeline>
<codeline lineno="7648"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>m_1stVectorIndex;</highlight></codeline>
<codeline lineno="7649"><highlight class="normal"><sp/><sp/><sp/><sp/>SECOND_VECTOR_MODE<sp/>m_2ndVectorMode;</highlight></codeline>
<codeline lineno="7650"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Number<sp/>of<sp/>items<sp/>in<sp/>1st<sp/>vector<sp/>with<sp/>hAllocation<sp/>=<sp/>null<sp/>at<sp/>the<sp/>beginning.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7651"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>m_1stNullItemsBeginCount;</highlight></codeline>
<codeline lineno="7652"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Number<sp/>of<sp/>other<sp/>items<sp/>in<sp/>1st<sp/>vector<sp/>with<sp/>hAllocation<sp/>=<sp/>null<sp/>somewhere<sp/>in<sp/>the<sp/>middle.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7653"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>m_1stNullItemsMiddleCount;</highlight></codeline>
<codeline lineno="7654"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Number<sp/>of<sp/>items<sp/>in<sp/>2nd<sp/>vector<sp/>with<sp/>hAllocation<sp/>=<sp/>null.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7655"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>m_2ndNullItemsCount;</highlight></codeline>
<codeline lineno="7656"><highlight class="normal"></highlight></codeline>
<codeline lineno="7657"><highlight class="normal"><sp/><sp/><sp/><sp/>SuballocationVectorType&amp;<sp/>AccessSuballocations1st()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_1stVectorIndex<sp/>?<sp/>m_Suballocations1<sp/>:<sp/>m_Suballocations0;<sp/>}</highlight></codeline>
<codeline lineno="7658"><highlight class="normal"><sp/><sp/><sp/><sp/>SuballocationVectorType&amp;<sp/>AccessSuballocations2nd()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_1stVectorIndex<sp/>?<sp/>m_Suballocations0<sp/>:<sp/>m_Suballocations1;<sp/>}</highlight></codeline>
<codeline lineno="7659"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SuballocationVectorType&amp;<sp/>AccessSuballocations1st()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_1stVectorIndex<sp/>?<sp/>m_Suballocations1<sp/>:<sp/>m_Suballocations0;<sp/>}</highlight></codeline>
<codeline lineno="7660"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SuballocationVectorType&amp;<sp/>AccessSuballocations2nd()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_1stVectorIndex<sp/>?<sp/>m_Suballocations0<sp/>:<sp/>m_Suballocations1;<sp/>}</highlight></codeline>
<codeline lineno="7661"><highlight class="normal"></highlight></codeline>
<codeline lineno="7662"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocation&amp;<sp/>FindSuballocation(VkDeviceSize<sp/>offset)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7663"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>ShouldCompact1st()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7664"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>CleanupAfterFree();</highlight></codeline>
<codeline lineno="7665"><highlight class="normal"></highlight></codeline>
<codeline lineno="7666"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>CreateAllocationRequest_LowerAddress(</highlight></codeline>
<codeline lineno="7667"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocSize,</highlight></codeline>
<codeline lineno="7668"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocAlignment,</highlight></codeline>
<codeline lineno="7669"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>allocType,</highlight></codeline>
<codeline lineno="7670"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>strategy,</highlight></codeline>
<codeline lineno="7671"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAllocationRequest*<sp/>pAllocationRequest);</highlight></codeline>
<codeline lineno="7672"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>CreateAllocationRequest_UpperAddress(</highlight></codeline>
<codeline lineno="7673"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocSize,</highlight></codeline>
<codeline lineno="7674"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocAlignment,</highlight></codeline>
<codeline lineno="7675"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>allocType,</highlight></codeline>
<codeline lineno="7676"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>strategy,</highlight></codeline>
<codeline lineno="7677"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAllocationRequest*<sp/>pAllocationRequest);</highlight></codeline>
<codeline lineno="7678"><highlight class="normal">};</highlight></codeline>
<codeline lineno="7679"><highlight class="normal"></highlight></codeline>
<codeline lineno="7680"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_BLOCK_METADATA_LINEAR_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7681"><highlight class="normal">VmaBlockMetadata_Linear::VmaBlockMetadata_Linear(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks,</highlight></codeline>
<codeline lineno="7682"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>bufferImageGranularity,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isVirtual)</highlight></codeline>
<codeline lineno="7683"><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>VmaBlockMetadata(pAllocationCallbacks,<sp/>bufferImageGranularity,<sp/>isVirtual),</highlight></codeline>
<codeline lineno="7684"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SumFreeSize(0),</highlight></codeline>
<codeline lineno="7685"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Suballocations0(VmaStlAllocator&lt;VmaSuballocation&gt;(pAllocationCallbacks)),</highlight></codeline>
<codeline lineno="7686"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Suballocations1(VmaStlAllocator&lt;VmaSuballocation&gt;(pAllocationCallbacks)),</highlight></codeline>
<codeline lineno="7687"><highlight class="normal"><sp/><sp/><sp/><sp/>m_1stVectorIndex(0),</highlight></codeline>
<codeline lineno="7688"><highlight class="normal"><sp/><sp/><sp/><sp/>m_2ndVectorMode(SECOND_VECTOR_EMPTY),</highlight></codeline>
<codeline lineno="7689"><highlight class="normal"><sp/><sp/><sp/><sp/>m_1stNullItemsBeginCount(0),</highlight></codeline>
<codeline lineno="7690"><highlight class="normal"><sp/><sp/><sp/><sp/>m_1stNullItemsMiddleCount(0),</highlight></codeline>
<codeline lineno="7691"><highlight class="normal"><sp/><sp/><sp/><sp/>m_2ndNullItemsCount(0)<sp/>{}</highlight></codeline>
<codeline lineno="7692"><highlight class="normal"></highlight></codeline>
<codeline lineno="7693"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Linear::Init(VkDeviceSize<sp/>size)</highlight></codeline>
<codeline lineno="7694"><highlight class="normal">{</highlight></codeline>
<codeline lineno="7695"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaBlockMetadata::Init(size);</highlight></codeline>
<codeline lineno="7696"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SumFreeSize<sp/>=<sp/>size;</highlight></codeline>
<codeline lineno="7697"><highlight class="normal">}</highlight></codeline>
<codeline lineno="7698"><highlight class="normal"></highlight></codeline>
<codeline lineno="7699"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Linear::Validate()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="7700"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="7701"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SuballocationVectorType&amp;<sp/>suballocations1st<sp/>=<sp/>AccessSuballocations1st();</highlight></codeline>
<codeline lineno="7702"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SuballocationVectorType&amp;<sp/>suballocations2nd<sp/>=<sp/>AccessSuballocations2nd();</highlight></codeline>
<codeline lineno="7703"><highlight class="normal"></highlight></codeline>
<codeline lineno="7704"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE(suballocations2nd.empty()<sp/>==<sp/>(m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_EMPTY));</highlight></codeline>
<codeline lineno="7705"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE(!suballocations1st.empty()<sp/>||</highlight></codeline>
<codeline lineno="7706"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations2nd.empty()<sp/>||</highlight></codeline>
<codeline lineno="7707"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_2ndVectorMode<sp/>!=<sp/>SECOND_VECTOR_RING_BUFFER);</highlight></codeline>
<codeline lineno="7708"><highlight class="normal"></highlight></codeline>
<codeline lineno="7709"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!suballocations1st.empty())</highlight></codeline>
<codeline lineno="7710"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7711"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Null<sp/>item<sp/>at<sp/>the<sp/>beginning<sp/>should<sp/>be<sp/>accounted<sp/>into<sp/>m_1stNullItemsBeginCount.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7712"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(suballocations1st[m_1stNullItemsBeginCount].type<sp/>!=<sp/>VMA_SUBALLOCATION_TYPE_FREE);</highlight></codeline>
<codeline lineno="7713"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Null<sp/>item<sp/>at<sp/>the<sp/>end<sp/>should<sp/>be<sp/>just<sp/>pop_back().</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7714"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(suballocations1st.back().type<sp/>!=<sp/>VMA_SUBALLOCATION_TYPE_FREE);</highlight></codeline>
<codeline lineno="7715"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7716"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!suballocations2nd.empty())</highlight></codeline>
<codeline lineno="7717"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7718"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Null<sp/>item<sp/>at<sp/>the<sp/>end<sp/>should<sp/>be<sp/>just<sp/>pop_back().</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7719"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(suballocations2nd.back().type<sp/>!=<sp/>VMA_SUBALLOCATION_TYPE_FREE);</highlight></codeline>
<codeline lineno="7720"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7721"><highlight class="normal"></highlight></codeline>
<codeline lineno="7722"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE(m_1stNullItemsBeginCount<sp/>+<sp/>m_1stNullItemsMiddleCount<sp/>&lt;=<sp/>suballocations1st.size());</highlight></codeline>
<codeline lineno="7723"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE(m_2ndNullItemsCount<sp/>&lt;=<sp/>suballocations2nd.size());</highlight></codeline>
<codeline lineno="7724"><highlight class="normal"></highlight></codeline>
<codeline lineno="7725"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>sumUsedSize<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="7726"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>suballoc1stCount<sp/>=<sp/>suballocations1st.size();</highlight></codeline>
<codeline lineno="7727"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>debugMargin<sp/>=<sp/>GetDebugMargin();</highlight></codeline>
<codeline lineno="7728"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>offset<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="7729"><highlight class="normal"></highlight></codeline>
<codeline lineno="7730"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_RING_BUFFER)</highlight></codeline>
<codeline lineno="7731"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7732"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>suballoc2ndCount<sp/>=<sp/>suballocations2nd.size();</highlight></codeline>
<codeline lineno="7733"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>nullItem2ndCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="7734"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>suballoc2ndCount;<sp/>++i)</highlight></codeline>
<codeline lineno="7735"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7736"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>suballoc<sp/>=<sp/>suballocations2nd[i];</highlight></codeline>
<codeline lineno="7737"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>currFree<sp/>=<sp/>(suballoc.type<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_FREE);</highlight></codeline>
<codeline lineno="7738"><highlight class="normal"></highlight></codeline>
<codeline lineno="7739"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>alloc<sp/>=<sp/>(<ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>)suballoc.userData;</highlight></codeline>
<codeline lineno="7740"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!IsVirtual())</highlight></codeline>
<codeline lineno="7741"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7742"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(currFree<sp/>==<sp/>(alloc<sp/>==<sp/>VK_NULL_HANDLE));</highlight></codeline>
<codeline lineno="7743"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7744"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(suballoc.offset<sp/>&gt;=<sp/>offset);</highlight></codeline>
<codeline lineno="7745"><highlight class="normal"></highlight></codeline>
<codeline lineno="7746"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!currFree)</highlight></codeline>
<codeline lineno="7747"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7748"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!IsVirtual())</highlight></codeline>
<codeline lineno="7749"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7750"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE((VkDeviceSize)alloc-&gt;GetAllocHandle()<sp/>==<sp/>suballoc.offset<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="7751"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(alloc-&gt;GetSize()<sp/>==<sp/>suballoc.size);</highlight></codeline>
<codeline lineno="7752"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7753"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sumUsedSize<sp/>+=<sp/>suballoc.size;</highlight></codeline>
<codeline lineno="7754"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7755"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7756"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7757"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++nullItem2ndCount;</highlight></codeline>
<codeline lineno="7758"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7759"><highlight class="normal"></highlight></codeline>
<codeline lineno="7760"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset<sp/>=<sp/>suballoc.offset<sp/>+<sp/>suballoc.size<sp/>+<sp/>debugMargin;</highlight></codeline>
<codeline lineno="7761"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7762"><highlight class="normal"></highlight></codeline>
<codeline lineno="7763"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(nullItem2ndCount<sp/>==<sp/>m_2ndNullItemsCount);</highlight></codeline>
<codeline lineno="7764"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7765"><highlight class="normal"></highlight></codeline>
<codeline lineno="7766"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>m_1stNullItemsBeginCount;<sp/>++i)</highlight></codeline>
<codeline lineno="7767"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7768"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>suballoc<sp/>=<sp/>suballocations1st[i];</highlight></codeline>
<codeline lineno="7769"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(suballoc.type<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_FREE<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="7770"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballoc.userData<sp/>==<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="7771"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7772"><highlight class="normal"></highlight></codeline>
<codeline lineno="7773"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>nullItem1stCount<sp/>=<sp/>m_1stNullItemsBeginCount;</highlight></codeline>
<codeline lineno="7774"><highlight class="normal"></highlight></codeline>
<codeline lineno="7775"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>m_1stNullItemsBeginCount;<sp/>i<sp/>&lt;<sp/>suballoc1stCount;<sp/>++i)</highlight></codeline>
<codeline lineno="7776"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7777"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>suballoc<sp/>=<sp/>suballocations1st[i];</highlight></codeline>
<codeline lineno="7778"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>currFree<sp/>=<sp/>(suballoc.type<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_FREE);</highlight></codeline>
<codeline lineno="7779"><highlight class="normal"></highlight></codeline>
<codeline lineno="7780"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>alloc<sp/>=<sp/>(<ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>)suballoc.userData;</highlight></codeline>
<codeline lineno="7781"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!IsVirtual())</highlight></codeline>
<codeline lineno="7782"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7783"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(currFree<sp/>==<sp/>(alloc<sp/>==<sp/>VK_NULL_HANDLE));</highlight></codeline>
<codeline lineno="7784"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7785"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(suballoc.offset<sp/>&gt;=<sp/>offset);</highlight></codeline>
<codeline lineno="7786"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(i<sp/>&gt;=<sp/>m_1stNullItemsBeginCount<sp/>||<sp/>currFree);</highlight></codeline>
<codeline lineno="7787"><highlight class="normal"></highlight></codeline>
<codeline lineno="7788"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!currFree)</highlight></codeline>
<codeline lineno="7789"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7790"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!IsVirtual())</highlight></codeline>
<codeline lineno="7791"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7792"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE((VkDeviceSize)alloc-&gt;GetAllocHandle()<sp/>==<sp/>suballoc.offset<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="7793"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(alloc-&gt;GetSize()<sp/>==<sp/>suballoc.size);</highlight></codeline>
<codeline lineno="7794"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7795"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sumUsedSize<sp/>+=<sp/>suballoc.size;</highlight></codeline>
<codeline lineno="7796"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7797"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7798"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7799"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++nullItem1stCount;</highlight></codeline>
<codeline lineno="7800"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7801"><highlight class="normal"></highlight></codeline>
<codeline lineno="7802"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset<sp/>=<sp/>suballoc.offset<sp/>+<sp/>suballoc.size<sp/>+<sp/>debugMargin;</highlight></codeline>
<codeline lineno="7803"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7804"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE(nullItem1stCount<sp/>==<sp/>m_1stNullItemsBeginCount<sp/>+<sp/>m_1stNullItemsMiddleCount);</highlight></codeline>
<codeline lineno="7805"><highlight class="normal"></highlight></codeline>
<codeline lineno="7806"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_DOUBLE_STACK)</highlight></codeline>
<codeline lineno="7807"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7808"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>suballoc2ndCount<sp/>=<sp/>suballocations2nd.size();</highlight></codeline>
<codeline lineno="7809"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>nullItem2ndCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="7810"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>suballoc2ndCount;<sp/>i--;<sp/>)</highlight></codeline>
<codeline lineno="7811"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7812"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>suballoc<sp/>=<sp/>suballocations2nd[i];</highlight></codeline>
<codeline lineno="7813"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>currFree<sp/>=<sp/>(suballoc.type<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_FREE);</highlight></codeline>
<codeline lineno="7814"><highlight class="normal"></highlight></codeline>
<codeline lineno="7815"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>alloc<sp/>=<sp/>(<ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>)suballoc.userData;</highlight></codeline>
<codeline lineno="7816"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(!IsVirtual())</highlight></codeline>
<codeline lineno="7817"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7818"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(currFree<sp/>==<sp/>(alloc<sp/>==<sp/>VK_NULL_HANDLE));</highlight></codeline>
<codeline lineno="7819"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7820"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(suballoc.offset<sp/>&gt;=<sp/>offset);</highlight></codeline>
<codeline lineno="7821"><highlight class="normal"></highlight></codeline>
<codeline lineno="7822"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!currFree)</highlight></codeline>
<codeline lineno="7823"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7824"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!IsVirtual())</highlight></codeline>
<codeline lineno="7825"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7826"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE((VkDeviceSize)alloc-&gt;GetAllocHandle()<sp/>==<sp/>suballoc.offset<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="7827"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(alloc-&gt;GetSize()<sp/>==<sp/>suballoc.size);</highlight></codeline>
<codeline lineno="7828"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7829"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sumUsedSize<sp/>+=<sp/>suballoc.size;</highlight></codeline>
<codeline lineno="7830"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7831"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7832"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7833"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++nullItem2ndCount;</highlight></codeline>
<codeline lineno="7834"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7835"><highlight class="normal"></highlight></codeline>
<codeline lineno="7836"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset<sp/>=<sp/>suballoc.offset<sp/>+<sp/>suballoc.size<sp/>+<sp/>debugMargin;</highlight></codeline>
<codeline lineno="7837"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7838"><highlight class="normal"></highlight></codeline>
<codeline lineno="7839"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(nullItem2ndCount<sp/>==<sp/>m_2ndNullItemsCount);</highlight></codeline>
<codeline lineno="7840"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7841"><highlight class="normal"></highlight></codeline>
<codeline lineno="7842"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE(offset<sp/>&lt;=<sp/>GetSize());</highlight></codeline>
<codeline lineno="7843"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE(m_SumFreeSize<sp/>==<sp/>GetSize()<sp/>-<sp/>sumUsedSize);</highlight></codeline>
<codeline lineno="7844"><highlight class="normal"></highlight></codeline>
<codeline lineno="7845"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="7846"><highlight class="normal">}</highlight></codeline>
<codeline lineno="7847"><highlight class="normal"></highlight></codeline>
<codeline lineno="7848"><highlight class="normal"></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Linear::GetAllocationCount()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="7849"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="7850"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>AccessSuballocations1st().size()<sp/>-<sp/>m_1stNullItemsBeginCount<sp/>-<sp/>m_1stNullItemsMiddleCount<sp/>+</highlight></codeline>
<codeline lineno="7851"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AccessSuballocations2nd().size()<sp/>-<sp/>m_2ndNullItemsCount;</highlight></codeline>
<codeline lineno="7852"><highlight class="normal">}</highlight></codeline>
<codeline lineno="7853"><highlight class="normal"></highlight></codeline>
<codeline lineno="7854"><highlight class="normal"></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Linear::GetFreeRegionsCount()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="7855"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="7856"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Function<sp/>only<sp/>used<sp/>for<sp/>defragmentation,<sp/>which<sp/>is<sp/>disabled<sp/>for<sp/>this<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7857"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="7858"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>SIZE_MAX;</highlight></codeline>
<codeline lineno="7859"><highlight class="normal">}</highlight></codeline>
<codeline lineno="7860"><highlight class="normal"></highlight></codeline>
<codeline lineno="7861"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Linear::AddDetailedStatistics(<ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>&amp;<sp/>inoutStats)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="7862"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="7863"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>size<sp/>=<sp/>GetSize();</highlight></codeline>
<codeline lineno="7864"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SuballocationVectorType&amp;<sp/>suballocations1st<sp/>=<sp/>AccessSuballocations1st();</highlight></codeline>
<codeline lineno="7865"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SuballocationVectorType&amp;<sp/>suballocations2nd<sp/>=<sp/>AccessSuballocations2nd();</highlight></codeline>
<codeline lineno="7866"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>suballoc1stCount<sp/>=<sp/>suballocations1st.size();</highlight></codeline>
<codeline lineno="7867"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>suballoc2ndCount<sp/>=<sp/>suballocations2nd.size();</highlight></codeline>
<codeline lineno="7868"><highlight class="normal"></highlight></codeline>
<codeline lineno="7869"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1a309179d5853a6a7cd534df497ee43957" kindref="member">blockCount</ref>++;</highlight></codeline>
<codeline lineno="7870"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1a2afbc1c7aa8ad7bbb8de06215ba7e5c4" kindref="member">blockBytes</ref><sp/>+=<sp/>size;</highlight></codeline>
<codeline lineno="7871"><highlight class="normal"></highlight></codeline>
<codeline lineno="7872"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>lastOffset<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="7873"><highlight class="normal"></highlight></codeline>
<codeline lineno="7874"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_RING_BUFFER)</highlight></codeline>
<codeline lineno="7875"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7876"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>freeSpace2ndTo1stEnd<sp/>=<sp/>suballocations1st[m_1stNullItemsBeginCount].offset;</highlight></codeline>
<codeline lineno="7877"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>nextAlloc2ndIndex<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="7878"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>freeSpace2ndTo1stEnd)</highlight></codeline>
<codeline lineno="7879"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7880"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>next<sp/>non-null<sp/>allocation<sp/>or<sp/>move<sp/>nextAllocIndex<sp/>to<sp/>the<sp/>end.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7881"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(nextAlloc2ndIndex<sp/>&lt;<sp/>suballoc2ndCount<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="7882"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations2nd[nextAlloc2ndIndex].userData<sp/>==<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="7883"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7884"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++nextAlloc2ndIndex;</highlight></codeline>
<codeline lineno="7885"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7886"><highlight class="normal"></highlight></codeline>
<codeline lineno="7887"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Found<sp/>non-null<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7888"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nextAlloc2ndIndex<sp/>&lt;<sp/>suballoc2ndCount)</highlight></codeline>
<codeline lineno="7889"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7890"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>suballoc<sp/>=<sp/>suballocations2nd[nextAlloc2ndIndex];</highlight></codeline>
<codeline lineno="7891"><highlight class="normal"></highlight></codeline>
<codeline lineno="7892"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>1.<sp/>Process<sp/>free<sp/>space<sp/>before<sp/>this<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7893"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>suballoc.offset)</highlight></codeline>
<codeline lineno="7894"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7895"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>free<sp/>space<sp/>from<sp/>lastOffset<sp/>to<sp/>suballoc.offset.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7896"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>unusedRangeSize<sp/>=<sp/>suballoc.offset<sp/>-<sp/>lastOffset;</highlight></codeline>
<codeline lineno="7897"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAddDetailedStatisticsUnusedRange(inoutStats,<sp/>unusedRangeSize);</highlight></codeline>
<codeline lineno="7898"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7899"><highlight class="normal"></highlight></codeline>
<codeline lineno="7900"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>2.<sp/>Process<sp/>this<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7901"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>allocation<sp/>with<sp/>suballoc.offset,<sp/>suballoc.size.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7902"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAddDetailedStatisticsAllocation(inoutStats,<sp/>suballoc.size);</highlight></codeline>
<codeline lineno="7903"><highlight class="normal"></highlight></codeline>
<codeline lineno="7904"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>3.<sp/>Prepare<sp/>for<sp/>next<sp/>iteration.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7905"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lastOffset<sp/>=<sp/>suballoc.offset<sp/>+<sp/>suballoc.size;</highlight></codeline>
<codeline lineno="7906"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++nextAlloc2ndIndex;</highlight></codeline>
<codeline lineno="7907"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7908"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>are<sp/>at<sp/>the<sp/>end.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7909"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7910"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7911"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>free<sp/>space<sp/>from<sp/>lastOffset<sp/>to<sp/>freeSpace2ndTo1stEnd.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7912"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>freeSpace2ndTo1stEnd)</highlight></codeline>
<codeline lineno="7913"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7914"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>unusedRangeSize<sp/>=<sp/>freeSpace2ndTo1stEnd<sp/>-<sp/>lastOffset;</highlight></codeline>
<codeline lineno="7915"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAddDetailedStatisticsUnusedRange(inoutStats,<sp/>unusedRangeSize);</highlight></codeline>
<codeline lineno="7916"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7917"><highlight class="normal"></highlight></codeline>
<codeline lineno="7918"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>End<sp/>of<sp/>loop.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7919"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lastOffset<sp/>=<sp/>freeSpace2ndTo1stEnd;</highlight></codeline>
<codeline lineno="7920"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7921"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7922"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7923"><highlight class="normal"></highlight></codeline>
<codeline lineno="7924"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>nextAlloc1stIndex<sp/>=<sp/>m_1stNullItemsBeginCount;</highlight></codeline>
<codeline lineno="7925"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>freeSpace1stTo2ndEnd<sp/>=</highlight></codeline>
<codeline lineno="7926"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_DOUBLE_STACK<sp/>?<sp/>suballocations2nd.back().offset<sp/>:<sp/>size;</highlight></codeline>
<codeline lineno="7927"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>freeSpace1stTo2ndEnd)</highlight></codeline>
<codeline lineno="7928"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7929"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>next<sp/>non-null<sp/>allocation<sp/>or<sp/>move<sp/>nextAllocIndex<sp/>to<sp/>the<sp/>end.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7930"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(nextAlloc1stIndex<sp/>&lt;<sp/>suballoc1stCount<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="7931"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations1st[nextAlloc1stIndex].userData<sp/>==<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="7932"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7933"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++nextAlloc1stIndex;</highlight></codeline>
<codeline lineno="7934"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7935"><highlight class="normal"></highlight></codeline>
<codeline lineno="7936"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Found<sp/>non-null<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7937"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nextAlloc1stIndex<sp/>&lt;<sp/>suballoc1stCount)</highlight></codeline>
<codeline lineno="7938"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7939"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>suballoc<sp/>=<sp/>suballocations1st[nextAlloc1stIndex];</highlight></codeline>
<codeline lineno="7940"><highlight class="normal"></highlight></codeline>
<codeline lineno="7941"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>1.<sp/>Process<sp/>free<sp/>space<sp/>before<sp/>this<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7942"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>suballoc.offset)</highlight></codeline>
<codeline lineno="7943"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7944"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>free<sp/>space<sp/>from<sp/>lastOffset<sp/>to<sp/>suballoc.offset.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7945"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>unusedRangeSize<sp/>=<sp/>suballoc.offset<sp/>-<sp/>lastOffset;</highlight></codeline>
<codeline lineno="7946"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAddDetailedStatisticsUnusedRange(inoutStats,<sp/>unusedRangeSize);</highlight></codeline>
<codeline lineno="7947"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7948"><highlight class="normal"></highlight></codeline>
<codeline lineno="7949"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>2.<sp/>Process<sp/>this<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7950"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>allocation<sp/>with<sp/>suballoc.offset,<sp/>suballoc.size.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7951"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAddDetailedStatisticsAllocation(inoutStats,<sp/>suballoc.size);</highlight></codeline>
<codeline lineno="7952"><highlight class="normal"></highlight></codeline>
<codeline lineno="7953"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>3.<sp/>Prepare<sp/>for<sp/>next<sp/>iteration.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7954"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lastOffset<sp/>=<sp/>suballoc.offset<sp/>+<sp/>suballoc.size;</highlight></codeline>
<codeline lineno="7955"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++nextAlloc1stIndex;</highlight></codeline>
<codeline lineno="7956"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7957"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>are<sp/>at<sp/>the<sp/>end.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7958"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7959"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7960"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>free<sp/>space<sp/>from<sp/>lastOffset<sp/>to<sp/>freeSpace1stTo2ndEnd.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7961"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>freeSpace1stTo2ndEnd)</highlight></codeline>
<codeline lineno="7962"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7963"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>unusedRangeSize<sp/>=<sp/>freeSpace1stTo2ndEnd<sp/>-<sp/>lastOffset;</highlight></codeline>
<codeline lineno="7964"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAddDetailedStatisticsUnusedRange(inoutStats,<sp/>unusedRangeSize);</highlight></codeline>
<codeline lineno="7965"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7966"><highlight class="normal"></highlight></codeline>
<codeline lineno="7967"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>End<sp/>of<sp/>loop.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7968"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lastOffset<sp/>=<sp/>freeSpace1stTo2ndEnd;</highlight></codeline>
<codeline lineno="7969"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7970"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7971"><highlight class="normal"></highlight></codeline>
<codeline lineno="7972"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_DOUBLE_STACK)</highlight></codeline>
<codeline lineno="7973"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7974"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>nextAlloc2ndIndex<sp/>=<sp/>suballocations2nd.size()<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="7975"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>size)</highlight></codeline>
<codeline lineno="7976"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7977"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>next<sp/>non-null<sp/>allocation<sp/>or<sp/>move<sp/>nextAllocIndex<sp/>to<sp/>the<sp/>end.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7978"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(nextAlloc2ndIndex<sp/>!=<sp/>SIZE_MAX<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="7979"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations2nd[nextAlloc2ndIndex].userData<sp/>==<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="7980"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7981"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--nextAlloc2ndIndex;</highlight></codeline>
<codeline lineno="7982"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7983"><highlight class="normal"></highlight></codeline>
<codeline lineno="7984"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Found<sp/>non-null<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7985"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nextAlloc2ndIndex<sp/>!=<sp/>SIZE_MAX)</highlight></codeline>
<codeline lineno="7986"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7987"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>suballoc<sp/>=<sp/>suballocations2nd[nextAlloc2ndIndex];</highlight></codeline>
<codeline lineno="7988"><highlight class="normal"></highlight></codeline>
<codeline lineno="7989"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>1.<sp/>Process<sp/>free<sp/>space<sp/>before<sp/>this<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7990"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>suballoc.offset)</highlight></codeline>
<codeline lineno="7991"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="7992"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>free<sp/>space<sp/>from<sp/>lastOffset<sp/>to<sp/>suballoc.offset.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7993"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>unusedRangeSize<sp/>=<sp/>suballoc.offset<sp/>-<sp/>lastOffset;</highlight></codeline>
<codeline lineno="7994"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAddDetailedStatisticsUnusedRange(inoutStats,<sp/>unusedRangeSize);</highlight></codeline>
<codeline lineno="7995"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="7996"><highlight class="normal"></highlight></codeline>
<codeline lineno="7997"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>2.<sp/>Process<sp/>this<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7998"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>allocation<sp/>with<sp/>suballoc.offset,<sp/>suballoc.size.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7999"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAddDetailedStatisticsAllocation(inoutStats,<sp/>suballoc.size);</highlight></codeline>
<codeline lineno="8000"><highlight class="normal"></highlight></codeline>
<codeline lineno="8001"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>3.<sp/>Prepare<sp/>for<sp/>next<sp/>iteration.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8002"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lastOffset<sp/>=<sp/>suballoc.offset<sp/>+<sp/>suballoc.size;</highlight></codeline>
<codeline lineno="8003"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--nextAlloc2ndIndex;</highlight></codeline>
<codeline lineno="8004"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8005"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>are<sp/>at<sp/>the<sp/>end.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8006"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8007"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8008"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>free<sp/>space<sp/>from<sp/>lastOffset<sp/>to<sp/>size.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8009"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>size)</highlight></codeline>
<codeline lineno="8010"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8011"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>unusedRangeSize<sp/>=<sp/>size<sp/>-<sp/>lastOffset;</highlight></codeline>
<codeline lineno="8012"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAddDetailedStatisticsUnusedRange(inoutStats,<sp/>unusedRangeSize);</highlight></codeline>
<codeline lineno="8013"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8014"><highlight class="normal"></highlight></codeline>
<codeline lineno="8015"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>End<sp/>of<sp/>loop.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8016"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lastOffset<sp/>=<sp/>size;</highlight></codeline>
<codeline lineno="8017"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8018"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8019"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8020"><highlight class="normal">}</highlight></codeline>
<codeline lineno="8021"><highlight class="normal"></highlight></codeline>
<codeline lineno="8022"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Linear::AddStatistics(<ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref>&amp;<sp/>inoutStats)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="8023"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="8024"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SuballocationVectorType&amp;<sp/>suballocations1st<sp/>=<sp/>AccessSuballocations1st();</highlight></codeline>
<codeline lineno="8025"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SuballocationVectorType&amp;<sp/>suballocations2nd<sp/>=<sp/>AccessSuballocations2nd();</highlight></codeline>
<codeline lineno="8026"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>size<sp/>=<sp/>GetSize();</highlight></codeline>
<codeline lineno="8027"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>suballoc1stCount<sp/>=<sp/>suballocations1st.size();</highlight></codeline>
<codeline lineno="8028"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>suballoc2ndCount<sp/>=<sp/>suballocations2nd.size();</highlight></codeline>
<codeline lineno="8029"><highlight class="normal"></highlight></codeline>
<codeline lineno="8030"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_statistics_1a309179d5853a6a7cd534df497ee43957" kindref="member">blockCount</ref>++;</highlight></codeline>
<codeline lineno="8031"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_statistics_1a2afbc1c7aa8ad7bbb8de06215ba7e5c4" kindref="member">blockBytes</ref><sp/>+=<sp/>size;</highlight></codeline>
<codeline lineno="8032"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_statistics_1a21db06eba3422f87a2b4b4703d879c16" kindref="member">allocationBytes</ref><sp/>+=<sp/>size<sp/>-<sp/>m_SumFreeSize;</highlight></codeline>
<codeline lineno="8033"><highlight class="normal"></highlight></codeline>
<codeline lineno="8034"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>lastOffset<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="8035"><highlight class="normal"></highlight></codeline>
<codeline lineno="8036"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_RING_BUFFER)</highlight></codeline>
<codeline lineno="8037"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8038"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>freeSpace2ndTo1stEnd<sp/>=<sp/>suballocations1st[m_1stNullItemsBeginCount].offset;</highlight></codeline>
<codeline lineno="8039"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>nextAlloc2ndIndex<sp/>=<sp/>m_1stNullItemsBeginCount;</highlight></codeline>
<codeline lineno="8040"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>freeSpace2ndTo1stEnd)</highlight></codeline>
<codeline lineno="8041"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8042"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>next<sp/>non-null<sp/>allocation<sp/>or<sp/>move<sp/>nextAlloc2ndIndex<sp/>to<sp/>the<sp/>end.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8043"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(nextAlloc2ndIndex<sp/>&lt;<sp/>suballoc2ndCount<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="8044"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations2nd[nextAlloc2ndIndex].userData<sp/>==<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="8045"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8046"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++nextAlloc2ndIndex;</highlight></codeline>
<codeline lineno="8047"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8048"><highlight class="normal"></highlight></codeline>
<codeline lineno="8049"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Found<sp/>non-null<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8050"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nextAlloc2ndIndex<sp/>&lt;<sp/>suballoc2ndCount)</highlight></codeline>
<codeline lineno="8051"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8052"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>suballoc<sp/>=<sp/>suballocations2nd[nextAlloc2ndIndex];</highlight></codeline>
<codeline lineno="8053"><highlight class="normal"></highlight></codeline>
<codeline lineno="8054"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>1.<sp/>Process<sp/>free<sp/>space<sp/>before<sp/>this<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8055"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>suballoc.offset)</highlight></codeline>
<codeline lineno="8056"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8057"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>free<sp/>space<sp/>from<sp/>lastOffset<sp/>to<sp/>suballoc.offset.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8058"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>unusedRangeSize<sp/>=<sp/>suballoc.offset<sp/>-<sp/>lastOffset;</highlight></codeline>
<codeline lineno="8059"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8060"><highlight class="normal"></highlight></codeline>
<codeline lineno="8061"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>2.<sp/>Process<sp/>this<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8062"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>allocation<sp/>with<sp/>suballoc.offset,<sp/>suballoc.size.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8063"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++inoutStats.<ref refid="struct_vma_statistics_1ab0ff76e50f58f9f54b6f265e5bf5dde2" kindref="member">allocationCount</ref>;</highlight></codeline>
<codeline lineno="8064"><highlight class="normal"></highlight></codeline>
<codeline lineno="8065"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>3.<sp/>Prepare<sp/>for<sp/>next<sp/>iteration.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8066"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lastOffset<sp/>=<sp/>suballoc.offset<sp/>+<sp/>suballoc.size;</highlight></codeline>
<codeline lineno="8067"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++nextAlloc2ndIndex;</highlight></codeline>
<codeline lineno="8068"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8069"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>are<sp/>at<sp/>the<sp/>end.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8070"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8071"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8072"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>freeSpace2ndTo1stEnd)</highlight></codeline>
<codeline lineno="8073"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8074"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>free<sp/>space<sp/>from<sp/>lastOffset<sp/>to<sp/>freeSpace2ndTo1stEnd.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8075"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>unusedRangeSize<sp/>=<sp/>freeSpace2ndTo1stEnd<sp/>-<sp/>lastOffset;</highlight></codeline>
<codeline lineno="8076"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8077"><highlight class="normal"></highlight></codeline>
<codeline lineno="8078"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>End<sp/>of<sp/>loop.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8079"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lastOffset<sp/>=<sp/>freeSpace2ndTo1stEnd;</highlight></codeline>
<codeline lineno="8080"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8081"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8082"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8083"><highlight class="normal"></highlight></codeline>
<codeline lineno="8084"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>nextAlloc1stIndex<sp/>=<sp/>m_1stNullItemsBeginCount;</highlight></codeline>
<codeline lineno="8085"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>freeSpace1stTo2ndEnd<sp/>=</highlight></codeline>
<codeline lineno="8086"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_DOUBLE_STACK<sp/>?<sp/>suballocations2nd.back().offset<sp/>:<sp/>size;</highlight></codeline>
<codeline lineno="8087"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>freeSpace1stTo2ndEnd)</highlight></codeline>
<codeline lineno="8088"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8089"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>next<sp/>non-null<sp/>allocation<sp/>or<sp/>move<sp/>nextAllocIndex<sp/>to<sp/>the<sp/>end.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8090"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(nextAlloc1stIndex<sp/>&lt;<sp/>suballoc1stCount<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="8091"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations1st[nextAlloc1stIndex].userData<sp/>==<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="8092"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8093"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++nextAlloc1stIndex;</highlight></codeline>
<codeline lineno="8094"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8095"><highlight class="normal"></highlight></codeline>
<codeline lineno="8096"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Found<sp/>non-null<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8097"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nextAlloc1stIndex<sp/>&lt;<sp/>suballoc1stCount)</highlight></codeline>
<codeline lineno="8098"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8099"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>suballoc<sp/>=<sp/>suballocations1st[nextAlloc1stIndex];</highlight></codeline>
<codeline lineno="8100"><highlight class="normal"></highlight></codeline>
<codeline lineno="8101"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>1.<sp/>Process<sp/>free<sp/>space<sp/>before<sp/>this<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8102"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>suballoc.offset)</highlight></codeline>
<codeline lineno="8103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>free<sp/>space<sp/>from<sp/>lastOffset<sp/>to<sp/>suballoc.offset.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8105"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>unusedRangeSize<sp/>=<sp/>suballoc.offset<sp/>-<sp/>lastOffset;</highlight></codeline>
<codeline lineno="8106"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8107"><highlight class="normal"></highlight></codeline>
<codeline lineno="8108"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>2.<sp/>Process<sp/>this<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8109"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>allocation<sp/>with<sp/>suballoc.offset,<sp/>suballoc.size.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8110"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++inoutStats.<ref refid="struct_vma_statistics_1ab0ff76e50f58f9f54b6f265e5bf5dde2" kindref="member">allocationCount</ref>;</highlight></codeline>
<codeline lineno="8111"><highlight class="normal"></highlight></codeline>
<codeline lineno="8112"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>3.<sp/>Prepare<sp/>for<sp/>next<sp/>iteration.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lastOffset<sp/>=<sp/>suballoc.offset<sp/>+<sp/>suballoc.size;</highlight></codeline>
<codeline lineno="8114"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++nextAlloc1stIndex;</highlight></codeline>
<codeline lineno="8115"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>are<sp/>at<sp/>the<sp/>end.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8118"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8119"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>freeSpace1stTo2ndEnd)</highlight></codeline>
<codeline lineno="8120"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>free<sp/>space<sp/>from<sp/>lastOffset<sp/>to<sp/>freeSpace1stTo2ndEnd.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>unusedRangeSize<sp/>=<sp/>freeSpace1stTo2ndEnd<sp/>-<sp/>lastOffset;</highlight></codeline>
<codeline lineno="8123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8124"><highlight class="normal"></highlight></codeline>
<codeline lineno="8125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>End<sp/>of<sp/>loop.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lastOffset<sp/>=<sp/>freeSpace1stTo2ndEnd;</highlight></codeline>
<codeline lineno="8127"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8128"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8129"><highlight class="normal"></highlight></codeline>
<codeline lineno="8130"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_DOUBLE_STACK)</highlight></codeline>
<codeline lineno="8131"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8132"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>nextAlloc2ndIndex<sp/>=<sp/>suballocations2nd.size()<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="8133"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>size)</highlight></codeline>
<codeline lineno="8134"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8135"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>next<sp/>non-null<sp/>allocation<sp/>or<sp/>move<sp/>nextAlloc2ndIndex<sp/>to<sp/>the<sp/>end.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8136"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(nextAlloc2ndIndex<sp/>!=<sp/>SIZE_MAX<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="8137"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations2nd[nextAlloc2ndIndex].userData<sp/>==<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="8138"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8139"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--nextAlloc2ndIndex;</highlight></codeline>
<codeline lineno="8140"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8141"><highlight class="normal"></highlight></codeline>
<codeline lineno="8142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Found<sp/>non-null<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8143"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nextAlloc2ndIndex<sp/>!=<sp/>SIZE_MAX)</highlight></codeline>
<codeline lineno="8144"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>suballoc<sp/>=<sp/>suballocations2nd[nextAlloc2ndIndex];</highlight></codeline>
<codeline lineno="8146"><highlight class="normal"></highlight></codeline>
<codeline lineno="8147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>1.<sp/>Process<sp/>free<sp/>space<sp/>before<sp/>this<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>suballoc.offset)</highlight></codeline>
<codeline lineno="8149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8150"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>free<sp/>space<sp/>from<sp/>lastOffset<sp/>to<sp/>suballoc.offset.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>unusedRangeSize<sp/>=<sp/>suballoc.offset<sp/>-<sp/>lastOffset;</highlight></codeline>
<codeline lineno="8152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8153"><highlight class="normal"></highlight></codeline>
<codeline lineno="8154"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>2.<sp/>Process<sp/>this<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>allocation<sp/>with<sp/>suballoc.offset,<sp/>suballoc.size.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8156"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++inoutStats.<ref refid="struct_vma_statistics_1ab0ff76e50f58f9f54b6f265e5bf5dde2" kindref="member">allocationCount</ref>;</highlight></codeline>
<codeline lineno="8157"><highlight class="normal"></highlight></codeline>
<codeline lineno="8158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>3.<sp/>Prepare<sp/>for<sp/>next<sp/>iteration.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8159"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lastOffset<sp/>=<sp/>suballoc.offset<sp/>+<sp/>suballoc.size;</highlight></codeline>
<codeline lineno="8160"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--nextAlloc2ndIndex;</highlight></codeline>
<codeline lineno="8161"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8162"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>are<sp/>at<sp/>the<sp/>end.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8163"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8164"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8165"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>size)</highlight></codeline>
<codeline lineno="8166"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>free<sp/>space<sp/>from<sp/>lastOffset<sp/>to<sp/>size.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8168"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>unusedRangeSize<sp/>=<sp/>size<sp/>-<sp/>lastOffset;</highlight></codeline>
<codeline lineno="8169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8170"><highlight class="normal"></highlight></codeline>
<codeline lineno="8171"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>End<sp/>of<sp/>loop.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8172"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lastOffset<sp/>=<sp/>size;</highlight></codeline>
<codeline lineno="8173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8174"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8175"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8176"><highlight class="normal">}</highlight></codeline>
<codeline lineno="8177"><highlight class="normal"></highlight></codeline>
<codeline lineno="8178"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8179"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Linear::PrintDetailedMap(</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>VmaJsonWriter&amp;<sp/>json)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="8180"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="8181"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>size<sp/>=<sp/>GetSize();</highlight></codeline>
<codeline lineno="8182"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SuballocationVectorType&amp;<sp/>suballocations1st<sp/>=<sp/>AccessSuballocations1st();</highlight></codeline>
<codeline lineno="8183"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SuballocationVectorType&amp;<sp/>suballocations2nd<sp/>=<sp/>AccessSuballocations2nd();</highlight></codeline>
<codeline lineno="8184"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>suballoc1stCount<sp/>=<sp/>suballocations1st.size();</highlight></codeline>
<codeline lineno="8185"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>suballoc2ndCount<sp/>=<sp/>suballocations2nd.size();</highlight></codeline>
<codeline lineno="8186"><highlight class="normal"></highlight></codeline>
<codeline lineno="8187"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>FIRST<sp/>PASS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8188"><highlight class="normal"></highlight></codeline>
<codeline lineno="8189"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>unusedRangeCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="8190"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>usedBytes<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="8191"><highlight class="normal"></highlight></codeline>
<codeline lineno="8192"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>lastOffset<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="8193"><highlight class="normal"></highlight></codeline>
<codeline lineno="8194"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>alloc2ndCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="8195"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_RING_BUFFER)</highlight></codeline>
<codeline lineno="8196"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>freeSpace2ndTo1stEnd<sp/>=<sp/>suballocations1st[m_1stNullItemsBeginCount].offset;</highlight></codeline>
<codeline lineno="8198"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>nextAlloc2ndIndex<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="8199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>freeSpace2ndTo1stEnd)</highlight></codeline>
<codeline lineno="8200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>next<sp/>non-null<sp/>allocation<sp/>or<sp/>move<sp/>nextAlloc2ndIndex<sp/>to<sp/>the<sp/>end.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(nextAlloc2ndIndex<sp/>&lt;<sp/>suballoc2ndCount<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="8203"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations2nd[nextAlloc2ndIndex].userData<sp/>==<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="8204"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8205"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++nextAlloc2ndIndex;</highlight></codeline>
<codeline lineno="8206"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8207"><highlight class="normal"></highlight></codeline>
<codeline lineno="8208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Found<sp/>non-null<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8209"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nextAlloc2ndIndex<sp/>&lt;<sp/>suballoc2ndCount)</highlight></codeline>
<codeline lineno="8210"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8211"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>suballoc<sp/>=<sp/>suballocations2nd[nextAlloc2ndIndex];</highlight></codeline>
<codeline lineno="8212"><highlight class="normal"></highlight></codeline>
<codeline lineno="8213"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>1.<sp/>Process<sp/>free<sp/>space<sp/>before<sp/>this<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8214"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>suballoc.offset)</highlight></codeline>
<codeline lineno="8215"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8216"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>free<sp/>space<sp/>from<sp/>lastOffset<sp/>to<sp/>suballoc.offset.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8217"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++unusedRangeCount;</highlight></codeline>
<codeline lineno="8218"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8219"><highlight class="normal"></highlight></codeline>
<codeline lineno="8220"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>2.<sp/>Process<sp/>this<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8221"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>allocation<sp/>with<sp/>suballoc.offset,<sp/>suballoc.size.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8222"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++alloc2ndCount;</highlight></codeline>
<codeline lineno="8223"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>usedBytes<sp/>+=<sp/>suballoc.size;</highlight></codeline>
<codeline lineno="8224"><highlight class="normal"></highlight></codeline>
<codeline lineno="8225"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>3.<sp/>Prepare<sp/>for<sp/>next<sp/>iteration.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8226"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lastOffset<sp/>=<sp/>suballoc.offset<sp/>+<sp/>suballoc.size;</highlight></codeline>
<codeline lineno="8227"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++nextAlloc2ndIndex;</highlight></codeline>
<codeline lineno="8228"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8229"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>are<sp/>at<sp/>the<sp/>end.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8230"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8231"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8232"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>freeSpace2ndTo1stEnd)</highlight></codeline>
<codeline lineno="8233"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8234"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>free<sp/>space<sp/>from<sp/>lastOffset<sp/>to<sp/>freeSpace2ndTo1stEnd.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8235"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++unusedRangeCount;</highlight></codeline>
<codeline lineno="8236"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8237"><highlight class="normal"></highlight></codeline>
<codeline lineno="8238"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>End<sp/>of<sp/>loop.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8239"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lastOffset<sp/>=<sp/>freeSpace2ndTo1stEnd;</highlight></codeline>
<codeline lineno="8240"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8241"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8242"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8243"><highlight class="normal"></highlight></codeline>
<codeline lineno="8244"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>nextAlloc1stIndex<sp/>=<sp/>m_1stNullItemsBeginCount;</highlight></codeline>
<codeline lineno="8245"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>alloc1stCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="8246"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>freeSpace1stTo2ndEnd<sp/>=</highlight></codeline>
<codeline lineno="8247"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_DOUBLE_STACK<sp/>?<sp/>suballocations2nd.back().offset<sp/>:<sp/>size;</highlight></codeline>
<codeline lineno="8248"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>freeSpace1stTo2ndEnd)</highlight></codeline>
<codeline lineno="8249"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8250"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>next<sp/>non-null<sp/>allocation<sp/>or<sp/>move<sp/>nextAllocIndex<sp/>to<sp/>the<sp/>end.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8251"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(nextAlloc1stIndex<sp/>&lt;<sp/>suballoc1stCount<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="8252"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations1st[nextAlloc1stIndex].userData<sp/>==<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="8253"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8254"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++nextAlloc1stIndex;</highlight></codeline>
<codeline lineno="8255"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8256"><highlight class="normal"></highlight></codeline>
<codeline lineno="8257"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Found<sp/>non-null<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8258"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nextAlloc1stIndex<sp/>&lt;<sp/>suballoc1stCount)</highlight></codeline>
<codeline lineno="8259"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>suballoc<sp/>=<sp/>suballocations1st[nextAlloc1stIndex];</highlight></codeline>
<codeline lineno="8261"><highlight class="normal"></highlight></codeline>
<codeline lineno="8262"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>1.<sp/>Process<sp/>free<sp/>space<sp/>before<sp/>this<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>suballoc.offset)</highlight></codeline>
<codeline lineno="8264"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8265"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>free<sp/>space<sp/>from<sp/>lastOffset<sp/>to<sp/>suballoc.offset.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8266"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++unusedRangeCount;</highlight></codeline>
<codeline lineno="8267"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8268"><highlight class="normal"></highlight></codeline>
<codeline lineno="8269"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>2.<sp/>Process<sp/>this<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8270"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>allocation<sp/>with<sp/>suballoc.offset,<sp/>suballoc.size.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8271"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++alloc1stCount;</highlight></codeline>
<codeline lineno="8272"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>usedBytes<sp/>+=<sp/>suballoc.size;</highlight></codeline>
<codeline lineno="8273"><highlight class="normal"></highlight></codeline>
<codeline lineno="8274"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>3.<sp/>Prepare<sp/>for<sp/>next<sp/>iteration.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8275"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lastOffset<sp/>=<sp/>suballoc.offset<sp/>+<sp/>suballoc.size;</highlight></codeline>
<codeline lineno="8276"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++nextAlloc1stIndex;</highlight></codeline>
<codeline lineno="8277"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8278"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>are<sp/>at<sp/>the<sp/>end.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8279"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8280"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8281"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>size)</highlight></codeline>
<codeline lineno="8282"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8283"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>free<sp/>space<sp/>from<sp/>lastOffset<sp/>to<sp/>freeSpace1stTo2ndEnd.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8284"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++unusedRangeCount;</highlight></codeline>
<codeline lineno="8285"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8286"><highlight class="normal"></highlight></codeline>
<codeline lineno="8287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>End<sp/>of<sp/>loop.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8288"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lastOffset<sp/>=<sp/>freeSpace1stTo2ndEnd;</highlight></codeline>
<codeline lineno="8289"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8290"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8291"><highlight class="normal"></highlight></codeline>
<codeline lineno="8292"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_DOUBLE_STACK)</highlight></codeline>
<codeline lineno="8293"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8294"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>nextAlloc2ndIndex<sp/>=<sp/>suballocations2nd.size()<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="8295"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>size)</highlight></codeline>
<codeline lineno="8296"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8297"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>next<sp/>non-null<sp/>allocation<sp/>or<sp/>move<sp/>nextAlloc2ndIndex<sp/>to<sp/>the<sp/>end.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8298"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(nextAlloc2ndIndex<sp/>!=<sp/>SIZE_MAX<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="8299"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations2nd[nextAlloc2ndIndex].userData<sp/>==<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="8300"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8301"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--nextAlloc2ndIndex;</highlight></codeline>
<codeline lineno="8302"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8303"><highlight class="normal"></highlight></codeline>
<codeline lineno="8304"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Found<sp/>non-null<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8305"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nextAlloc2ndIndex<sp/>!=<sp/>SIZE_MAX)</highlight></codeline>
<codeline lineno="8306"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8307"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>suballoc<sp/>=<sp/>suballocations2nd[nextAlloc2ndIndex];</highlight></codeline>
<codeline lineno="8308"><highlight class="normal"></highlight></codeline>
<codeline lineno="8309"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>1.<sp/>Process<sp/>free<sp/>space<sp/>before<sp/>this<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8310"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>suballoc.offset)</highlight></codeline>
<codeline lineno="8311"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>free<sp/>space<sp/>from<sp/>lastOffset<sp/>to<sp/>suballoc.offset.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8313"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++unusedRangeCount;</highlight></codeline>
<codeline lineno="8314"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8315"><highlight class="normal"></highlight></codeline>
<codeline lineno="8316"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>2.<sp/>Process<sp/>this<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8317"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>allocation<sp/>with<sp/>suballoc.offset,<sp/>suballoc.size.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8318"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++alloc2ndCount;</highlight></codeline>
<codeline lineno="8319"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>usedBytes<sp/>+=<sp/>suballoc.size;</highlight></codeline>
<codeline lineno="8320"><highlight class="normal"></highlight></codeline>
<codeline lineno="8321"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>3.<sp/>Prepare<sp/>for<sp/>next<sp/>iteration.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8322"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lastOffset<sp/>=<sp/>suballoc.offset<sp/>+<sp/>suballoc.size;</highlight></codeline>
<codeline lineno="8323"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--nextAlloc2ndIndex;</highlight></codeline>
<codeline lineno="8324"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8325"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>are<sp/>at<sp/>the<sp/>end.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8328"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>size)</highlight></codeline>
<codeline lineno="8329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8330"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>free<sp/>space<sp/>from<sp/>lastOffset<sp/>to<sp/>size.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++unusedRangeCount;</highlight></codeline>
<codeline lineno="8332"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8333"><highlight class="normal"></highlight></codeline>
<codeline lineno="8334"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>End<sp/>of<sp/>loop.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8335"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lastOffset<sp/>=<sp/>size;</highlight></codeline>
<codeline lineno="8336"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8337"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8338"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8339"><highlight class="normal"></highlight></codeline>
<codeline lineno="8340"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>unusedBytes<sp/>=<sp/>size<sp/>-<sp/>usedBytes;</highlight></codeline>
<codeline lineno="8341"><highlight class="normal"><sp/><sp/><sp/><sp/>PrintDetailedMap_Begin(json,<sp/>unusedBytes,<sp/>alloc1stCount<sp/>+<sp/>alloc2ndCount,<sp/>unusedRangeCount);</highlight></codeline>
<codeline lineno="8342"><highlight class="normal"></highlight></codeline>
<codeline lineno="8343"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>SECOND<sp/>PASS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8344"><highlight class="normal"><sp/><sp/><sp/><sp/>lastOffset<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="8345"><highlight class="normal"></highlight></codeline>
<codeline lineno="8346"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_RING_BUFFER)</highlight></codeline>
<codeline lineno="8347"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8348"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>freeSpace2ndTo1stEnd<sp/>=<sp/>suballocations1st[m_1stNullItemsBeginCount].offset;</highlight></codeline>
<codeline lineno="8349"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>nextAlloc2ndIndex<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="8350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>freeSpace2ndTo1stEnd)</highlight></codeline>
<codeline lineno="8351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8352"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>next<sp/>non-null<sp/>allocation<sp/>or<sp/>move<sp/>nextAlloc2ndIndex<sp/>to<sp/>the<sp/>end.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8353"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(nextAlloc2ndIndex<sp/>&lt;<sp/>suballoc2ndCount<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="8354"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations2nd[nextAlloc2ndIndex].userData<sp/>==<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="8355"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8356"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++nextAlloc2ndIndex;</highlight></codeline>
<codeline lineno="8357"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8358"><highlight class="normal"></highlight></codeline>
<codeline lineno="8359"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Found<sp/>non-null<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8360"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nextAlloc2ndIndex<sp/>&lt;<sp/>suballoc2ndCount)</highlight></codeline>
<codeline lineno="8361"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8362"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>suballoc<sp/>=<sp/>suballocations2nd[nextAlloc2ndIndex];</highlight></codeline>
<codeline lineno="8363"><highlight class="normal"></highlight></codeline>
<codeline lineno="8364"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>1.<sp/>Process<sp/>free<sp/>space<sp/>before<sp/>this<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8365"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>suballoc.offset)</highlight></codeline>
<codeline lineno="8366"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8367"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>free<sp/>space<sp/>from<sp/>lastOffset<sp/>to<sp/>suballoc.offset.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8368"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>unusedRangeSize<sp/>=<sp/>suballoc.offset<sp/>-<sp/>lastOffset;</highlight></codeline>
<codeline lineno="8369"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrintDetailedMap_UnusedRange(json,<sp/>lastOffset,<sp/>unusedRangeSize);</highlight></codeline>
<codeline lineno="8370"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8371"><highlight class="normal"></highlight></codeline>
<codeline lineno="8372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>2.<sp/>Process<sp/>this<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8373"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>allocation<sp/>with<sp/>suballoc.offset,<sp/>suballoc.size.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8374"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrintDetailedMap_Allocation(json,<sp/>suballoc.offset,<sp/>suballoc.size,<sp/>suballoc.userData);</highlight></codeline>
<codeline lineno="8375"><highlight class="normal"></highlight></codeline>
<codeline lineno="8376"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>3.<sp/>Prepare<sp/>for<sp/>next<sp/>iteration.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8377"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lastOffset<sp/>=<sp/>suballoc.offset<sp/>+<sp/>suballoc.size;</highlight></codeline>
<codeline lineno="8378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++nextAlloc2ndIndex;</highlight></codeline>
<codeline lineno="8379"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8380"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>are<sp/>at<sp/>the<sp/>end.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8381"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8382"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8383"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>freeSpace2ndTo1stEnd)</highlight></codeline>
<codeline lineno="8384"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8385"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>free<sp/>space<sp/>from<sp/>lastOffset<sp/>to<sp/>freeSpace2ndTo1stEnd.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8386"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>unusedRangeSize<sp/>=<sp/>freeSpace2ndTo1stEnd<sp/>-<sp/>lastOffset;</highlight></codeline>
<codeline lineno="8387"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrintDetailedMap_UnusedRange(json,<sp/>lastOffset,<sp/>unusedRangeSize);</highlight></codeline>
<codeline lineno="8388"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8389"><highlight class="normal"></highlight></codeline>
<codeline lineno="8390"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>End<sp/>of<sp/>loop.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8391"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lastOffset<sp/>=<sp/>freeSpace2ndTo1stEnd;</highlight></codeline>
<codeline lineno="8392"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8393"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8394"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8395"><highlight class="normal"></highlight></codeline>
<codeline lineno="8396"><highlight class="normal"><sp/><sp/><sp/><sp/>nextAlloc1stIndex<sp/>=<sp/>m_1stNullItemsBeginCount;</highlight></codeline>
<codeline lineno="8397"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>freeSpace1stTo2ndEnd)</highlight></codeline>
<codeline lineno="8398"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8399"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>next<sp/>non-null<sp/>allocation<sp/>or<sp/>move<sp/>nextAllocIndex<sp/>to<sp/>the<sp/>end.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8400"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(nextAlloc1stIndex<sp/>&lt;<sp/>suballoc1stCount<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="8401"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations1st[nextAlloc1stIndex].userData<sp/>==<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="8402"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8403"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++nextAlloc1stIndex;</highlight></codeline>
<codeline lineno="8404"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8405"><highlight class="normal"></highlight></codeline>
<codeline lineno="8406"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Found<sp/>non-null<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8407"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nextAlloc1stIndex<sp/>&lt;<sp/>suballoc1stCount)</highlight></codeline>
<codeline lineno="8408"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8409"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>suballoc<sp/>=<sp/>suballocations1st[nextAlloc1stIndex];</highlight></codeline>
<codeline lineno="8410"><highlight class="normal"></highlight></codeline>
<codeline lineno="8411"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>1.<sp/>Process<sp/>free<sp/>space<sp/>before<sp/>this<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8412"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>suballoc.offset)</highlight></codeline>
<codeline lineno="8413"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8414"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>free<sp/>space<sp/>from<sp/>lastOffset<sp/>to<sp/>suballoc.offset.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8415"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>unusedRangeSize<sp/>=<sp/>suballoc.offset<sp/>-<sp/>lastOffset;</highlight></codeline>
<codeline lineno="8416"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrintDetailedMap_UnusedRange(json,<sp/>lastOffset,<sp/>unusedRangeSize);</highlight></codeline>
<codeline lineno="8417"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8418"><highlight class="normal"></highlight></codeline>
<codeline lineno="8419"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>2.<sp/>Process<sp/>this<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8420"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>allocation<sp/>with<sp/>suballoc.offset,<sp/>suballoc.size.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8421"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrintDetailedMap_Allocation(json,<sp/>suballoc.offset,<sp/>suballoc.size,<sp/>suballoc.userData);</highlight></codeline>
<codeline lineno="8422"><highlight class="normal"></highlight></codeline>
<codeline lineno="8423"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>3.<sp/>Prepare<sp/>for<sp/>next<sp/>iteration.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8424"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lastOffset<sp/>=<sp/>suballoc.offset<sp/>+<sp/>suballoc.size;</highlight></codeline>
<codeline lineno="8425"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++nextAlloc1stIndex;</highlight></codeline>
<codeline lineno="8426"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8427"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>are<sp/>at<sp/>the<sp/>end.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8428"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8429"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8430"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>freeSpace1stTo2ndEnd)</highlight></codeline>
<codeline lineno="8431"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8432"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>free<sp/>space<sp/>from<sp/>lastOffset<sp/>to<sp/>freeSpace1stTo2ndEnd.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8433"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>unusedRangeSize<sp/>=<sp/>freeSpace1stTo2ndEnd<sp/>-<sp/>lastOffset;</highlight></codeline>
<codeline lineno="8434"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrintDetailedMap_UnusedRange(json,<sp/>lastOffset,<sp/>unusedRangeSize);</highlight></codeline>
<codeline lineno="8435"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8436"><highlight class="normal"></highlight></codeline>
<codeline lineno="8437"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>End<sp/>of<sp/>loop.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8438"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lastOffset<sp/>=<sp/>freeSpace1stTo2ndEnd;</highlight></codeline>
<codeline lineno="8439"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8440"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8441"><highlight class="normal"></highlight></codeline>
<codeline lineno="8442"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_DOUBLE_STACK)</highlight></codeline>
<codeline lineno="8443"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8444"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>nextAlloc2ndIndex<sp/>=<sp/>suballocations2nd.size()<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="8445"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>size)</highlight></codeline>
<codeline lineno="8446"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8447"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>next<sp/>non-null<sp/>allocation<sp/>or<sp/>move<sp/>nextAlloc2ndIndex<sp/>to<sp/>the<sp/>end.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8448"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(nextAlloc2ndIndex<sp/>!=<sp/>SIZE_MAX<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="8449"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations2nd[nextAlloc2ndIndex].userData<sp/>==<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="8450"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8451"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--nextAlloc2ndIndex;</highlight></codeline>
<codeline lineno="8452"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8453"><highlight class="normal"></highlight></codeline>
<codeline lineno="8454"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Found<sp/>non-null<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8455"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nextAlloc2ndIndex<sp/>!=<sp/>SIZE_MAX)</highlight></codeline>
<codeline lineno="8456"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8457"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>suballoc<sp/>=<sp/>suballocations2nd[nextAlloc2ndIndex];</highlight></codeline>
<codeline lineno="8458"><highlight class="normal"></highlight></codeline>
<codeline lineno="8459"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>1.<sp/>Process<sp/>free<sp/>space<sp/>before<sp/>this<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8460"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>suballoc.offset)</highlight></codeline>
<codeline lineno="8461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8462"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>free<sp/>space<sp/>from<sp/>lastOffset<sp/>to<sp/>suballoc.offset.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8463"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>unusedRangeSize<sp/>=<sp/>suballoc.offset<sp/>-<sp/>lastOffset;</highlight></codeline>
<codeline lineno="8464"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrintDetailedMap_UnusedRange(json,<sp/>lastOffset,<sp/>unusedRangeSize);</highlight></codeline>
<codeline lineno="8465"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8466"><highlight class="normal"></highlight></codeline>
<codeline lineno="8467"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>2.<sp/>Process<sp/>this<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8468"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>allocation<sp/>with<sp/>suballoc.offset,<sp/>suballoc.size.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8469"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrintDetailedMap_Allocation(json,<sp/>suballoc.offset,<sp/>suballoc.size,<sp/>suballoc.userData);</highlight></codeline>
<codeline lineno="8470"><highlight class="normal"></highlight></codeline>
<codeline lineno="8471"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>3.<sp/>Prepare<sp/>for<sp/>next<sp/>iteration.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8472"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lastOffset<sp/>=<sp/>suballoc.offset<sp/>+<sp/>suballoc.size;</highlight></codeline>
<codeline lineno="8473"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--nextAlloc2ndIndex;</highlight></codeline>
<codeline lineno="8474"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8475"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>are<sp/>at<sp/>the<sp/>end.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8476"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8477"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8478"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lastOffset<sp/>&lt;<sp/>size)</highlight></codeline>
<codeline lineno="8479"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8480"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>free<sp/>space<sp/>from<sp/>lastOffset<sp/>to<sp/>size.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8481"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>unusedRangeSize<sp/>=<sp/>size<sp/>-<sp/>lastOffset;</highlight></codeline>
<codeline lineno="8482"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrintDetailedMap_UnusedRange(json,<sp/>lastOffset,<sp/>unusedRangeSize);</highlight></codeline>
<codeline lineno="8483"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8484"><highlight class="normal"></highlight></codeline>
<codeline lineno="8485"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>End<sp/>of<sp/>loop.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8486"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lastOffset<sp/>=<sp/>size;</highlight></codeline>
<codeline lineno="8487"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8488"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8489"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8490"><highlight class="normal"></highlight></codeline>
<codeline lineno="8491"><highlight class="normal"><sp/><sp/><sp/><sp/>PrintDetailedMap_End(json);</highlight></codeline>
<codeline lineno="8492"><highlight class="normal">}</highlight></codeline>
<codeline lineno="8493"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8494"><highlight class="normal"></highlight></codeline>
<codeline lineno="8495"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Linear::CreateAllocationRequest(</highlight></codeline>
<codeline lineno="8496"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocSize,</highlight></codeline>
<codeline lineno="8497"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocAlignment,</highlight></codeline>
<codeline lineno="8498"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>upperAddress,</highlight></codeline>
<codeline lineno="8499"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>allocType,</highlight></codeline>
<codeline lineno="8500"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>strategy,</highlight></codeline>
<codeline lineno="8501"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocationRequest*<sp/>pAllocationRequest)</highlight></codeline>
<codeline lineno="8502"><highlight class="normal">{</highlight></codeline>
<codeline lineno="8503"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocSize<sp/>&gt;<sp/>0);</highlight></codeline>
<codeline lineno="8504"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocType<sp/>!=<sp/>VMA_SUBALLOCATION_TYPE_FREE);</highlight></codeline>
<codeline lineno="8505"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(pAllocationRequest<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="8506"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(Validate());</highlight></codeline>
<codeline lineno="8507"><highlight class="normal"><sp/><sp/><sp/><sp/>pAllocationRequest-&gt;size<sp/>=<sp/>allocSize;</highlight></codeline>
<codeline lineno="8508"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>upperAddress<sp/>?</highlight></codeline>
<codeline lineno="8509"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CreateAllocationRequest_UpperAddress(</highlight></codeline>
<codeline lineno="8510"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocSize,<sp/>allocAlignment,<sp/>allocType,<sp/>strategy,<sp/>pAllocationRequest)<sp/>:</highlight></codeline>
<codeline lineno="8511"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CreateAllocationRequest_LowerAddress(</highlight></codeline>
<codeline lineno="8512"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocSize,<sp/>allocAlignment,<sp/>allocType,<sp/>strategy,<sp/>pAllocationRequest);</highlight></codeline>
<codeline lineno="8513"><highlight class="normal">}</highlight></codeline>
<codeline lineno="8514"><highlight class="normal"></highlight></codeline>
<codeline lineno="8515"><highlight class="normal">VkResult<sp/>VmaBlockMetadata_Linear::CheckCorruption(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pBlockData)</highlight></codeline>
<codeline lineno="8516"><highlight class="normal">{</highlight></codeline>
<codeline lineno="8517"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(!IsVirtual());</highlight></codeline>
<codeline lineno="8518"><highlight class="normal"><sp/><sp/><sp/><sp/>SuballocationVectorType&amp;<sp/>suballocations1st<sp/>=<sp/>AccessSuballocations1st();</highlight></codeline>
<codeline lineno="8519"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>m_1stNullItemsBeginCount,<sp/>count<sp/>=<sp/>suballocations1st.size();<sp/>i<sp/>&lt;<sp/>count;<sp/>++i)</highlight></codeline>
<codeline lineno="8520"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8521"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>suballoc<sp/>=<sp/>suballocations1st[i];</highlight></codeline>
<codeline lineno="8522"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(suballoc.type<sp/>!=<sp/>VMA_SUBALLOCATION_TYPE_FREE)</highlight></codeline>
<codeline lineno="8523"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8524"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!VmaValidateMagicValue(pBlockData,<sp/>suballoc.offset<sp/>+<sp/>suballoc.size))</highlight></codeline>
<codeline lineno="8525"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8526"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;MEMORY<sp/>CORRUPTION<sp/>DETECTED<sp/>AFTER<sp/>VALIDATED<sp/>ALLOCATION!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="8527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_UNKNOWN_COPY;</highlight></codeline>
<codeline lineno="8528"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8529"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8530"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8531"><highlight class="normal"></highlight></codeline>
<codeline lineno="8532"><highlight class="normal"><sp/><sp/><sp/><sp/>SuballocationVectorType&amp;<sp/>suballocations2nd<sp/>=<sp/>AccessSuballocations2nd();</highlight></codeline>
<codeline lineno="8533"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0,<sp/>count<sp/>=<sp/>suballocations2nd.size();<sp/>i<sp/>&lt;<sp/>count;<sp/>++i)</highlight></codeline>
<codeline lineno="8534"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8535"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>suballoc<sp/>=<sp/>suballocations2nd[i];</highlight></codeline>
<codeline lineno="8536"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(suballoc.type<sp/>!=<sp/>VMA_SUBALLOCATION_TYPE_FREE)</highlight></codeline>
<codeline lineno="8537"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8538"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!VmaValidateMagicValue(pBlockData,<sp/>suballoc.offset<sp/>+<sp/>suballoc.size))</highlight></codeline>
<codeline lineno="8539"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8540"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;MEMORY<sp/>CORRUPTION<sp/>DETECTED<sp/>AFTER<sp/>VALIDATED<sp/>ALLOCATION!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="8541"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_UNKNOWN_COPY;</highlight></codeline>
<codeline lineno="8542"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8543"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8544"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8545"><highlight class="normal"></highlight></codeline>
<codeline lineno="8546"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="8547"><highlight class="normal">}</highlight></codeline>
<codeline lineno="8548"><highlight class="normal"></highlight></codeline>
<codeline lineno="8549"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Linear::Alloc(</highlight></codeline>
<codeline lineno="8550"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaAllocationRequest&amp;<sp/>request,</highlight></codeline>
<codeline lineno="8551"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>type,</highlight></codeline>
<codeline lineno="8552"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>userData)</highlight></codeline>
<codeline lineno="8553"><highlight class="normal">{</highlight></codeline>
<codeline lineno="8554"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>offset<sp/>=<sp/>(VkDeviceSize)request.allocHandle<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="8555"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation<sp/>newSuballoc<sp/>=<sp/>{<sp/>offset,<sp/>request.size,<sp/>userData,<sp/>type<sp/>};</highlight></codeline>
<codeline lineno="8556"><highlight class="normal"></highlight></codeline>
<codeline lineno="8557"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(request.type)</highlight></codeline>
<codeline lineno="8558"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8559"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VmaAllocationRequestType::UpperAddress:</highlight></codeline>
<codeline lineno="8560"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8561"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(m_2ndVectorMode<sp/>!=<sp/>SECOND_VECTOR_RING_BUFFER<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="8562"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;CRITICAL<sp/>ERROR:<sp/>Trying<sp/>to<sp/>use<sp/>linear<sp/>allocator<sp/>as<sp/>double<sp/>stack<sp/>while<sp/>it<sp/>was<sp/>already<sp/>used<sp/>as<sp/>ring<sp/>buffer.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="8563"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SuballocationVectorType&amp;<sp/>suballocations2nd<sp/>=<sp/>AccessSuballocations2nd();</highlight></codeline>
<codeline lineno="8564"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations2nd.push_back(newSuballoc);</highlight></codeline>
<codeline lineno="8565"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_2ndVectorMode<sp/>=<sp/>SECOND_VECTOR_DOUBLE_STACK;</highlight></codeline>
<codeline lineno="8566"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8567"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="8568"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VmaAllocationRequestType::EndOf1st:</highlight></codeline>
<codeline lineno="8569"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8570"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SuballocationVectorType&amp;<sp/>suballocations1st<sp/>=<sp/>AccessSuballocations1st();</highlight></codeline>
<codeline lineno="8571"><highlight class="normal"></highlight></codeline>
<codeline lineno="8572"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(suballocations1st.empty()<sp/>||</highlight></codeline>
<codeline lineno="8573"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset<sp/>&gt;=<sp/>suballocations1st.back().offset<sp/>+<sp/>suballocations1st.back().size);</highlight></codeline>
<codeline lineno="8574"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>if<sp/>it<sp/>fits<sp/>before<sp/>the<sp/>end<sp/>of<sp/>the<sp/>block.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8575"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(offset<sp/>+<sp/>request.size<sp/>&lt;=<sp/>GetSize());</highlight></codeline>
<codeline lineno="8576"><highlight class="normal"></highlight></codeline>
<codeline lineno="8577"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations1st.push_back(newSuballoc);</highlight></codeline>
<codeline lineno="8578"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8579"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="8580"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VmaAllocationRequestType::EndOf2nd:</highlight></codeline>
<codeline lineno="8581"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8582"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SuballocationVectorType&amp;<sp/>suballocations1st<sp/>=<sp/>AccessSuballocations1st();</highlight></codeline>
<codeline lineno="8583"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>New<sp/>allocation<sp/>at<sp/>the<sp/>end<sp/>of<sp/>2-part<sp/>ring<sp/>buffer,<sp/>so<sp/>before<sp/>first<sp/>allocation<sp/>from<sp/>1st<sp/>vector.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8584"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(!suballocations1st.empty()<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="8585"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>offset<sp/>+<sp/>request.size<sp/>&lt;=<sp/>suballocations1st[m_1stNullItemsBeginCount].offset);</highlight></codeline>
<codeline lineno="8586"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SuballocationVectorType&amp;<sp/>suballocations2nd<sp/>=<sp/>AccessSuballocations2nd();</highlight></codeline>
<codeline lineno="8587"><highlight class="normal"></highlight></codeline>
<codeline lineno="8588"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(m_2ndVectorMode)</highlight></codeline>
<codeline lineno="8589"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8590"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>SECOND_VECTOR_EMPTY:</highlight></codeline>
<codeline lineno="8591"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>First<sp/>allocation<sp/>from<sp/>second<sp/>part<sp/>ring<sp/>buffer.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8592"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(suballocations2nd.empty());</highlight></codeline>
<codeline lineno="8593"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_2ndVectorMode<sp/>=<sp/>SECOND_VECTOR_RING_BUFFER;</highlight></codeline>
<codeline lineno="8594"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="8595"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>SECOND_VECTOR_RING_BUFFER:</highlight></codeline>
<codeline lineno="8596"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>2-part<sp/>ring<sp/>buffer<sp/>is<sp/>already<sp/>started.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8597"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(!suballocations2nd.empty());</highlight></codeline>
<codeline lineno="8598"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="8599"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>SECOND_VECTOR_DOUBLE_STACK:</highlight></codeline>
<codeline lineno="8600"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;CRITICAL<sp/>ERROR:<sp/>Trying<sp/>to<sp/>use<sp/>linear<sp/>allocator<sp/>as<sp/>ring<sp/>buffer<sp/>while<sp/>it<sp/>was<sp/>already<sp/>used<sp/>as<sp/>double<sp/>stack.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="8601"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="8602"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="8603"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="8604"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8605"><highlight class="normal"></highlight></codeline>
<codeline lineno="8606"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations2nd.push_back(newSuballoc);</highlight></codeline>
<codeline lineno="8607"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8608"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="8609"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="8610"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;CRITICAL<sp/>INTERNAL<sp/>ERROR.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="8611"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8612"><highlight class="normal"></highlight></codeline>
<codeline lineno="8613"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SumFreeSize<sp/>-=<sp/>newSuballoc.size;</highlight></codeline>
<codeline lineno="8614"><highlight class="normal">}</highlight></codeline>
<codeline lineno="8615"><highlight class="normal"></highlight></codeline>
<codeline lineno="8616"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Linear::Free(VmaAllocHandle<sp/>allocHandle)</highlight></codeline>
<codeline lineno="8617"><highlight class="normal">{</highlight></codeline>
<codeline lineno="8618"><highlight class="normal"><sp/><sp/><sp/><sp/>SuballocationVectorType&amp;<sp/>suballocations1st<sp/>=<sp/>AccessSuballocations1st();</highlight></codeline>
<codeline lineno="8619"><highlight class="normal"><sp/><sp/><sp/><sp/>SuballocationVectorType&amp;<sp/>suballocations2nd<sp/>=<sp/>AccessSuballocations2nd();</highlight></codeline>
<codeline lineno="8620"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>offset<sp/>=<sp/>(VkDeviceSize)allocHandle<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="8621"><highlight class="normal"></highlight></codeline>
<codeline lineno="8622"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!suballocations1st.empty())</highlight></codeline>
<codeline lineno="8623"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8624"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>First<sp/>allocation:<sp/>Mark<sp/>it<sp/>as<sp/>next<sp/>empty<sp/>at<sp/>the<sp/>beginning.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8625"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocation&amp;<sp/>firstSuballoc<sp/>=<sp/>suballocations1st[m_1stNullItemsBeginCount];</highlight></codeline>
<codeline lineno="8626"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(firstSuballoc.offset<sp/>==<sp/>offset)</highlight></codeline>
<codeline lineno="8627"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8628"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>firstSuballoc.type<sp/>=<sp/>VMA_SUBALLOCATION_TYPE_FREE;</highlight></codeline>
<codeline lineno="8629"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>firstSuballoc.userData<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="8630"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_SumFreeSize<sp/>+=<sp/>firstSuballoc.size;</highlight></codeline>
<codeline lineno="8631"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++m_1stNullItemsBeginCount;</highlight></codeline>
<codeline lineno="8632"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CleanupAfterFree();</highlight></codeline>
<codeline lineno="8633"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="8634"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8635"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8636"><highlight class="normal"></highlight></codeline>
<codeline lineno="8637"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Last<sp/>allocation<sp/>in<sp/>2-part<sp/>ring<sp/>buffer<sp/>or<sp/>top<sp/>of<sp/>upper<sp/>stack<sp/>(same<sp/>logic).</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8638"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_RING_BUFFER<sp/>||</highlight></codeline>
<codeline lineno="8639"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_DOUBLE_STACK)</highlight></codeline>
<codeline lineno="8640"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8641"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocation&amp;<sp/>lastSuballoc<sp/>=<sp/>suballocations2nd.back();</highlight></codeline>
<codeline lineno="8642"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lastSuballoc.offset<sp/>==<sp/>offset)</highlight></codeline>
<codeline lineno="8643"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8644"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_SumFreeSize<sp/>+=<sp/>lastSuballoc.size;</highlight></codeline>
<codeline lineno="8645"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations2nd.pop_back();</highlight></codeline>
<codeline lineno="8646"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CleanupAfterFree();</highlight></codeline>
<codeline lineno="8647"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="8648"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8649"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8650"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Last<sp/>allocation<sp/>in<sp/>1st<sp/>vector.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8651"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_EMPTY)</highlight></codeline>
<codeline lineno="8652"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8653"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocation&amp;<sp/>lastSuballoc<sp/>=<sp/>suballocations1st.back();</highlight></codeline>
<codeline lineno="8654"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lastSuballoc.offset<sp/>==<sp/>offset)</highlight></codeline>
<codeline lineno="8655"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8656"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_SumFreeSize<sp/>+=<sp/>lastSuballoc.size;</highlight></codeline>
<codeline lineno="8657"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations1st.pop_back();</highlight></codeline>
<codeline lineno="8658"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CleanupAfterFree();</highlight></codeline>
<codeline lineno="8659"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="8660"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8661"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8662"><highlight class="normal"></highlight></codeline>
<codeline lineno="8663"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocation<sp/>refSuballoc;</highlight></codeline>
<codeline lineno="8664"><highlight class="normal"><sp/><sp/><sp/><sp/>refSuballoc.offset<sp/>=<sp/>offset;</highlight></codeline>
<codeline lineno="8665"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Rest<sp/>of<sp/>members<sp/>stays<sp/>uninitialized<sp/>intentionally<sp/>for<sp/>better<sp/>performance.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8666"><highlight class="normal"></highlight></codeline>
<codeline lineno="8667"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Item<sp/>from<sp/>the<sp/>middle<sp/>of<sp/>1st<sp/>vector.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8668"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8669"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SuballocationVectorType::iterator<sp/>it<sp/>=<sp/>VmaBinaryFindSorted(</highlight></codeline>
<codeline lineno="8670"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations1st.begin()<sp/>+<sp/>m_1stNullItemsBeginCount,</highlight></codeline>
<codeline lineno="8671"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations1st.end(),</highlight></codeline>
<codeline lineno="8672"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>refSuballoc,</highlight></codeline>
<codeline lineno="8673"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationOffsetLess());</highlight></codeline>
<codeline lineno="8674"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(it<sp/>!=<sp/>suballocations1st.end())</highlight></codeline>
<codeline lineno="8675"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8676"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it-&gt;type<sp/>=<sp/>VMA_SUBALLOCATION_TYPE_FREE;</highlight></codeline>
<codeline lineno="8677"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it-&gt;userData<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="8678"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++m_1stNullItemsMiddleCount;</highlight></codeline>
<codeline lineno="8679"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_SumFreeSize<sp/>+=<sp/>it-&gt;size;</highlight></codeline>
<codeline lineno="8680"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CleanupAfterFree();</highlight></codeline>
<codeline lineno="8681"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="8682"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8683"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8684"><highlight class="normal"></highlight></codeline>
<codeline lineno="8685"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_2ndVectorMode<sp/>!=<sp/>SECOND_VECTOR_EMPTY)</highlight></codeline>
<codeline lineno="8686"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8687"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Item<sp/>from<sp/>the<sp/>middle<sp/>of<sp/>2nd<sp/>vector.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8688"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SuballocationVectorType::iterator<sp/>it<sp/>=<sp/>m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_RING_BUFFER<sp/>?</highlight></codeline>
<codeline lineno="8689"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaBinaryFindSorted(suballocations2nd.begin(),<sp/>suballocations2nd.end(),<sp/>refSuballoc,<sp/>VmaSuballocationOffsetLess())<sp/>:</highlight></codeline>
<codeline lineno="8690"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaBinaryFindSorted(suballocations2nd.begin(),<sp/>suballocations2nd.end(),<sp/>refSuballoc,<sp/>VmaSuballocationOffsetGreater());</highlight></codeline>
<codeline lineno="8691"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(it<sp/>!=<sp/>suballocations2nd.end())</highlight></codeline>
<codeline lineno="8692"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8693"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it-&gt;type<sp/>=<sp/>VMA_SUBALLOCATION_TYPE_FREE;</highlight></codeline>
<codeline lineno="8694"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it-&gt;userData<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="8695"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++m_2ndNullItemsCount;</highlight></codeline>
<codeline lineno="8696"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_SumFreeSize<sp/>+=<sp/>it-&gt;size;</highlight></codeline>
<codeline lineno="8697"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CleanupAfterFree();</highlight></codeline>
<codeline lineno="8698"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="8699"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8700"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8701"><highlight class="normal"></highlight></codeline>
<codeline lineno="8702"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Allocation<sp/>to<sp/>free<sp/>not<sp/>found<sp/>in<sp/>linear<sp/>allocator!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="8703"><highlight class="normal">}</highlight></codeline>
<codeline lineno="8704"><highlight class="normal"></highlight></codeline>
<codeline lineno="8705"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Linear::GetAllocationInfo(VmaAllocHandle<sp/>allocHandle,<sp/><ref refid="struct_vma_virtual_allocation_info" kindref="compound">VmaVirtualAllocationInfo</ref>&amp;<sp/>outInfo)</highlight></codeline>
<codeline lineno="8706"><highlight class="normal">{</highlight></codeline>
<codeline lineno="8707"><highlight class="normal"><sp/><sp/><sp/><sp/>outInfo.<ref refid="struct_vma_virtual_allocation_info_1accb40a8205f49ccca3de975da7d1a2b5" kindref="member">offset</ref><sp/>=<sp/>(VkDeviceSize)allocHandle<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="8708"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocation&amp;<sp/>suballoc<sp/>=<sp/>FindSuballocation(outInfo.<ref refid="struct_vma_virtual_allocation_info_1accb40a8205f49ccca3de975da7d1a2b5" kindref="member">offset</ref>);</highlight></codeline>
<codeline lineno="8709"><highlight class="normal"><sp/><sp/><sp/><sp/>outInfo.<ref refid="struct_vma_virtual_allocation_info_1afb6d6bd0a6813869ea0842048d40aa2b" kindref="member">size</ref><sp/>=<sp/>suballoc.size;</highlight></codeline>
<codeline lineno="8710"><highlight class="normal"><sp/><sp/><sp/><sp/>outInfo.<ref refid="struct_vma_virtual_allocation_info_1a224aa08739618d27066a16b7f60a2bbc" kindref="member">pUserData</ref><sp/>=<sp/>suballoc.userData;</highlight></codeline>
<codeline lineno="8711"><highlight class="normal">}</highlight></codeline>
<codeline lineno="8712"><highlight class="normal"></highlight></codeline>
<codeline lineno="8713"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>VmaBlockMetadata_Linear::GetAllocationUserData(VmaAllocHandle<sp/>allocHandle)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="8714"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="8715"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>FindSuballocation((VkDeviceSize)allocHandle<sp/>-<sp/>1).userData;</highlight></codeline>
<codeline lineno="8716"><highlight class="normal">}</highlight></codeline>
<codeline lineno="8717"><highlight class="normal"></highlight></codeline>
<codeline lineno="8718"><highlight class="normal">VmaAllocHandle<sp/>VmaBlockMetadata_Linear::GetAllocationListBegin()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="8719"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="8720"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Function<sp/>only<sp/>used<sp/>for<sp/>defragmentation,<sp/>which<sp/>is<sp/>disabled<sp/>for<sp/>this<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8721"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="8722"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="8723"><highlight class="normal">}</highlight></codeline>
<codeline lineno="8724"><highlight class="normal"></highlight></codeline>
<codeline lineno="8725"><highlight class="normal">VmaAllocHandle<sp/>VmaBlockMetadata_Linear::GetNextAllocation(VmaAllocHandle<sp/>prevAlloc)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="8726"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="8727"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Function<sp/>only<sp/>used<sp/>for<sp/>defragmentation,<sp/>which<sp/>is<sp/>disabled<sp/>for<sp/>this<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8728"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="8729"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="8730"><highlight class="normal">}</highlight></codeline>
<codeline lineno="8731"><highlight class="normal"></highlight></codeline>
<codeline lineno="8732"><highlight class="normal">VkDeviceSize<sp/>VmaBlockMetadata_Linear::GetNextFreeRegionSize(VmaAllocHandle<sp/>alloc)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="8733"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="8734"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Function<sp/>only<sp/>used<sp/>for<sp/>defragmentation,<sp/>which<sp/>is<sp/>disabled<sp/>for<sp/>this<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8735"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="8736"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="8737"><highlight class="normal">}</highlight></codeline>
<codeline lineno="8738"><highlight class="normal"></highlight></codeline>
<codeline lineno="8739"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Linear::Clear()</highlight></codeline>
<codeline lineno="8740"><highlight class="normal">{</highlight></codeline>
<codeline lineno="8741"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SumFreeSize<sp/>=<sp/>GetSize();</highlight></codeline>
<codeline lineno="8742"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Suballocations0.clear();</highlight></codeline>
<codeline lineno="8743"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Suballocations1.clear();</highlight></codeline>
<codeline lineno="8744"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Leaving<sp/>m_1stVectorIndex<sp/>unchanged<sp/>-<sp/>it<sp/>doesn&apos;t<sp/>matter.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8745"><highlight class="normal"><sp/><sp/><sp/><sp/>m_2ndVectorMode<sp/>=<sp/>SECOND_VECTOR_EMPTY;</highlight></codeline>
<codeline lineno="8746"><highlight class="normal"><sp/><sp/><sp/><sp/>m_1stNullItemsBeginCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="8747"><highlight class="normal"><sp/><sp/><sp/><sp/>m_1stNullItemsMiddleCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="8748"><highlight class="normal"><sp/><sp/><sp/><sp/>m_2ndNullItemsCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="8749"><highlight class="normal">}</highlight></codeline>
<codeline lineno="8750"><highlight class="normal"></highlight></codeline>
<codeline lineno="8751"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Linear::SetAllocationUserData(VmaAllocHandle<sp/>allocHandle,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>userData)</highlight></codeline>
<codeline lineno="8752"><highlight class="normal">{</highlight></codeline>
<codeline lineno="8753"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocation&amp;<sp/>suballoc<sp/>=<sp/>FindSuballocation((VkDeviceSize)allocHandle<sp/>-<sp/>1);</highlight></codeline>
<codeline lineno="8754"><highlight class="normal"><sp/><sp/><sp/><sp/>suballoc.userData<sp/>=<sp/>userData;</highlight></codeline>
<codeline lineno="8755"><highlight class="normal">}</highlight></codeline>
<codeline lineno="8756"><highlight class="normal"></highlight></codeline>
<codeline lineno="8757"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Linear::DebugLogAllAllocations()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="8758"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="8759"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SuballocationVectorType&amp;<sp/>suballocations1st<sp/>=<sp/>AccessSuballocations1st();</highlight></codeline>
<codeline lineno="8760"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>it<sp/>=<sp/>suballocations1st.begin()<sp/>+<sp/>m_1stNullItemsBeginCount;<sp/>it<sp/>!=<sp/>suballocations1st.end();<sp/>++it)</highlight></codeline>
<codeline lineno="8761"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(it-&gt;type<sp/>!=<sp/>VMA_SUBALLOCATION_TYPE_FREE)</highlight></codeline>
<codeline lineno="8762"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>DebugLogAllocation(it-&gt;offset,<sp/>it-&gt;size,<sp/>it-&gt;userData);</highlight></codeline>
<codeline lineno="8763"><highlight class="normal"></highlight></codeline>
<codeline lineno="8764"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SuballocationVectorType&amp;<sp/>suballocations2nd<sp/>=<sp/>AccessSuballocations2nd();</highlight></codeline>
<codeline lineno="8765"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>it<sp/>=<sp/>suballocations2nd.begin();<sp/>it<sp/>!=<sp/>suballocations2nd.end();<sp/>++it)</highlight></codeline>
<codeline lineno="8766"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(it-&gt;type<sp/>!=<sp/>VMA_SUBALLOCATION_TYPE_FREE)</highlight></codeline>
<codeline lineno="8767"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>DebugLogAllocation(it-&gt;offset,<sp/>it-&gt;size,<sp/>it-&gt;userData);</highlight></codeline>
<codeline lineno="8768"><highlight class="normal">}</highlight></codeline>
<codeline lineno="8769"><highlight class="normal"></highlight></codeline>
<codeline lineno="8770"><highlight class="normal">VmaSuballocation&amp;<sp/>VmaBlockMetadata_Linear::FindSuballocation(VkDeviceSize<sp/>offset)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="8771"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="8772"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SuballocationVectorType&amp;<sp/>suballocations1st<sp/>=<sp/>AccessSuballocations1st();</highlight></codeline>
<codeline lineno="8773"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>SuballocationVectorType&amp;<sp/>suballocations2nd<sp/>=<sp/>AccessSuballocations2nd();</highlight></codeline>
<codeline lineno="8774"><highlight class="normal"></highlight></codeline>
<codeline lineno="8775"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocation<sp/>refSuballoc;</highlight></codeline>
<codeline lineno="8776"><highlight class="normal"><sp/><sp/><sp/><sp/>refSuballoc.offset<sp/>=<sp/>offset;</highlight></codeline>
<codeline lineno="8777"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Rest<sp/>of<sp/>members<sp/>stays<sp/>uninitialized<sp/>intentionally<sp/>for<sp/>better<sp/>performance.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8778"><highlight class="normal"></highlight></codeline>
<codeline lineno="8779"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Item<sp/>from<sp/>the<sp/>1st<sp/>vector.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8780"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8781"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SuballocationVectorType::const_iterator<sp/>it<sp/>=<sp/>VmaBinaryFindSorted(</highlight></codeline>
<codeline lineno="8782"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations1st.begin()<sp/>+<sp/>m_1stNullItemsBeginCount,</highlight></codeline>
<codeline lineno="8783"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations1st.end(),</highlight></codeline>
<codeline lineno="8784"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>refSuballoc,</highlight></codeline>
<codeline lineno="8785"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationOffsetLess());</highlight></codeline>
<codeline lineno="8786"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(it<sp/>!=<sp/>suballocations1st.end())</highlight></codeline>
<codeline lineno="8787"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8788"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const_cast&lt;</highlight><highlight class="normal">VmaSuballocation&amp;</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(*it);</highlight></codeline>
<codeline lineno="8789"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8790"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8791"><highlight class="normal"></highlight></codeline>
<codeline lineno="8792"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_2ndVectorMode<sp/>!=<sp/>SECOND_VECTOR_EMPTY)</highlight></codeline>
<codeline lineno="8793"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8794"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Rest<sp/>of<sp/>members<sp/>stays<sp/>uninitialized<sp/>intentionally<sp/>for<sp/>better<sp/>performance.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8795"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SuballocationVectorType::const_iterator<sp/>it<sp/>=<sp/>m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_RING_BUFFER<sp/>?</highlight></codeline>
<codeline lineno="8796"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaBinaryFindSorted(suballocations2nd.begin(),<sp/>suballocations2nd.end(),<sp/>refSuballoc,<sp/>VmaSuballocationOffsetLess())<sp/>:</highlight></codeline>
<codeline lineno="8797"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaBinaryFindSorted(suballocations2nd.begin(),<sp/>suballocations2nd.end(),<sp/>refSuballoc,<sp/>VmaSuballocationOffsetGreater());</highlight></codeline>
<codeline lineno="8798"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(it<sp/>!=<sp/>suballocations2nd.end())</highlight></codeline>
<codeline lineno="8799"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8800"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const_cast&lt;</highlight><highlight class="normal">VmaSuballocation&amp;</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(*it);</highlight></codeline>
<codeline lineno="8801"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8802"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8803"><highlight class="normal"></highlight></codeline>
<codeline lineno="8804"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Allocation<sp/>not<sp/>found<sp/>in<sp/>linear<sp/>allocator!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="8805"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const_cast&lt;</highlight><highlight class="normal">VmaSuballocation&amp;</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(suballocations1st.back());<sp/></highlight><highlight class="comment">//<sp/>Should<sp/>never<sp/>occur.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8806"><highlight class="normal">}</highlight></codeline>
<codeline lineno="8807"><highlight class="normal"></highlight></codeline>
<codeline lineno="8808"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Linear::ShouldCompact1st()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="8809"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="8810"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>nullItemCount<sp/>=<sp/>m_1stNullItemsBeginCount<sp/>+<sp/>m_1stNullItemsMiddleCount;</highlight></codeline>
<codeline lineno="8811"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>suballocCount<sp/>=<sp/>AccessSuballocations1st().size();</highlight></codeline>
<codeline lineno="8812"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>suballocCount<sp/>&gt;<sp/>32<sp/>&amp;&amp;<sp/>nullItemCount<sp/>*<sp/>2<sp/>&gt;=<sp/>(suballocCount<sp/>-<sp/>nullItemCount)<sp/>*<sp/>3;</highlight></codeline>
<codeline lineno="8813"><highlight class="normal">}</highlight></codeline>
<codeline lineno="8814"><highlight class="normal"></highlight></codeline>
<codeline lineno="8815"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Linear::CleanupAfterFree()</highlight></codeline>
<codeline lineno="8816"><highlight class="normal">{</highlight></codeline>
<codeline lineno="8817"><highlight class="normal"><sp/><sp/><sp/><sp/>SuballocationVectorType&amp;<sp/>suballocations1st<sp/>=<sp/>AccessSuballocations1st();</highlight></codeline>
<codeline lineno="8818"><highlight class="normal"><sp/><sp/><sp/><sp/>SuballocationVectorType&amp;<sp/>suballocations2nd<sp/>=<sp/>AccessSuballocations2nd();</highlight></codeline>
<codeline lineno="8819"><highlight class="normal"></highlight></codeline>
<codeline lineno="8820"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(IsEmpty())</highlight></codeline>
<codeline lineno="8821"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8822"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations1st.clear();</highlight></codeline>
<codeline lineno="8823"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations2nd.clear();</highlight></codeline>
<codeline lineno="8824"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_1stNullItemsBeginCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="8825"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_1stNullItemsMiddleCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="8826"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_2ndNullItemsCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="8827"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_2ndVectorMode<sp/>=<sp/>SECOND_VECTOR_EMPTY;</highlight></codeline>
<codeline lineno="8828"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8829"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8830"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8831"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>suballoc1stCount<sp/>=<sp/>suballocations1st.size();</highlight></codeline>
<codeline lineno="8832"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>nullItem1stCount<sp/>=<sp/>m_1stNullItemsBeginCount<sp/>+<sp/>m_1stNullItemsMiddleCount;</highlight></codeline>
<codeline lineno="8833"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(nullItem1stCount<sp/>&lt;=<sp/>suballoc1stCount);</highlight></codeline>
<codeline lineno="8834"><highlight class="normal"></highlight></codeline>
<codeline lineno="8835"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>more<sp/>null<sp/>items<sp/>at<sp/>the<sp/>beginning<sp/>of<sp/>1st<sp/>vector.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8836"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(m_1stNullItemsBeginCount<sp/>&lt;<sp/>suballoc1stCount<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="8837"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations1st[m_1stNullItemsBeginCount].type<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_FREE)</highlight></codeline>
<codeline lineno="8838"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8839"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++m_1stNullItemsBeginCount;</highlight></codeline>
<codeline lineno="8840"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--m_1stNullItemsMiddleCount;</highlight></codeline>
<codeline lineno="8841"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8842"><highlight class="normal"></highlight></codeline>
<codeline lineno="8843"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>more<sp/>null<sp/>items<sp/>at<sp/>the<sp/>end<sp/>of<sp/>1st<sp/>vector.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8844"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(m_1stNullItemsMiddleCount<sp/>&gt;<sp/>0<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="8845"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations1st.back().type<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_FREE)</highlight></codeline>
<codeline lineno="8846"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8847"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--m_1stNullItemsMiddleCount;</highlight></codeline>
<codeline lineno="8848"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations1st.pop_back();</highlight></codeline>
<codeline lineno="8849"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8850"><highlight class="normal"></highlight></codeline>
<codeline lineno="8851"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>more<sp/>null<sp/>items<sp/>at<sp/>the<sp/>end<sp/>of<sp/>2nd<sp/>vector.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8852"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(m_2ndNullItemsCount<sp/>&gt;<sp/>0<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="8853"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations2nd.back().type<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_FREE)</highlight></codeline>
<codeline lineno="8854"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8855"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--m_2ndNullItemsCount;</highlight></codeline>
<codeline lineno="8856"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations2nd.pop_back();</highlight></codeline>
<codeline lineno="8857"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8858"><highlight class="normal"></highlight></codeline>
<codeline lineno="8859"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>more<sp/>null<sp/>items<sp/>at<sp/>the<sp/>beginning<sp/>of<sp/>2nd<sp/>vector.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8860"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(m_2ndNullItemsCount<sp/>&gt;<sp/>0<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="8861"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations2nd[0].type<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_FREE)</highlight></codeline>
<codeline lineno="8862"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8863"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--m_2ndNullItemsCount;</highlight></codeline>
<codeline lineno="8864"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaVectorRemove(suballocations2nd,<sp/>0);</highlight></codeline>
<codeline lineno="8865"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8866"><highlight class="normal"></highlight></codeline>
<codeline lineno="8867"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ShouldCompact1st())</highlight></codeline>
<codeline lineno="8868"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8869"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>nonNullItemCount<sp/>=<sp/>suballoc1stCount<sp/>-<sp/>nullItem1stCount;</highlight></codeline>
<codeline lineno="8870"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>srcIndex<sp/>=<sp/>m_1stNullItemsBeginCount;</highlight></codeline>
<codeline lineno="8871"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>dstIndex<sp/>=<sp/>0;<sp/>dstIndex<sp/>&lt;<sp/>nonNullItemCount;<sp/>++dstIndex)</highlight></codeline>
<codeline lineno="8872"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8873"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(suballocations1st[srcIndex].type<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_FREE)</highlight></codeline>
<codeline lineno="8874"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8875"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++srcIndex;</highlight></codeline>
<codeline lineno="8876"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8877"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(dstIndex<sp/>!=<sp/>srcIndex)</highlight></codeline>
<codeline lineno="8878"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8879"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations1st[dstIndex]<sp/>=<sp/>suballocations1st[srcIndex];</highlight></codeline>
<codeline lineno="8880"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8881"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++srcIndex;</highlight></codeline>
<codeline lineno="8882"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8883"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations1st.resize(nonNullItemCount);</highlight></codeline>
<codeline lineno="8884"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_1stNullItemsBeginCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="8885"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_1stNullItemsMiddleCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="8886"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8887"><highlight class="normal"></highlight></codeline>
<codeline lineno="8888"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>2nd<sp/>vector<sp/>became<sp/>empty.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8889"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(suballocations2nd.empty())</highlight></codeline>
<codeline lineno="8890"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8891"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_2ndVectorMode<sp/>=<sp/>SECOND_VECTOR_EMPTY;</highlight></codeline>
<codeline lineno="8892"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8893"><highlight class="normal"></highlight></codeline>
<codeline lineno="8894"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>1st<sp/>vector<sp/>became<sp/>empty.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8895"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(suballocations1st.size()<sp/>-<sp/>m_1stNullItemsBeginCount<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="8896"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8897"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations1st.clear();</highlight></codeline>
<codeline lineno="8898"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_1stNullItemsBeginCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="8899"><highlight class="normal"></highlight></codeline>
<codeline lineno="8900"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!suballocations2nd.empty()<sp/>&amp;&amp;<sp/>m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_RING_BUFFER)</highlight></codeline>
<codeline lineno="8901"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8902"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Swap<sp/>1st<sp/>with<sp/>2nd.<sp/>Now<sp/>2nd<sp/>is<sp/>empty.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8903"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_2ndVectorMode<sp/>=<sp/>SECOND_VECTOR_EMPTY;</highlight></codeline>
<codeline lineno="8904"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_1stNullItemsMiddleCount<sp/>=<sp/>m_2ndNullItemsCount;</highlight></codeline>
<codeline lineno="8905"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(m_1stNullItemsBeginCount<sp/>&lt;<sp/>suballocations2nd.size()<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="8906"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations2nd[m_1stNullItemsBeginCount].type<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_FREE)</highlight></codeline>
<codeline lineno="8907"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8908"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++m_1stNullItemsBeginCount;</highlight></codeline>
<codeline lineno="8909"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--m_1stNullItemsMiddleCount;</highlight></codeline>
<codeline lineno="8910"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8911"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_2ndNullItemsCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="8912"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_1stVectorIndex<sp/>^=<sp/>1;</highlight></codeline>
<codeline lineno="8913"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8914"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8915"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8916"><highlight class="normal"></highlight></codeline>
<codeline lineno="8917"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(Validate());</highlight></codeline>
<codeline lineno="8918"><highlight class="normal">}</highlight></codeline>
<codeline lineno="8919"><highlight class="normal"></highlight></codeline>
<codeline lineno="8920"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Linear::CreateAllocationRequest_LowerAddress(</highlight></codeline>
<codeline lineno="8921"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocSize,</highlight></codeline>
<codeline lineno="8922"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocAlignment,</highlight></codeline>
<codeline lineno="8923"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>allocType,</highlight></codeline>
<codeline lineno="8924"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>strategy,</highlight></codeline>
<codeline lineno="8925"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocationRequest*<sp/>pAllocationRequest)</highlight></codeline>
<codeline lineno="8926"><highlight class="normal">{</highlight></codeline>
<codeline lineno="8927"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>blockSize<sp/>=<sp/>GetSize();</highlight></codeline>
<codeline lineno="8928"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>debugMargin<sp/>=<sp/>GetDebugMargin();</highlight></codeline>
<codeline lineno="8929"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>bufferImageGranularity<sp/>=<sp/>GetBufferImageGranularity();</highlight></codeline>
<codeline lineno="8930"><highlight class="normal"><sp/><sp/><sp/><sp/>SuballocationVectorType&amp;<sp/>suballocations1st<sp/>=<sp/>AccessSuballocations1st();</highlight></codeline>
<codeline lineno="8931"><highlight class="normal"><sp/><sp/><sp/><sp/>SuballocationVectorType&amp;<sp/>suballocations2nd<sp/>=<sp/>AccessSuballocations2nd();</highlight></codeline>
<codeline lineno="8932"><highlight class="normal"></highlight></codeline>
<codeline lineno="8933"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_EMPTY<sp/>||<sp/>m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_DOUBLE_STACK)</highlight></codeline>
<codeline lineno="8934"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8935"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Try<sp/>to<sp/>allocate<sp/>at<sp/>the<sp/>end<sp/>of<sp/>1st<sp/>vector.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8936"><highlight class="normal"></highlight></codeline>
<codeline lineno="8937"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>resultBaseOffset<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="8938"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!suballocations1st.empty())</highlight></codeline>
<codeline lineno="8939"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8940"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>lastSuballoc<sp/>=<sp/>suballocations1st.back();</highlight></codeline>
<codeline lineno="8941"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>resultBaseOffset<sp/>=<sp/>lastSuballoc.offset<sp/>+<sp/>lastSuballoc.size<sp/>+<sp/>debugMargin;</highlight></codeline>
<codeline lineno="8942"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8943"><highlight class="normal"></highlight></codeline>
<codeline lineno="8944"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Start<sp/>from<sp/>offset<sp/>equal<sp/>to<sp/>beginning<sp/>of<sp/>free<sp/>space.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8945"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>resultOffset<sp/>=<sp/>resultBaseOffset;</highlight></codeline>
<codeline lineno="8946"><highlight class="normal"></highlight></codeline>
<codeline lineno="8947"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Apply<sp/>alignment.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8948"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>resultOffset<sp/>=<sp/>VmaAlignUp(resultOffset,<sp/>allocAlignment);</highlight></codeline>
<codeline lineno="8949"><highlight class="normal"></highlight></codeline>
<codeline lineno="8950"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>previous<sp/>suballocations<sp/>for<sp/>BufferImageGranularity<sp/>conflicts.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8951"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Make<sp/>bigger<sp/>alignment<sp/>if<sp/>necessary.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8952"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(bufferImageGranularity<sp/>&gt;<sp/>1<sp/>&amp;&amp;<sp/>bufferImageGranularity<sp/>!=<sp/>allocAlignment<sp/>&amp;&amp;<sp/>!suballocations1st.empty())</highlight></codeline>
<codeline lineno="8953"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8954"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>bufferImageGranularityConflict<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="8955"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>prevSuballocIndex<sp/>=<sp/>suballocations1st.size();<sp/>prevSuballocIndex--;<sp/>)</highlight></codeline>
<codeline lineno="8956"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8957"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>prevSuballoc<sp/>=<sp/>suballocations1st[prevSuballocIndex];</highlight></codeline>
<codeline lineno="8958"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(VmaBlocksOnSamePage(prevSuballoc.offset,<sp/>prevSuballoc.size,<sp/>resultOffset,<sp/>bufferImageGranularity))</highlight></codeline>
<codeline lineno="8959"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8960"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(VmaIsBufferImageGranularityConflict(prevSuballoc.type,<sp/>allocType))</highlight></codeline>
<codeline lineno="8961"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8962"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bufferImageGranularityConflict<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="8963"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="8964"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8965"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8966"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8967"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Already<sp/>on<sp/>previous<sp/>page.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8968"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="8969"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8970"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(bufferImageGranularityConflict)</highlight></codeline>
<codeline lineno="8971"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8972"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>resultOffset<sp/>=<sp/>VmaAlignUp(resultOffset,<sp/>bufferImageGranularity);</highlight></codeline>
<codeline lineno="8973"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8974"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8975"><highlight class="normal"></highlight></codeline>
<codeline lineno="8976"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>freeSpaceEnd<sp/>=<sp/>m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_DOUBLE_STACK<sp/>?</highlight></codeline>
<codeline lineno="8977"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations2nd.back().offset<sp/>:<sp/>blockSize;</highlight></codeline>
<codeline lineno="8978"><highlight class="normal"></highlight></codeline>
<codeline lineno="8979"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>enough<sp/>free<sp/>space<sp/>at<sp/>the<sp/>end<sp/>after<sp/>alignment.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8980"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(resultOffset<sp/>+<sp/>allocSize<sp/>+<sp/>debugMargin<sp/>&lt;=<sp/>freeSpaceEnd)</highlight></codeline>
<codeline lineno="8981"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8982"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>next<sp/>suballocations<sp/>for<sp/>BufferImageGranularity<sp/>conflicts.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8983"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>conflict<sp/>exists,<sp/>allocation<sp/>cannot<sp/>be<sp/>made<sp/>here.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8984"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((allocSize<sp/>%<sp/>bufferImageGranularity<sp/>||<sp/>resultOffset<sp/>%<sp/>bufferImageGranularity)<sp/>&amp;&amp;<sp/>m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_DOUBLE_STACK)</highlight></codeline>
<codeline lineno="8985"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8986"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>nextSuballocIndex<sp/>=<sp/>suballocations2nd.size();<sp/>nextSuballocIndex--;<sp/>)</highlight></codeline>
<codeline lineno="8987"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8988"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>nextSuballoc<sp/>=<sp/>suballocations2nd[nextSuballocIndex];</highlight></codeline>
<codeline lineno="8989"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(VmaBlocksOnSamePage(resultOffset,<sp/>allocSize,<sp/>nextSuballoc.offset,<sp/>bufferImageGranularity))</highlight></codeline>
<codeline lineno="8990"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8991"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(VmaIsBufferImageGranularityConflict(allocType,<sp/>nextSuballoc.type))</highlight></codeline>
<codeline lineno="8992"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8993"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="8994"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8995"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="8996"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8997"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="8998"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Already<sp/>on<sp/>previous<sp/>page.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8999"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9000"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9001"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9002"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9003"><highlight class="normal"></highlight></codeline>
<codeline lineno="9004"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>All<sp/>tests<sp/>passed:<sp/>Success.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9005"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocationRequest-&gt;allocHandle<sp/>=<sp/>(VmaAllocHandle)(resultOffset<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="9006"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>pAllocationRequest-&gt;item,<sp/>customData<sp/>unused.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9007"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocationRequest-&gt;type<sp/>=<sp/>VmaAllocationRequestType::EndOf1st;</highlight></codeline>
<codeline lineno="9008"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9009"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9010"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9011"><highlight class="normal"></highlight></codeline>
<codeline lineno="9012"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Wrap-around<sp/>to<sp/>end<sp/>of<sp/>2nd<sp/>vector.<sp/>Try<sp/>to<sp/>allocate<sp/>there,<sp/>watching<sp/>for<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9013"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>beginning<sp/>of<sp/>1st<sp/>vector<sp/>as<sp/>the<sp/>end<sp/>of<sp/>free<sp/>space.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9014"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_EMPTY<sp/>||<sp/>m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_RING_BUFFER)</highlight></codeline>
<codeline lineno="9015"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9016"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(!suballocations1st.empty());</highlight></codeline>
<codeline lineno="9017"><highlight class="normal"></highlight></codeline>
<codeline lineno="9018"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>resultBaseOffset<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="9019"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!suballocations2nd.empty())</highlight></codeline>
<codeline lineno="9020"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9021"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>lastSuballoc<sp/>=<sp/>suballocations2nd.back();</highlight></codeline>
<codeline lineno="9022"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>resultBaseOffset<sp/>=<sp/>lastSuballoc.offset<sp/>+<sp/>lastSuballoc.size<sp/>+<sp/>debugMargin;</highlight></codeline>
<codeline lineno="9023"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9024"><highlight class="normal"></highlight></codeline>
<codeline lineno="9025"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Start<sp/>from<sp/>offset<sp/>equal<sp/>to<sp/>beginning<sp/>of<sp/>free<sp/>space.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9026"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>resultOffset<sp/>=<sp/>resultBaseOffset;</highlight></codeline>
<codeline lineno="9027"><highlight class="normal"></highlight></codeline>
<codeline lineno="9028"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Apply<sp/>alignment.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9029"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>resultOffset<sp/>=<sp/>VmaAlignUp(resultOffset,<sp/>allocAlignment);</highlight></codeline>
<codeline lineno="9030"><highlight class="normal"></highlight></codeline>
<codeline lineno="9031"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>previous<sp/>suballocations<sp/>for<sp/>BufferImageGranularity<sp/>conflicts.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9032"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Make<sp/>bigger<sp/>alignment<sp/>if<sp/>necessary.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9033"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(bufferImageGranularity<sp/>&gt;<sp/>1<sp/>&amp;&amp;<sp/>bufferImageGranularity<sp/>!=<sp/>allocAlignment<sp/>&amp;&amp;<sp/>!suballocations2nd.empty())</highlight></codeline>
<codeline lineno="9034"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9035"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>bufferImageGranularityConflict<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9036"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>prevSuballocIndex<sp/>=<sp/>suballocations2nd.size();<sp/>prevSuballocIndex--;<sp/>)</highlight></codeline>
<codeline lineno="9037"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9038"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>prevSuballoc<sp/>=<sp/>suballocations2nd[prevSuballocIndex];</highlight></codeline>
<codeline lineno="9039"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(VmaBlocksOnSamePage(prevSuballoc.offset,<sp/>prevSuballoc.size,<sp/>resultOffset,<sp/>bufferImageGranularity))</highlight></codeline>
<codeline lineno="9040"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9041"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(VmaIsBufferImageGranularityConflict(prevSuballoc.type,<sp/>allocType))</highlight></codeline>
<codeline lineno="9042"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9043"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bufferImageGranularityConflict<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9044"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9045"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9046"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9047"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9048"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Already<sp/>on<sp/>previous<sp/>page.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9049"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9050"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9051"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(bufferImageGranularityConflict)</highlight></codeline>
<codeline lineno="9052"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9053"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>resultOffset<sp/>=<sp/>VmaAlignUp(resultOffset,<sp/>bufferImageGranularity);</highlight></codeline>
<codeline lineno="9054"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9055"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9056"><highlight class="normal"></highlight></codeline>
<codeline lineno="9057"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index1st<sp/>=<sp/>m_1stNullItemsBeginCount;</highlight></codeline>
<codeline lineno="9058"><highlight class="normal"></highlight></codeline>
<codeline lineno="9059"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>enough<sp/>free<sp/>space<sp/>at<sp/>the<sp/>end<sp/>after<sp/>alignment.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9060"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((index1st<sp/>==<sp/>suballocations1st.size()<sp/>&amp;&amp;<sp/>resultOffset<sp/>+<sp/>allocSize<sp/>+<sp/>debugMargin<sp/>&lt;=<sp/>blockSize)<sp/>||</highlight></codeline>
<codeline lineno="9061"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(index1st<sp/>&lt;<sp/>suballocations1st.size()<sp/>&amp;&amp;<sp/>resultOffset<sp/>+<sp/>allocSize<sp/>+<sp/>debugMargin<sp/>&lt;=<sp/>suballocations1st[index1st].offset))</highlight></codeline>
<codeline lineno="9062"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9063"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>next<sp/>suballocations<sp/>for<sp/>BufferImageGranularity<sp/>conflicts.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9064"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>conflict<sp/>exists,<sp/>allocation<sp/>cannot<sp/>be<sp/>made<sp/>here.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9065"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(allocSize<sp/>%<sp/>bufferImageGranularity<sp/>||<sp/>resultOffset<sp/>%<sp/>bufferImageGranularity)</highlight></codeline>
<codeline lineno="9066"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9067"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>nextSuballocIndex<sp/>=<sp/>index1st;</highlight></codeline>
<codeline lineno="9068"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nextSuballocIndex<sp/>&lt;<sp/>suballocations1st.size();</highlight></codeline>
<codeline lineno="9069"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nextSuballocIndex++)</highlight></codeline>
<codeline lineno="9070"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9071"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>nextSuballoc<sp/>=<sp/>suballocations1st[nextSuballocIndex];</highlight></codeline>
<codeline lineno="9072"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(VmaBlocksOnSamePage(resultOffset,<sp/>allocSize,<sp/>nextSuballoc.offset,<sp/>bufferImageGranularity))</highlight></codeline>
<codeline lineno="9073"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9074"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(VmaIsBufferImageGranularityConflict(allocType,<sp/>nextSuballoc.type))</highlight></codeline>
<codeline lineno="9075"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9076"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9077"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9078"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9079"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9080"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9081"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Already<sp/>on<sp/>next<sp/>page.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9082"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9083"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9084"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9085"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9086"><highlight class="normal"></highlight></codeline>
<codeline lineno="9087"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>All<sp/>tests<sp/>passed:<sp/>Success.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9088"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocationRequest-&gt;allocHandle<sp/>=<sp/>(VmaAllocHandle)(resultOffset<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="9089"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocationRequest-&gt;type<sp/>=<sp/>VmaAllocationRequestType::EndOf2nd;</highlight></codeline>
<codeline lineno="9090"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>pAllocationRequest-&gt;item,<sp/>customData<sp/>unused.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9091"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9092"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9093"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9094"><highlight class="normal"></highlight></codeline>
<codeline lineno="9095"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9096"><highlight class="normal">}</highlight></codeline>
<codeline lineno="9097"><highlight class="normal"></highlight></codeline>
<codeline lineno="9098"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Linear::CreateAllocationRequest_UpperAddress(</highlight></codeline>
<codeline lineno="9099"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocSize,</highlight></codeline>
<codeline lineno="9100"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocAlignment,</highlight></codeline>
<codeline lineno="9101"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>allocType,</highlight></codeline>
<codeline lineno="9102"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>strategy,</highlight></codeline>
<codeline lineno="9103"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocationRequest*<sp/>pAllocationRequest)</highlight></codeline>
<codeline lineno="9104"><highlight class="normal">{</highlight></codeline>
<codeline lineno="9105"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>blockSize<sp/>=<sp/>GetSize();</highlight></codeline>
<codeline lineno="9106"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>bufferImageGranularity<sp/>=<sp/>GetBufferImageGranularity();</highlight></codeline>
<codeline lineno="9107"><highlight class="normal"><sp/><sp/><sp/><sp/>SuballocationVectorType&amp;<sp/>suballocations1st<sp/>=<sp/>AccessSuballocations1st();</highlight></codeline>
<codeline lineno="9108"><highlight class="normal"><sp/><sp/><sp/><sp/>SuballocationVectorType&amp;<sp/>suballocations2nd<sp/>=<sp/>AccessSuballocations2nd();</highlight></codeline>
<codeline lineno="9109"><highlight class="normal"></highlight></codeline>
<codeline lineno="9110"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_2ndVectorMode<sp/>==<sp/>SECOND_VECTOR_RING_BUFFER)</highlight></codeline>
<codeline lineno="9111"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9112"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Trying<sp/>to<sp/>use<sp/>pool<sp/>with<sp/>linear<sp/>algorithm<sp/>as<sp/>double<sp/>stack,<sp/>while<sp/>it<sp/>is<sp/>already<sp/>being<sp/>used<sp/>as<sp/>ring<sp/>buffer.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="9113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9114"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9115"><highlight class="normal"></highlight></codeline>
<codeline lineno="9116"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Try<sp/>to<sp/>allocate<sp/>before<sp/>2nd.back(),<sp/>or<sp/>end<sp/>of<sp/>block<sp/>if<sp/>2nd.empty().</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9117"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(allocSize<sp/>&gt;<sp/>blockSize)</highlight></codeline>
<codeline lineno="9118"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9119"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9120"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9121"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>resultBaseOffset<sp/>=<sp/>blockSize<sp/>-<sp/>allocSize;</highlight></codeline>
<codeline lineno="9122"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!suballocations2nd.empty())</highlight></codeline>
<codeline lineno="9123"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9124"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>lastSuballoc<sp/>=<sp/>suballocations2nd.back();</highlight></codeline>
<codeline lineno="9125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>resultBaseOffset<sp/>=<sp/>lastSuballoc.offset<sp/>-<sp/>allocSize;</highlight></codeline>
<codeline lineno="9126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(allocSize<sp/>&gt;<sp/>lastSuballoc.offset)</highlight></codeline>
<codeline lineno="9127"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9128"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9129"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9130"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9131"><highlight class="normal"></highlight></codeline>
<codeline lineno="9132"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Start<sp/>from<sp/>offset<sp/>equal<sp/>to<sp/>end<sp/>of<sp/>free<sp/>space.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9133"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>resultOffset<sp/>=<sp/>resultBaseOffset;</highlight></codeline>
<codeline lineno="9134"><highlight class="normal"></highlight></codeline>
<codeline lineno="9135"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>debugMargin<sp/>=<sp/>GetDebugMargin();</highlight></codeline>
<codeline lineno="9136"><highlight class="normal"></highlight></codeline>
<codeline lineno="9137"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Apply<sp/>debugMargin<sp/>at<sp/>the<sp/>end.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9138"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(debugMargin<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="9139"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9140"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(resultOffset<sp/>&lt;<sp/>debugMargin)</highlight></codeline>
<codeline lineno="9141"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9143"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9144"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>resultOffset<sp/>-=<sp/>debugMargin;</highlight></codeline>
<codeline lineno="9145"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9146"><highlight class="normal"></highlight></codeline>
<codeline lineno="9147"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Apply<sp/>alignment.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9148"><highlight class="normal"><sp/><sp/><sp/><sp/>resultOffset<sp/>=<sp/>VmaAlignDown(resultOffset,<sp/>allocAlignment);</highlight></codeline>
<codeline lineno="9149"><highlight class="normal"></highlight></codeline>
<codeline lineno="9150"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>next<sp/>suballocations<sp/>from<sp/>2nd<sp/>for<sp/>BufferImageGranularity<sp/>conflicts.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9151"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Make<sp/>bigger<sp/>alignment<sp/>if<sp/>necessary.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9152"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(bufferImageGranularity<sp/>&gt;<sp/>1<sp/>&amp;&amp;<sp/>bufferImageGranularity<sp/>!=<sp/>allocAlignment<sp/>&amp;&amp;<sp/>!suballocations2nd.empty())</highlight></codeline>
<codeline lineno="9153"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9154"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>bufferImageGranularityConflict<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>nextSuballocIndex<sp/>=<sp/>suballocations2nd.size();<sp/>nextSuballocIndex--;<sp/>)</highlight></codeline>
<codeline lineno="9156"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9157"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>nextSuballoc<sp/>=<sp/>suballocations2nd[nextSuballocIndex];</highlight></codeline>
<codeline lineno="9158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(VmaBlocksOnSamePage(resultOffset,<sp/>allocSize,<sp/>nextSuballoc.offset,<sp/>bufferImageGranularity))</highlight></codeline>
<codeline lineno="9159"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9160"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(VmaIsBufferImageGranularityConflict(nextSuballoc.type,<sp/>allocType))</highlight></codeline>
<codeline lineno="9161"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9162"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bufferImageGranularityConflict<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9163"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9164"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9165"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9166"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Already<sp/>on<sp/>previous<sp/>page.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9168"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9170"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(bufferImageGranularityConflict)</highlight></codeline>
<codeline lineno="9171"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9172"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>resultOffset<sp/>=<sp/>VmaAlignDown(resultOffset,<sp/>bufferImageGranularity);</highlight></codeline>
<codeline lineno="9173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9174"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9175"><highlight class="normal"></highlight></codeline>
<codeline lineno="9176"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>There<sp/>is<sp/>enough<sp/>free<sp/>space.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9177"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>endOf1st<sp/>=<sp/>!suballocations1st.empty()<sp/>?</highlight></codeline>
<codeline lineno="9178"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocations1st.back().offset<sp/>+<sp/>suballocations1st.back().size<sp/>:</highlight></codeline>
<codeline lineno="9179"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0;</highlight></codeline>
<codeline lineno="9180"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(endOf1st<sp/>+<sp/>debugMargin<sp/>&lt;=<sp/>resultOffset)</highlight></codeline>
<codeline lineno="9181"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>previous<sp/>suballocations<sp/>for<sp/>BufferImageGranularity<sp/>conflicts.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>conflict<sp/>exists,<sp/>allocation<sp/>cannot<sp/>be<sp/>made<sp/>here.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(bufferImageGranularity<sp/>&gt;<sp/>1)</highlight></codeline>
<codeline lineno="9185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>prevSuballocIndex<sp/>=<sp/>suballocations1st.size();<sp/>prevSuballocIndex--;<sp/>)</highlight></codeline>
<codeline lineno="9187"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9188"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaSuballocation&amp;<sp/>prevSuballoc<sp/>=<sp/>suballocations1st[prevSuballocIndex];</highlight></codeline>
<codeline lineno="9189"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(VmaBlocksOnSamePage(prevSuballoc.offset,<sp/>prevSuballoc.size,<sp/>resultOffset,<sp/>bufferImageGranularity))</highlight></codeline>
<codeline lineno="9190"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9191"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(VmaIsBufferImageGranularityConflict(allocType,<sp/>prevSuballoc.type))</highlight></codeline>
<codeline lineno="9192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9193"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9194"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9196"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9198"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Already<sp/>on<sp/>next<sp/>page.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9203"><highlight class="normal"></highlight></codeline>
<codeline lineno="9204"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>All<sp/>tests<sp/>passed:<sp/>Success.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9205"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocationRequest-&gt;allocHandle<sp/>=<sp/>(VmaAllocHandle)(resultOffset<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="9206"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>pAllocationRequest-&gt;item<sp/>unused.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9207"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocationRequest-&gt;type<sp/>=<sp/>VmaAllocationRequestType::UpperAddress;</highlight></codeline>
<codeline lineno="9208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9209"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9210"><highlight class="normal"></highlight></codeline>
<codeline lineno="9211"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9212"><highlight class="normal">}</highlight></codeline>
<codeline lineno="9213"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_BLOCK_METADATA_LINEAR_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9214"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_BLOCK_METADATA_LINEAR</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9215"><highlight class="normal"></highlight></codeline>
<codeline lineno="9216"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9217"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_BLOCK_METADATA_BUDDY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9218"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="9219"><highlight class="comment">-<sp/>GetSize()<sp/>is<sp/>the<sp/>original<sp/>size<sp/>of<sp/>allocated<sp/>memory<sp/>block.</highlight></codeline>
<codeline lineno="9220"><highlight class="comment">-<sp/>m_UsableSize<sp/>is<sp/>this<sp/>size<sp/>aligned<sp/>down<sp/>to<sp/>a<sp/>power<sp/>of<sp/>two.</highlight></codeline>
<codeline lineno="9221"><highlight class="comment"><sp/><sp/>All<sp/>allocations<sp/>and<sp/>calculations<sp/>happen<sp/>relative<sp/>to<sp/>m_UsableSize.</highlight></codeline>
<codeline lineno="9222"><highlight class="comment">-<sp/>GetUnusableSize()<sp/>is<sp/>the<sp/>difference<sp/>between<sp/>them.</highlight></codeline>
<codeline lineno="9223"><highlight class="comment"><sp/><sp/>It<sp/>is<sp/>reported<sp/>as<sp/>separate,<sp/>unused<sp/>range,<sp/>not<sp/>available<sp/>for<sp/>allocations.</highlight></codeline>
<codeline lineno="9224"><highlight class="comment"></highlight></codeline>
<codeline lineno="9225"><highlight class="comment">Node<sp/>at<sp/>level<sp/>0<sp/>has<sp/>size<sp/>=<sp/>m_UsableSize.</highlight></codeline>
<codeline lineno="9226"><highlight class="comment">Each<sp/>next<sp/>level<sp/>contains<sp/>nodes<sp/>with<sp/>size<sp/>2<sp/>times<sp/>smaller<sp/>than<sp/>current<sp/>level.</highlight></codeline>
<codeline lineno="9227"><highlight class="comment">m_LevelCount<sp/>is<sp/>the<sp/>maximum<sp/>number<sp/>of<sp/>levels<sp/>to<sp/>use<sp/>in<sp/>the<sp/>current<sp/>object.</highlight></codeline>
<codeline lineno="9228"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9229"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaBlockMetadata_Buddy<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>VmaBlockMetadata</highlight></codeline>
<codeline lineno="9230"><highlight class="normal">{</highlight></codeline>
<codeline lineno="9231"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_CLASS_NO_COPY(VmaBlockMetadata_Buddy)</highlight></codeline>
<codeline lineno="9232"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="9233"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaBlockMetadata_Buddy(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks,</highlight></codeline>
<codeline lineno="9234"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>bufferImageGranularity,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isVirtual);</highlight></codeline>
<codeline lineno="9235"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>~VmaBlockMetadata_Buddy();</highlight></codeline>
<codeline lineno="9236"><highlight class="normal"></highlight></codeline>
<codeline lineno="9237"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>GetAllocationCount()</highlight><highlight class="keyword"><sp/>const<sp/>override<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_AllocationCount;<sp/>}</highlight></codeline>
<codeline lineno="9238"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>GetSumFreeSize()</highlight><highlight class="keyword"><sp/>const<sp/>override<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_SumFreeSize<sp/>+<sp/>GetUnusableSize();<sp/>}</highlight></codeline>
<codeline lineno="9239"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>IsEmpty()</highlight><highlight class="keyword"><sp/>const<sp/>override<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Root-&gt;type<sp/>==<sp/>Node::TYPE_FREE;<sp/>}</highlight></codeline>
<codeline lineno="9240"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>CheckCorruption(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pBlockData)</highlight><highlight class="keyword"><sp/>override<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_FEATURE_NOT_PRESENT;<sp/>}</highlight></codeline>
<codeline lineno="9241"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>GetAllocationOffset(VmaAllocHandle<sp/>allocHandle)</highlight><highlight class="keyword"><sp/>const<sp/>override<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(VkDeviceSize)allocHandle<sp/>-<sp/>1;<sp/>};</highlight></codeline>
<codeline lineno="9242"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DebugLogAllAllocations()</highlight><highlight class="keyword"><sp/>const<sp/>override<sp/></highlight><highlight class="normal">{<sp/>DebugLogAllAllocationNode(m_Root,<sp/>0);<sp/>}</highlight></codeline>
<codeline lineno="9243"><highlight class="normal"></highlight></codeline>
<codeline lineno="9244"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Init(VkDeviceSize<sp/>size)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9245"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>Validate()<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9246"><highlight class="normal"></highlight></codeline>
<codeline lineno="9247"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>AddDetailedStatistics(<ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>&amp;<sp/>inoutStats)<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9248"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>AddStatistics(<ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref>&amp;<sp/>inoutStats)<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9249"><highlight class="normal"></highlight></codeline>
<codeline lineno="9250"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9251"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>PrintDetailedMap(</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>VmaJsonWriter&amp;<sp/>json,<sp/>uint32_t<sp/>mapRefCount)<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9252"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9253"><highlight class="normal"></highlight></codeline>
<codeline lineno="9254"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>CreateAllocationRequest(</highlight></codeline>
<codeline lineno="9255"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocSize,</highlight></codeline>
<codeline lineno="9256"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocAlignment,</highlight></codeline>
<codeline lineno="9257"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>upperAddress,</highlight></codeline>
<codeline lineno="9258"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>allocType,</highlight></codeline>
<codeline lineno="9259"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>strategy,</highlight></codeline>
<codeline lineno="9260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAllocationRequest*<sp/>pAllocationRequest)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9261"><highlight class="normal"></highlight></codeline>
<codeline lineno="9262"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Alloc(</highlight></codeline>
<codeline lineno="9263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaAllocationRequest&amp;<sp/>request,</highlight></codeline>
<codeline lineno="9264"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>type,</highlight></codeline>
<codeline lineno="9265"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>userData)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9266"><highlight class="normal"></highlight></codeline>
<codeline lineno="9267"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Free(VmaAllocHandle<sp/>allocHandle)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9268"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GetAllocationInfo(VmaAllocHandle<sp/>allocHandle,<sp/><ref refid="struct_vma_virtual_allocation_info" kindref="compound">VmaVirtualAllocationInfo</ref>&amp;<sp/>outInfo)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9269"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>GetAllocationUserData(VmaAllocHandle<sp/>allocHandle)<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9270"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocHandle<sp/>GetAllocationListBegin()<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9271"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocHandle<sp/>GetNextAllocation(VmaAllocHandle<sp/>prevAlloc)<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9272"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Clear()<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9273"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>SetAllocationUserData(VmaAllocHandle<sp/>allocHandle,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>userData)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9274"><highlight class="normal"></highlight></codeline>
<codeline lineno="9275"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="9276"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>MAX_LEVELS<sp/>=<sp/>48;</highlight></codeline>
<codeline lineno="9277"><highlight class="normal"></highlight></codeline>
<codeline lineno="9278"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">ValidationContext</highlight></codeline>
<codeline lineno="9279"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9280"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>calculatedAllocationCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="9281"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>calculatedFreeCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="9282"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>calculatedSumFreeSize<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="9283"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="9284"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">Node</highlight></codeline>
<codeline lineno="9285"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9286"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>offset;</highlight></codeline>
<codeline lineno="9287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/>TYPE</highlight></codeline>
<codeline lineno="9288"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9289"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TYPE_FREE,</highlight></codeline>
<codeline lineno="9290"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TYPE_ALLOCATION,</highlight></codeline>
<codeline lineno="9291"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TYPE_SPLIT,</highlight></codeline>
<codeline lineno="9292"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TYPE_COUNT</highlight></codeline>
<codeline lineno="9293"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>type;</highlight></codeline>
<codeline lineno="9294"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node*<sp/>parent;</highlight></codeline>
<codeline lineno="9295"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node*<sp/>buddy;</highlight></codeline>
<codeline lineno="9296"><highlight class="normal"></highlight></codeline>
<codeline lineno="9297"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">union</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9298"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9299"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9300"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9301"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node*<sp/>prev;</highlight></codeline>
<codeline lineno="9302"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node*<sp/>next;</highlight></codeline>
<codeline lineno="9303"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>free;</highlight></codeline>
<codeline lineno="9304"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9305"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9306"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>userData;</highlight></codeline>
<codeline lineno="9307"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/>allocation;</highlight></codeline>
<codeline lineno="9308"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9309"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9310"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node*<sp/>leftChild;</highlight></codeline>
<codeline lineno="9311"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/><ref refid="namespacevlkxtemp_1a25b1d4d7ac9a80fab1c584cba39c9420" kindref="member">split</ref>;</highlight></codeline>
<codeline lineno="9312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="9313"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="9314"><highlight class="normal"></highlight></codeline>
<codeline lineno="9315"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Size<sp/>of<sp/>the<sp/>memory<sp/>block<sp/>aligned<sp/>down<sp/>to<sp/>a<sp/>power<sp/>of<sp/>two.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9316"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>m_UsableSize;</highlight></codeline>
<codeline lineno="9317"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>m_LevelCount;</highlight></codeline>
<codeline lineno="9318"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaPoolAllocator&lt;Node&gt;<sp/>m_NodeAllocator;</highlight></codeline>
<codeline lineno="9319"><highlight class="normal"><sp/><sp/><sp/><sp/>Node*<sp/>m_Root;</highlight></codeline>
<codeline lineno="9320"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9321"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9322"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node*<sp/>front;</highlight></codeline>
<codeline lineno="9323"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node*<sp/>back;</highlight></codeline>
<codeline lineno="9324"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/>m_FreeList[MAX_LEVELS];</highlight></codeline>
<codeline lineno="9325"><highlight class="normal"></highlight></codeline>
<codeline lineno="9326"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Number<sp/>of<sp/>nodes<sp/>in<sp/>the<sp/>tree<sp/>with<sp/>type<sp/>==<sp/>TYPE_ALLOCATION.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9327"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>m_AllocationCount;</highlight></codeline>
<codeline lineno="9328"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Number<sp/>of<sp/>nodes<sp/>in<sp/>the<sp/>tree<sp/>with<sp/>type<sp/>==<sp/>TYPE_FREE.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9329"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>m_FreeCount;</highlight></codeline>
<codeline lineno="9330"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Doesn&apos;t<sp/>include<sp/>space<sp/>wasted<sp/>due<sp/>to<sp/>internal<sp/>fragmentation<sp/>-<sp/>allocation<sp/>sizes<sp/>are<sp/>just<sp/>aligned<sp/>up<sp/>to<sp/>node<sp/>sizes.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9331"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Doesn&apos;t<sp/>include<sp/>unusable<sp/>size.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9332"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>m_SumFreeSize;</highlight></codeline>
<codeline lineno="9333"><highlight class="normal"></highlight></codeline>
<codeline lineno="9334"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>GetUnusableSize()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>GetSize()<sp/>-<sp/>m_UsableSize;<sp/>}</highlight></codeline>
<codeline lineno="9335"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>LevelToNodeSize(uint32_t<sp/>level)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_UsableSize<sp/>&gt;&gt;<sp/>level;<sp/>}</highlight></codeline>
<codeline lineno="9336"><highlight class="normal"></highlight></codeline>
<codeline lineno="9337"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>AlignAllocationSize(VkDeviceSize<sp/>size)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="9338"><highlight class="keyword"><sp/><sp/><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="9339"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!IsVirtual())</highlight></codeline>
<codeline lineno="9340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size<sp/>=<sp/>VmaAlignUp(size,<sp/>(VkDeviceSize)16);</highlight></codeline>
<codeline lineno="9342"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VmaNextPow2(size);</highlight></codeline>
<codeline lineno="9344"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9345"><highlight class="normal"><sp/><sp/><sp/><sp/>Node*<sp/>FindAllocationNode(VkDeviceSize<sp/>offset,<sp/>uint32_t&amp;<sp/>outLevel)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9346"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DeleteNodeChildren(Node*<sp/>node);</highlight></codeline>
<codeline lineno="9347"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>ValidateNode(ValidationContext&amp;<sp/>ctx,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Node*<sp/>parent,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Node*<sp/>curr,<sp/>uint32_t<sp/>level,<sp/>VkDeviceSize<sp/>levelNodeSize)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9348"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>AllocSizeToLevel(VkDeviceSize<sp/>allocSize)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9349"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>AddNodeToDetailedStatistics(<ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>&amp;<sp/>inoutStats,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Node*<sp/>node,<sp/>VkDeviceSize<sp/>levelNodeSize)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9350"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Adds<sp/>node<sp/>to<sp/>the<sp/>front<sp/>of<sp/>FreeList<sp/>at<sp/>given<sp/>level.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9351"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>node-&gt;type<sp/>must<sp/>be<sp/>FREE.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9352"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>node-&gt;free.prev,<sp/>next<sp/>can<sp/>be<sp/>undefined.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9353"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>AddToFreeListFront(uint32_t<sp/>level,<sp/>Node*<sp/>node);</highlight></codeline>
<codeline lineno="9354"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Removes<sp/>node<sp/>from<sp/>FreeList<sp/>at<sp/>given<sp/>level.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9355"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>node-&gt;type<sp/>must<sp/>be<sp/>FREE.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9356"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>node-&gt;free.prev,<sp/>next<sp/>stay<sp/>untouched.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9357"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>RemoveFromFreeList(uint32_t<sp/>level,<sp/>Node*<sp/>node);</highlight></codeline>
<codeline lineno="9358"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DebugLogAllAllocationNode(Node*<sp/>node,<sp/>uint32_t<sp/>level)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9359"><highlight class="normal"></highlight></codeline>
<codeline lineno="9360"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9361"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>PrintDetailedMapNode(</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>VmaJsonWriter&amp;<sp/>json,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Node*<sp/>node,<sp/>VkDeviceSize<sp/>levelNodeSize)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9362"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9363"><highlight class="normal">};</highlight></codeline>
<codeline lineno="9364"><highlight class="normal"></highlight></codeline>
<codeline lineno="9365"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_BLOCK_METADATA_BUDDY_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9366"><highlight class="normal">VmaBlockMetadata_Buddy::VmaBlockMetadata_Buddy(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks,</highlight></codeline>
<codeline lineno="9367"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>bufferImageGranularity,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isVirtual)</highlight></codeline>
<codeline lineno="9368"><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>VmaBlockMetadata(pAllocationCallbacks,<sp/>bufferImageGranularity,<sp/>isVirtual),</highlight></codeline>
<codeline lineno="9369"><highlight class="normal"><sp/><sp/><sp/><sp/>m_NodeAllocator(pAllocationCallbacks,<sp/>32),<sp/></highlight><highlight class="comment">//<sp/>firstBlockCapacity</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9370"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Root(VMA_NULL),</highlight></codeline>
<codeline lineno="9371"><highlight class="normal"><sp/><sp/><sp/><sp/>m_AllocationCount(0),</highlight></codeline>
<codeline lineno="9372"><highlight class="normal"><sp/><sp/><sp/><sp/>m_FreeCount(1),</highlight></codeline>
<codeline lineno="9373"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SumFreeSize(0)</highlight></codeline>
<codeline lineno="9374"><highlight class="normal">{</highlight></codeline>
<codeline lineno="9375"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(m_FreeList,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(m_FreeList));</highlight></codeline>
<codeline lineno="9376"><highlight class="normal">}</highlight></codeline>
<codeline lineno="9377"><highlight class="normal"></highlight></codeline>
<codeline lineno="9378"><highlight class="normal">VmaBlockMetadata_Buddy::~VmaBlockMetadata_Buddy()</highlight></codeline>
<codeline lineno="9379"><highlight class="normal">{</highlight></codeline>
<codeline lineno="9380"><highlight class="normal"><sp/><sp/><sp/><sp/>DeleteNodeChildren(m_Root);</highlight></codeline>
<codeline lineno="9381"><highlight class="normal"><sp/><sp/><sp/><sp/>m_NodeAllocator.Free(m_Root);</highlight></codeline>
<codeline lineno="9382"><highlight class="normal">}</highlight></codeline>
<codeline lineno="9383"><highlight class="normal"></highlight></codeline>
<codeline lineno="9384"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Buddy::Init(VkDeviceSize<sp/>size)</highlight></codeline>
<codeline lineno="9385"><highlight class="normal">{</highlight></codeline>
<codeline lineno="9386"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaBlockMetadata::Init(size);</highlight></codeline>
<codeline lineno="9387"><highlight class="normal"></highlight></codeline>
<codeline lineno="9388"><highlight class="normal"><sp/><sp/><sp/><sp/>m_UsableSize<sp/>=<sp/>VmaPrevPow2(size);</highlight></codeline>
<codeline lineno="9389"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SumFreeSize<sp/>=<sp/>m_UsableSize;</highlight></codeline>
<codeline lineno="9390"><highlight class="normal"></highlight></codeline>
<codeline lineno="9391"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Calculate<sp/>m_LevelCount.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9392"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>minNodeSize<sp/>=<sp/>IsVirtual()<sp/>?<sp/>1<sp/>:<sp/>16;</highlight></codeline>
<codeline lineno="9393"><highlight class="normal"><sp/><sp/><sp/><sp/>m_LevelCount<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="9394"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(m_LevelCount<sp/>&lt;<sp/>MAX_LEVELS<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="9395"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>LevelToNodeSize(m_LevelCount)<sp/>&gt;=<sp/>minNodeSize)</highlight></codeline>
<codeline lineno="9396"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9397"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++m_LevelCount;</highlight></codeline>
<codeline lineno="9398"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9399"><highlight class="normal"></highlight></codeline>
<codeline lineno="9400"><highlight class="normal"><sp/><sp/><sp/><sp/>Node*<sp/>rootNode<sp/>=<sp/>m_NodeAllocator.Alloc();</highlight></codeline>
<codeline lineno="9401"><highlight class="normal"><sp/><sp/><sp/><sp/>rootNode-&gt;offset<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="9402"><highlight class="normal"><sp/><sp/><sp/><sp/>rootNode-&gt;type<sp/>=<sp/>Node::TYPE_FREE;</highlight></codeline>
<codeline lineno="9403"><highlight class="normal"><sp/><sp/><sp/><sp/>rootNode-&gt;parent<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="9404"><highlight class="normal"><sp/><sp/><sp/><sp/>rootNode-&gt;buddy<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="9405"><highlight class="normal"></highlight></codeline>
<codeline lineno="9406"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Root<sp/>=<sp/>rootNode;</highlight></codeline>
<codeline lineno="9407"><highlight class="normal"><sp/><sp/><sp/><sp/>AddToFreeListFront(0,<sp/>rootNode);</highlight></codeline>
<codeline lineno="9408"><highlight class="normal">}</highlight></codeline>
<codeline lineno="9409"><highlight class="normal"></highlight></codeline>
<codeline lineno="9410"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Buddy::Validate()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="9411"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="9412"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Validate<sp/>tree.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9413"><highlight class="normal"><sp/><sp/><sp/><sp/>ValidationContext<sp/>ctx;</highlight></codeline>
<codeline lineno="9414"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ValidateNode(ctx,<sp/>VMA_NULL,<sp/>m_Root,<sp/>0,<sp/>LevelToNodeSize(0)))</highlight></codeline>
<codeline lineno="9415"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9416"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(</highlight><highlight class="keyword">false</highlight><highlight class="normal"><sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;ValidateNode<sp/>failed.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="9417"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9418"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE(m_AllocationCount<sp/>==<sp/>ctx.calculatedAllocationCount);</highlight></codeline>
<codeline lineno="9419"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE(m_SumFreeSize<sp/>==<sp/>ctx.calculatedSumFreeSize);</highlight></codeline>
<codeline lineno="9420"><highlight class="normal"></highlight></codeline>
<codeline lineno="9421"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Validate<sp/>free<sp/>node<sp/>lists.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9422"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(uint32_t<sp/>level<sp/>=<sp/>0;<sp/>level<sp/>&lt;<sp/>m_LevelCount;<sp/>++level)</highlight></codeline>
<codeline lineno="9423"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9424"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(m_FreeList[level].front<sp/>==<sp/>VMA_NULL<sp/>||</highlight></codeline>
<codeline lineno="9425"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_FreeList[level].front-&gt;free.prev<sp/>==<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="9426"><highlight class="normal"></highlight></codeline>
<codeline lineno="9427"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(Node*<sp/>node<sp/>=<sp/>m_FreeList[level].front;</highlight></codeline>
<codeline lineno="9428"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node<sp/>!=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="9429"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node<sp/>=<sp/>node-&gt;free.next)</highlight></codeline>
<codeline lineno="9430"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9431"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(node-&gt;type<sp/>==<sp/>Node::TYPE_FREE);</highlight></codeline>
<codeline lineno="9432"><highlight class="normal"></highlight></codeline>
<codeline lineno="9433"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(node-&gt;free.next<sp/>==<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="9434"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9435"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(m_FreeList[level].back<sp/>==<sp/>node);</highlight></codeline>
<codeline lineno="9436"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9437"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9438"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9439"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(node-&gt;free.next-&gt;free.prev<sp/>==<sp/>node);</highlight></codeline>
<codeline lineno="9440"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9441"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9442"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9443"><highlight class="normal"></highlight></codeline>
<codeline lineno="9444"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Validate<sp/>that<sp/>free<sp/>lists<sp/>ar<sp/>higher<sp/>levels<sp/>are<sp/>empty.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9445"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(uint32_t<sp/>level<sp/>=<sp/>m_LevelCount;<sp/>level<sp/>&lt;<sp/>MAX_LEVELS;<sp/>++level)</highlight></codeline>
<codeline lineno="9446"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9447"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(m_FreeList[level].front<sp/>==<sp/>VMA_NULL<sp/>&amp;&amp;<sp/>m_FreeList[level].back<sp/>==<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="9448"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9449"><highlight class="normal"></highlight></codeline>
<codeline lineno="9450"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9451"><highlight class="normal">}</highlight></codeline>
<codeline lineno="9452"><highlight class="normal"></highlight></codeline>
<codeline lineno="9453"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Buddy::AddDetailedStatistics(<ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>&amp;<sp/>inoutStats)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="9454"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="9455"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1a309179d5853a6a7cd534df497ee43957" kindref="member">blockCount</ref>++;</highlight></codeline>
<codeline lineno="9456"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1a2afbc1c7aa8ad7bbb8de06215ba7e5c4" kindref="member">blockBytes</ref><sp/>+=<sp/>GetSize();</highlight></codeline>
<codeline lineno="9457"><highlight class="normal"></highlight></codeline>
<codeline lineno="9458"><highlight class="normal"><sp/><sp/><sp/><sp/>AddNodeToDetailedStatistics(inoutStats,<sp/>m_Root,<sp/>LevelToNodeSize(0));</highlight></codeline>
<codeline lineno="9459"><highlight class="normal"></highlight></codeline>
<codeline lineno="9460"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>unusableSize<sp/>=<sp/>GetUnusableSize();</highlight></codeline>
<codeline lineno="9461"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(unusableSize<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="9462"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAddDetailedStatisticsUnusedRange(inoutStats,<sp/>unusableSize);</highlight></codeline>
<codeline lineno="9463"><highlight class="normal">}</highlight></codeline>
<codeline lineno="9464"><highlight class="normal"></highlight></codeline>
<codeline lineno="9465"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Buddy::AddStatistics(<ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref>&amp;<sp/>inoutStats)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="9466"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="9467"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_statistics_1a309179d5853a6a7cd534df497ee43957" kindref="member">blockCount</ref>++;</highlight></codeline>
<codeline lineno="9468"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_statistics_1ab0ff76e50f58f9f54b6f265e5bf5dde2" kindref="member">allocationCount</ref><sp/>+=<sp/>(uint32_t)m_AllocationCount;</highlight></codeline>
<codeline lineno="9469"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_statistics_1a2afbc1c7aa8ad7bbb8de06215ba7e5c4" kindref="member">blockBytes</ref><sp/>+=<sp/>GetSize();</highlight></codeline>
<codeline lineno="9470"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_statistics_1a21db06eba3422f87a2b4b4703d879c16" kindref="member">allocationBytes</ref><sp/>+=<sp/>GetSize()<sp/>-<sp/>m_SumFreeSize;</highlight></codeline>
<codeline lineno="9471"><highlight class="normal">}</highlight></codeline>
<codeline lineno="9472"><highlight class="normal"></highlight></codeline>
<codeline lineno="9473"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9474"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Buddy::PrintDetailedMap(</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>VmaJsonWriter&amp;<sp/>json,<sp/>uint32_t<sp/>mapRefCount)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="9475"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="9476"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref><sp/>stats;</highlight></codeline>
<codeline lineno="9477"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaClearDetailedStatistics(stats);</highlight></codeline>
<codeline lineno="9478"><highlight class="normal"><sp/><sp/><sp/><sp/>AddDetailedStatistics(stats);</highlight></codeline>
<codeline lineno="9479"><highlight class="normal"></highlight></codeline>
<codeline lineno="9480"><highlight class="normal"><sp/><sp/><sp/><sp/>PrintDetailedMap_Begin(</highlight></codeline>
<codeline lineno="9481"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json,</highlight></codeline>
<codeline lineno="9482"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stats.<ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1a2afbc1c7aa8ad7bbb8de06215ba7e5c4" kindref="member">blockBytes</ref><sp/>-<sp/>stats.<ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1a21db06eba3422f87a2b4b4703d879c16" kindref="member">allocationBytes</ref>,</highlight></codeline>
<codeline lineno="9483"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stats.<ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1ab0ff76e50f58f9f54b6f265e5bf5dde2" kindref="member">allocationCount</ref>,</highlight></codeline>
<codeline lineno="9484"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stats.<ref refid="struct_vma_detailed_statistics_1ab721bf04892e8b67802d4ddb7734638a" kindref="member">unusedRangeCount</ref>,</highlight></codeline>
<codeline lineno="9485"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mapRefCount);</highlight></codeline>
<codeline lineno="9486"><highlight class="normal"></highlight></codeline>
<codeline lineno="9487"><highlight class="normal"><sp/><sp/><sp/><sp/>PrintDetailedMapNode(json,<sp/>m_Root,<sp/>LevelToNodeSize(0));</highlight></codeline>
<codeline lineno="9488"><highlight class="normal"></highlight></codeline>
<codeline lineno="9489"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>unusableSize<sp/>=<sp/>GetUnusableSize();</highlight></codeline>
<codeline lineno="9490"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(unusableSize<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="9491"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9492"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrintDetailedMap_UnusedRange(json,</highlight></codeline>
<codeline lineno="9493"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_UsableSize,<sp/></highlight><highlight class="comment">//<sp/>offset</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9494"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>unusableSize);<sp/></highlight><highlight class="comment">//<sp/>size</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9495"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9496"><highlight class="normal"></highlight></codeline>
<codeline lineno="9497"><highlight class="normal"><sp/><sp/><sp/><sp/>PrintDetailedMap_End(json);</highlight></codeline>
<codeline lineno="9498"><highlight class="normal">}</highlight></codeline>
<codeline lineno="9499"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9500"><highlight class="normal"></highlight></codeline>
<codeline lineno="9501"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Buddy::CreateAllocationRequest(</highlight></codeline>
<codeline lineno="9502"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocSize,</highlight></codeline>
<codeline lineno="9503"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocAlignment,</highlight></codeline>
<codeline lineno="9504"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>upperAddress,</highlight></codeline>
<codeline lineno="9505"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>allocType,</highlight></codeline>
<codeline lineno="9506"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>strategy,</highlight></codeline>
<codeline lineno="9507"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocationRequest*<sp/>pAllocationRequest)</highlight></codeline>
<codeline lineno="9508"><highlight class="normal">{</highlight></codeline>
<codeline lineno="9509"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(!upperAddress<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT<sp/>can<sp/>be<sp/>used<sp/>only<sp/>with<sp/>linear<sp/>algorithm.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="9510"><highlight class="normal"></highlight></codeline>
<codeline lineno="9511"><highlight class="normal"><sp/><sp/><sp/><sp/>allocSize<sp/>=<sp/>AlignAllocationSize(allocSize);</highlight></codeline>
<codeline lineno="9512"><highlight class="normal"></highlight></codeline>
<codeline lineno="9513"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Simple<sp/>way<sp/>to<sp/>respect<sp/>bufferImageGranularity.<sp/>May<sp/>be<sp/>optimized<sp/>some<sp/>day.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9514"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Whenever<sp/>it<sp/>might<sp/>be<sp/>an<sp/>OPTIMAL<sp/>image...</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9515"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(allocType<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_UNKNOWN<sp/>||</highlight></codeline>
<codeline lineno="9516"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocType<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_IMAGE_UNKNOWN<sp/>||</highlight></codeline>
<codeline lineno="9517"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocType<sp/>==<sp/>VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL)</highlight></codeline>
<codeline lineno="9518"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9519"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocAlignment<sp/>=<sp/>VMA_MAX(allocAlignment,<sp/>GetBufferImageGranularity());</highlight></codeline>
<codeline lineno="9520"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocSize<sp/>=<sp/>VmaAlignUp(allocSize,<sp/>GetBufferImageGranularity());</highlight></codeline>
<codeline lineno="9521"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9522"><highlight class="normal"></highlight></codeline>
<codeline lineno="9523"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(allocSize<sp/>&gt;<sp/>m_UsableSize)</highlight></codeline>
<codeline lineno="9524"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9525"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9526"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9527"><highlight class="normal"></highlight></codeline>
<codeline lineno="9528"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>targetLevel<sp/>=<sp/>AllocSizeToLevel(allocSize);</highlight></codeline>
<codeline lineno="9529"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(uint32_t<sp/>level<sp/>=<sp/>targetLevel;<sp/>level--;<sp/>)</highlight></codeline>
<codeline lineno="9530"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9531"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(Node*<sp/>freeNode<sp/>=<sp/>m_FreeList[level].front;</highlight></codeline>
<codeline lineno="9532"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>freeNode<sp/>!=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="9533"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>freeNode<sp/>=<sp/>freeNode-&gt;free.next)</highlight></codeline>
<codeline lineno="9534"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9535"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(freeNode-&gt;offset<sp/>%<sp/>allocAlignment<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="9536"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9537"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocationRequest-&gt;type<sp/>=<sp/>VmaAllocationRequestType::Normal;</highlight></codeline>
<codeline lineno="9538"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocationRequest-&gt;allocHandle<sp/>=<sp/>(VmaAllocHandle)(freeNode-&gt;offset<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="9539"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocationRequest-&gt;size<sp/>=<sp/>allocSize;</highlight></codeline>
<codeline lineno="9540"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocationRequest-&gt;customData<sp/>=<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)(uintptr_t)level;</highlight></codeline>
<codeline lineno="9541"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9542"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9543"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9544"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9545"><highlight class="normal"></highlight></codeline>
<codeline lineno="9546"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9547"><highlight class="normal">}</highlight></codeline>
<codeline lineno="9548"><highlight class="normal"></highlight></codeline>
<codeline lineno="9549"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Buddy::Alloc(</highlight></codeline>
<codeline lineno="9550"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaAllocationRequest&amp;<sp/>request,</highlight></codeline>
<codeline lineno="9551"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>type,</highlight></codeline>
<codeline lineno="9552"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>userData)</highlight></codeline>
<codeline lineno="9553"><highlight class="normal">{</highlight></codeline>
<codeline lineno="9554"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(request.type<sp/>==<sp/>VmaAllocationRequestType::Normal);</highlight></codeline>
<codeline lineno="9555"><highlight class="normal"></highlight></codeline>
<codeline lineno="9556"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>targetLevel<sp/>=<sp/>AllocSizeToLevel(request.size);</highlight></codeline>
<codeline lineno="9557"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>currLevel<sp/>=<sp/>(uint32_t)(uintptr_t)request.customData;</highlight></codeline>
<codeline lineno="9558"><highlight class="normal"></highlight></codeline>
<codeline lineno="9559"><highlight class="normal"><sp/><sp/><sp/><sp/>Node*<sp/>currNode<sp/>=<sp/>m_FreeList[currLevel].front;</highlight></codeline>
<codeline lineno="9560"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(currNode<sp/>!=<sp/>VMA_NULL<sp/>&amp;&amp;<sp/>currNode-&gt;type<sp/>==<sp/>Node::TYPE_FREE);</highlight></codeline>
<codeline lineno="9561"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>offset<sp/>=<sp/>(VkDeviceSize)request.allocHandle<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="9562"><highlight class="normal"><sp/><sp/><sp/><sp/>while<sp/>(currNode-&gt;offset<sp/>!=<sp/>offset)</highlight></codeline>
<codeline lineno="9563"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9564"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>currNode<sp/>=<sp/>currNode-&gt;free.next;</highlight></codeline>
<codeline lineno="9565"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(currNode<sp/>!=<sp/>VMA_NULL<sp/>&amp;&amp;<sp/>currNode-&gt;type<sp/>==<sp/>Node::TYPE_FREE);</highlight></codeline>
<codeline lineno="9566"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9567"><highlight class="normal"></highlight></codeline>
<codeline lineno="9568"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>down,<sp/>splitting<sp/>free<sp/>nodes.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9569"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(currLevel<sp/>&lt;<sp/>targetLevel)</highlight></codeline>
<codeline lineno="9570"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9571"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>currNode<sp/>is<sp/>already<sp/>first<sp/>free<sp/>node<sp/>at<sp/>currLevel.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9572"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Remove<sp/>it<sp/>from<sp/>list<sp/>of<sp/>free<sp/>nodes<sp/>at<sp/>this<sp/>currLevel.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9573"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>RemoveFromFreeList(currLevel,<sp/>currNode);</highlight></codeline>
<codeline lineno="9574"><highlight class="normal"></highlight></codeline>
<codeline lineno="9575"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>childrenLevel<sp/>=<sp/>currLevel<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="9576"><highlight class="normal"></highlight></codeline>
<codeline lineno="9577"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>two<sp/>free<sp/>sub-nodes.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9578"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node*<sp/>leftChild<sp/>=<sp/>m_NodeAllocator.Alloc();</highlight></codeline>
<codeline lineno="9579"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node*<sp/>rightChild<sp/>=<sp/>m_NodeAllocator.Alloc();</highlight></codeline>
<codeline lineno="9580"><highlight class="normal"></highlight></codeline>
<codeline lineno="9581"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>leftChild-&gt;offset<sp/>=<sp/>currNode-&gt;offset;</highlight></codeline>
<codeline lineno="9582"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>leftChild-&gt;type<sp/>=<sp/>Node::TYPE_FREE;</highlight></codeline>
<codeline lineno="9583"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>leftChild-&gt;parent<sp/>=<sp/>currNode;</highlight></codeline>
<codeline lineno="9584"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>leftChild-&gt;buddy<sp/>=<sp/>rightChild;</highlight></codeline>
<codeline lineno="9585"><highlight class="normal"></highlight></codeline>
<codeline lineno="9586"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rightChild-&gt;offset<sp/>=<sp/>currNode-&gt;offset<sp/>+<sp/>LevelToNodeSize(childrenLevel);</highlight></codeline>
<codeline lineno="9587"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rightChild-&gt;type<sp/>=<sp/>Node::TYPE_FREE;</highlight></codeline>
<codeline lineno="9588"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rightChild-&gt;parent<sp/>=<sp/>currNode;</highlight></codeline>
<codeline lineno="9589"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rightChild-&gt;buddy<sp/>=<sp/>leftChild;</highlight></codeline>
<codeline lineno="9590"><highlight class="normal"></highlight></codeline>
<codeline lineno="9591"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Convert<sp/>current<sp/>currNode<sp/>to<sp/>split<sp/>type.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9592"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>currNode-&gt;type<sp/>=<sp/>Node::TYPE_SPLIT;</highlight></codeline>
<codeline lineno="9593"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>currNode-&gt;split.leftChild<sp/>=<sp/>leftChild;</highlight></codeline>
<codeline lineno="9594"><highlight class="normal"></highlight></codeline>
<codeline lineno="9595"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Add<sp/>child<sp/>nodes<sp/>to<sp/>free<sp/>list.<sp/>Order<sp/>is<sp/>important!</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9596"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AddToFreeListFront(childrenLevel,<sp/>rightChild);</highlight></codeline>
<codeline lineno="9597"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AddToFreeListFront(childrenLevel,<sp/>leftChild);</highlight></codeline>
<codeline lineno="9598"><highlight class="normal"></highlight></codeline>
<codeline lineno="9599"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++m_FreeCount;</highlight></codeline>
<codeline lineno="9600"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++currLevel;</highlight></codeline>
<codeline lineno="9601"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>currNode<sp/>=<sp/>m_FreeList[currLevel].front;</highlight></codeline>
<codeline lineno="9602"><highlight class="normal"></highlight></codeline>
<codeline lineno="9603"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="9604"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>We<sp/>can<sp/>be<sp/>sure<sp/>that<sp/>currNode,<sp/>as<sp/>left<sp/>child<sp/>of<sp/>node<sp/>previously<sp/>split,</highlight></codeline>
<codeline lineno="9605"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>also<sp/>fulfills<sp/>the<sp/>alignment<sp/>requirement.</highlight></codeline>
<codeline lineno="9606"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9607"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9608"><highlight class="normal"></highlight></codeline>
<codeline lineno="9609"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Remove<sp/>from<sp/>free<sp/>list.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9610"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(currLevel<sp/>==<sp/>targetLevel<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="9611"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>currNode<sp/>!=<sp/>VMA_NULL<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="9612"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>currNode-&gt;type<sp/>==<sp/>Node::TYPE_FREE);</highlight></codeline>
<codeline lineno="9613"><highlight class="normal"><sp/><sp/><sp/><sp/>RemoveFromFreeList(currLevel,<sp/>currNode);</highlight></codeline>
<codeline lineno="9614"><highlight class="normal"></highlight></codeline>
<codeline lineno="9615"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Convert<sp/>to<sp/>allocation<sp/>node.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9616"><highlight class="normal"><sp/><sp/><sp/><sp/>currNode-&gt;type<sp/>=<sp/>Node::TYPE_ALLOCATION;</highlight></codeline>
<codeline lineno="9617"><highlight class="normal"><sp/><sp/><sp/><sp/>currNode-&gt;allocation.userData<sp/>=<sp/>userData;</highlight></codeline>
<codeline lineno="9618"><highlight class="normal"></highlight></codeline>
<codeline lineno="9619"><highlight class="normal"><sp/><sp/><sp/><sp/>++m_AllocationCount;</highlight></codeline>
<codeline lineno="9620"><highlight class="normal"><sp/><sp/><sp/><sp/>--m_FreeCount;</highlight></codeline>
<codeline lineno="9621"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SumFreeSize<sp/>-=<sp/>request.size;</highlight></codeline>
<codeline lineno="9622"><highlight class="normal">}</highlight></codeline>
<codeline lineno="9623"><highlight class="normal"></highlight></codeline>
<codeline lineno="9624"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Buddy::GetAllocationInfo(VmaAllocHandle<sp/>allocHandle,<sp/><ref refid="struct_vma_virtual_allocation_info" kindref="compound">VmaVirtualAllocationInfo</ref>&amp;<sp/>outInfo)</highlight></codeline>
<codeline lineno="9625"><highlight class="normal">{</highlight></codeline>
<codeline lineno="9626"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>level<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="9627"><highlight class="normal"><sp/><sp/><sp/><sp/>outInfo.<ref refid="struct_vma_virtual_allocation_info_1accb40a8205f49ccca3de975da7d1a2b5" kindref="member">offset</ref><sp/>=<sp/>(VkDeviceSize)allocHandle<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="9628"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Node*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>node<sp/>=<sp/>FindAllocationNode(outInfo.<ref refid="struct_vma_virtual_allocation_info_1accb40a8205f49ccca3de975da7d1a2b5" kindref="member">offset</ref>,<sp/>level);</highlight></codeline>
<codeline lineno="9629"><highlight class="normal"><sp/><sp/><sp/><sp/>outInfo.<ref refid="struct_vma_virtual_allocation_info_1afb6d6bd0a6813869ea0842048d40aa2b" kindref="member">size</ref><sp/>=<sp/>LevelToNodeSize(level);</highlight></codeline>
<codeline lineno="9630"><highlight class="normal"><sp/><sp/><sp/><sp/>outInfo.<ref refid="struct_vma_virtual_allocation_info_1a224aa08739618d27066a16b7f60a2bbc" kindref="member">pUserData</ref><sp/>=<sp/>node-&gt;allocation.userData;</highlight></codeline>
<codeline lineno="9631"><highlight class="normal">}</highlight></codeline>
<codeline lineno="9632"><highlight class="normal"></highlight></codeline>
<codeline lineno="9633"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>VmaBlockMetadata_Buddy::GetAllocationUserData(VmaAllocHandle<sp/>allocHandle)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="9634"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="9635"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>level<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="9636"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Node*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>node<sp/>=<sp/>FindAllocationNode((VkDeviceSize)allocHandle<sp/>-<sp/>1,<sp/>level);</highlight></codeline>
<codeline lineno="9637"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>node-&gt;allocation.userData;</highlight></codeline>
<codeline lineno="9638"><highlight class="normal">}</highlight></codeline>
<codeline lineno="9639"><highlight class="normal"></highlight></codeline>
<codeline lineno="9640"><highlight class="normal">VmaAllocHandle<sp/>VmaBlockMetadata_Buddy::GetAllocationListBegin()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="9641"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="9642"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Function<sp/>only<sp/>used<sp/>for<sp/>defragmentation,<sp/>which<sp/>is<sp/>disabled<sp/>for<sp/>this<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9643"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="9644"><highlight class="normal">}</highlight></codeline>
<codeline lineno="9645"><highlight class="normal"></highlight></codeline>
<codeline lineno="9646"><highlight class="normal">VmaAllocHandle<sp/>VmaBlockMetadata_Buddy::GetNextAllocation(VmaAllocHandle<sp/>prevAlloc)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="9647"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="9648"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Function<sp/>only<sp/>used<sp/>for<sp/>defragmentation,<sp/>which<sp/>is<sp/>disabled<sp/>for<sp/>this<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9649"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="9650"><highlight class="normal">}</highlight></codeline>
<codeline lineno="9651"><highlight class="normal"></highlight></codeline>
<codeline lineno="9652"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Buddy::DeleteNodeChildren(Node*<sp/>node)</highlight></codeline>
<codeline lineno="9653"><highlight class="normal">{</highlight></codeline>
<codeline lineno="9654"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(node-&gt;type<sp/>==<sp/>Node::TYPE_SPLIT)</highlight></codeline>
<codeline lineno="9655"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9656"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>DeleteNodeChildren(node-&gt;split.leftChild-&gt;buddy);</highlight></codeline>
<codeline lineno="9657"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>DeleteNodeChildren(node-&gt;split.leftChild);</highlight></codeline>
<codeline lineno="9658"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>allocationCallbacks<sp/>=<sp/>GetAllocationCallbacks();</highlight></codeline>
<codeline lineno="9659"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_NodeAllocator.Free(node-&gt;split.leftChild-&gt;buddy);</highlight></codeline>
<codeline lineno="9660"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_NodeAllocator.Free(node-&gt;split.leftChild);</highlight></codeline>
<codeline lineno="9661"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9662"><highlight class="normal">}</highlight></codeline>
<codeline lineno="9663"><highlight class="normal"></highlight></codeline>
<codeline lineno="9664"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Buddy::Clear()</highlight></codeline>
<codeline lineno="9665"><highlight class="normal">{</highlight></codeline>
<codeline lineno="9666"><highlight class="normal"><sp/><sp/><sp/><sp/>DeleteNodeChildren(m_Root);</highlight></codeline>
<codeline lineno="9667"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Root-&gt;type<sp/>=<sp/>Node::TYPE_FREE;</highlight></codeline>
<codeline lineno="9668"><highlight class="normal"><sp/><sp/><sp/><sp/>m_AllocationCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="9669"><highlight class="normal"><sp/><sp/><sp/><sp/>m_FreeCount<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="9670"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SumFreeSize<sp/>=<sp/>m_UsableSize;</highlight></codeline>
<codeline lineno="9671"><highlight class="normal">}</highlight></codeline>
<codeline lineno="9672"><highlight class="normal"></highlight></codeline>
<codeline lineno="9673"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Buddy::SetAllocationUserData(VmaAllocHandle<sp/>allocHandle,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>userData)</highlight></codeline>
<codeline lineno="9674"><highlight class="normal">{</highlight></codeline>
<codeline lineno="9675"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>level<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="9676"><highlight class="normal"><sp/><sp/><sp/><sp/>Node*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>node<sp/>=<sp/>FindAllocationNode((VkDeviceSize)allocHandle<sp/>-<sp/>1,<sp/>level);</highlight></codeline>
<codeline lineno="9677"><highlight class="normal"><sp/><sp/><sp/><sp/>node-&gt;allocation.userData<sp/>=<sp/>userData;</highlight></codeline>
<codeline lineno="9678"><highlight class="normal">}</highlight></codeline>
<codeline lineno="9679"><highlight class="normal"></highlight></codeline>
<codeline lineno="9680"><highlight class="normal">VmaBlockMetadata_Buddy::Node*<sp/>VmaBlockMetadata_Buddy::FindAllocationNode(VkDeviceSize<sp/>offset,<sp/>uint32_t&amp;<sp/>outLevel)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="9681"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="9682"><highlight class="normal"><sp/><sp/><sp/><sp/>Node*<sp/>node<sp/>=<sp/>m_Root;</highlight></codeline>
<codeline lineno="9683"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>nodeOffset<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="9684"><highlight class="normal"><sp/><sp/><sp/><sp/>outLevel<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="9685"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>levelNodeSize<sp/>=<sp/>LevelToNodeSize(0);</highlight></codeline>
<codeline lineno="9686"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(node-&gt;type<sp/>==<sp/>Node::TYPE_SPLIT)</highlight></codeline>
<codeline lineno="9687"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9688"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>nextLevelNodeSize<sp/>=<sp/>levelNodeSize<sp/>&gt;&gt;<sp/>1;</highlight></codeline>
<codeline lineno="9689"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(offset<sp/>&lt;<sp/>nodeOffset<sp/>+<sp/>nextLevelNodeSize)</highlight></codeline>
<codeline lineno="9690"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9691"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node<sp/>=<sp/>node-&gt;split.leftChild;</highlight></codeline>
<codeline lineno="9692"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9693"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9694"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9695"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node<sp/>=<sp/>node-&gt;split.leftChild-&gt;buddy;</highlight></codeline>
<codeline lineno="9696"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nodeOffset<sp/>+=<sp/>nextLevelNodeSize;</highlight></codeline>
<codeline lineno="9697"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9698"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++outLevel;</highlight></codeline>
<codeline lineno="9699"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>levelNodeSize<sp/>=<sp/>nextLevelNodeSize;</highlight></codeline>
<codeline lineno="9700"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9701"><highlight class="normal"></highlight></codeline>
<codeline lineno="9702"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(node<sp/>!=<sp/>VMA_NULL<sp/>&amp;&amp;<sp/>node-&gt;type<sp/>==<sp/>Node::TYPE_ALLOCATION);</highlight></codeline>
<codeline lineno="9703"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>node;</highlight></codeline>
<codeline lineno="9704"><highlight class="normal">}</highlight></codeline>
<codeline lineno="9705"><highlight class="normal"></highlight></codeline>
<codeline lineno="9706"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Buddy::ValidateNode(ValidationContext&amp;<sp/>ctx,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Node*<sp/>parent,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Node*<sp/>curr,<sp/>uint32_t<sp/>level,<sp/>VkDeviceSize<sp/>levelNodeSize)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="9707"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="9708"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE(level<sp/>&lt;<sp/>m_LevelCount);</highlight></codeline>
<codeline lineno="9709"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE(curr-&gt;parent<sp/>==<sp/>parent);</highlight></codeline>
<codeline lineno="9710"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE((curr-&gt;buddy<sp/>==<sp/>VMA_NULL)<sp/>==<sp/>(parent<sp/>==<sp/>VMA_NULL));</highlight></codeline>
<codeline lineno="9711"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE(curr-&gt;buddy<sp/>==<sp/>VMA_NULL<sp/>||<sp/>curr-&gt;buddy-&gt;buddy<sp/>==<sp/>curr);</highlight></codeline>
<codeline lineno="9712"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(curr-&gt;type)</highlight></codeline>
<codeline lineno="9713"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9714"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>Node::TYPE_FREE:</highlight></codeline>
<codeline lineno="9715"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>curr-&gt;free.prev,<sp/>next<sp/>are<sp/>validated<sp/>separately.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9716"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ctx.calculatedSumFreeSize<sp/>+=<sp/>levelNodeSize;</highlight></codeline>
<codeline lineno="9717"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++ctx.calculatedFreeCount;</highlight></codeline>
<codeline lineno="9718"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9719"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>Node::TYPE_ALLOCATION:</highlight></codeline>
<codeline lineno="9720"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++ctx.calculatedAllocationCount;</highlight></codeline>
<codeline lineno="9721"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!IsVirtual())</highlight></codeline>
<codeline lineno="9722"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9723"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(curr-&gt;allocation.userData<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="9724"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9725"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9726"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>Node::TYPE_SPLIT:</highlight></codeline>
<codeline lineno="9727"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9728"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>childrenLevel<sp/>=<sp/>level<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="9729"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>childrenLevelNodeSize<sp/>=<sp/>levelNodeSize<sp/>&gt;&gt;<sp/>1;</highlight></codeline>
<codeline lineno="9730"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Node*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>leftChild<sp/>=<sp/>curr-&gt;split.leftChild;</highlight></codeline>
<codeline lineno="9731"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(leftChild<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="9732"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(leftChild-&gt;offset<sp/>==<sp/>curr-&gt;offset);</highlight></codeline>
<codeline lineno="9733"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ValidateNode(ctx,<sp/>curr,<sp/>leftChild,<sp/>childrenLevel,<sp/>childrenLevelNodeSize))</highlight></codeline>
<codeline lineno="9734"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9735"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(</highlight><highlight class="keyword">false</highlight><highlight class="normal"><sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;ValidateNode<sp/>for<sp/>left<sp/>child<sp/>failed.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="9736"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9737"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Node*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>rightChild<sp/>=<sp/>leftChild-&gt;buddy;</highlight></codeline>
<codeline lineno="9738"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(rightChild-&gt;offset<sp/>==<sp/>curr-&gt;offset<sp/>+<sp/>childrenLevelNodeSize);</highlight></codeline>
<codeline lineno="9739"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ValidateNode(ctx,<sp/>curr,<sp/>rightChild,<sp/>childrenLevel,<sp/>childrenLevelNodeSize))</highlight></codeline>
<codeline lineno="9740"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9741"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(</highlight><highlight class="keyword">false</highlight><highlight class="normal"><sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;ValidateNode<sp/>for<sp/>right<sp/>child<sp/>failed.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="9742"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9743"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9744"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9745"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="9746"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9747"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9748"><highlight class="normal"></highlight></codeline>
<codeline lineno="9749"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9750"><highlight class="normal">}</highlight></codeline>
<codeline lineno="9751"><highlight class="normal"></highlight></codeline>
<codeline lineno="9752"><highlight class="normal">uint32_t<sp/>VmaBlockMetadata_Buddy::AllocSizeToLevel(VkDeviceSize<sp/>allocSize)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="9753"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="9754"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>I<sp/>know<sp/>this<sp/>could<sp/>be<sp/>optimized<sp/>somehow<sp/>e.g.<sp/>by<sp/>using<sp/>std::log2p1<sp/>from<sp/>C++20.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9755"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>level<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="9756"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>currLevelNodeSize<sp/>=<sp/>m_UsableSize;</highlight></codeline>
<codeline lineno="9757"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>nextLevelNodeSize<sp/>=<sp/>currLevelNodeSize<sp/>&gt;&gt;<sp/>1;</highlight></codeline>
<codeline lineno="9758"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(allocSize<sp/>&lt;=<sp/>nextLevelNodeSize<sp/>&amp;&amp;<sp/>level<sp/>+<sp/>1<sp/>&lt;<sp/>m_LevelCount)</highlight></codeline>
<codeline lineno="9759"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9760"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++level;</highlight></codeline>
<codeline lineno="9761"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>currLevelNodeSize<sp/>&gt;&gt;=<sp/>1;</highlight></codeline>
<codeline lineno="9762"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nextLevelNodeSize<sp/>&gt;&gt;=<sp/>1;</highlight></codeline>
<codeline lineno="9763"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9764"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>level;</highlight></codeline>
<codeline lineno="9765"><highlight class="normal">}</highlight></codeline>
<codeline lineno="9766"><highlight class="normal"></highlight></codeline>
<codeline lineno="9767"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Buddy::Free(VmaAllocHandle<sp/>allocHandle)</highlight></codeline>
<codeline lineno="9768"><highlight class="normal">{</highlight></codeline>
<codeline lineno="9769"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>level<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="9770"><highlight class="normal"><sp/><sp/><sp/><sp/>Node*<sp/>node<sp/>=<sp/>FindAllocationNode((VkDeviceSize)allocHandle<sp/>-<sp/>1,<sp/>level);</highlight></codeline>
<codeline lineno="9771"><highlight class="normal"></highlight></codeline>
<codeline lineno="9772"><highlight class="normal"><sp/><sp/><sp/><sp/>++m_FreeCount;</highlight></codeline>
<codeline lineno="9773"><highlight class="normal"><sp/><sp/><sp/><sp/>--m_AllocationCount;</highlight></codeline>
<codeline lineno="9774"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SumFreeSize<sp/>+=<sp/>LevelToNodeSize(level);</highlight></codeline>
<codeline lineno="9775"><highlight class="normal"></highlight></codeline>
<codeline lineno="9776"><highlight class="normal"><sp/><sp/><sp/><sp/>node-&gt;type<sp/>=<sp/>Node::TYPE_FREE;</highlight></codeline>
<codeline lineno="9777"><highlight class="normal"></highlight></codeline>
<codeline lineno="9778"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Join<sp/>free<sp/>nodes<sp/>if<sp/>possible.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9779"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(level<sp/>&gt;<sp/>0<sp/>&amp;&amp;<sp/>node-&gt;buddy-&gt;type<sp/>==<sp/>Node::TYPE_FREE)</highlight></codeline>
<codeline lineno="9780"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9781"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>RemoveFromFreeList(level,<sp/>node-&gt;buddy);</highlight></codeline>
<codeline lineno="9782"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>parent<sp/>=<sp/>node-&gt;parent;</highlight></codeline>
<codeline lineno="9783"><highlight class="normal"></highlight></codeline>
<codeline lineno="9784"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_NodeAllocator.Free(node-&gt;buddy);</highlight></codeline>
<codeline lineno="9785"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_NodeAllocator.Free(node);</highlight></codeline>
<codeline lineno="9786"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>parent-&gt;type<sp/>=<sp/>Node::TYPE_FREE;</highlight></codeline>
<codeline lineno="9787"><highlight class="normal"></highlight></codeline>
<codeline lineno="9788"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node<sp/>=<sp/>parent;</highlight></codeline>
<codeline lineno="9789"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--level;</highlight></codeline>
<codeline lineno="9790"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--m_FreeCount;</highlight></codeline>
<codeline lineno="9791"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9792"><highlight class="normal"></highlight></codeline>
<codeline lineno="9793"><highlight class="normal"><sp/><sp/><sp/><sp/>AddToFreeListFront(level,<sp/>node);</highlight></codeline>
<codeline lineno="9794"><highlight class="normal">}</highlight></codeline>
<codeline lineno="9795"><highlight class="normal"></highlight></codeline>
<codeline lineno="9796"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Buddy::AddNodeToDetailedStatistics(<ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>&amp;<sp/>inoutStats,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Node*<sp/>node,<sp/>VkDeviceSize<sp/>levelNodeSize)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="9797"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="9798"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(node-&gt;type)</highlight></codeline>
<codeline lineno="9799"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9800"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>Node::TYPE_FREE:</highlight></codeline>
<codeline lineno="9801"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAddDetailedStatisticsUnusedRange(inoutStats,<sp/>levelNodeSize);</highlight></codeline>
<codeline lineno="9802"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9803"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>Node::TYPE_ALLOCATION:</highlight></codeline>
<codeline lineno="9804"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAddDetailedStatisticsAllocation(inoutStats,<sp/>levelNodeSize);</highlight></codeline>
<codeline lineno="9805"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9806"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>Node::TYPE_SPLIT:</highlight></codeline>
<codeline lineno="9807"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9808"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>childrenNodeSize<sp/>=<sp/>levelNodeSize<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="9809"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Node*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>leftChild<sp/>=<sp/>node-&gt;split.leftChild;</highlight></codeline>
<codeline lineno="9810"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AddNodeToDetailedStatistics(inoutStats,<sp/>leftChild,<sp/>childrenNodeSize);</highlight></codeline>
<codeline lineno="9811"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Node*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>rightChild<sp/>=<sp/>leftChild-&gt;buddy;</highlight></codeline>
<codeline lineno="9812"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AddNodeToDetailedStatistics(inoutStats,<sp/>rightChild,<sp/>childrenNodeSize);</highlight></codeline>
<codeline lineno="9813"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9814"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9815"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="9816"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="9817"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9818"><highlight class="normal">}</highlight></codeline>
<codeline lineno="9819"><highlight class="normal"></highlight></codeline>
<codeline lineno="9820"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Buddy::AddToFreeListFront(uint32_t<sp/>level,<sp/>Node*<sp/>node)</highlight></codeline>
<codeline lineno="9821"><highlight class="normal">{</highlight></codeline>
<codeline lineno="9822"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(node-&gt;type<sp/>==<sp/>Node::TYPE_FREE);</highlight></codeline>
<codeline lineno="9823"><highlight class="normal"></highlight></codeline>
<codeline lineno="9824"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>List<sp/>is<sp/>empty.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9825"><highlight class="normal"><sp/><sp/><sp/><sp/>Node*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>frontNode<sp/>=<sp/>m_FreeList[level].front;</highlight></codeline>
<codeline lineno="9826"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(frontNode<sp/>==<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="9827"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9828"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(m_FreeList[level].back<sp/>==<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="9829"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node-&gt;free.prev<sp/>=<sp/>node-&gt;free.next<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="9830"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_FreeList[level].front<sp/>=<sp/>m_FreeList[level].back<sp/>=<sp/>node;</highlight></codeline>
<codeline lineno="9831"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9832"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9833"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9834"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(frontNode-&gt;free.prev<sp/>==<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="9835"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node-&gt;free.prev<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="9836"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node-&gt;free.next<sp/>=<sp/>frontNode;</highlight></codeline>
<codeline lineno="9837"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>frontNode-&gt;free.prev<sp/>=<sp/>node;</highlight></codeline>
<codeline lineno="9838"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_FreeList[level].front<sp/>=<sp/>node;</highlight></codeline>
<codeline lineno="9839"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9840"><highlight class="normal">}</highlight></codeline>
<codeline lineno="9841"><highlight class="normal"></highlight></codeline>
<codeline lineno="9842"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Buddy::RemoveFromFreeList(uint32_t<sp/>level,<sp/>Node*<sp/>node)</highlight></codeline>
<codeline lineno="9843"><highlight class="normal">{</highlight></codeline>
<codeline lineno="9844"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_FreeList[level].front<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="9845"><highlight class="normal"></highlight></codeline>
<codeline lineno="9846"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>It<sp/>is<sp/>at<sp/>the<sp/>front.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9847"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(node-&gt;free.prev<sp/>==<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="9848"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9849"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(m_FreeList[level].front<sp/>==<sp/>node);</highlight></codeline>
<codeline lineno="9850"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_FreeList[level].front<sp/>=<sp/>node-&gt;free.next;</highlight></codeline>
<codeline lineno="9851"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9852"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9853"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9854"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>prevFreeNode<sp/>=<sp/>node-&gt;free.prev;</highlight></codeline>
<codeline lineno="9855"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(prevFreeNode-&gt;free.next<sp/>==<sp/>node);</highlight></codeline>
<codeline lineno="9856"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prevFreeNode-&gt;free.next<sp/>=<sp/>node-&gt;free.next;</highlight></codeline>
<codeline lineno="9857"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9858"><highlight class="normal"></highlight></codeline>
<codeline lineno="9859"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>It<sp/>is<sp/>at<sp/>the<sp/>back.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9860"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(node-&gt;free.next<sp/>==<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="9861"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9862"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(m_FreeList[level].back<sp/>==<sp/>node);</highlight></codeline>
<codeline lineno="9863"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_FreeList[level].back<sp/>=<sp/>node-&gt;free.prev;</highlight></codeline>
<codeline lineno="9864"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9865"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9866"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9867"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>nextFreeNode<sp/>=<sp/>node-&gt;free.next;</highlight></codeline>
<codeline lineno="9868"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(nextFreeNode-&gt;free.prev<sp/>==<sp/>node);</highlight></codeline>
<codeline lineno="9869"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nextFreeNode-&gt;free.prev<sp/>=<sp/>node-&gt;free.prev;</highlight></codeline>
<codeline lineno="9870"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9871"><highlight class="normal">}</highlight></codeline>
<codeline lineno="9872"><highlight class="normal"></highlight></codeline>
<codeline lineno="9873"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Buddy::DebugLogAllAllocationNode(Node*<sp/>node,<sp/>uint32_t<sp/>level)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="9874"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="9875"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(node-&gt;type)</highlight></codeline>
<codeline lineno="9876"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9877"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>Node::TYPE_FREE:</highlight></codeline>
<codeline lineno="9878"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9879"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>Node::TYPE_ALLOCATION:</highlight></codeline>
<codeline lineno="9880"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>DebugLogAllocation(node-&gt;offset,<sp/>LevelToNodeSize(level),<sp/>node-&gt;allocation.userData);</highlight></codeline>
<codeline lineno="9881"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9882"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>Node::TYPE_SPLIT:</highlight></codeline>
<codeline lineno="9883"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9884"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++level;</highlight></codeline>
<codeline lineno="9885"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>DebugLogAllAllocationNode(node-&gt;split.leftChild,<sp/>level);</highlight></codeline>
<codeline lineno="9886"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>DebugLogAllAllocationNode(node-&gt;split.leftChild-&gt;buddy,<sp/>level);</highlight></codeline>
<codeline lineno="9887"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9888"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9889"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="9890"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="9891"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9892"><highlight class="normal">}</highlight></codeline>
<codeline lineno="9893"><highlight class="normal"></highlight></codeline>
<codeline lineno="9894"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9895"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_Buddy::PrintDetailedMapNode(</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>VmaJsonWriter&amp;<sp/>json,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Node*<sp/>node,<sp/>VkDeviceSize<sp/>levelNodeSize)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="9896"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="9897"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(node-&gt;type)</highlight></codeline>
<codeline lineno="9898"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9899"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>Node::TYPE_FREE:</highlight></codeline>
<codeline lineno="9900"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrintDetailedMap_UnusedRange(json,<sp/>node-&gt;offset,<sp/>levelNodeSize);</highlight></codeline>
<codeline lineno="9901"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9902"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>Node::TYPE_ALLOCATION:</highlight></codeline>
<codeline lineno="9903"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrintDetailedMap_Allocation(json,<sp/>node-&gt;offset,<sp/>levelNodeSize,<sp/>node-&gt;allocation.userData);</highlight></codeline>
<codeline lineno="9904"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9905"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>Node::TYPE_SPLIT:</highlight></codeline>
<codeline lineno="9906"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9907"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>childrenNodeSize<sp/>=<sp/>levelNodeSize<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="9908"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Node*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>leftChild<sp/>=<sp/>node-&gt;split.leftChild;</highlight></codeline>
<codeline lineno="9909"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrintDetailedMapNode(json,<sp/>leftChild,<sp/>childrenNodeSize);</highlight></codeline>
<codeline lineno="9910"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Node*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>rightChild<sp/>=<sp/>leftChild-&gt;buddy;</highlight></codeline>
<codeline lineno="9911"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrintDetailedMapNode(json,<sp/>rightChild,<sp/>childrenNodeSize);</highlight></codeline>
<codeline lineno="9912"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9913"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9914"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="9915"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="9916"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="9917"><highlight class="normal">}</highlight></codeline>
<codeline lineno="9918"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9919"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_BLOCK_METADATA_BUDDY_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9920"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_BLOCK_METADATA_BUDDY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9921"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9922"><highlight class="normal"></highlight></codeline>
<codeline lineno="9923"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_BLOCK_METADATA_TLSF</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9924"><highlight class="normal"></highlight><highlight class="comment">//<sp/>To<sp/>not<sp/>search<sp/>current<sp/>larger<sp/>region<sp/>if<sp/>first<sp/>allocation<sp/>won&apos;t<sp/>succeed<sp/>and<sp/>skip<sp/>to<sp/>smaller<sp/>range</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9925"><highlight class="normal"></highlight><highlight class="comment">//<sp/>use<sp/>with<sp/>VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT<sp/>as<sp/>strategy<sp/>in<sp/>CreateAllocationRequest().</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9926"><highlight class="normal"></highlight><highlight class="comment">//<sp/>When<sp/>fragmentation<sp/>and<sp/>reusal<sp/>of<sp/>previous<sp/>blocks<sp/>doesn&apos;t<sp/>matter<sp/>then<sp/>use<sp/>with</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9927"><highlight class="normal"></highlight><highlight class="comment">//<sp/>VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT<sp/>for<sp/>fastest<sp/>alloc<sp/>time<sp/>possible.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9928"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaBlockMetadata_TLSF<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>VmaBlockMetadata</highlight></codeline>
<codeline lineno="9929"><highlight class="normal">{</highlight></codeline>
<codeline lineno="9930"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_CLASS_NO_COPY(VmaBlockMetadata_TLSF)</highlight></codeline>
<codeline lineno="9931"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="9932"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaBlockMetadata_TLSF(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks,</highlight></codeline>
<codeline lineno="9933"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>bufferImageGranularity,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isVirtual);</highlight></codeline>
<codeline lineno="9934"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>~VmaBlockMetadata_TLSF();</highlight></codeline>
<codeline lineno="9935"><highlight class="normal"></highlight></codeline>
<codeline lineno="9936"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>GetAllocationCount()</highlight><highlight class="keyword"><sp/>const<sp/>override<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_AllocCount;<sp/>}</highlight></codeline>
<codeline lineno="9937"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>GetFreeRegionsCount()</highlight><highlight class="keyword"><sp/>const<sp/>override<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_BlocksFreeCount<sp/>+<sp/>1;<sp/>}</highlight></codeline>
<codeline lineno="9938"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>GetSumFreeSize()</highlight><highlight class="keyword"><sp/>const<sp/>override<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_BlocksFreeSize<sp/>+<sp/>m_NullBlock-&gt;size;<sp/>}</highlight></codeline>
<codeline lineno="9939"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>IsEmpty()</highlight><highlight class="keyword"><sp/>const<sp/>override<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_NullBlock-&gt;offset<sp/>==<sp/>0;<sp/>}</highlight></codeline>
<codeline lineno="9940"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>GetAllocationOffset(VmaAllocHandle<sp/>allocHandle)</highlight><highlight class="keyword"><sp/>const<sp/>override<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>((Block*)allocHandle)-&gt;offset;<sp/>};</highlight></codeline>
<codeline lineno="9941"><highlight class="normal"></highlight></codeline>
<codeline lineno="9942"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Init(VkDeviceSize<sp/>size)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9943"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>Validate()<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9944"><highlight class="normal"></highlight></codeline>
<codeline lineno="9945"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>AddDetailedStatistics(<ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>&amp;<sp/>inoutStats)<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9946"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>AddStatistics(<ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref>&amp;<sp/>inoutStats)<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9947"><highlight class="normal"></highlight></codeline>
<codeline lineno="9948"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9949"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>PrintDetailedMap(</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>VmaJsonWriter&amp;<sp/>json)<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9950"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9951"><highlight class="normal"></highlight></codeline>
<codeline lineno="9952"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>CreateAllocationRequest(</highlight></codeline>
<codeline lineno="9953"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocSize,</highlight></codeline>
<codeline lineno="9954"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocAlignment,</highlight></codeline>
<codeline lineno="9955"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>upperAddress,</highlight></codeline>
<codeline lineno="9956"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>allocType,</highlight></codeline>
<codeline lineno="9957"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>strategy,</highlight></codeline>
<codeline lineno="9958"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAllocationRequest*<sp/>pAllocationRequest)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9959"><highlight class="normal"></highlight></codeline>
<codeline lineno="9960"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>CheckCorruption(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pBlockData)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9961"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Alloc(</highlight></codeline>
<codeline lineno="9962"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaAllocationRequest&amp;<sp/>request,</highlight></codeline>
<codeline lineno="9963"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>type,</highlight></codeline>
<codeline lineno="9964"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>userData)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9965"><highlight class="normal"></highlight></codeline>
<codeline lineno="9966"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Free(VmaAllocHandle<sp/>allocHandle)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9967"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GetAllocationInfo(VmaAllocHandle<sp/>allocHandle,<sp/><ref refid="struct_vma_virtual_allocation_info" kindref="compound">VmaVirtualAllocationInfo</ref>&amp;<sp/>outInfo)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9968"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>GetAllocationUserData(VmaAllocHandle<sp/>allocHandle)<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9969"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocHandle<sp/>GetAllocationListBegin()<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9970"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocHandle<sp/>GetNextAllocation(VmaAllocHandle<sp/>prevAlloc)<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9971"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>GetNextFreeRegionSize(VmaAllocHandle<sp/>alloc)<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9972"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Clear()<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9973"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>SetAllocationUserData(VmaAllocHandle<sp/>allocHandle,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>userData)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9974"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DebugLogAllAllocations()<sp/></highlight><highlight class="keyword">const<sp/>override</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="9975"><highlight class="normal"></highlight></codeline>
<codeline lineno="9976"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="9977"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>According<sp/>to<sp/>original<sp/>paper<sp/>it<sp/>should<sp/>be<sp/>preferable<sp/>4<sp/>or<sp/>5:</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9978"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>M.<sp/>Masmano,<sp/>I.<sp/>Ripoll,<sp/>A.<sp/>Crespo,<sp/>and<sp/>J.<sp/>Real<sp/>&quot;TLSF:<sp/>a<sp/>New<sp/>Dynamic<sp/>Memory<sp/>Allocator<sp/>for<sp/>Real-Time<sp/>Systems&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9979"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>http://www.gii.upv.es/tlsf/files/ecrts04_tlsf.pdf</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9980"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint8_t<sp/>SECOND_LEVEL_INDEX<sp/>=<sp/>5;</highlight></codeline>
<codeline lineno="9981"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint16_t<sp/>SMALL_BUFFER_SIZE<sp/>=<sp/>256;</highlight></codeline>
<codeline lineno="9982"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>INITIAL_BLOCK_ALLOC_COUNT<sp/>=<sp/>16;</highlight></codeline>
<codeline lineno="9983"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint8_t<sp/>MEMORY_CLASS_SHIFT<sp/>=<sp/>7;</highlight></codeline>
<codeline lineno="9984"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint8_t<sp/>MAX_MEMORY_CLASSES<sp/>=<sp/>65<sp/>-<sp/>MEMORY_CLASS_SHIFT;</highlight></codeline>
<codeline lineno="9985"><highlight class="normal"></highlight></codeline>
<codeline lineno="9986"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">Block</highlight></codeline>
<codeline lineno="9987"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="9988"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="9989"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>offset;</highlight></codeline>
<codeline lineno="9990"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size;</highlight></codeline>
<codeline lineno="9991"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Block*<sp/>prevPhysical;</highlight></codeline>
<codeline lineno="9992"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Block*<sp/>nextPhysical;</highlight></codeline>
<codeline lineno="9993"><highlight class="normal"></highlight></codeline>
<codeline lineno="9994"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>MarkFree()<sp/>{<sp/>prevFree<sp/>=<sp/>VMA_NULL;<sp/>}</highlight></codeline>
<codeline lineno="9995"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>MarkTaken()<sp/>{<sp/>prevFree<sp/>=<sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">;<sp/>}</highlight></codeline>
<codeline lineno="9996"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>IsFree()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>prevFree<sp/>!=<sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">;<sp/>}</highlight></codeline>
<codeline lineno="9997"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*&amp;<sp/>UserData()<sp/>{<sp/>VMA_HEAVY_ASSERT(!IsFree());<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>userData;<sp/>}</highlight></codeline>
<codeline lineno="9998"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Block*&amp;<sp/>PrevFree()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>prevFree;<sp/>}</highlight></codeline>
<codeline lineno="9999"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Block*&amp;<sp/>NextFree()<sp/>{<sp/>VMA_HEAVY_ASSERT(IsFree());<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>nextFree;<sp/>}</highlight></codeline>
<codeline lineno="10000"><highlight class="normal"></highlight></codeline>
<codeline lineno="10001"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="10002"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Block*<sp/>prevFree;<sp/></highlight><highlight class="comment">//<sp/>Address<sp/>of<sp/>the<sp/>same<sp/>block<sp/>here<sp/>indicates<sp/>that<sp/>block<sp/>is<sp/>taken</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10003"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">union</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10004"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10005"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Block*<sp/>nextFree;</highlight></codeline>
<codeline lineno="10006"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>userData;</highlight></codeline>
<codeline lineno="10007"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="10008"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="10009"><highlight class="normal"></highlight></codeline>
<codeline lineno="10010"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>m_AllocCount;</highlight></codeline>
<codeline lineno="10011"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Total<sp/>number<sp/>of<sp/>free<sp/>blocks<sp/>besides<sp/>null<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10012"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>m_BlocksFreeCount;</highlight></codeline>
<codeline lineno="10013"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Total<sp/>size<sp/>of<sp/>free<sp/>blocks<sp/>excluding<sp/>null<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10014"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>m_BlocksFreeSize;</highlight></codeline>
<codeline lineno="10015"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>m_IsFreeBitmap;</highlight></codeline>
<codeline lineno="10016"><highlight class="normal"><sp/><sp/><sp/><sp/>uint8_t<sp/>m_MemoryClasses;</highlight></codeline>
<codeline lineno="10017"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>m_InnerIsFreeBitmap[MAX_MEMORY_CLASSES];</highlight></codeline>
<codeline lineno="10018"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>m_ListsCount;</highlight></codeline>
<codeline lineno="10019"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="10020"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>0:<sp/>0-3<sp/>lists<sp/>for<sp/>small<sp/>buffers</highlight></codeline>
<codeline lineno="10021"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>1+:<sp/>0-(2^SLI-1)<sp/>lists<sp/>for<sp/>normal<sp/>buffers</highlight></codeline>
<codeline lineno="10022"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10023"><highlight class="normal"><sp/><sp/><sp/><sp/>Block**<sp/>m_FreeList;</highlight></codeline>
<codeline lineno="10024"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaPoolAllocator&lt;Block&gt;<sp/>m_BlockAllocator;</highlight></codeline>
<codeline lineno="10025"><highlight class="normal"><sp/><sp/><sp/><sp/>Block*<sp/>m_NullBlock;</highlight></codeline>
<codeline lineno="10026"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaBlockBufferImageGranularity<sp/>m_GranularityHandler;</highlight></codeline>
<codeline lineno="10027"><highlight class="normal"></highlight></codeline>
<codeline lineno="10028"><highlight class="normal"><sp/><sp/><sp/><sp/>uint8_t<sp/>SizeToMemoryClass(VkDeviceSize<sp/>size)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10029"><highlight class="normal"><sp/><sp/><sp/><sp/>uint16_t<sp/>SizeToSecondIndex(VkDeviceSize<sp/>size,<sp/>uint8_t<sp/>memoryClass)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10030"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>GetListIndex(uint8_t<sp/>memoryClass,<sp/>uint16_t<sp/>secondIndex)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10031"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>GetListIndex(VkDeviceSize<sp/>size)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10032"><highlight class="normal"></highlight></codeline>
<codeline lineno="10033"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>RemoveFreeBlock(Block*<sp/>block);</highlight></codeline>
<codeline lineno="10034"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>InsertFreeBlock(Block*<sp/>block);</highlight></codeline>
<codeline lineno="10035"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>MergeBlock(Block*<sp/>block,<sp/>Block*<sp/>prev);</highlight></codeline>
<codeline lineno="10036"><highlight class="normal"></highlight></codeline>
<codeline lineno="10037"><highlight class="normal"><sp/><sp/><sp/><sp/>Block*<sp/>FindFreeBlock(VkDeviceSize<sp/>size,<sp/>uint32_t&amp;<sp/>listIndex)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10038"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>CheckBlock(</highlight></codeline>
<codeline lineno="10039"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Block&amp;<sp/>block,</highlight></codeline>
<codeline lineno="10040"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>listIndex,</highlight></codeline>
<codeline lineno="10041"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocSize,</highlight></codeline>
<codeline lineno="10042"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocAlignment,</highlight></codeline>
<codeline lineno="10043"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>allocType,</highlight></codeline>
<codeline lineno="10044"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAllocationRequest*<sp/>pAllocationRequest);</highlight></codeline>
<codeline lineno="10045"><highlight class="normal">};</highlight></codeline>
<codeline lineno="10046"><highlight class="normal"></highlight></codeline>
<codeline lineno="10047"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_BLOCK_METADATA_TLSF_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10048"><highlight class="normal">VmaBlockMetadata_TLSF::VmaBlockMetadata_TLSF(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks,</highlight></codeline>
<codeline lineno="10049"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>bufferImageGranularity,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isVirtual)</highlight></codeline>
<codeline lineno="10050"><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>VmaBlockMetadata(pAllocationCallbacks,<sp/>bufferImageGranularity,<sp/>isVirtual),</highlight></codeline>
<codeline lineno="10051"><highlight class="normal"><sp/><sp/><sp/><sp/>m_AllocCount(0),</highlight></codeline>
<codeline lineno="10052"><highlight class="normal"><sp/><sp/><sp/><sp/>m_BlocksFreeCount(0),</highlight></codeline>
<codeline lineno="10053"><highlight class="normal"><sp/><sp/><sp/><sp/>m_BlocksFreeSize(0),</highlight></codeline>
<codeline lineno="10054"><highlight class="normal"><sp/><sp/><sp/><sp/>m_IsFreeBitmap(0),</highlight></codeline>
<codeline lineno="10055"><highlight class="normal"><sp/><sp/><sp/><sp/>m_MemoryClasses(0),</highlight></codeline>
<codeline lineno="10056"><highlight class="normal"><sp/><sp/><sp/><sp/>m_ListsCount(0),</highlight></codeline>
<codeline lineno="10057"><highlight class="normal"><sp/><sp/><sp/><sp/>m_FreeList(VMA_NULL),</highlight></codeline>
<codeline lineno="10058"><highlight class="normal"><sp/><sp/><sp/><sp/>m_BlockAllocator(pAllocationCallbacks,<sp/>INITIAL_BLOCK_ALLOC_COUNT),</highlight></codeline>
<codeline lineno="10059"><highlight class="normal"><sp/><sp/><sp/><sp/>m_NullBlock(VMA_NULL),</highlight></codeline>
<codeline lineno="10060"><highlight class="normal"><sp/><sp/><sp/><sp/>m_GranularityHandler(bufferImageGranularity)<sp/>{}</highlight></codeline>
<codeline lineno="10061"><highlight class="normal"></highlight></codeline>
<codeline lineno="10062"><highlight class="normal">VmaBlockMetadata_TLSF::~VmaBlockMetadata_TLSF()</highlight></codeline>
<codeline lineno="10063"><highlight class="normal">{</highlight></codeline>
<codeline lineno="10064"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_FreeList)</highlight></codeline>
<codeline lineno="10065"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vma_delete_array(GetAllocationCallbacks(),<sp/>m_FreeList,<sp/>m_ListsCount);</highlight></codeline>
<codeline lineno="10066"><highlight class="normal"><sp/><sp/><sp/><sp/>m_GranularityHandler.Destroy(GetAllocationCallbacks());</highlight></codeline>
<codeline lineno="10067"><highlight class="normal">}</highlight></codeline>
<codeline lineno="10068"><highlight class="normal"></highlight></codeline>
<codeline lineno="10069"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_TLSF::Init(VkDeviceSize<sp/>size)</highlight></codeline>
<codeline lineno="10070"><highlight class="normal">{</highlight></codeline>
<codeline lineno="10071"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaBlockMetadata::Init(size);</highlight></codeline>
<codeline lineno="10072"><highlight class="normal"></highlight></codeline>
<codeline lineno="10073"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!IsVirtual())</highlight></codeline>
<codeline lineno="10074"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_GranularityHandler.Init(GetAllocationCallbacks(),<sp/>size);</highlight></codeline>
<codeline lineno="10075"><highlight class="normal"></highlight></codeline>
<codeline lineno="10076"><highlight class="normal"><sp/><sp/><sp/><sp/>m_NullBlock<sp/>=<sp/>m_BlockAllocator.Alloc();</highlight></codeline>
<codeline lineno="10077"><highlight class="normal"><sp/><sp/><sp/><sp/>m_NullBlock-&gt;size<sp/>=<sp/>size;</highlight></codeline>
<codeline lineno="10078"><highlight class="normal"><sp/><sp/><sp/><sp/>m_NullBlock-&gt;offset<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="10079"><highlight class="normal"><sp/><sp/><sp/><sp/>m_NullBlock-&gt;prevPhysical<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="10080"><highlight class="normal"><sp/><sp/><sp/><sp/>m_NullBlock-&gt;nextPhysical<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="10081"><highlight class="normal"><sp/><sp/><sp/><sp/>m_NullBlock-&gt;MarkFree();</highlight></codeline>
<codeline lineno="10082"><highlight class="normal"><sp/><sp/><sp/><sp/>m_NullBlock-&gt;NextFree()<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="10083"><highlight class="normal"><sp/><sp/><sp/><sp/>m_NullBlock-&gt;PrevFree()<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="10084"><highlight class="normal"><sp/><sp/><sp/><sp/>uint8_t<sp/>memoryClass<sp/>=<sp/>SizeToMemoryClass(size);</highlight></codeline>
<codeline lineno="10085"><highlight class="normal"><sp/><sp/><sp/><sp/>uint16_t<sp/>sli<sp/>=<sp/>SizeToSecondIndex(size,<sp/>memoryClass);</highlight></codeline>
<codeline lineno="10086"><highlight class="normal"><sp/><sp/><sp/><sp/>m_ListsCount<sp/>=<sp/>(memoryClass<sp/>==<sp/>0<sp/>?<sp/>0<sp/>:<sp/>(memoryClass<sp/>-<sp/>1)<sp/>*<sp/>(1UL<sp/>&lt;&lt;<sp/>SECOND_LEVEL_INDEX)<sp/>+<sp/>sli)<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="10087"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(IsVirtual())</highlight></codeline>
<codeline lineno="10088"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_ListsCount<sp/>+=<sp/>1UL<sp/>&lt;&lt;<sp/>SECOND_LEVEL_INDEX;</highlight></codeline>
<codeline lineno="10089"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10090"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_ListsCount<sp/>+=<sp/>4;</highlight></codeline>
<codeline lineno="10091"><highlight class="normal"></highlight></codeline>
<codeline lineno="10092"><highlight class="normal"><sp/><sp/><sp/><sp/>m_MemoryClasses<sp/>=<sp/>memoryClass<sp/>+<sp/>2;</highlight></codeline>
<codeline lineno="10093"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(m_InnerIsFreeBitmap,<sp/>0,<sp/>MAX_MEMORY_CLASSES<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(uint32_t));</highlight></codeline>
<codeline lineno="10094"><highlight class="normal"></highlight></codeline>
<codeline lineno="10095"><highlight class="normal"><sp/><sp/><sp/><sp/>m_FreeList<sp/>=<sp/>vma_new_array(GetAllocationCallbacks(),<sp/>Block*,<sp/>m_ListsCount);</highlight></codeline>
<codeline lineno="10096"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(m_FreeList,<sp/>0,<sp/>m_ListsCount<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(Block*));</highlight></codeline>
<codeline lineno="10097"><highlight class="normal">}</highlight></codeline>
<codeline lineno="10098"><highlight class="normal"></highlight></codeline>
<codeline lineno="10099"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaBlockMetadata_TLSF::Validate()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="10100"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="10101"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE(GetSumFreeSize()<sp/>&lt;=<sp/>GetSize());</highlight></codeline>
<codeline lineno="10102"><highlight class="normal"></highlight></codeline>
<codeline lineno="10103"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>calculatedSize<sp/>=<sp/>m_NullBlock-&gt;size;</highlight></codeline>
<codeline lineno="10104"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>calculatedFreeSize<sp/>=<sp/>m_NullBlock-&gt;size;</highlight></codeline>
<codeline lineno="10105"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>allocCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="10106"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>freeCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="10107"><highlight class="normal"></highlight></codeline>
<codeline lineno="10108"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>integrity<sp/>of<sp/>free<sp/>lists</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10109"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(uint32_t<sp/>list<sp/>=<sp/>0;<sp/>list<sp/>&lt;<sp/>m_ListsCount;<sp/>++list)</highlight></codeline>
<codeline lineno="10110"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10111"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Block*<sp/>block<sp/>=<sp/>m_FreeList[list];</highlight></codeline>
<codeline lineno="10112"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(block<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="10113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10114"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(block-&gt;IsFree());</highlight></codeline>
<codeline lineno="10115"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(block-&gt;PrevFree()<sp/>==<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="10116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(block-&gt;NextFree())</highlight></codeline>
<codeline lineno="10117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10118"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(block-&gt;NextFree()-&gt;IsFree());</highlight></codeline>
<codeline lineno="10119"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(block-&gt;NextFree()-&gt;PrevFree()<sp/>==<sp/>block);</highlight></codeline>
<codeline lineno="10120"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block<sp/>=<sp/>block-&gt;NextFree();</highlight></codeline>
<codeline lineno="10121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10123"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10124"><highlight class="normal"></highlight></codeline>
<codeline lineno="10125"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>nextOffset<sp/>=<sp/>m_NullBlock-&gt;offset;</highlight></codeline>
<codeline lineno="10126"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>validateCtx<sp/>=<sp/>m_GranularityHandler.StartValidation(GetAllocationCallbacks(),<sp/>IsVirtual());</highlight></codeline>
<codeline lineno="10127"><highlight class="normal"></highlight></codeline>
<codeline lineno="10128"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE(m_NullBlock-&gt;nextPhysical<sp/>==<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="10129"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_NullBlock-&gt;prevPhysical)</highlight></codeline>
<codeline lineno="10130"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(m_NullBlock-&gt;prevPhysical-&gt;nextPhysical<sp/>==<sp/>m_NullBlock);</highlight></codeline>
<codeline lineno="10132"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10133"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>all<sp/>blocks</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10134"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(Block*<sp/>prev<sp/>=<sp/>m_NullBlock-&gt;prevPhysical;<sp/>prev<sp/>!=<sp/>VMA_NULL;<sp/>prev<sp/>=<sp/>prev-&gt;prevPhysical)</highlight></codeline>
<codeline lineno="10135"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10136"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(prev-&gt;offset<sp/>+<sp/>prev-&gt;size<sp/>==<sp/>nextOffset);</highlight></codeline>
<codeline lineno="10137"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nextOffset<sp/>=<sp/>prev-&gt;offset;</highlight></codeline>
<codeline lineno="10138"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>calculatedSize<sp/>+=<sp/>prev-&gt;size;</highlight></codeline>
<codeline lineno="10139"><highlight class="normal"></highlight></codeline>
<codeline lineno="10140"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>listIndex<sp/>=<sp/>GetListIndex(prev-&gt;size);</highlight></codeline>
<codeline lineno="10141"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(prev-&gt;IsFree())</highlight></codeline>
<codeline lineno="10142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10143"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++freeCount;</highlight></codeline>
<codeline lineno="10144"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>if<sp/>free<sp/>block<sp/>belongs<sp/>to<sp/>free<sp/>list</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Block*<sp/>freeBlock<sp/>=<sp/>m_FreeList[listIndex];</highlight></codeline>
<codeline lineno="10146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(freeBlock<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="10147"><highlight class="normal"></highlight></codeline>
<codeline lineno="10148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>found<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10150"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(freeBlock<sp/>==<sp/>prev)</highlight></codeline>
<codeline lineno="10152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>found<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10153"><highlight class="normal"></highlight></codeline>
<codeline lineno="10154"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>freeBlock<sp/>=<sp/>freeBlock-&gt;NextFree();</highlight></codeline>
<codeline lineno="10155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(!found<sp/>&amp;&amp;<sp/>freeBlock<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="10156"><highlight class="normal"></highlight></codeline>
<codeline lineno="10157"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(found);</highlight></codeline>
<codeline lineno="10158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>calculatedFreeSize<sp/>+=<sp/>prev-&gt;size;</highlight></codeline>
<codeline lineno="10159"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10160"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10161"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10162"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++allocCount;</highlight></codeline>
<codeline lineno="10163"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>if<sp/>taken<sp/>block<sp/>is<sp/>not<sp/>on<sp/>a<sp/>free<sp/>list</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10164"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Block*<sp/>freeBlock<sp/>=<sp/>m_FreeList[listIndex];</highlight></codeline>
<codeline lineno="10165"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(freeBlock)</highlight></codeline>
<codeline lineno="10166"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(freeBlock<sp/>!=<sp/>prev);</highlight></codeline>
<codeline lineno="10168"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>freeBlock<sp/>=<sp/>freeBlock-&gt;NextFree();</highlight></codeline>
<codeline lineno="10169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10170"><highlight class="normal"></highlight></codeline>
<codeline lineno="10171"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!IsVirtual())</highlight></codeline>
<codeline lineno="10172"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(m_GranularityHandler.Validate(validateCtx,<sp/>prev-&gt;offset,<sp/>prev-&gt;size));</highlight></codeline>
<codeline lineno="10174"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10176"><highlight class="normal"></highlight></codeline>
<codeline lineno="10177"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(prev-&gt;prevPhysical)</highlight></codeline>
<codeline lineno="10178"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10179"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(prev-&gt;prevPhysical-&gt;nextPhysical<sp/>==<sp/>prev);</highlight></codeline>
<codeline lineno="10180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10181"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10182"><highlight class="normal"></highlight></codeline>
<codeline lineno="10183"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!IsVirtual())</highlight></codeline>
<codeline lineno="10184"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_VALIDATE(m_GranularityHandler.FinishValidation(validateCtx));</highlight></codeline>
<codeline lineno="10186"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10187"><highlight class="normal"></highlight></codeline>
<codeline lineno="10188"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE(nextOffset<sp/>==<sp/>0);</highlight></codeline>
<codeline lineno="10189"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE(calculatedSize<sp/>==<sp/>GetSize());</highlight></codeline>
<codeline lineno="10190"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE(calculatedFreeSize<sp/>==<sp/>GetSumFreeSize());</highlight></codeline>
<codeline lineno="10191"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE(allocCount<sp/>==<sp/>m_AllocCount);</highlight></codeline>
<codeline lineno="10192"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE(freeCount<sp/>==<sp/>m_BlocksFreeCount);</highlight></codeline>
<codeline lineno="10193"><highlight class="normal"></highlight></codeline>
<codeline lineno="10194"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10195"><highlight class="normal">}</highlight></codeline>
<codeline lineno="10196"><highlight class="normal"></highlight></codeline>
<codeline lineno="10197"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_TLSF::AddDetailedStatistics(<ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>&amp;<sp/>inoutStats)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="10198"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="10199"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1a309179d5853a6a7cd534df497ee43957" kindref="member">blockCount</ref>++;</highlight></codeline>
<codeline lineno="10200"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1a2afbc1c7aa8ad7bbb8de06215ba7e5c4" kindref="member">blockBytes</ref><sp/>+=<sp/>GetSize();</highlight></codeline>
<codeline lineno="10201"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_NullBlock-&gt;size<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="10202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAddDetailedStatisticsUnusedRange(inoutStats,<sp/>m_NullBlock-&gt;size);</highlight></codeline>
<codeline lineno="10203"><highlight class="normal"></highlight></codeline>
<codeline lineno="10204"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(Block*<sp/>block<sp/>=<sp/>m_NullBlock-&gt;prevPhysical;<sp/>block<sp/>!=<sp/>VMA_NULL;<sp/>block<sp/>=<sp/>block-&gt;prevPhysical)</highlight></codeline>
<codeline lineno="10205"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10206"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(block-&gt;IsFree())</highlight></codeline>
<codeline lineno="10207"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAddDetailedStatisticsUnusedRange(inoutStats,<sp/>block-&gt;size);</highlight></codeline>
<codeline lineno="10208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10209"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAddDetailedStatisticsAllocation(inoutStats,<sp/>block-&gt;size);</highlight></codeline>
<codeline lineno="10210"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10211"><highlight class="normal">}</highlight></codeline>
<codeline lineno="10212"><highlight class="normal"></highlight></codeline>
<codeline lineno="10213"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_TLSF::AddStatistics(<ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref>&amp;<sp/>inoutStats)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="10214"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="10215"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_statistics_1a309179d5853a6a7cd534df497ee43957" kindref="member">blockCount</ref>++;</highlight></codeline>
<codeline lineno="10216"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_statistics_1ab0ff76e50f58f9f54b6f265e5bf5dde2" kindref="member">allocationCount</ref><sp/>+=<sp/>(uint32_t)m_AllocCount;</highlight></codeline>
<codeline lineno="10217"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_statistics_1a2afbc1c7aa8ad7bbb8de06215ba7e5c4" kindref="member">blockBytes</ref><sp/>+=<sp/>GetSize();</highlight></codeline>
<codeline lineno="10218"><highlight class="normal"><sp/><sp/><sp/><sp/>inoutStats.<ref refid="struct_vma_statistics_1a21db06eba3422f87a2b4b4703d879c16" kindref="member">allocationBytes</ref><sp/>+=<sp/>GetSize()<sp/>-<sp/>GetSumFreeSize();</highlight></codeline>
<codeline lineno="10219"><highlight class="normal">}</highlight></codeline>
<codeline lineno="10220"><highlight class="normal"></highlight></codeline>
<codeline lineno="10221"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10222"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_TLSF::PrintDetailedMap(</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>VmaJsonWriter&amp;<sp/>json)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="10223"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="10224"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>blockCount<sp/>=<sp/>m_AllocCount<sp/>+<sp/>m_BlocksFreeCount;</highlight></codeline>
<codeline lineno="10225"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaStlAllocator&lt;Block*&gt;<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>(GetAllocationCallbacks());</highlight></codeline>
<codeline lineno="10226"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaVector&lt;Block*,<sp/>VmaStlAllocator&lt;Block*&gt;&gt;<sp/>blockList(blockCount,<sp/>allocator);</highlight></codeline>
<codeline lineno="10227"><highlight class="normal"></highlight></codeline>
<codeline lineno="10228"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>blockCount;</highlight></codeline>
<codeline lineno="10229"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(Block*<sp/>block<sp/>=<sp/>m_NullBlock-&gt;prevPhysical;<sp/>block<sp/>!=<sp/>VMA_NULL;<sp/>block<sp/>=<sp/>block-&gt;prevPhysical)</highlight></codeline>
<codeline lineno="10230"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10231"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>blockList[--i]<sp/>=<sp/>block;</highlight></codeline>
<codeline lineno="10232"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10233"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(i<sp/>==<sp/>0);</highlight></codeline>
<codeline lineno="10234"><highlight class="normal"></highlight></codeline>
<codeline lineno="10235"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref><sp/>stats;</highlight></codeline>
<codeline lineno="10236"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaClearDetailedStatistics(stats);</highlight></codeline>
<codeline lineno="10237"><highlight class="normal"><sp/><sp/><sp/><sp/>AddDetailedStatistics(stats);</highlight></codeline>
<codeline lineno="10238"><highlight class="normal"></highlight></codeline>
<codeline lineno="10239"><highlight class="normal"><sp/><sp/><sp/><sp/>PrintDetailedMap_Begin(json,</highlight></codeline>
<codeline lineno="10240"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stats.<ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1a2afbc1c7aa8ad7bbb8de06215ba7e5c4" kindref="member">blockBytes</ref><sp/>-<sp/>stats.<ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1a21db06eba3422f87a2b4b4703d879c16" kindref="member">allocationBytes</ref>,</highlight></codeline>
<codeline lineno="10241"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stats.<ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1ab0ff76e50f58f9f54b6f265e5bf5dde2" kindref="member">allocationCount</ref>,</highlight></codeline>
<codeline lineno="10242"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stats.<ref refid="struct_vma_detailed_statistics_1ab721bf04892e8b67802d4ddb7734638a" kindref="member">unusedRangeCount</ref>);</highlight></codeline>
<codeline lineno="10243"><highlight class="normal"></highlight></codeline>
<codeline lineno="10244"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(;<sp/>i<sp/>&lt;<sp/>blockCount;<sp/>++i)</highlight></codeline>
<codeline lineno="10245"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10246"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Block*<sp/>block<sp/>=<sp/>blockList[i];</highlight></codeline>
<codeline lineno="10247"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(block-&gt;IsFree())</highlight></codeline>
<codeline lineno="10248"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrintDetailedMap_UnusedRange(json,<sp/>block-&gt;offset,<sp/>block-&gt;size);</highlight></codeline>
<codeline lineno="10249"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10250"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrintDetailedMap_Allocation(json,<sp/>block-&gt;offset,<sp/>block-&gt;size,<sp/>block-&gt;UserData());</highlight></codeline>
<codeline lineno="10251"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10252"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_NullBlock-&gt;size<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="10253"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrintDetailedMap_UnusedRange(json,<sp/>m_NullBlock-&gt;offset,<sp/>m_NullBlock-&gt;size);</highlight></codeline>
<codeline lineno="10254"><highlight class="normal"></highlight></codeline>
<codeline lineno="10255"><highlight class="normal"><sp/><sp/><sp/><sp/>PrintDetailedMap_End(json);</highlight></codeline>
<codeline lineno="10256"><highlight class="normal">}</highlight></codeline>
<codeline lineno="10257"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10258"><highlight class="normal"></highlight></codeline>
<codeline lineno="10259"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaBlockMetadata_TLSF::CreateAllocationRequest(</highlight></codeline>
<codeline lineno="10260"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocSize,</highlight></codeline>
<codeline lineno="10261"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocAlignment,</highlight></codeline>
<codeline lineno="10262"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>upperAddress,</highlight></codeline>
<codeline lineno="10263"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>allocType,</highlight></codeline>
<codeline lineno="10264"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>strategy,</highlight></codeline>
<codeline lineno="10265"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocationRequest*<sp/>pAllocationRequest)</highlight></codeline>
<codeline lineno="10266"><highlight class="normal">{</highlight></codeline>
<codeline lineno="10267"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocSize<sp/>&gt;<sp/>0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Cannot<sp/>allocate<sp/>empty<sp/>block!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="10268"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(!upperAddress<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT<sp/>can<sp/>be<sp/>used<sp/>only<sp/>with<sp/>linear<sp/>algorithm.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="10269"><highlight class="normal"></highlight></codeline>
<codeline lineno="10270"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>For<sp/>small<sp/>granularity<sp/>round<sp/>up</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10271"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!IsVirtual())</highlight></codeline>
<codeline lineno="10272"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_GranularityHandler.RoundupAllocRequest(allocType,<sp/>allocSize,<sp/>allocAlignment);</highlight></codeline>
<codeline lineno="10273"><highlight class="normal"></highlight></codeline>
<codeline lineno="10274"><highlight class="normal"><sp/><sp/><sp/><sp/>allocSize<sp/>+=<sp/>GetDebugMargin();</highlight></codeline>
<codeline lineno="10275"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Quick<sp/>check<sp/>for<sp/>too<sp/>small<sp/>pool</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10276"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(allocSize<sp/>&gt;<sp/>GetSumFreeSize())</highlight></codeline>
<codeline lineno="10277"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10278"><highlight class="normal"></highlight></codeline>
<codeline lineno="10279"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>no<sp/>free<sp/>blocks<sp/>in<sp/>pool<sp/>then<sp/>check<sp/>only<sp/>null<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10280"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_BlocksFreeCount<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="10281"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>CheckBlock(*m_NullBlock,<sp/>m_ListsCount,<sp/>allocSize,<sp/>allocAlignment,<sp/>allocType,<sp/>pAllocationRequest);</highlight></codeline>
<codeline lineno="10282"><highlight class="normal"></highlight></codeline>
<codeline lineno="10283"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Round<sp/>up<sp/>to<sp/>the<sp/>next<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10284"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>sizeForNextList<sp/>=<sp/>allocSize;</highlight></codeline>
<codeline lineno="10285"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>smallSizeStep<sp/>=<sp/>SMALL_BUFFER_SIZE<sp/>/<sp/>(IsVirtual()<sp/>?<sp/>1<sp/>&lt;&lt;<sp/>SECOND_LEVEL_INDEX<sp/>:<sp/>4);</highlight></codeline>
<codeline lineno="10286"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(allocSize<sp/>&gt;<sp/>SMALL_BUFFER_SIZE)</highlight></codeline>
<codeline lineno="10287"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10288"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sizeForNextList<sp/>+=<sp/>(1ULL<sp/>&lt;&lt;<sp/>(VMA_BITSCAN_MSB(allocSize)<sp/>-<sp/>SECOND_LEVEL_INDEX));</highlight></codeline>
<codeline lineno="10289"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10290"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(allocSize<sp/>&gt;<sp/>SMALL_BUFFER_SIZE<sp/>-<sp/>smallSizeStep)</highlight></codeline>
<codeline lineno="10291"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sizeForNextList<sp/>=<sp/>SMALL_BUFFER_SIZE<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="10292"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10293"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sizeForNextList<sp/>+=<sp/>smallSizeStep;</highlight></codeline>
<codeline lineno="10294"><highlight class="normal"></highlight></codeline>
<codeline lineno="10295"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>nextListIndex<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="10296"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>prevListIndex<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="10297"><highlight class="normal"><sp/><sp/><sp/><sp/>Block*<sp/>nextListBlock<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="10298"><highlight class="normal"><sp/><sp/><sp/><sp/>Block*<sp/>prevListBlock<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="10299"><highlight class="normal"></highlight></codeline>
<codeline lineno="10300"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>blocks<sp/>according<sp/>to<sp/>strategies</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10301"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(strategy<sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a0729e932b7ea170e3a128cad96c5cf6d" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</ref>)</highlight></codeline>
<codeline lineno="10302"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10303"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Quick<sp/>check<sp/>for<sp/>larger<sp/>block<sp/>first</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10304"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nextListBlock<sp/>=<sp/>FindFreeBlock(sizeForNextList,<sp/>nextListIndex);</highlight></codeline>
<codeline lineno="10305"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nextListBlock<sp/>!=<sp/>VMA_NULL<sp/>&amp;&amp;<sp/>CheckBlock(*nextListBlock,<sp/>nextListIndex,<sp/>allocSize,<sp/>allocAlignment,<sp/>allocType,<sp/>pAllocationRequest))</highlight></codeline>
<codeline lineno="10306"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10307"><highlight class="normal"></highlight></codeline>
<codeline lineno="10308"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>not<sp/>fitted<sp/>then<sp/>null<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10309"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(CheckBlock(*m_NullBlock,<sp/>m_ListsCount,<sp/>allocSize,<sp/>allocAlignment,<sp/>allocType,<sp/>pAllocationRequest))</highlight></codeline>
<codeline lineno="10310"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10311"><highlight class="normal"></highlight></codeline>
<codeline lineno="10312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Null<sp/>block<sp/>failed,<sp/>search<sp/>larger<sp/>bucket</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10313"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(nextListBlock)</highlight></codeline>
<codeline lineno="10314"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10315"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(CheckBlock(*nextListBlock,<sp/>nextListIndex,<sp/>allocSize,<sp/>allocAlignment,<sp/>allocType,<sp/>pAllocationRequest))</highlight></codeline>
<codeline lineno="10316"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10317"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nextListBlock<sp/>=<sp/>nextListBlock-&gt;NextFree();</highlight></codeline>
<codeline lineno="10318"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10319"><highlight class="normal"></highlight></codeline>
<codeline lineno="10320"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Failed<sp/>again,<sp/>check<sp/>best<sp/>fit<sp/>bucket</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10321"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prevListBlock<sp/>=<sp/>FindFreeBlock(allocSize,<sp/>prevListIndex);</highlight></codeline>
<codeline lineno="10322"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(prevListBlock)</highlight></codeline>
<codeline lineno="10323"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10324"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(CheckBlock(*prevListBlock,<sp/>prevListIndex,<sp/>allocSize,<sp/>allocAlignment,<sp/>allocType,<sp/>pAllocationRequest))</highlight></codeline>
<codeline lineno="10325"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prevListBlock<sp/>=<sp/>prevListBlock-&gt;NextFree();</highlight></codeline>
<codeline lineno="10327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10328"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10329"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(strategy<sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8af1210cf591784afa026d94998f735d" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</ref>)</highlight></codeline>
<codeline lineno="10330"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>best<sp/>fit<sp/>bucket</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10332"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prevListBlock<sp/>=<sp/>FindFreeBlock(allocSize,<sp/>prevListIndex);</highlight></codeline>
<codeline lineno="10333"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(prevListBlock)</highlight></codeline>
<codeline lineno="10334"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10335"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(CheckBlock(*prevListBlock,<sp/>prevListIndex,<sp/>allocSize,<sp/>allocAlignment,<sp/>allocType,<sp/>pAllocationRequest))</highlight></codeline>
<codeline lineno="10336"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10337"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prevListBlock<sp/>=<sp/>prevListBlock-&gt;NextFree();</highlight></codeline>
<codeline lineno="10338"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10339"><highlight class="normal"></highlight></codeline>
<codeline lineno="10340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>failed<sp/>check<sp/>null<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(CheckBlock(*m_NullBlock,<sp/>m_ListsCount,<sp/>allocSize,<sp/>allocAlignment,<sp/>allocType,<sp/>pAllocationRequest))</highlight></codeline>
<codeline lineno="10342"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10343"><highlight class="normal"></highlight></codeline>
<codeline lineno="10344"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>larger<sp/>bucket</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10345"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nextListBlock<sp/>=<sp/>FindFreeBlock(sizeForNextList,<sp/>nextListIndex);</highlight></codeline>
<codeline lineno="10346"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(nextListBlock)</highlight></codeline>
<codeline lineno="10347"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10348"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(CheckBlock(*nextListBlock,<sp/>nextListIndex,<sp/>allocSize,<sp/>allocAlignment,<sp/>allocType,<sp/>pAllocationRequest))</highlight></codeline>
<codeline lineno="10349"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nextListBlock<sp/>=<sp/>nextListBlock-&gt;NextFree();</highlight></codeline>
<codeline lineno="10351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10352"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10353"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(strategy<sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8099acedc0d04cdccaaddcfe37fd227d" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</ref><sp/>)</highlight></codeline>
<codeline lineno="10354"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10355"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Perform<sp/>search<sp/>from<sp/>the<sp/>start</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10356"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaStlAllocator&lt;Block*&gt;<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>(GetAllocationCallbacks());</highlight></codeline>
<codeline lineno="10357"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaVector&lt;Block*,<sp/>VmaStlAllocator&lt;Block*&gt;&gt;<sp/>blockList(m_BlocksFreeCount,<sp/>allocator);</highlight></codeline>
<codeline lineno="10358"><highlight class="normal"></highlight></codeline>
<codeline lineno="10359"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>m_BlocksFreeCount;</highlight></codeline>
<codeline lineno="10360"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(Block*<sp/>block<sp/>=<sp/>m_NullBlock-&gt;prevPhysical;<sp/>block<sp/>!=<sp/>VMA_NULL;<sp/>block<sp/>=<sp/>block-&gt;prevPhysical)</highlight></codeline>
<codeline lineno="10361"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10362"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(block-&gt;IsFree()<sp/>&amp;&amp;<sp/>block-&gt;size<sp/>&gt;=<sp/>allocSize)</highlight></codeline>
<codeline lineno="10363"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>blockList[--i]<sp/>=<sp/>block;</highlight></codeline>
<codeline lineno="10364"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10365"><highlight class="normal"></highlight></codeline>
<codeline lineno="10366"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(;<sp/>i<sp/>&lt;<sp/>m_BlocksFreeCount;<sp/>++i)</highlight></codeline>
<codeline lineno="10367"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10368"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Block&amp;<sp/>block<sp/>=<sp/>*blockList[i];</highlight></codeline>
<codeline lineno="10369"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(CheckBlock(block,<sp/>GetListIndex(block.size),<sp/>allocSize,<sp/>allocAlignment,<sp/>allocType,<sp/>pAllocationRequest))</highlight></codeline>
<codeline lineno="10370"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10371"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10372"><highlight class="normal"></highlight></codeline>
<codeline lineno="10373"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>failed<sp/>check<sp/>null<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10374"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(CheckBlock(*m_NullBlock,<sp/>m_ListsCount,<sp/>allocSize,<sp/>allocAlignment,<sp/>allocType,<sp/>pAllocationRequest))</highlight></codeline>
<codeline lineno="10375"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10376"><highlight class="normal"></highlight></codeline>
<codeline lineno="10377"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Whole<sp/>range<sp/>searched,<sp/>no<sp/>more<sp/>memory</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10379"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10380"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10381"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10382"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>larger<sp/>bucket</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10383"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nextListBlock<sp/>=<sp/>FindFreeBlock(sizeForNextList,<sp/>nextListIndex);</highlight></codeline>
<codeline lineno="10384"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(nextListBlock)</highlight></codeline>
<codeline lineno="10385"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10386"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(CheckBlock(*nextListBlock,<sp/>nextListIndex,<sp/>allocSize,<sp/>allocAlignment,<sp/>allocType,<sp/>pAllocationRequest))</highlight></codeline>
<codeline lineno="10387"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10388"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nextListBlock<sp/>=<sp/>nextListBlock-&gt;NextFree();</highlight></codeline>
<codeline lineno="10389"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10390"><highlight class="normal"></highlight></codeline>
<codeline lineno="10391"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>failed<sp/>check<sp/>null<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10392"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(CheckBlock(*m_NullBlock,<sp/>m_ListsCount,<sp/>allocSize,<sp/>allocAlignment,<sp/>allocType,<sp/>pAllocationRequest))</highlight></codeline>
<codeline lineno="10393"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10394"><highlight class="normal"></highlight></codeline>
<codeline lineno="10395"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>best<sp/>fit<sp/>bucket</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10396"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prevListBlock<sp/>=<sp/>FindFreeBlock(allocSize,<sp/>prevListIndex);</highlight></codeline>
<codeline lineno="10397"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(prevListBlock)</highlight></codeline>
<codeline lineno="10398"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10399"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(CheckBlock(*prevListBlock,<sp/>prevListIndex,<sp/>allocSize,<sp/>allocAlignment,<sp/>allocType,<sp/>pAllocationRequest))</highlight></codeline>
<codeline lineno="10400"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10401"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prevListBlock<sp/>=<sp/>prevListBlock-&gt;NextFree();</highlight></codeline>
<codeline lineno="10402"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10403"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10404"><highlight class="normal"></highlight></codeline>
<codeline lineno="10405"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Worst<sp/>case,<sp/>full<sp/>search<sp/>has<sp/>to<sp/>be<sp/>done</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10406"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(++nextListIndex<sp/>&lt;<sp/>m_ListsCount)</highlight></codeline>
<codeline lineno="10407"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10408"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nextListBlock<sp/>=<sp/>m_FreeList[nextListIndex];</highlight></codeline>
<codeline lineno="10409"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(nextListBlock)</highlight></codeline>
<codeline lineno="10410"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10411"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(CheckBlock(*nextListBlock,<sp/>nextListIndex,<sp/>allocSize,<sp/>allocAlignment,<sp/>allocType,<sp/>pAllocationRequest))</highlight></codeline>
<codeline lineno="10412"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10413"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nextListBlock<sp/>=<sp/>nextListBlock-&gt;NextFree();</highlight></codeline>
<codeline lineno="10414"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10415"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10416"><highlight class="normal"></highlight></codeline>
<codeline lineno="10417"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>No<sp/>more<sp/>memory<sp/>sadly</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10418"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10419"><highlight class="normal">}</highlight></codeline>
<codeline lineno="10420"><highlight class="normal"></highlight></codeline>
<codeline lineno="10421"><highlight class="normal">VkResult<sp/>VmaBlockMetadata_TLSF::CheckCorruption(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pBlockData)</highlight></codeline>
<codeline lineno="10422"><highlight class="normal">{</highlight></codeline>
<codeline lineno="10423"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(Block*<sp/>block<sp/>=<sp/>m_NullBlock-&gt;prevPhysical;<sp/>block<sp/>!=<sp/>VMA_NULL;<sp/>block<sp/>=<sp/>block-&gt;prevPhysical)</highlight></codeline>
<codeline lineno="10424"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10425"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!block-&gt;IsFree())</highlight></codeline>
<codeline lineno="10426"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10427"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!VmaValidateMagicValue(pBlockData,<sp/>block-&gt;offset<sp/>+<sp/>block-&gt;size))</highlight></codeline>
<codeline lineno="10428"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10429"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;MEMORY<sp/>CORRUPTION<sp/>DETECTED<sp/>AFTER<sp/>VALIDATED<sp/>ALLOCATION!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="10430"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_UNKNOWN_COPY;</highlight></codeline>
<codeline lineno="10431"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10432"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10433"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10434"><highlight class="normal"></highlight></codeline>
<codeline lineno="10435"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="10436"><highlight class="normal">}</highlight></codeline>
<codeline lineno="10437"><highlight class="normal"></highlight></codeline>
<codeline lineno="10438"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_TLSF::Alloc(</highlight></codeline>
<codeline lineno="10439"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaAllocationRequest&amp;<sp/>request,</highlight></codeline>
<codeline lineno="10440"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>type,</highlight></codeline>
<codeline lineno="10441"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>userData)</highlight></codeline>
<codeline lineno="10442"><highlight class="normal">{</highlight></codeline>
<codeline lineno="10443"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(request.type<sp/>==<sp/>VmaAllocationRequestType::TLSF);</highlight></codeline>
<codeline lineno="10444"><highlight class="normal"></highlight></codeline>
<codeline lineno="10445"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>block<sp/>and<sp/>pop<sp/>it<sp/>from<sp/>the<sp/>free<sp/>list</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10446"><highlight class="normal"><sp/><sp/><sp/><sp/>Block*<sp/>currentBlock<sp/>=<sp/>(Block*)request.allocHandle;</highlight></codeline>
<codeline lineno="10447"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>offset<sp/>=<sp/>request.algorithmData;</highlight></codeline>
<codeline lineno="10448"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(currentBlock<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="10449"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(currentBlock-&gt;offset<sp/>&lt;=<sp/>offset);</highlight></codeline>
<codeline lineno="10450"><highlight class="normal"></highlight></codeline>
<codeline lineno="10451"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(currentBlock<sp/>!=<sp/>m_NullBlock)</highlight></codeline>
<codeline lineno="10452"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>RemoveFreeBlock(currentBlock);</highlight></codeline>
<codeline lineno="10453"><highlight class="normal"></highlight></codeline>
<codeline lineno="10454"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>debugMargin<sp/>=<sp/>GetDebugMargin();</highlight></codeline>
<codeline lineno="10455"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>misssingAlignment<sp/>=<sp/>offset<sp/>-<sp/>currentBlock-&gt;offset;</highlight></codeline>
<codeline lineno="10456"><highlight class="normal"></highlight></codeline>
<codeline lineno="10457"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Append<sp/>missing<sp/>alignment<sp/>to<sp/>prev<sp/>block<sp/>or<sp/>create<sp/>new<sp/>one</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10458"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(misssingAlignment)</highlight></codeline>
<codeline lineno="10459"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10460"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Block*<sp/>prevBlock<sp/>=<sp/>currentBlock-&gt;prevPhysical;</highlight></codeline>
<codeline lineno="10461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(prevBlock<sp/>!=<sp/>VMA_NULL<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;There<sp/>should<sp/>be<sp/>no<sp/>missing<sp/>alignment<sp/>at<sp/>offset<sp/>0!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="10462"><highlight class="normal"></highlight></codeline>
<codeline lineno="10463"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(prevBlock-&gt;IsFree()<sp/>&amp;&amp;<sp/>prevBlock-&gt;size<sp/>!=<sp/>debugMargin)</highlight></codeline>
<codeline lineno="10464"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10465"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>oldList<sp/>=<sp/>GetListIndex(prevBlock-&gt;size);</highlight></codeline>
<codeline lineno="10466"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prevBlock-&gt;size<sp/>+=<sp/>misssingAlignment;</highlight></codeline>
<codeline lineno="10467"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>if<sp/>new<sp/>size<sp/>crosses<sp/>list<sp/>bucket</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10468"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(oldList<sp/>!=<sp/>GetListIndex(prevBlock-&gt;size))</highlight></codeline>
<codeline lineno="10469"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10470"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prevBlock-&gt;size<sp/>-=<sp/>misssingAlignment;</highlight></codeline>
<codeline lineno="10471"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>RemoveFreeBlock(prevBlock);</highlight></codeline>
<codeline lineno="10472"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prevBlock-&gt;size<sp/>+=<sp/>misssingAlignment;</highlight></codeline>
<codeline lineno="10473"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>InsertFreeBlock(prevBlock);</highlight></codeline>
<codeline lineno="10474"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10475"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10476"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_BlocksFreeSize<sp/>+=<sp/>misssingAlignment;</highlight></codeline>
<codeline lineno="10477"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10478"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10479"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10480"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Block*<sp/>newBlock<sp/>=<sp/>m_BlockAllocator.Alloc();</highlight></codeline>
<codeline lineno="10481"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>currentBlock-&gt;prevPhysical<sp/>=<sp/>newBlock;</highlight></codeline>
<codeline lineno="10482"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prevBlock-&gt;nextPhysical<sp/>=<sp/>newBlock;</highlight></codeline>
<codeline lineno="10483"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newBlock-&gt;prevPhysical<sp/>=<sp/>prevBlock;</highlight></codeline>
<codeline lineno="10484"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newBlock-&gt;nextPhysical<sp/>=<sp/>currentBlock;</highlight></codeline>
<codeline lineno="10485"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newBlock-&gt;size<sp/>=<sp/>misssingAlignment;</highlight></codeline>
<codeline lineno="10486"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newBlock-&gt;offset<sp/>=<sp/>currentBlock-&gt;offset;</highlight></codeline>
<codeline lineno="10487"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newBlock-&gt;MarkTaken();</highlight></codeline>
<codeline lineno="10488"><highlight class="normal"></highlight></codeline>
<codeline lineno="10489"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>InsertFreeBlock(newBlock);</highlight></codeline>
<codeline lineno="10490"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10491"><highlight class="normal"></highlight></codeline>
<codeline lineno="10492"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>currentBlock-&gt;size<sp/>-=<sp/>misssingAlignment;</highlight></codeline>
<codeline lineno="10493"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>currentBlock-&gt;offset<sp/>+=<sp/>misssingAlignment;</highlight></codeline>
<codeline lineno="10494"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10495"><highlight class="normal"></highlight></codeline>
<codeline lineno="10496"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size<sp/>=<sp/>request.size<sp/>+<sp/>debugMargin;</highlight></codeline>
<codeline lineno="10497"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(currentBlock-&gt;size<sp/>==<sp/>size)</highlight></codeline>
<codeline lineno="10498"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10499"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(currentBlock<sp/>==<sp/>m_NullBlock)</highlight></codeline>
<codeline lineno="10500"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10501"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Setup<sp/>new<sp/>null<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10502"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_NullBlock<sp/>=<sp/>m_BlockAllocator.Alloc();</highlight></codeline>
<codeline lineno="10503"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_NullBlock-&gt;size<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="10504"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_NullBlock-&gt;offset<sp/>=<sp/>currentBlock-&gt;offset<sp/>+<sp/>size;</highlight></codeline>
<codeline lineno="10505"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_NullBlock-&gt;prevPhysical<sp/>=<sp/>currentBlock;</highlight></codeline>
<codeline lineno="10506"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_NullBlock-&gt;nextPhysical<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="10507"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_NullBlock-&gt;MarkFree();</highlight></codeline>
<codeline lineno="10508"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_NullBlock-&gt;PrevFree()<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="10509"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_NullBlock-&gt;NextFree()<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="10510"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>currentBlock-&gt;nextPhysical<sp/>=<sp/>m_NullBlock;</highlight></codeline>
<codeline lineno="10511"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>currentBlock-&gt;MarkTaken();</highlight></codeline>
<codeline lineno="10512"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10513"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10514"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10515"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10516"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(currentBlock-&gt;size<sp/>&gt;<sp/>size<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Proper<sp/>block<sp/>already<sp/>found,<sp/>shouldn&apos;t<sp/>find<sp/>smaller<sp/>one!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="10517"><highlight class="normal"></highlight></codeline>
<codeline lineno="10518"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>new<sp/>free<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10519"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Block*<sp/>newBlock<sp/>=<sp/>m_BlockAllocator.Alloc();</highlight></codeline>
<codeline lineno="10520"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newBlock-&gt;size<sp/>=<sp/>currentBlock-&gt;size<sp/>-<sp/>size;</highlight></codeline>
<codeline lineno="10521"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newBlock-&gt;offset<sp/>=<sp/>currentBlock-&gt;offset<sp/>+<sp/>size;</highlight></codeline>
<codeline lineno="10522"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newBlock-&gt;prevPhysical<sp/>=<sp/>currentBlock;</highlight></codeline>
<codeline lineno="10523"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newBlock-&gt;nextPhysical<sp/>=<sp/>currentBlock-&gt;nextPhysical;</highlight></codeline>
<codeline lineno="10524"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>currentBlock-&gt;nextPhysical<sp/>=<sp/>newBlock;</highlight></codeline>
<codeline lineno="10525"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>currentBlock-&gt;size<sp/>=<sp/>size;</highlight></codeline>
<codeline lineno="10526"><highlight class="normal"></highlight></codeline>
<codeline lineno="10527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(currentBlock<sp/>==<sp/>m_NullBlock)</highlight></codeline>
<codeline lineno="10528"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10529"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_NullBlock<sp/>=<sp/>newBlock;</highlight></codeline>
<codeline lineno="10530"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_NullBlock-&gt;MarkFree();</highlight></codeline>
<codeline lineno="10531"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_NullBlock-&gt;NextFree()<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="10532"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_NullBlock-&gt;PrevFree()<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="10533"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>currentBlock-&gt;MarkTaken();</highlight></codeline>
<codeline lineno="10534"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10535"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10536"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10537"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newBlock-&gt;nextPhysical-&gt;prevPhysical<sp/>=<sp/>newBlock;</highlight></codeline>
<codeline lineno="10538"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newBlock-&gt;MarkTaken();</highlight></codeline>
<codeline lineno="10539"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>InsertFreeBlock(newBlock);</highlight></codeline>
<codeline lineno="10540"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10541"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10542"><highlight class="normal"><sp/><sp/><sp/><sp/>currentBlock-&gt;UserData()<sp/>=<sp/>userData;</highlight></codeline>
<codeline lineno="10543"><highlight class="normal"></highlight></codeline>
<codeline lineno="10544"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(debugMargin<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="10545"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10546"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>currentBlock-&gt;size<sp/>-=<sp/>debugMargin;</highlight></codeline>
<codeline lineno="10547"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Block*<sp/>newBlock<sp/>=<sp/>m_BlockAllocator.Alloc();</highlight></codeline>
<codeline lineno="10548"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newBlock-&gt;size<sp/>=<sp/>debugMargin;</highlight></codeline>
<codeline lineno="10549"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newBlock-&gt;offset<sp/>=<sp/>currentBlock-&gt;offset<sp/>+<sp/>currentBlock-&gt;size;</highlight></codeline>
<codeline lineno="10550"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newBlock-&gt;prevPhysical<sp/>=<sp/>currentBlock;</highlight></codeline>
<codeline lineno="10551"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newBlock-&gt;nextPhysical<sp/>=<sp/>currentBlock-&gt;nextPhysical;</highlight></codeline>
<codeline lineno="10552"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newBlock-&gt;MarkTaken();</highlight></codeline>
<codeline lineno="10553"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>currentBlock-&gt;nextPhysical-&gt;prevPhysical<sp/>=<sp/>newBlock;</highlight></codeline>
<codeline lineno="10554"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>currentBlock-&gt;nextPhysical<sp/>=<sp/>newBlock;</highlight></codeline>
<codeline lineno="10555"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>InsertFreeBlock(newBlock);</highlight></codeline>
<codeline lineno="10556"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10557"><highlight class="normal"></highlight></codeline>
<codeline lineno="10558"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!IsVirtual())</highlight></codeline>
<codeline lineno="10559"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_GranularityHandler.AllocPages((uint8_t)(uintptr_t)request.customData,</highlight></codeline>
<codeline lineno="10560"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>currentBlock-&gt;offset,<sp/>currentBlock-&gt;size);</highlight></codeline>
<codeline lineno="10561"><highlight class="normal"><sp/><sp/><sp/><sp/>++m_AllocCount;</highlight></codeline>
<codeline lineno="10562"><highlight class="normal">}</highlight></codeline>
<codeline lineno="10563"><highlight class="normal"></highlight></codeline>
<codeline lineno="10564"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_TLSF::Free(VmaAllocHandle<sp/>allocHandle)</highlight></codeline>
<codeline lineno="10565"><highlight class="normal">{</highlight></codeline>
<codeline lineno="10566"><highlight class="normal"><sp/><sp/><sp/><sp/>Block*<sp/>block<sp/>=<sp/>(Block*)allocHandle;</highlight></codeline>
<codeline lineno="10567"><highlight class="normal"><sp/><sp/><sp/><sp/>Block*<sp/>next<sp/>=<sp/>block-&gt;nextPhysical;</highlight></codeline>
<codeline lineno="10568"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(!block-&gt;IsFree()<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Block<sp/>is<sp/>already<sp/>free!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="10569"><highlight class="normal"></highlight></codeline>
<codeline lineno="10570"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!IsVirtual())</highlight></codeline>
<codeline lineno="10571"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_GranularityHandler.FreePages(block-&gt;offset,<sp/>block-&gt;size);</highlight></codeline>
<codeline lineno="10572"><highlight class="normal"><sp/><sp/><sp/><sp/>--m_AllocCount;</highlight></codeline>
<codeline lineno="10573"><highlight class="normal"></highlight></codeline>
<codeline lineno="10574"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>debugMargin<sp/>=<sp/>GetDebugMargin();</highlight></codeline>
<codeline lineno="10575"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(debugMargin<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="10576"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10577"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>RemoveFreeBlock(next);</highlight></codeline>
<codeline lineno="10578"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MergeBlock(next,<sp/>block);</highlight></codeline>
<codeline lineno="10579"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block<sp/>=<sp/>next;</highlight></codeline>
<codeline lineno="10580"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>next<sp/>=<sp/>next-&gt;nextPhysical;</highlight></codeline>
<codeline lineno="10581"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10582"><highlight class="normal"></highlight></codeline>
<codeline lineno="10583"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Try<sp/>merging</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10584"><highlight class="normal"><sp/><sp/><sp/><sp/>Block*<sp/>prev<sp/>=<sp/>block-&gt;prevPhysical;</highlight></codeline>
<codeline lineno="10585"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(prev<sp/>!=<sp/>VMA_NULL<sp/>&amp;&amp;<sp/>prev-&gt;IsFree()<sp/>&amp;&amp;<sp/>prev-&gt;size<sp/>!=<sp/>debugMargin)</highlight></codeline>
<codeline lineno="10586"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10587"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>RemoveFreeBlock(prev);</highlight></codeline>
<codeline lineno="10588"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MergeBlock(block,<sp/>prev);</highlight></codeline>
<codeline lineno="10589"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10590"><highlight class="normal"></highlight></codeline>
<codeline lineno="10591"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!next-&gt;IsFree())</highlight></codeline>
<codeline lineno="10592"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>InsertFreeBlock(block);</highlight></codeline>
<codeline lineno="10593"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(next<sp/>==<sp/>m_NullBlock)</highlight></codeline>
<codeline lineno="10594"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MergeBlock(m_NullBlock,<sp/>block);</highlight></codeline>
<codeline lineno="10595"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10596"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10597"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>RemoveFreeBlock(next);</highlight></codeline>
<codeline lineno="10598"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MergeBlock(next,<sp/>block);</highlight></codeline>
<codeline lineno="10599"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>InsertFreeBlock(next);</highlight></codeline>
<codeline lineno="10600"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10601"><highlight class="normal">}</highlight></codeline>
<codeline lineno="10602"><highlight class="normal"></highlight></codeline>
<codeline lineno="10603"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_TLSF::GetAllocationInfo(VmaAllocHandle<sp/>allocHandle,<sp/><ref refid="struct_vma_virtual_allocation_info" kindref="compound">VmaVirtualAllocationInfo</ref>&amp;<sp/>outInfo)</highlight></codeline>
<codeline lineno="10604"><highlight class="normal">{</highlight></codeline>
<codeline lineno="10605"><highlight class="normal"><sp/><sp/><sp/><sp/>Block*<sp/>block<sp/>=<sp/>(Block*)allocHandle;</highlight></codeline>
<codeline lineno="10606"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(!block-&gt;IsFree()<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Cannot<sp/>get<sp/>allocation<sp/>info<sp/>for<sp/>free<sp/>block!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="10607"><highlight class="normal"><sp/><sp/><sp/><sp/>outInfo.<ref refid="struct_vma_virtual_allocation_info_1accb40a8205f49ccca3de975da7d1a2b5" kindref="member">offset</ref><sp/>=<sp/>block-&gt;offset;</highlight></codeline>
<codeline lineno="10608"><highlight class="normal"><sp/><sp/><sp/><sp/>outInfo.<ref refid="struct_vma_virtual_allocation_info_1afb6d6bd0a6813869ea0842048d40aa2b" kindref="member">size</ref><sp/>=<sp/>block-&gt;size;</highlight></codeline>
<codeline lineno="10609"><highlight class="normal"><sp/><sp/><sp/><sp/>outInfo.<ref refid="struct_vma_virtual_allocation_info_1a224aa08739618d27066a16b7f60a2bbc" kindref="member">pUserData</ref><sp/>=<sp/>block-&gt;UserData();</highlight></codeline>
<codeline lineno="10610"><highlight class="normal">}</highlight></codeline>
<codeline lineno="10611"><highlight class="normal"></highlight></codeline>
<codeline lineno="10612"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>VmaBlockMetadata_TLSF::GetAllocationUserData(VmaAllocHandle<sp/>allocHandle)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="10613"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="10614"><highlight class="normal"><sp/><sp/><sp/><sp/>Block*<sp/>block<sp/>=<sp/>(Block*)allocHandle;</highlight></codeline>
<codeline lineno="10615"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(!block-&gt;IsFree()<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Cannot<sp/>get<sp/>user<sp/>data<sp/>for<sp/>free<sp/>block!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="10616"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>block-&gt;UserData();</highlight></codeline>
<codeline lineno="10617"><highlight class="normal">}</highlight></codeline>
<codeline lineno="10618"><highlight class="normal"></highlight></codeline>
<codeline lineno="10619"><highlight class="normal">VmaAllocHandle<sp/>VmaBlockMetadata_TLSF::GetAllocationListBegin()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="10620"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="10621"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_AllocCount<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="10622"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="10623"><highlight class="normal"></highlight></codeline>
<codeline lineno="10624"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(Block*<sp/>block<sp/>=<sp/>m_NullBlock-&gt;prevPhysical;<sp/>block;<sp/>block<sp/>=<sp/>block-&gt;prevPhysical)</highlight></codeline>
<codeline lineno="10625"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10626"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!block-&gt;IsFree())</highlight></codeline>
<codeline lineno="10627"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(VmaAllocHandle)block;</highlight></codeline>
<codeline lineno="10628"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10629"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(</highlight><highlight class="keyword">false</highlight><highlight class="normal"><sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;If<sp/>m_AllocCount<sp/>&gt;<sp/>0<sp/>then<sp/>should<sp/>find<sp/>any<sp/>allocation!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="10630"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="10631"><highlight class="normal">}</highlight></codeline>
<codeline lineno="10632"><highlight class="normal"></highlight></codeline>
<codeline lineno="10633"><highlight class="normal">VmaAllocHandle<sp/>VmaBlockMetadata_TLSF::GetNextAllocation(VmaAllocHandle<sp/>prevAlloc)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="10634"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="10635"><highlight class="normal"><sp/><sp/><sp/><sp/>Block*<sp/>startBlock<sp/>=<sp/>(Block*)prevAlloc;</highlight></codeline>
<codeline lineno="10636"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(!startBlock-&gt;IsFree()<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Incorrect<sp/>block!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="10637"><highlight class="normal"></highlight></codeline>
<codeline lineno="10638"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(Block*<sp/>block<sp/>=<sp/>startBlock-&gt;prevPhysical;<sp/>block;<sp/>block<sp/>=<sp/>block-&gt;prevPhysical)</highlight></codeline>
<codeline lineno="10639"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10640"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!block-&gt;IsFree())</highlight></codeline>
<codeline lineno="10641"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(VmaAllocHandle)block;</highlight></codeline>
<codeline lineno="10642"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10643"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="10644"><highlight class="normal">}</highlight></codeline>
<codeline lineno="10645"><highlight class="normal"></highlight></codeline>
<codeline lineno="10646"><highlight class="normal">VkDeviceSize<sp/>VmaBlockMetadata_TLSF::GetNextFreeRegionSize(VmaAllocHandle<sp/>alloc)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="10647"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="10648"><highlight class="normal"><sp/><sp/><sp/><sp/>Block*<sp/>block<sp/>=<sp/>(Block*)alloc;</highlight></codeline>
<codeline lineno="10649"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(!block-&gt;IsFree()<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Incorrect<sp/>block!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="10650"><highlight class="normal"></highlight></codeline>
<codeline lineno="10651"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(block-&gt;prevPhysical)</highlight></codeline>
<codeline lineno="10652"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>block-&gt;prevPhysical-&gt;IsFree()<sp/>?<sp/>block-&gt;prevPhysical-&gt;size<sp/>:<sp/>0;</highlight></codeline>
<codeline lineno="10653"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="10654"><highlight class="normal">}</highlight></codeline>
<codeline lineno="10655"><highlight class="normal"></highlight></codeline>
<codeline lineno="10656"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_TLSF::Clear()</highlight></codeline>
<codeline lineno="10657"><highlight class="normal">{</highlight></codeline>
<codeline lineno="10658"><highlight class="normal"><sp/><sp/><sp/><sp/>m_AllocCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="10659"><highlight class="normal"><sp/><sp/><sp/><sp/>m_BlocksFreeCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="10660"><highlight class="normal"><sp/><sp/><sp/><sp/>m_BlocksFreeSize<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="10661"><highlight class="normal"><sp/><sp/><sp/><sp/>m_IsFreeBitmap<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="10662"><highlight class="normal"><sp/><sp/><sp/><sp/>m_NullBlock-&gt;offset<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="10663"><highlight class="normal"><sp/><sp/><sp/><sp/>m_NullBlock-&gt;size<sp/>=<sp/>GetSize();</highlight></codeline>
<codeline lineno="10664"><highlight class="normal"><sp/><sp/><sp/><sp/>Block*<sp/>block<sp/>=<sp/>m_NullBlock-&gt;prevPhysical;</highlight></codeline>
<codeline lineno="10665"><highlight class="normal"><sp/><sp/><sp/><sp/>m_NullBlock-&gt;prevPhysical<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="10666"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(block)</highlight></codeline>
<codeline lineno="10667"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10668"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Block*<sp/>prev<sp/>=<sp/>block-&gt;prevPhysical;</highlight></codeline>
<codeline lineno="10669"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_BlockAllocator.Free(block);</highlight></codeline>
<codeline lineno="10670"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block<sp/>=<sp/>prev;</highlight></codeline>
<codeline lineno="10671"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10672"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(m_FreeList,<sp/>0,<sp/>m_ListsCount<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(Block*));</highlight></codeline>
<codeline lineno="10673"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(m_InnerIsFreeBitmap,<sp/>0,<sp/>m_MemoryClasses<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(uint32_t));</highlight></codeline>
<codeline lineno="10674"><highlight class="normal"><sp/><sp/><sp/><sp/>m_GranularityHandler.Clear();</highlight></codeline>
<codeline lineno="10675"><highlight class="normal">}</highlight></codeline>
<codeline lineno="10676"><highlight class="normal"></highlight></codeline>
<codeline lineno="10677"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_TLSF::SetAllocationUserData(VmaAllocHandle<sp/>allocHandle,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>userData)</highlight></codeline>
<codeline lineno="10678"><highlight class="normal">{</highlight></codeline>
<codeline lineno="10679"><highlight class="normal"><sp/><sp/><sp/><sp/>Block*<sp/>block<sp/>=<sp/>(Block*)allocHandle;</highlight></codeline>
<codeline lineno="10680"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(!block-&gt;IsFree()<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Trying<sp/>to<sp/>set<sp/>user<sp/>data<sp/>for<sp/>not<sp/>allocated<sp/>block!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="10681"><highlight class="normal"><sp/><sp/><sp/><sp/>block-&gt;UserData()<sp/>=<sp/>userData;</highlight></codeline>
<codeline lineno="10682"><highlight class="normal">}</highlight></codeline>
<codeline lineno="10683"><highlight class="normal"></highlight></codeline>
<codeline lineno="10684"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_TLSF::DebugLogAllAllocations()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="10685"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="10686"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(Block*<sp/>block<sp/>=<sp/>m_NullBlock-&gt;prevPhysical;<sp/>block<sp/>!=<sp/>VMA_NULL;<sp/>block<sp/>=<sp/>block-&gt;prevPhysical)</highlight></codeline>
<codeline lineno="10687"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!block-&gt;IsFree())</highlight></codeline>
<codeline lineno="10688"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>DebugLogAllocation(block-&gt;offset,<sp/>block-&gt;size,<sp/>block-&gt;UserData());</highlight></codeline>
<codeline lineno="10689"><highlight class="normal">}</highlight></codeline>
<codeline lineno="10690"><highlight class="normal"></highlight></codeline>
<codeline lineno="10691"><highlight class="normal">uint8_t<sp/>VmaBlockMetadata_TLSF::SizeToMemoryClass(VkDeviceSize<sp/>size)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="10692"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="10693"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(size<sp/>&gt;<sp/>SMALL_BUFFER_SIZE)</highlight></codeline>
<codeline lineno="10694"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VMA_BITSCAN_MSB(size)<sp/>-<sp/>MEMORY_CLASS_SHIFT;</highlight></codeline>
<codeline lineno="10695"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="10696"><highlight class="normal">}</highlight></codeline>
<codeline lineno="10697"><highlight class="normal"></highlight></codeline>
<codeline lineno="10698"><highlight class="normal">uint16_t<sp/>VmaBlockMetadata_TLSF::SizeToSecondIndex(VkDeviceSize<sp/>size,<sp/>uint8_t<sp/>memoryClass)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="10699"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="10700"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(memoryClass<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="10701"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10702"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(IsVirtual())</highlight></codeline>
<codeline lineno="10703"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">uint16_t</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">((size<sp/>-<sp/>1)<sp/>/<sp/>8);</highlight></codeline>
<codeline lineno="10704"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10705"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">uint16_t</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">((size<sp/>-<sp/>1)<sp/>/<sp/>64);</highlight></codeline>
<codeline lineno="10706"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10707"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">uint16_t</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">((size<sp/>&gt;&gt;<sp/>(memoryClass<sp/>+<sp/>MEMORY_CLASS_SHIFT<sp/>-<sp/>SECOND_LEVEL_INDEX))<sp/>^<sp/>(1U<sp/>&lt;&lt;<sp/>SECOND_LEVEL_INDEX));</highlight></codeline>
<codeline lineno="10708"><highlight class="normal">}</highlight></codeline>
<codeline lineno="10709"><highlight class="normal"></highlight></codeline>
<codeline lineno="10710"><highlight class="normal">uint32_t<sp/>VmaBlockMetadata_TLSF::GetListIndex(uint8_t<sp/>memoryClass,<sp/>uint16_t<sp/>secondIndex)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="10711"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="10712"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(memoryClass<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="10713"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>secondIndex;</highlight></codeline>
<codeline lineno="10714"><highlight class="normal"></highlight></codeline>
<codeline lineno="10715"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>index<sp/>=<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">uint32_t</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(memoryClass<sp/>-<sp/>1)<sp/>*<sp/>(1<sp/>&lt;&lt;<sp/>SECOND_LEVEL_INDEX)<sp/>+<sp/>secondIndex;</highlight></codeline>
<codeline lineno="10716"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(IsVirtual())</highlight></codeline>
<codeline lineno="10717"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>index<sp/>+<sp/>(1<sp/>&lt;&lt;<sp/>SECOND_LEVEL_INDEX);</highlight></codeline>
<codeline lineno="10718"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10719"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>index<sp/>+<sp/>4;</highlight></codeline>
<codeline lineno="10720"><highlight class="normal">}</highlight></codeline>
<codeline lineno="10721"><highlight class="normal"></highlight></codeline>
<codeline lineno="10722"><highlight class="normal">uint32_t<sp/>VmaBlockMetadata_TLSF::GetListIndex(VkDeviceSize<sp/>size)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="10723"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="10724"><highlight class="normal"><sp/><sp/><sp/><sp/>uint8_t<sp/>memoryClass<sp/>=<sp/>SizeToMemoryClass(size);</highlight></codeline>
<codeline lineno="10725"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>GetListIndex(memoryClass,<sp/>SizeToSecondIndex(size,<sp/>memoryClass));</highlight></codeline>
<codeline lineno="10726"><highlight class="normal">}</highlight></codeline>
<codeline lineno="10727"><highlight class="normal"></highlight></codeline>
<codeline lineno="10728"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_TLSF::RemoveFreeBlock(Block*<sp/>block)</highlight></codeline>
<codeline lineno="10729"><highlight class="normal">{</highlight></codeline>
<codeline lineno="10730"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(block<sp/>!=<sp/>m_NullBlock);</highlight></codeline>
<codeline lineno="10731"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(block-&gt;IsFree());</highlight></codeline>
<codeline lineno="10732"><highlight class="normal"></highlight></codeline>
<codeline lineno="10733"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(block-&gt;NextFree()<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="10734"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block-&gt;NextFree()-&gt;PrevFree()<sp/>=<sp/>block-&gt;PrevFree();</highlight></codeline>
<codeline lineno="10735"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(block-&gt;PrevFree()<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="10736"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block-&gt;PrevFree()-&gt;NextFree()<sp/>=<sp/>block-&gt;NextFree();</highlight></codeline>
<codeline lineno="10737"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10738"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10739"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint8_t<sp/>memClass<sp/>=<sp/>SizeToMemoryClass(block-&gt;size);</highlight></codeline>
<codeline lineno="10740"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint16_t<sp/>secondIndex<sp/>=<sp/>SizeToSecondIndex(block-&gt;size,<sp/>memClass);</highlight></codeline>
<codeline lineno="10741"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>index<sp/>=<sp/>GetListIndex(memClass,<sp/>secondIndex);</highlight></codeline>
<codeline lineno="10742"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(m_FreeList[index]<sp/>==<sp/>block);</highlight></codeline>
<codeline lineno="10743"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_FreeList[index]<sp/>=<sp/>block-&gt;NextFree();</highlight></codeline>
<codeline lineno="10744"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(block-&gt;NextFree()<sp/>==<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="10745"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10746"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_InnerIsFreeBitmap[memClass]<sp/>&amp;=<sp/>~(1U<sp/>&lt;&lt;<sp/>secondIndex);</highlight></codeline>
<codeline lineno="10747"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_InnerIsFreeBitmap[memClass]<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="10748"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_IsFreeBitmap<sp/>&amp;=<sp/>~(1UL<sp/>&lt;&lt;<sp/>memClass);</highlight></codeline>
<codeline lineno="10749"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10750"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10751"><highlight class="normal"><sp/><sp/><sp/><sp/>block-&gt;MarkTaken();</highlight></codeline>
<codeline lineno="10752"><highlight class="normal"><sp/><sp/><sp/><sp/>block-&gt;UserData()<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="10753"><highlight class="normal"><sp/><sp/><sp/><sp/>--m_BlocksFreeCount;</highlight></codeline>
<codeline lineno="10754"><highlight class="normal"><sp/><sp/><sp/><sp/>m_BlocksFreeSize<sp/>-=<sp/>block-&gt;size;</highlight></codeline>
<codeline lineno="10755"><highlight class="normal">}</highlight></codeline>
<codeline lineno="10756"><highlight class="normal"></highlight></codeline>
<codeline lineno="10757"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_TLSF::InsertFreeBlock(Block*<sp/>block)</highlight></codeline>
<codeline lineno="10758"><highlight class="normal">{</highlight></codeline>
<codeline lineno="10759"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(block<sp/>!=<sp/>m_NullBlock);</highlight></codeline>
<codeline lineno="10760"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(!block-&gt;IsFree()<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Cannot<sp/>insert<sp/>block<sp/>twice!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="10761"><highlight class="normal"></highlight></codeline>
<codeline lineno="10762"><highlight class="normal"><sp/><sp/><sp/><sp/>uint8_t<sp/>memClass<sp/>=<sp/>SizeToMemoryClass(block-&gt;size);</highlight></codeline>
<codeline lineno="10763"><highlight class="normal"><sp/><sp/><sp/><sp/>uint16_t<sp/>secondIndex<sp/>=<sp/>SizeToSecondIndex(block-&gt;size,<sp/>memClass);</highlight></codeline>
<codeline lineno="10764"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>index<sp/>=<sp/>GetListIndex(memClass,<sp/>secondIndex);</highlight></codeline>
<codeline lineno="10765"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(index<sp/>&lt;<sp/>m_ListsCount);</highlight></codeline>
<codeline lineno="10766"><highlight class="normal"><sp/><sp/><sp/><sp/>block-&gt;PrevFree()<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="10767"><highlight class="normal"><sp/><sp/><sp/><sp/>block-&gt;NextFree()<sp/>=<sp/>m_FreeList[index];</highlight></codeline>
<codeline lineno="10768"><highlight class="normal"><sp/><sp/><sp/><sp/>m_FreeList[index]<sp/>=<sp/>block;</highlight></codeline>
<codeline lineno="10769"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(block-&gt;NextFree()<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="10770"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block-&gt;NextFree()-&gt;PrevFree()<sp/>=<sp/>block;</highlight></codeline>
<codeline lineno="10771"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10772"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10773"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_InnerIsFreeBitmap[memClass]<sp/>|=<sp/>1U<sp/>&lt;&lt;<sp/>secondIndex;</highlight></codeline>
<codeline lineno="10774"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_IsFreeBitmap<sp/>|=<sp/>1UL<sp/>&lt;&lt;<sp/>memClass;</highlight></codeline>
<codeline lineno="10775"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10776"><highlight class="normal"><sp/><sp/><sp/><sp/>++m_BlocksFreeCount;</highlight></codeline>
<codeline lineno="10777"><highlight class="normal"><sp/><sp/><sp/><sp/>m_BlocksFreeSize<sp/>+=<sp/>block-&gt;size;</highlight></codeline>
<codeline lineno="10778"><highlight class="normal">}</highlight></codeline>
<codeline lineno="10779"><highlight class="normal"></highlight></codeline>
<codeline lineno="10780"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockMetadata_TLSF::MergeBlock(Block*<sp/>block,<sp/>Block*<sp/>prev)</highlight></codeline>
<codeline lineno="10781"><highlight class="normal">{</highlight></codeline>
<codeline lineno="10782"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(block-&gt;prevPhysical<sp/>==<sp/>prev<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Cannot<sp/>merge<sp/>seperate<sp/>physical<sp/>regions!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="10783"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(!prev-&gt;IsFree()<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Cannot<sp/>merge<sp/>block<sp/>that<sp/>belongs<sp/>to<sp/>free<sp/>list!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="10784"><highlight class="normal"></highlight></codeline>
<codeline lineno="10785"><highlight class="normal"><sp/><sp/><sp/><sp/>block-&gt;offset<sp/>=<sp/>prev-&gt;offset;</highlight></codeline>
<codeline lineno="10786"><highlight class="normal"><sp/><sp/><sp/><sp/>block-&gt;size<sp/>+=<sp/>prev-&gt;size;</highlight></codeline>
<codeline lineno="10787"><highlight class="normal"><sp/><sp/><sp/><sp/>block-&gt;prevPhysical<sp/>=<sp/>prev-&gt;prevPhysical;</highlight></codeline>
<codeline lineno="10788"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(block-&gt;prevPhysical)</highlight></codeline>
<codeline lineno="10789"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block-&gt;prevPhysical-&gt;nextPhysical<sp/>=<sp/>block;</highlight></codeline>
<codeline lineno="10790"><highlight class="normal"><sp/><sp/><sp/><sp/>m_BlockAllocator.Free(prev);</highlight></codeline>
<codeline lineno="10791"><highlight class="normal">}</highlight></codeline>
<codeline lineno="10792"><highlight class="normal"></highlight></codeline>
<codeline lineno="10793"><highlight class="normal">VmaBlockMetadata_TLSF::Block*<sp/>VmaBlockMetadata_TLSF::FindFreeBlock(VkDeviceSize<sp/>size,<sp/>uint32_t&amp;<sp/>listIndex)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="10794"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="10795"><highlight class="normal"><sp/><sp/><sp/><sp/>uint8_t<sp/>memoryClass<sp/>=<sp/>SizeToMemoryClass(size);</highlight></codeline>
<codeline lineno="10796"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>innerFreeMap<sp/>=<sp/>m_InnerIsFreeBitmap[memoryClass]<sp/>&amp;<sp/>(~0U<sp/>&lt;&lt;<sp/>SizeToSecondIndex(size,<sp/>memoryClass));</highlight></codeline>
<codeline lineno="10797"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!innerFreeMap)</highlight></codeline>
<codeline lineno="10798"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10799"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>higher<sp/>levels<sp/>for<sp/>avaiable<sp/>blocks</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10800"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>freeMap<sp/>=<sp/>m_IsFreeBitmap<sp/>&amp;<sp/>(~0UL<sp/>&lt;&lt;<sp/>(memoryClass<sp/>+<sp/>1));</highlight></codeline>
<codeline lineno="10801"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!freeMap)</highlight></codeline>
<codeline lineno="10802"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VMA_NULL;<sp/></highlight><highlight class="comment">//<sp/>No<sp/>more<sp/>memory<sp/>avaible</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10803"><highlight class="normal"></highlight></codeline>
<codeline lineno="10804"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>lowest<sp/>free<sp/>region</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10805"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memoryClass<sp/>=<sp/>VMA_BITSCAN_LSB(freeMap);</highlight></codeline>
<codeline lineno="10806"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>innerFreeMap<sp/>=<sp/>m_InnerIsFreeBitmap[memoryClass];</highlight></codeline>
<codeline lineno="10807"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(innerFreeMap<sp/>!=<sp/>0);</highlight></codeline>
<codeline lineno="10808"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10809"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>lowest<sp/>free<sp/>subregion</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10810"><highlight class="normal"><sp/><sp/><sp/><sp/>listIndex<sp/>=<sp/>GetListIndex(memoryClass,<sp/>VMA_BITSCAN_LSB(innerFreeMap));</highlight></codeline>
<codeline lineno="10811"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_FreeList[listIndex]);</highlight></codeline>
<codeline lineno="10812"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_FreeList[listIndex];</highlight></codeline>
<codeline lineno="10813"><highlight class="normal">}</highlight></codeline>
<codeline lineno="10814"><highlight class="normal"></highlight></codeline>
<codeline lineno="10815"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaBlockMetadata_TLSF::CheckBlock(</highlight></codeline>
<codeline lineno="10816"><highlight class="normal"><sp/><sp/><sp/><sp/>Block&amp;<sp/>block,</highlight></codeline>
<codeline lineno="10817"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>listIndex,</highlight></codeline>
<codeline lineno="10818"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocSize,</highlight></codeline>
<codeline lineno="10819"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocAlignment,</highlight></codeline>
<codeline lineno="10820"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>allocType,</highlight></codeline>
<codeline lineno="10821"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocationRequest*<sp/>pAllocationRequest)</highlight></codeline>
<codeline lineno="10822"><highlight class="normal">{</highlight></codeline>
<codeline lineno="10823"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(block.IsFree()<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Block<sp/>is<sp/>already<sp/>taken!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="10824"><highlight class="normal"></highlight></codeline>
<codeline lineno="10825"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>alignedOffset<sp/>=<sp/>VmaAlignUp(block.offset,<sp/>allocAlignment);</highlight></codeline>
<codeline lineno="10826"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(block.size<sp/>&lt;<sp/>allocSize<sp/>+<sp/>alignedOffset<sp/>-<sp/>block.offset)</highlight></codeline>
<codeline lineno="10827"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10828"><highlight class="normal"></highlight></codeline>
<codeline lineno="10829"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>for<sp/>granularity<sp/>conflicts</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10830"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!IsVirtual()<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="10831"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_GranularityHandler.CheckConflictAndAlignUp(alignedOffset,<sp/>allocSize,<sp/>block.offset,<sp/>block.size,<sp/>allocType))</highlight></codeline>
<codeline lineno="10832"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10833"><highlight class="normal"></highlight></codeline>
<codeline lineno="10834"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Alloc<sp/>successful</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10835"><highlight class="normal"><sp/><sp/><sp/><sp/>pAllocationRequest-&gt;type<sp/>=<sp/>VmaAllocationRequestType::TLSF;</highlight></codeline>
<codeline lineno="10836"><highlight class="normal"><sp/><sp/><sp/><sp/>pAllocationRequest-&gt;allocHandle<sp/>=<sp/>(VmaAllocHandle)&amp;block;</highlight></codeline>
<codeline lineno="10837"><highlight class="normal"><sp/><sp/><sp/><sp/>pAllocationRequest-&gt;size<sp/>=<sp/>allocSize<sp/>-<sp/>GetDebugMargin();</highlight></codeline>
<codeline lineno="10838"><highlight class="normal"><sp/><sp/><sp/><sp/>pAllocationRequest-&gt;customData<sp/>=<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)allocType;</highlight></codeline>
<codeline lineno="10839"><highlight class="normal"><sp/><sp/><sp/><sp/>pAllocationRequest-&gt;algorithmData<sp/>=<sp/>alignedOffset;</highlight></codeline>
<codeline lineno="10840"><highlight class="normal"></highlight></codeline>
<codeline lineno="10841"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Place<sp/>block<sp/>at<sp/>the<sp/>start<sp/>of<sp/>list<sp/>if<sp/>it&apos;s<sp/>normal<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10842"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(listIndex<sp/>!=<sp/>m_ListsCount<sp/>&amp;&amp;<sp/>block.PrevFree())</highlight></codeline>
<codeline lineno="10843"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="10844"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block.PrevFree()-&gt;NextFree()<sp/>=<sp/>block.NextFree();</highlight></codeline>
<codeline lineno="10845"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(block.NextFree())</highlight></codeline>
<codeline lineno="10846"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block.NextFree()-&gt;PrevFree()<sp/>=<sp/>block.PrevFree();</highlight></codeline>
<codeline lineno="10847"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block.PrevFree()<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="10848"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block.NextFree()<sp/>=<sp/>m_FreeList[listIndex];</highlight></codeline>
<codeline lineno="10849"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_FreeList[listIndex]<sp/>=<sp/>&amp;block;</highlight></codeline>
<codeline lineno="10850"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(block.NextFree())</highlight></codeline>
<codeline lineno="10851"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block.NextFree()-&gt;PrevFree()<sp/>=<sp/>&amp;block;</highlight></codeline>
<codeline lineno="10852"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="10853"><highlight class="normal"></highlight></codeline>
<codeline lineno="10854"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10855"><highlight class="normal">}</highlight></codeline>
<codeline lineno="10856"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_BLOCK_METADATA_TLSF_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10857"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_BLOCK_METADATA_TLSF</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10858"><highlight class="normal"></highlight></codeline>
<codeline lineno="10859"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_BLOCK_VECTOR</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10860"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="10861"><highlight class="comment">Sequence<sp/>of<sp/>VmaDeviceMemoryBlock.<sp/>Represents<sp/>memory<sp/>blocks<sp/>allocated<sp/>for<sp/>a<sp/>specific</highlight></codeline>
<codeline lineno="10862"><highlight class="comment">Vulkan<sp/>memory<sp/>type.</highlight></codeline>
<codeline lineno="10863"><highlight class="comment"></highlight></codeline>
<codeline lineno="10864"><highlight class="comment">Synchronized<sp/>internally<sp/>with<sp/>a<sp/>mutex.</highlight></codeline>
<codeline lineno="10865"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10866"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaBlockVector</highlight></codeline>
<codeline lineno="10867"><highlight class="normal">{</highlight></codeline>
<codeline lineno="10868"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">friend</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaDefragmentationContext_T;</highlight></codeline>
<codeline lineno="10869"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_CLASS_NO_COPY(VmaBlockVector)</highlight></codeline>
<codeline lineno="10870"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="10871"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaBlockVector(</highlight></codeline>
<codeline lineno="10872"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,</highlight></codeline>
<codeline lineno="10873"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>hParentPool,</highlight></codeline>
<codeline lineno="10874"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>memoryTypeIndex,</highlight></codeline>
<codeline lineno="10875"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>preferredBlockSize,</highlight></codeline>
<codeline lineno="10876"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>minBlockCount,</highlight></codeline>
<codeline lineno="10877"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>maxBlockCount,</highlight></codeline>
<codeline lineno="10878"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>bufferImageGranularity,</highlight></codeline>
<codeline lineno="10879"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>explicitBlockSize,</highlight></codeline>
<codeline lineno="10880"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>algorithm,</highlight></codeline>
<codeline lineno="10881"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>priority,</highlight></codeline>
<codeline lineno="10882"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>minAllocationAlignment,</highlight></codeline>
<codeline lineno="10883"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pMemoryAllocateNext);</highlight></codeline>
<codeline lineno="10884"><highlight class="normal"><sp/><sp/><sp/><sp/>~VmaBlockVector();</highlight></codeline>
<codeline lineno="10885"><highlight class="normal"></highlight></codeline>
<codeline lineno="10886"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>GetAllocator()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_hAllocator;<sp/>}</highlight></codeline>
<codeline lineno="10887"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>GetParentPool()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_hParentPool;<sp/>}</highlight></codeline>
<codeline lineno="10888"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>IsCustomPool()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_hParentPool<sp/>!=<sp/>VMA_NULL;<sp/>}</highlight></codeline>
<codeline lineno="10889"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>GetMemoryTypeIndex()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_MemoryTypeIndex;<sp/>}</highlight></codeline>
<codeline lineno="10890"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>GetPreferredBlockSize()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_PreferredBlockSize;<sp/>}</highlight></codeline>
<codeline lineno="10891"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>GetBufferImageGranularity()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_BufferImageGranularity;<sp/>}</highlight></codeline>
<codeline lineno="10892"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>GetAlgorithm()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Algorithm;<sp/>}</highlight></codeline>
<codeline lineno="10893"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>HasExplicitBlockSize()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_ExplicitBlockSize;<sp/>}</highlight></codeline>
<codeline lineno="10894"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>GetPriority()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Priority;<sp/>}</highlight></codeline>
<codeline lineno="10895"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>GetAllocationNextPtr()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pMemoryAllocateNext;<sp/>}</highlight></codeline>
<codeline lineno="10896"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>To<sp/>be<sp/>used<sp/>only<sp/>while<sp/>the<sp/>m_Mutex<sp/>is<sp/>locked.<sp/>Used<sp/>during<sp/>defragmentation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10897"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>GetBlockCount()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Blocks.size();<sp/>}</highlight></codeline>
<codeline lineno="10898"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>To<sp/>be<sp/>used<sp/>only<sp/>while<sp/>the<sp/>m_Mutex<sp/>is<sp/>locked.<sp/>Used<sp/>during<sp/>defragmentation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10899"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/>GetBlock(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Blocks[index];<sp/>}</highlight></codeline>
<codeline lineno="10900"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_RW_MUTEX<sp/>&amp;GetMutex()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Mutex;<sp/>}</highlight></codeline>
<codeline lineno="10901"><highlight class="normal"></highlight></codeline>
<codeline lineno="10902"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>CreateMinBlocks();</highlight></codeline>
<codeline lineno="10903"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>AddStatistics(<ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref>&amp;<sp/>inoutStats);</highlight></codeline>
<codeline lineno="10904"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>AddDetailedStatistics(<ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>&amp;<sp/>inoutStats);</highlight></codeline>
<codeline lineno="10905"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>IsEmpty();</highlight></codeline>
<codeline lineno="10906"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>IsCorruptionDetectionEnabled()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10907"><highlight class="normal"></highlight></codeline>
<codeline lineno="10908"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>Allocate(</highlight></codeline>
<codeline lineno="10909"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size,</highlight></codeline>
<codeline lineno="10910"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>alignment,</highlight></codeline>
<codeline lineno="10911"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>&amp;<sp/>createInfo,</highlight></codeline>
<codeline lineno="10912"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>suballocType,</highlight></codeline>
<codeline lineno="10913"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>allocationCount,</highlight></codeline>
<codeline lineno="10914"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>pAllocations);</highlight></codeline>
<codeline lineno="10915"><highlight class="normal"></highlight></codeline>
<codeline lineno="10916"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Free(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>hAllocation);</highlight></codeline>
<codeline lineno="10917"><highlight class="normal"></highlight></codeline>
<codeline lineno="10918"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10919"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>PrintDetailedMap(</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>VmaJsonWriter&amp;<sp/>json);</highlight></codeline>
<codeline lineno="10920"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10921"><highlight class="normal"></highlight></codeline>
<codeline lineno="10922"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>CheckCorruption();</highlight></codeline>
<codeline lineno="10923"><highlight class="normal"></highlight></codeline>
<codeline lineno="10924"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="10925"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>m_hAllocator;</highlight></codeline>
<codeline lineno="10926"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>m_hParentPool;</highlight></codeline>
<codeline lineno="10927"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>m_MemoryTypeIndex;</highlight></codeline>
<codeline lineno="10928"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>m_PreferredBlockSize;</highlight></codeline>
<codeline lineno="10929"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>m_MinBlockCount;</highlight></codeline>
<codeline lineno="10930"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>m_MaxBlockCount;</highlight></codeline>
<codeline lineno="10931"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>m_BufferImageGranularity;</highlight></codeline>
<codeline lineno="10932"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>m_ExplicitBlockSize;</highlight></codeline>
<codeline lineno="10933"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>m_Algorithm;</highlight></codeline>
<codeline lineno="10934"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>m_Priority;</highlight></codeline>
<codeline lineno="10935"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>m_MinAllocationAlignment;</highlight></codeline>
<codeline lineno="10936"><highlight class="normal"></highlight></codeline>
<codeline lineno="10937"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>m_pMemoryAllocateNext;</highlight></codeline>
<codeline lineno="10938"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_RW_MUTEX<sp/>m_Mutex;</highlight></codeline>
<codeline lineno="10939"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Incrementally<sp/>sorted<sp/>by<sp/>sumFreeSize,<sp/>ascending.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10940"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaVector&lt;VmaDeviceMemoryBlock*,<sp/>VmaStlAllocator&lt;VmaDeviceMemoryBlock*&gt;&gt;<sp/>m_Blocks;</highlight></codeline>
<codeline lineno="10941"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>m_NextBlockId;</highlight></codeline>
<codeline lineno="10942"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>m_IncrementalSort<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10943"><highlight class="normal"></highlight></codeline>
<codeline lineno="10944"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>SetIncrementalSort(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>val)<sp/>{<sp/>m_IncrementalSort<sp/>=<sp/>val;<sp/>}</highlight></codeline>
<codeline lineno="10945"><highlight class="normal"></highlight></codeline>
<codeline lineno="10946"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>CalcMaxBlockSize()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="10947"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Finds<sp/>and<sp/>removes<sp/>given<sp/>block<sp/>from<sp/>vector.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10948"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Remove(VmaDeviceMemoryBlock*<sp/>pBlock);</highlight></codeline>
<codeline lineno="10949"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Performs<sp/>single<sp/>step<sp/>in<sp/>sorting<sp/>m_Blocks.<sp/>They<sp/>may<sp/>not<sp/>be<sp/>fully<sp/>sorted</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10950"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>after<sp/>this<sp/>call.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10951"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>IncrementallySortBlocks();</highlight></codeline>
<codeline lineno="10952"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>SortByFreeSize();</highlight></codeline>
<codeline lineno="10953"><highlight class="normal"></highlight></codeline>
<codeline lineno="10954"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>AllocatePage(</highlight></codeline>
<codeline lineno="10955"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size,</highlight></codeline>
<codeline lineno="10956"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>alignment,</highlight></codeline>
<codeline lineno="10957"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>&amp;<sp/>createInfo,</highlight></codeline>
<codeline lineno="10958"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>suballocType,</highlight></codeline>
<codeline lineno="10959"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>pAllocation);</highlight></codeline>
<codeline lineno="10960"><highlight class="normal"></highlight></codeline>
<codeline lineno="10961"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>AllocateFromBlock(</highlight></codeline>
<codeline lineno="10962"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/>pBlock,</highlight></codeline>
<codeline lineno="10963"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size,</highlight></codeline>
<codeline lineno="10964"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>alignment,</highlight></codeline>
<codeline lineno="10965"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ga5225e5e11f8376f6a31a1791f3d6e817" kindref="member">VmaAllocationCreateFlags</ref><sp/>allocFlags,</highlight></codeline>
<codeline lineno="10966"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pUserData,</highlight></codeline>
<codeline lineno="10967"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>suballocType,</highlight></codeline>
<codeline lineno="10968"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>strategy,</highlight></codeline>
<codeline lineno="10969"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>pAllocation);</highlight></codeline>
<codeline lineno="10970"><highlight class="normal"></highlight></codeline>
<codeline lineno="10971"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>CommitAllocationRequest(</highlight></codeline>
<codeline lineno="10972"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAllocationRequest&amp;<sp/>allocRequest,</highlight></codeline>
<codeline lineno="10973"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/>pBlock,</highlight></codeline>
<codeline lineno="10974"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>alignment,</highlight></codeline>
<codeline lineno="10975"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ga5225e5e11f8376f6a31a1791f3d6e817" kindref="member">VmaAllocationCreateFlags</ref><sp/>allocFlags,</highlight></codeline>
<codeline lineno="10976"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pUserData,</highlight></codeline>
<codeline lineno="10977"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>suballocType,</highlight></codeline>
<codeline lineno="10978"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>pAllocation);</highlight></codeline>
<codeline lineno="10979"><highlight class="normal"></highlight></codeline>
<codeline lineno="10980"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>CreateBlock(VkDeviceSize<sp/>blockSize,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal">*<sp/>pNewBlockIndex);</highlight></codeline>
<codeline lineno="10981"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>HasEmptyBlock();</highlight></codeline>
<codeline lineno="10982"><highlight class="normal">};</highlight></codeline>
<codeline lineno="10983"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_BLOCK_VECTOR</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10984"><highlight class="normal"></highlight></codeline>
<codeline lineno="10985"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_DEFRAGMENTATION_CONTEXT</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10986"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaDefragmentationContext_T</highlight></codeline>
<codeline lineno="10987"><highlight class="normal">{</highlight></codeline>
<codeline lineno="10988"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_CLASS_NO_COPY(VmaDefragmentationContext_T)</highlight></codeline>
<codeline lineno="10989"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="10990"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaDefragmentationContext_T(</highlight></codeline>
<codeline lineno="10991"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,</highlight></codeline>
<codeline lineno="10992"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_defragmentation_info" kindref="compound">VmaDefragmentationInfo</ref>&amp;<sp/>info);</highlight></codeline>
<codeline lineno="10993"><highlight class="normal"><sp/><sp/><sp/><sp/>~VmaDefragmentationContext_T();</highlight></codeline>
<codeline lineno="10994"><highlight class="normal"></highlight></codeline>
<codeline lineno="10995"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GetStats(<ref refid="struct_vma_defragmentation_stats" kindref="compound">VmaDefragmentationStats</ref>&amp;<sp/>outStats)<sp/>{<sp/>outStats<sp/>=<sp/>m_GlobalStats;<sp/>}</highlight></codeline>
<codeline lineno="10996"><highlight class="normal"></highlight></codeline>
<codeline lineno="10997"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>DefragmentPassBegin(<ref refid="struct_vma_defragmentation_pass_move_info" kindref="compound">VmaDefragmentationPassMoveInfo</ref>&amp;<sp/>moveInfo);</highlight></codeline>
<codeline lineno="10998"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>DefragmentPassEnd(<ref refid="struct_vma_defragmentation_pass_move_info" kindref="compound">VmaDefragmentationPassMoveInfo</ref>&amp;<sp/>moveInfo);</highlight></codeline>
<codeline lineno="10999"><highlight class="normal"></highlight></codeline>
<codeline lineno="11000"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="11001"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Max<sp/>number<sp/>of<sp/>allocations<sp/>to<sp/>ignore<sp/>due<sp/>to<sp/>size<sp/>constraints<sp/>before<sp/>ending<sp/>single<sp/>pass</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11002"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint8_t<sp/>MAX_ALLOCS_TO_IGNORE<sp/>=<sp/>16;</highlight></codeline>
<codeline lineno="11003"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">enum<sp/>class</highlight><highlight class="normal"><sp/>CounterStatus<sp/>{<sp/>Pass,<sp/>Ignore,<sp/>End<sp/>};</highlight></codeline>
<codeline lineno="11004"><highlight class="normal"></highlight></codeline>
<codeline lineno="11005"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">FragmentedBlock</highlight></codeline>
<codeline lineno="11006"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11007"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>data;</highlight></codeline>
<codeline lineno="11008"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/>block;</highlight></codeline>
<codeline lineno="11009"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="11010"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">StateBalanced</highlight></codeline>
<codeline lineno="11011"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11012"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>avgFreeSize<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="11013"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>avgAllocSize<sp/>=<sp/>UINT64_MAX;</highlight></codeline>
<codeline lineno="11014"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="11015"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">StateExtensive</highlight></codeline>
<codeline lineno="11016"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11017"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">enum<sp/>class</highlight><highlight class="normal"><sp/>Operation<sp/>:<sp/>uint8_t</highlight></codeline>
<codeline lineno="11018"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11019"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FindFreeBlockBuffer,<sp/>FindFreeBlockTexture,<sp/>FindFreeBlockAll,</highlight></codeline>
<codeline lineno="11020"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MoveBuffers,<sp/>MoveTextures,<sp/>MoveAll,</highlight></codeline>
<codeline lineno="11021"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cleanup,<sp/>Done</highlight></codeline>
<codeline lineno="11022"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="11023"><highlight class="normal"></highlight></codeline>
<codeline lineno="11024"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Operation<sp/>operation<sp/>=<sp/>Operation::FindFreeBlockTexture;</highlight></codeline>
<codeline lineno="11025"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>firstFreeBlock<sp/>=<sp/>SIZE_MAX;</highlight></codeline>
<codeline lineno="11026"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="11027"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">MoveAllocationData</highlight></codeline>
<codeline lineno="11028"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11029"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size;</highlight></codeline>
<codeline lineno="11030"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>alignment;</highlight></codeline>
<codeline lineno="11031"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>type;</highlight></codeline>
<codeline lineno="11032"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ga5225e5e11f8376f6a31a1791f3d6e817" kindref="member">VmaAllocationCreateFlags</ref><sp/>flags;</highlight></codeline>
<codeline lineno="11033"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_defragmentation_move" kindref="compound">VmaDefragmentationMove</ref><sp/>move<sp/>=<sp/>{};</highlight></codeline>
<codeline lineno="11034"><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="11035"><highlight class="normal"></highlight></codeline>
<codeline lineno="11036"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>m_MaxPassBytes;</highlight></codeline>
<codeline lineno="11037"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>m_MaxPassAllocations;</highlight></codeline>
<codeline lineno="11038"><highlight class="normal"></highlight></codeline>
<codeline lineno="11039"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaStlAllocator&lt;VmaDefragmentationMove&gt;<sp/>m_MoveAllocator;</highlight></codeline>
<codeline lineno="11040"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaVector&lt;VmaDefragmentationMove,<sp/>VmaStlAllocator&lt;VmaDefragmentationMove&gt;&gt;<sp/>m_Moves;</highlight></codeline>
<codeline lineno="11041"><highlight class="normal"></highlight></codeline>
<codeline lineno="11042"><highlight class="normal"><sp/><sp/><sp/><sp/>uint8_t<sp/>m_IgnoredAllocs<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="11043"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>m_Algorithm;</highlight></codeline>
<codeline lineno="11044"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>m_BlockVectorCount;</highlight></codeline>
<codeline lineno="11045"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaBlockVector*<sp/>m_PoolBlockVector;</highlight></codeline>
<codeline lineno="11046"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaBlockVector**<sp/>m_pBlockVectors;</highlight></codeline>
<codeline lineno="11047"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>m_ImmovableBlockCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="11048"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_defragmentation_stats" kindref="compound">VmaDefragmentationStats</ref><sp/>m_GlobalStats<sp/>=<sp/>{<sp/>0<sp/>};</highlight></codeline>
<codeline lineno="11049"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_defragmentation_stats" kindref="compound">VmaDefragmentationStats</ref><sp/>m_PassStats<sp/>=<sp/>{<sp/>0<sp/>};</highlight></codeline>
<codeline lineno="11050"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>m_AlgorithmState<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="11051"><highlight class="normal"></highlight></codeline>
<codeline lineno="11052"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>MoveAllocationData<sp/>GetMoveData(VmaAllocHandle<sp/>handle,<sp/>VmaBlockMetadata*<sp/>metadata);</highlight></codeline>
<codeline lineno="11053"><highlight class="normal"><sp/><sp/><sp/><sp/>CounterStatus<sp/>CheckCounters(VkDeviceSize<sp/>bytes);</highlight></codeline>
<codeline lineno="11054"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>IncrementCounters(VkDeviceSize<sp/>bytes);</highlight></codeline>
<codeline lineno="11055"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>ReallocWithinBlock(VmaBlockVector&amp;<sp/>vector,<sp/>VmaDeviceMemoryBlock*<sp/>block);</highlight></codeline>
<codeline lineno="11056"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>AllocInOtherBlock(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>start,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>end,<sp/>MoveAllocationData&amp;<sp/>data,<sp/>VmaBlockVector&amp;<sp/>vector);</highlight></codeline>
<codeline lineno="11057"><highlight class="normal"></highlight></codeline>
<codeline lineno="11058"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>ComputeDefragmentation(VmaBlockVector&amp;<sp/>vector,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index);</highlight></codeline>
<codeline lineno="11059"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>ComputeDefragmentation_Fast(VmaBlockVector&amp;<sp/>vector);</highlight></codeline>
<codeline lineno="11060"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>ComputeDefragmentation_Balanced(VmaBlockVector&amp;<sp/>vector,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>update);</highlight></codeline>
<codeline lineno="11061"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>ComputeDefragmentation_Full(VmaBlockVector&amp;<sp/>vector);</highlight></codeline>
<codeline lineno="11062"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>ComputeDefragmentation_Extensive(VmaBlockVector&amp;<sp/>vector,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index);</highlight></codeline>
<codeline lineno="11063"><highlight class="normal"></highlight></codeline>
<codeline lineno="11064"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>UpdateVectorStatistics(VmaBlockVector&amp;<sp/>vector,<sp/>StateBalanced&amp;<sp/>state);</highlight></codeline>
<codeline lineno="11065"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>MoveDataToFreeBlocks(VmaSuballocationType<sp/>currentType,</highlight></codeline>
<codeline lineno="11066"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaBlockVector&amp;<sp/>vector,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>firstFreeBlock,</highlight></codeline>
<codeline lineno="11067"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">&amp;<sp/>texturePresent,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">&amp;<sp/>bufferPresent,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">&amp;<sp/>otherPresent);</highlight></codeline>
<codeline lineno="11068"><highlight class="normal">};</highlight></codeline>
<codeline lineno="11069"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_DEFRAGMENTATION_CONTEXT</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11070"><highlight class="normal"></highlight></codeline>
<codeline lineno="11071"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_POOL_T</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11072"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaPool_T</highlight></codeline>
<codeline lineno="11073"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11074"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">friend</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaPoolListItemTraits;</highlight></codeline>
<codeline lineno="11075"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_CLASS_NO_COPY(VmaPool_T)</highlight></codeline>
<codeline lineno="11076"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="11077"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaBlockVector<sp/>m_BlockVector;</highlight></codeline>
<codeline lineno="11078"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaDedicatedAllocationList<sp/>m_DedicatedAllocations;</highlight></codeline>
<codeline lineno="11079"><highlight class="normal"></highlight></codeline>
<codeline lineno="11080"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaPool_T(</highlight></codeline>
<codeline lineno="11081"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,</highlight></codeline>
<codeline lineno="11082"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_pool_create_info" kindref="compound">VmaPoolCreateInfo</ref>&amp;<sp/>createInfo,</highlight></codeline>
<codeline lineno="11083"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>preferredBlockSize);</highlight></codeline>
<codeline lineno="11084"><highlight class="normal"><sp/><sp/><sp/><sp/>~VmaPool_T();</highlight></codeline>
<codeline lineno="11085"><highlight class="normal"></highlight></codeline>
<codeline lineno="11086"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>GetId()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Id;<sp/>}</highlight></codeline>
<codeline lineno="11087"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>SetId(uint32_t<sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal">)<sp/>{<sp/>VMA_ASSERT(m_Id<sp/>==<sp/>0);<sp/>m_Id<sp/>=<sp/>id;<sp/>}</highlight></codeline>
<codeline lineno="11088"><highlight class="normal"></highlight></codeline>
<codeline lineno="11089"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>GetName()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Name;<sp/>}</highlight></codeline>
<codeline lineno="11090"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>SetName(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>pName);</highlight></codeline>
<codeline lineno="11091"><highlight class="normal"></highlight></codeline>
<codeline lineno="11092"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11093"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//void<sp/>PrintDetailedMap(class<sp/>VmaStringBuilder&amp;<sp/>sb);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11094"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11095"><highlight class="normal"></highlight></codeline>
<codeline lineno="11096"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="11097"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>m_Id;</highlight></codeline>
<codeline lineno="11098"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>m_Name;</highlight></codeline>
<codeline lineno="11099"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaPool_T*<sp/>m_PrevPool<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="11100"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaPool_T*<sp/>m_NextPool<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="11101"><highlight class="normal">};</highlight></codeline>
<codeline lineno="11102"><highlight class="normal"></highlight></codeline>
<codeline lineno="11103"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaPoolListItemTraits</highlight></codeline>
<codeline lineno="11104"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11105"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VmaPool_T<sp/>ItemType;</highlight></codeline>
<codeline lineno="11106"><highlight class="normal"></highlight></codeline>
<codeline lineno="11107"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>ItemType*<sp/>GetPrev(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ItemType*<sp/>item)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>item-&gt;m_PrevPool;<sp/>}</highlight></codeline>
<codeline lineno="11108"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>ItemType*<sp/>GetNext(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>ItemType*<sp/>item)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>item-&gt;m_NextPool;<sp/>}</highlight></codeline>
<codeline lineno="11109"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>ItemType*&amp;<sp/>AccessPrev(ItemType*<sp/>item)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>item-&gt;m_PrevPool;<sp/>}</highlight></codeline>
<codeline lineno="11110"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>ItemType*&amp;<sp/>AccessNext(ItemType*<sp/>item)<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>item-&gt;m_NextPool;<sp/>}</highlight></codeline>
<codeline lineno="11111"><highlight class="normal">};</highlight></codeline>
<codeline lineno="11112"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_POOL_T</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11113"><highlight class="normal"></highlight></codeline>
<codeline lineno="11114"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_CURRENT_BUDGET_DATA</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11115"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaCurrentBudgetData</highlight></codeline>
<codeline lineno="11116"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11117"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ATOMIC_UINT32<sp/>m_BlockCount[VK_MAX_MEMORY_HEAPS];</highlight></codeline>
<codeline lineno="11118"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ATOMIC_UINT32<sp/>m_AllocationCount[VK_MAX_MEMORY_HEAPS];</highlight></codeline>
<codeline lineno="11119"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ATOMIC_UINT64<sp/>m_BlockBytes[VK_MAX_MEMORY_HEAPS];</highlight></codeline>
<codeline lineno="11120"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ATOMIC_UINT64<sp/>m_AllocationBytes[VK_MAX_MEMORY_HEAPS];</highlight></codeline>
<codeline lineno="11121"><highlight class="normal"></highlight></codeline>
<codeline lineno="11122"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_MEMORY_BUDGET</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11123"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ATOMIC_UINT32<sp/>m_OperationsSinceBudgetFetch;</highlight></codeline>
<codeline lineno="11124"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_RW_MUTEX<sp/>m_BudgetMutex;</highlight></codeline>
<codeline lineno="11125"><highlight class="normal"><sp/><sp/><sp/><sp/>uint64_t<sp/>m_VulkanUsage[VK_MAX_MEMORY_HEAPS];</highlight></codeline>
<codeline lineno="11126"><highlight class="normal"><sp/><sp/><sp/><sp/>uint64_t<sp/>m_VulkanBudget[VK_MAX_MEMORY_HEAPS];</highlight></codeline>
<codeline lineno="11127"><highlight class="normal"><sp/><sp/><sp/><sp/>uint64_t<sp/>m_BlockBytesAtBudgetFetch[VK_MAX_MEMORY_HEAPS];</highlight></codeline>
<codeline lineno="11128"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>VMA_MEMORY_BUDGET</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11129"><highlight class="normal"></highlight></codeline>
<codeline lineno="11130"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaCurrentBudgetData();</highlight></codeline>
<codeline lineno="11131"><highlight class="normal"></highlight></codeline>
<codeline lineno="11132"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>AddAllocation(uint32_t<sp/>heapIndex,<sp/>VkDeviceSize<sp/>allocationSize);</highlight></codeline>
<codeline lineno="11133"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>RemoveAllocation(uint32_t<sp/>heapIndex,<sp/>VkDeviceSize<sp/>allocationSize);</highlight></codeline>
<codeline lineno="11134"><highlight class="normal">};</highlight></codeline>
<codeline lineno="11135"><highlight class="normal"></highlight></codeline>
<codeline lineno="11136"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_CURRENT_BUDGET_DATA_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11137"><highlight class="normal">VmaCurrentBudgetData::VmaCurrentBudgetData()</highlight></codeline>
<codeline lineno="11138"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11139"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(uint32_t<sp/>heapIndex<sp/>=<sp/>0;<sp/>heapIndex<sp/>&lt;<sp/>VK_MAX_MEMORY_HEAPS;<sp/>++heapIndex)</highlight></codeline>
<codeline lineno="11140"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11141"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_BlockCount[heapIndex]<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="11142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_AllocationCount[heapIndex]<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="11143"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_BlockBytes[heapIndex]<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="11144"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_AllocationBytes[heapIndex]<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="11145"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_MEMORY_BUDGET</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_VulkanUsage[heapIndex]<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="11147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_VulkanBudget[heapIndex]<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="11148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_BlockBytesAtBudgetFetch[heapIndex]<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="11149"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11150"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11151"><highlight class="normal"></highlight></codeline>
<codeline lineno="11152"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_MEMORY_BUDGET</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11153"><highlight class="normal"><sp/><sp/><sp/><sp/>m_OperationsSinceBudgetFetch<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="11154"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11155"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11156"><highlight class="normal"></highlight></codeline>
<codeline lineno="11157"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaCurrentBudgetData::AddAllocation(uint32_t<sp/>heapIndex,<sp/>VkDeviceSize<sp/>allocationSize)</highlight></codeline>
<codeline lineno="11158"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11159"><highlight class="normal"><sp/><sp/><sp/><sp/>m_AllocationBytes[heapIndex]<sp/>+=<sp/>allocationSize;</highlight></codeline>
<codeline lineno="11160"><highlight class="normal"><sp/><sp/><sp/><sp/>++m_AllocationCount[heapIndex];</highlight></codeline>
<codeline lineno="11161"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_MEMORY_BUDGET</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11162"><highlight class="normal"><sp/><sp/><sp/><sp/>++m_OperationsSinceBudgetFetch;</highlight></codeline>
<codeline lineno="11163"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11164"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11165"><highlight class="normal"></highlight></codeline>
<codeline lineno="11166"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaCurrentBudgetData::RemoveAllocation(uint32_t<sp/>heapIndex,<sp/>VkDeviceSize<sp/>allocationSize)</highlight></codeline>
<codeline lineno="11167"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11168"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_AllocationBytes[heapIndex]<sp/>&gt;=<sp/>allocationSize);</highlight></codeline>
<codeline lineno="11169"><highlight class="normal"><sp/><sp/><sp/><sp/>m_AllocationBytes[heapIndex]<sp/>-=<sp/>allocationSize;</highlight></codeline>
<codeline lineno="11170"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_AllocationCount[heapIndex]<sp/>&gt;<sp/>0);</highlight></codeline>
<codeline lineno="11171"><highlight class="normal"><sp/><sp/><sp/><sp/>--m_AllocationCount[heapIndex];</highlight></codeline>
<codeline lineno="11172"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_MEMORY_BUDGET</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11173"><highlight class="normal"><sp/><sp/><sp/><sp/>++m_OperationsSinceBudgetFetch;</highlight></codeline>
<codeline lineno="11174"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11175"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11176"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_CURRENT_BUDGET_DATA_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11177"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_CURRENT_BUDGET_DATA</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11178"><highlight class="normal"></highlight></codeline>
<codeline lineno="11179"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_ALLOCATION_OBJECT_ALLOCATOR</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11180"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="11181"><highlight class="comment">Thread-safe<sp/>wrapper<sp/>over<sp/>VmaPoolAllocator<sp/>free<sp/>list,<sp/>for<sp/>allocation<sp/>of<sp/>VmaAllocation_T<sp/>objects.</highlight></codeline>
<codeline lineno="11182"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11183"><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">VmaAllocationObjectAllocator</highlight></codeline>
<codeline lineno="11184"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11185"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_CLASS_NO_COPY(VmaAllocationObjectAllocator)</highlight></codeline>
<codeline lineno="11186"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="11187"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocationObjectAllocator(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>pAllocationCallbacks)</highlight></codeline>
<codeline lineno="11188"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>m_Allocator(pAllocationCallbacks,<sp/>1024)<sp/>{}</highlight></codeline>
<codeline lineno="11189"><highlight class="normal"></highlight></codeline>
<codeline lineno="11190"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal">...<sp/>Types&gt;<sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>Allocate(Types&amp;&amp;...<sp/>args);</highlight></codeline>
<codeline lineno="11191"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Free(<ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>hAlloc);</highlight></codeline>
<codeline lineno="11192"><highlight class="normal"></highlight></codeline>
<codeline lineno="11193"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="11194"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_MUTEX<sp/>m_Mutex;</highlight></codeline>
<codeline lineno="11195"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaPoolAllocator&lt;VmaAllocation_T&gt;<sp/>m_Allocator;</highlight></codeline>
<codeline lineno="11196"><highlight class="normal">};</highlight></codeline>
<codeline lineno="11197"><highlight class="normal"></highlight></codeline>
<codeline lineno="11198"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal">...<sp/>Types&gt;</highlight></codeline>
<codeline lineno="11199"><highlight class="normal"><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>VmaAllocationObjectAllocator::Allocate(Types&amp;&amp;...<sp/>args)</highlight></codeline>
<codeline lineno="11200"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11201"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaMutexLock<sp/>mutexLock(m_Mutex);</highlight></codeline>
<codeline lineno="11202"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Allocator.Alloc&lt;Types...&gt;(std::forward&lt;Types&gt;(args)...);</highlight></codeline>
<codeline lineno="11203"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11204"><highlight class="normal"></highlight></codeline>
<codeline lineno="11205"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocationObjectAllocator::Free(<ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>hAlloc)</highlight></codeline>
<codeline lineno="11206"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11207"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaMutexLock<sp/>mutexLock(m_Mutex);</highlight></codeline>
<codeline lineno="11208"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Allocator.Free(hAlloc);</highlight></codeline>
<codeline lineno="11209"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11210"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_ALLOCATION_OBJECT_ALLOCATOR</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11211"><highlight class="normal"></highlight></codeline>
<codeline lineno="11212"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_VIRTUAL_BLOCK_T</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11213"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaVirtualBlock_T</highlight></codeline>
<codeline lineno="11214"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11215"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_CLASS_NO_COPY(VmaVirtualBlock_T)</highlight></codeline>
<codeline lineno="11216"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="11217"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>m_AllocationCallbacksSpecified;</highlight></codeline>
<codeline lineno="11218"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks<sp/>m_AllocationCallbacks;</highlight></codeline>
<codeline lineno="11219"><highlight class="normal"></highlight></codeline>
<codeline lineno="11220"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaVirtualBlock_T(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_virtual_block_create_info" kindref="compound">VmaVirtualBlockCreateInfo</ref>&amp;<sp/>createInfo);</highlight></codeline>
<codeline lineno="11221"><highlight class="normal"><sp/><sp/><sp/><sp/>~VmaVirtualBlock_T();</highlight></codeline>
<codeline lineno="11222"><highlight class="normal"></highlight></codeline>
<codeline lineno="11223"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>Init()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;<sp/>}</highlight></codeline>
<codeline lineno="11224"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>IsEmpty()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Metadata-&gt;IsEmpty();<sp/>}</highlight></codeline>
<codeline lineno="11225"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Free(<ref refid="struct_vma_virtual_allocation" kindref="compound">VmaVirtualAllocation</ref><sp/>allocation)<sp/>{<sp/>m_Metadata-&gt;Free((VmaAllocHandle)allocation);<sp/>}</highlight></codeline>
<codeline lineno="11226"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>SetAllocationUserData(<ref refid="struct_vma_virtual_allocation" kindref="compound">VmaVirtualAllocation</ref><sp/>allocation,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>userData)<sp/>{<sp/>m_Metadata-&gt;SetAllocationUserData((VmaAllocHandle)allocation,<sp/>userData);<sp/>}</highlight></codeline>
<codeline lineno="11227"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Clear()<sp/>{<sp/>m_Metadata-&gt;Clear();<sp/>}</highlight></codeline>
<codeline lineno="11228"><highlight class="normal"></highlight></codeline>
<codeline lineno="11229"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>GetAllocationCallbacks()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="11230"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GetAllocationInfo(<ref refid="struct_vma_virtual_allocation" kindref="compound">VmaVirtualAllocation</ref><sp/>allocation,<sp/><ref refid="struct_vma_virtual_allocation_info" kindref="compound">VmaVirtualAllocationInfo</ref>&amp;<sp/>outInfo);</highlight></codeline>
<codeline lineno="11231"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>Allocate(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_virtual_allocation_create_info" kindref="compound">VmaVirtualAllocationCreateInfo</ref>&amp;<sp/>createInfo,<sp/><ref refid="struct_vma_virtual_allocation" kindref="compound">VmaVirtualAllocation</ref>&amp;<sp/>outAllocation,</highlight></codeline>
<codeline lineno="11232"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize*<sp/>outOffset);</highlight></codeline>
<codeline lineno="11233"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GetStatistics(<ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref>&amp;<sp/>outStats)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="11234"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>CalculateDetailedStatistics(<ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>&amp;<sp/>outStats)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="11235"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11236"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>BuildStatsString(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>detailedMap,<sp/>VmaStringBuilder&amp;<sp/>sb)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="11237"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11238"><highlight class="normal"></highlight></codeline>
<codeline lineno="11239"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="11240"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaBlockMetadata*<sp/>m_Metadata;</highlight></codeline>
<codeline lineno="11241"><highlight class="normal">};</highlight></codeline>
<codeline lineno="11242"><highlight class="normal"></highlight></codeline>
<codeline lineno="11243"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_VIRTUAL_BLOCK_T_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11244"><highlight class="normal">VmaVirtualBlock_T::VmaVirtualBlock_T(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_virtual_block_create_info" kindref="compound">VmaVirtualBlockCreateInfo</ref>&amp;<sp/>createInfo)</highlight></codeline>
<codeline lineno="11245"><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>m_AllocationCallbacksSpecified(createInfo.pAllocationCallbacks<sp/>!=<sp/>VMA_NULL),</highlight></codeline>
<codeline lineno="11246"><highlight class="normal"><sp/><sp/><sp/><sp/>m_AllocationCallbacks(createInfo.pAllocationCallbacks<sp/>!=<sp/>VMA_NULL<sp/>?<sp/>*createInfo.pAllocationCallbacks<sp/>:<sp/>VmaEmptyAllocationCallbacks)</highlight></codeline>
<codeline lineno="11247"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11248"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>algorithm<sp/>=<sp/>createInfo.<ref refid="struct_vma_virtual_block_create_info_1aaab9bf7e2d228c02ab6d90a72a6e6912" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__virtual_1gga88bcf8c1cd3bb1610ff7343811c65bcaaf9487467136e1a9e371894dc3a7c4844" kindref="member">VMA_VIRTUAL_BLOCK_CREATE_ALGORITHM_MASK</ref>;</highlight></codeline>
<codeline lineno="11249"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(algorithm)</highlight></codeline>
<codeline lineno="11250"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11251"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="11252"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="11253"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>0:</highlight></codeline>
<codeline lineno="11254"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Metadata<sp/>=<sp/>vma_new(GetAllocationCallbacks(),<sp/>VmaBlockMetadata_TLSF)(VK_NULL_HANDLE,<sp/>1,<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="11255"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="11256"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__group__virtual_1gga88bcf8c1cd3bb1610ff7343811c65bcaae6423e2fa2f3c9211b21c819e3f10f96" kindref="member">VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT</ref>:</highlight></codeline>
<codeline lineno="11257"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Metadata<sp/>=<sp/>vma_new(GetAllocationCallbacks(),<sp/>VmaBlockMetadata_Linear)(VK_NULL_HANDLE,<sp/>1,<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="11258"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="11259"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11260"><highlight class="normal"></highlight></codeline>
<codeline lineno="11261"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Metadata-&gt;Init(createInfo.<ref refid="struct_vma_virtual_block_create_info_1a670ab8c6a6e822f3c36781d79e8824e9" kindref="member">size</ref>);</highlight></codeline>
<codeline lineno="11262"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11263"><highlight class="normal"></highlight></codeline>
<codeline lineno="11264"><highlight class="normal">VmaVirtualBlock_T::~VmaVirtualBlock_T()</highlight></codeline>
<codeline lineno="11265"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11266"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Define<sp/>macro<sp/>VMA_DEBUG_LOG<sp/>to<sp/>receive<sp/>the<sp/>list<sp/>of<sp/>the<sp/>unfreed<sp/>allocations</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11267"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!m_Metadata-&gt;IsEmpty())</highlight></codeline>
<codeline lineno="11268"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Metadata-&gt;DebugLogAllAllocations();</highlight></codeline>
<codeline lineno="11269"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>is<sp/>the<sp/>most<sp/>important<sp/>assert<sp/>in<sp/>the<sp/>entire<sp/>library.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11270"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Hitting<sp/>it<sp/>means<sp/>you<sp/>have<sp/>some<sp/>memory<sp/>leak<sp/>-<sp/>unreleased<sp/>virtual<sp/>allocations.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11271"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_Metadata-&gt;IsEmpty()<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Some<sp/>virtual<sp/>allocations<sp/>were<sp/>not<sp/>freed<sp/>before<sp/>destruction<sp/>of<sp/>this<sp/>virtual<sp/>block!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="11272"><highlight class="normal"></highlight></codeline>
<codeline lineno="11273"><highlight class="normal"><sp/><sp/><sp/><sp/>vma_delete(GetAllocationCallbacks(),<sp/>m_Metadata);</highlight></codeline>
<codeline lineno="11274"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11275"><highlight class="normal"></highlight></codeline>
<codeline lineno="11276"><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>VmaVirtualBlock_T::GetAllocationCallbacks()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="11277"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="11278"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_AllocationCallbacksSpecified<sp/>?<sp/>&amp;m_AllocationCallbacks<sp/>:<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="11279"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11280"><highlight class="normal"></highlight></codeline>
<codeline lineno="11281"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaVirtualBlock_T::GetAllocationInfo(<ref refid="struct_vma_virtual_allocation" kindref="compound">VmaVirtualAllocation</ref><sp/>allocation,<sp/><ref refid="struct_vma_virtual_allocation_info" kindref="compound">VmaVirtualAllocationInfo</ref>&amp;<sp/>outInfo)</highlight></codeline>
<codeline lineno="11282"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11283"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Metadata-&gt;GetAllocationInfo((VmaAllocHandle)allocation,<sp/>outInfo);</highlight></codeline>
<codeline lineno="11284"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11285"><highlight class="normal"></highlight></codeline>
<codeline lineno="11286"><highlight class="normal">VkResult<sp/>VmaVirtualBlock_T::Allocate(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_virtual_allocation_create_info" kindref="compound">VmaVirtualAllocationCreateInfo</ref>&amp;<sp/>createInfo,<sp/><ref refid="struct_vma_virtual_allocation" kindref="compound">VmaVirtualAllocation</ref>&amp;<sp/>outAllocation,</highlight></codeline>
<codeline lineno="11287"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize*<sp/>outOffset)</highlight></codeline>
<codeline lineno="11288"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11289"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocationRequest<sp/>request<sp/>=<sp/>{};</highlight></codeline>
<codeline lineno="11290"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_Metadata-&gt;CreateAllocationRequest(</highlight></codeline>
<codeline lineno="11291"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>createInfo.<ref refid="struct_vma_virtual_allocation_create_info_1aae08752b86817abd0d944c6025dc603e" kindref="member">size</ref>,<sp/></highlight><highlight class="comment">//<sp/>allocSize</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11292"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_MAX(createInfo.<ref refid="struct_vma_virtual_allocation_create_info_1a9d19709872fc1904a105079e1c885821" kindref="member">alignment</ref>,<sp/>(VkDeviceSize)1),<sp/></highlight><highlight class="comment">//<sp/>allocAlignment</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11293"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(createInfo.<ref refid="struct_vma_virtual_allocation_create_info_1ab10e16956cc4bf20ced9de77d1129ea4" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__virtual_1gga2e9c64d405b14156fea7e10c4ad06cb6a9524a329a55b5ec390d57d90b67ad78e" kindref="member">VMA_VIRTUAL_ALLOCATION_CREATE_UPPER_ADDRESS_BIT</ref>)<sp/>!=<sp/>0,<sp/></highlight><highlight class="comment">//<sp/>upperAddress</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11294"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_SUBALLOCATION_TYPE_UNKNOWN,<sp/></highlight><highlight class="comment">//<sp/>allocType<sp/>-<sp/>unimportant</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11295"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>createInfo.<ref refid="struct_vma_virtual_allocation_create_info_1ab10e16956cc4bf20ced9de77d1129ea4" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__virtual_1gga2e9c64d405b14156fea7e10c4ad06cb6ac5b5e45c335368d18df59c9f27df17e3" kindref="member">VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MASK</ref>,<sp/></highlight><highlight class="comment">//<sp/>strategy</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11296"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;request))</highlight></codeline>
<codeline lineno="11297"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11298"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Metadata-&gt;Alloc(request,</highlight></codeline>
<codeline lineno="11299"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_SUBALLOCATION_TYPE_UNKNOWN,<sp/></highlight><highlight class="comment">//<sp/>type<sp/>-<sp/>unimportant</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11300"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>createInfo.<ref refid="struct_vma_virtual_allocation_create_info_1aa84c85b0b8037cd4972172a0507de360" kindref="member">pUserData</ref>);</highlight></codeline>
<codeline lineno="11301"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outAllocation<sp/>=<sp/>(<ref refid="struct_vma_virtual_allocation" kindref="compound">VmaVirtualAllocation</ref>)request.allocHandle;</highlight></codeline>
<codeline lineno="11302"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(outOffset)</highlight></codeline>
<codeline lineno="11303"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*outOffset<sp/>=<sp/>m_Metadata-&gt;GetAllocationOffset(request.allocHandle);</highlight></codeline>
<codeline lineno="11304"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="11305"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11306"><highlight class="normal"><sp/><sp/><sp/><sp/>outAllocation<sp/>=<sp/>(<ref refid="struct_vma_virtual_allocation" kindref="compound">VmaVirtualAllocation</ref>)VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="11307"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(outOffset)</highlight></codeline>
<codeline lineno="11308"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*outOffset<sp/>=<sp/>UINT64_MAX;</highlight></codeline>
<codeline lineno="11309"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_OUT_OF_DEVICE_MEMORY;</highlight></codeline>
<codeline lineno="11310"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11311"><highlight class="normal"></highlight></codeline>
<codeline lineno="11312"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaVirtualBlock_T::GetStatistics(<ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref>&amp;<sp/>outStats)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="11313"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="11314"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaClearStatistics(outStats);</highlight></codeline>
<codeline lineno="11315"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Metadata-&gt;AddStatistics(outStats);</highlight></codeline>
<codeline lineno="11316"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11317"><highlight class="normal"></highlight></codeline>
<codeline lineno="11318"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaVirtualBlock_T::CalculateDetailedStatistics(<ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>&amp;<sp/>outStats)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="11319"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="11320"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaClearDetailedStatistics(outStats);</highlight></codeline>
<codeline lineno="11321"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Metadata-&gt;AddDetailedStatistics(outStats);</highlight></codeline>
<codeline lineno="11322"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11323"><highlight class="normal"></highlight></codeline>
<codeline lineno="11324"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11325"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaVirtualBlock_T::BuildStatsString(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>detailedMap,<sp/>VmaStringBuilder&amp;<sp/>sb)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="11326"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="11327"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaJsonWriter<sp/>json(GetAllocationCallbacks(),<sp/>sb);</highlight></codeline>
<codeline lineno="11328"><highlight class="normal"><sp/><sp/><sp/><sp/>json.BeginObject();</highlight></codeline>
<codeline lineno="11329"><highlight class="normal"></highlight></codeline>
<codeline lineno="11330"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref><sp/>stats;</highlight></codeline>
<codeline lineno="11331"><highlight class="normal"><sp/><sp/><sp/><sp/>CalculateDetailedStatistics(stats);</highlight></codeline>
<codeline lineno="11332"><highlight class="normal"></highlight></codeline>
<codeline lineno="11333"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;Stats&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="11334"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaPrintDetailedStatistics(json,<sp/>stats);</highlight></codeline>
<codeline lineno="11335"><highlight class="normal"></highlight></codeline>
<codeline lineno="11336"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(detailedMap)</highlight></codeline>
<codeline lineno="11337"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11338"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;Details&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="11339"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.BeginObject();</highlight></codeline>
<codeline lineno="11340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Metadata-&gt;PrintDetailedMap(json);</highlight></codeline>
<codeline lineno="11341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.EndObject();</highlight></codeline>
<codeline lineno="11342"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11343"><highlight class="normal"></highlight></codeline>
<codeline lineno="11344"><highlight class="normal"><sp/><sp/><sp/><sp/>json.EndObject();</highlight></codeline>
<codeline lineno="11345"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11346"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11347"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_VIRTUAL_BLOCK_T_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11348"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_VIRTUAL_BLOCK_T</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11349"><highlight class="normal"></highlight></codeline>
<codeline lineno="11350"><highlight class="normal"></highlight></codeline>
<codeline lineno="11351"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Main<sp/>allocator<sp/>object.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11352"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">VmaAllocator_T</highlight></codeline>
<codeline lineno="11353"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11354"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_CLASS_NO_COPY(VmaAllocator_T)</highlight></codeline>
<codeline lineno="11355"><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="11356"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>m_UseMutex;</highlight></codeline>
<codeline lineno="11357"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>m_VulkanApiVersion;</highlight></codeline>
<codeline lineno="11358"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>m_UseKhrDedicatedAllocation;<sp/></highlight><highlight class="comment">//<sp/>Can<sp/>be<sp/>set<sp/>only<sp/>if<sp/>m_VulkanApiVersion<sp/>&lt;<sp/>VK_MAKE_VERSION(1,<sp/>1,<sp/>0).</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11359"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>m_UseKhrBindMemory2;<sp/></highlight><highlight class="comment">//<sp/>Can<sp/>be<sp/>set<sp/>only<sp/>if<sp/>m_VulkanApiVersion<sp/>&lt;<sp/>VK_MAKE_VERSION(1,<sp/>1,<sp/>0).</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11360"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>m_UseExtMemoryBudget;</highlight></codeline>
<codeline lineno="11361"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>m_UseAmdDeviceCoherentMemory;</highlight></codeline>
<codeline lineno="11362"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>m_UseKhrBufferDeviceAddress;</highlight></codeline>
<codeline lineno="11363"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>m_UseExtMemoryPriority;</highlight></codeline>
<codeline lineno="11364"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDevice<sp/>m_hDevice;</highlight></codeline>
<codeline lineno="11365"><highlight class="normal"><sp/><sp/><sp/><sp/>VkInstance<sp/>m_hInstance;</highlight></codeline>
<codeline lineno="11366"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>m_AllocationCallbacksSpecified;</highlight></codeline>
<codeline lineno="11367"><highlight class="normal"><sp/><sp/><sp/><sp/>VkAllocationCallbacks<sp/>m_AllocationCallbacks;</highlight></codeline>
<codeline lineno="11368"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_device_memory_callbacks" kindref="compound">VmaDeviceMemoryCallbacks</ref><sp/>m_DeviceMemoryCallbacks;</highlight></codeline>
<codeline lineno="11369"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocationObjectAllocator<sp/>m_AllocationObjectAllocator;</highlight></codeline>
<codeline lineno="11370"><highlight class="normal"></highlight></codeline>
<codeline lineno="11371"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Each<sp/>bit<sp/>(1<sp/>&lt;&lt;<sp/>i)<sp/>is<sp/>set<sp/>if<sp/>HeapSizeLimit<sp/>is<sp/>enabled<sp/>for<sp/>that<sp/>heap,<sp/>so<sp/>cannot<sp/>allocate<sp/>more<sp/>than<sp/>the<sp/>heap<sp/>size.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11372"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>m_HeapSizeLimitMask;</highlight></codeline>
<codeline lineno="11373"><highlight class="normal"></highlight></codeline>
<codeline lineno="11374"><highlight class="normal"><sp/><sp/><sp/><sp/>VkPhysicalDeviceProperties<sp/>m_PhysicalDeviceProperties;</highlight></codeline>
<codeline lineno="11375"><highlight class="normal"><sp/><sp/><sp/><sp/>VkPhysicalDeviceMemoryProperties<sp/>m_MemProps;</highlight></codeline>
<codeline lineno="11376"><highlight class="normal"></highlight></codeline>
<codeline lineno="11377"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Default<sp/>pools.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11378"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaBlockVector*<sp/>m_pBlockVectors[VK_MAX_MEMORY_TYPES];</highlight></codeline>
<codeline lineno="11379"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaDedicatedAllocationList<sp/>m_DedicatedAllocations[VK_MAX_MEMORY_TYPES];</highlight></codeline>
<codeline lineno="11380"><highlight class="normal"></highlight></codeline>
<codeline lineno="11381"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaCurrentBudgetData<sp/>m_Budget;</highlight></codeline>
<codeline lineno="11382"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ATOMIC_UINT32<sp/>m_DeviceMemoryCount;<sp/></highlight><highlight class="comment">//<sp/>Total<sp/>number<sp/>of<sp/>VkDeviceMemory<sp/>objects.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11383"><highlight class="normal"></highlight></codeline>
<codeline lineno="11384"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocator_T(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocator_create_info" kindref="compound">VmaAllocatorCreateInfo</ref>*<sp/>pCreateInfo);</highlight></codeline>
<codeline lineno="11385"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>Init(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocator_create_info" kindref="compound">VmaAllocatorCreateInfo</ref>*<sp/>pCreateInfo);</highlight></codeline>
<codeline lineno="11386"><highlight class="normal"><sp/><sp/><sp/><sp/>~VmaAllocator_T();</highlight></codeline>
<codeline lineno="11387"><highlight class="normal"></highlight></codeline>
<codeline lineno="11388"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>GetAllocationCallbacks()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="11389"><highlight class="keyword"><sp/><sp/><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="11390"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_AllocationCallbacksSpecified<sp/>?<sp/>&amp;m_AllocationCallbacks<sp/>:<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="11391"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11392"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_vulkan_functions" kindref="compound">VmaVulkanFunctions</ref>&amp;<sp/>GetVulkanFunctions()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="11393"><highlight class="keyword"><sp/><sp/><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="11394"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_VulkanFunctions;</highlight></codeline>
<codeline lineno="11395"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11396"><highlight class="normal"></highlight></codeline>
<codeline lineno="11397"><highlight class="normal"><sp/><sp/><sp/><sp/>VkPhysicalDevice<sp/>GetPhysicalDevice()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_PhysicalDevice;<sp/>}</highlight></codeline>
<codeline lineno="11398"><highlight class="normal"></highlight></codeline>
<codeline lineno="11399"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>GetBufferImageGranularity()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="11400"><highlight class="keyword"><sp/><sp/><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="11401"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VMA_MAX(</highlight></codeline>
<codeline lineno="11402"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">VkDeviceSize</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(VMA_DEBUG_MIN_BUFFER_IMAGE_GRANULARITY),</highlight></codeline>
<codeline lineno="11403"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_PhysicalDeviceProperties.limits.bufferImageGranularity);</highlight></codeline>
<codeline lineno="11404"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11405"><highlight class="normal"></highlight></codeline>
<codeline lineno="11406"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>GetMemoryHeapCount()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_MemProps.memoryHeapCount;<sp/>}</highlight></codeline>
<codeline lineno="11407"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>GetMemoryTypeCount()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_MemProps.memoryTypeCount;<sp/>}</highlight></codeline>
<codeline lineno="11408"><highlight class="normal"></highlight></codeline>
<codeline lineno="11409"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>MemoryTypeIndexToHeapIndex(uint32_t<sp/>memTypeIndex)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="11410"><highlight class="keyword"><sp/><sp/><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="11411"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(memTypeIndex<sp/>&lt;<sp/>m_MemProps.memoryTypeCount);</highlight></codeline>
<codeline lineno="11412"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_MemProps.memoryTypes[memTypeIndex].heapIndex;</highlight></codeline>
<codeline lineno="11413"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11414"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>True<sp/>when<sp/>specific<sp/>memory<sp/>type<sp/>is<sp/>HOST_VISIBLE<sp/>but<sp/>not<sp/>HOST_COHERENT.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11415"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>IsMemoryTypeNonCoherent(uint32_t<sp/>memTypeIndex)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="11416"><highlight class="keyword"><sp/><sp/><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="11417"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(m_MemProps.memoryTypes[memTypeIndex].propertyFlags<sp/>&amp;<sp/>(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT<sp/>|<sp/>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT))<sp/>==</highlight></codeline>
<codeline lineno="11418"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;</highlight></codeline>
<codeline lineno="11419"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11420"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Minimum<sp/>alignment<sp/>for<sp/>all<sp/>allocations<sp/>in<sp/>specific<sp/>memory<sp/>type.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11421"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>GetMemoryTypeMinAlignment(uint32_t<sp/>memTypeIndex)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="11422"><highlight class="keyword"><sp/><sp/><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="11423"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>IsMemoryTypeNonCoherent(memTypeIndex)<sp/>?</highlight></codeline>
<codeline lineno="11424"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_MAX((VkDeviceSize)VMA_MIN_ALIGNMENT,<sp/>m_PhysicalDeviceProperties.limits.nonCoherentAtomSize)<sp/>:</highlight></codeline>
<codeline lineno="11425"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(VkDeviceSize)VMA_MIN_ALIGNMENT;</highlight></codeline>
<codeline lineno="11426"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11427"><highlight class="normal"></highlight></codeline>
<codeline lineno="11428"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>IsIntegratedGpu()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="11429"><highlight class="keyword"><sp/><sp/><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="11430"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_PhysicalDeviceProperties.deviceType<sp/>==<sp/>VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU;</highlight></codeline>
<codeline lineno="11431"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11432"><highlight class="normal"></highlight></codeline>
<codeline lineno="11433"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>GetGlobalMemoryTypeBits()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_GlobalMemoryTypeBits;<sp/>}</highlight></codeline>
<codeline lineno="11434"><highlight class="normal"></highlight></codeline>
<codeline lineno="11435"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GetBufferMemoryRequirements(</highlight></codeline>
<codeline lineno="11436"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkBuffer<sp/>hBuffer,</highlight></codeline>
<codeline lineno="11437"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkMemoryRequirements&amp;<sp/>memReq,</highlight></codeline>
<codeline lineno="11438"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">&amp;<sp/>requiresDedicatedAllocation,</highlight></codeline>
<codeline lineno="11439"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">&amp;<sp/>prefersDedicatedAllocation)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="11440"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GetImageMemoryRequirements(</highlight></codeline>
<codeline lineno="11441"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkImage<sp/>hImage,</highlight></codeline>
<codeline lineno="11442"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkMemoryRequirements&amp;<sp/>memReq,</highlight></codeline>
<codeline lineno="11443"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">&amp;<sp/>requiresDedicatedAllocation,</highlight></codeline>
<codeline lineno="11444"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">&amp;<sp/>prefersDedicatedAllocation)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="11445"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>FindMemoryTypeIndex(</highlight></codeline>
<codeline lineno="11446"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>memoryTypeBits,</highlight></codeline>
<codeline lineno="11447"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>*<sp/>pAllocationCreateInfo,</highlight></codeline>
<codeline lineno="11448"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkFlags<sp/>bufImgUsage,<sp/></highlight><highlight class="comment">//<sp/>VkBufferCreateInfo::usage<sp/>or<sp/>VkImageCreateInfo::usage.<sp/>UINT32_MAX<sp/>if<sp/>unknown.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11449"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t*<sp/>pMemoryTypeIndex)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="11450"><highlight class="normal"></highlight></codeline>
<codeline lineno="11451"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Main<sp/>allocation<sp/>function.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11452"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>AllocateMemory(</highlight></codeline>
<codeline lineno="11453"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkMemoryRequirements&amp;<sp/>vkMemReq,</highlight></codeline>
<codeline lineno="11454"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>requiresDedicatedAllocation,</highlight></codeline>
<codeline lineno="11455"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>prefersDedicatedAllocation,</highlight></codeline>
<codeline lineno="11456"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkBuffer<sp/>dedicatedBuffer,</highlight></codeline>
<codeline lineno="11457"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkImage<sp/>dedicatedImage,</highlight></codeline>
<codeline lineno="11458"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkFlags<sp/>dedicatedBufferImageUsage,<sp/></highlight><highlight class="comment">//<sp/>UINT32_MAX<sp/>if<sp/>unknown.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11459"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>&amp;<sp/>createInfo,</highlight></codeline>
<codeline lineno="11460"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>suballocType,</highlight></codeline>
<codeline lineno="11461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>allocationCount,</highlight></codeline>
<codeline lineno="11462"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>pAllocations);</highlight></codeline>
<codeline lineno="11463"><highlight class="normal"></highlight></codeline>
<codeline lineno="11464"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Main<sp/>deallocation<sp/>function.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11465"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>FreeMemory(</highlight></codeline>
<codeline lineno="11466"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>allocationCount,</highlight></codeline>
<codeline lineno="11467"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>pAllocations);</highlight></codeline>
<codeline lineno="11468"><highlight class="normal"></highlight></codeline>
<codeline lineno="11469"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>CalculateStatistics(<ref refid="struct_vma_total_statistics" kindref="compound">VmaTotalStatistics</ref>*<sp/>pStats);</highlight></codeline>
<codeline lineno="11470"><highlight class="normal"></highlight></codeline>
<codeline lineno="11471"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GetHeapBudgets(</highlight></codeline>
<codeline lineno="11472"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_budget" kindref="compound">VmaBudget</ref>*<sp/>outBudgets,<sp/>uint32_t<sp/>firstHeap,<sp/>uint32_t<sp/>heapCount);</highlight></codeline>
<codeline lineno="11473"><highlight class="normal"></highlight></codeline>
<codeline lineno="11474"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11475"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>PrintDetailedMap(</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>VmaJsonWriter&amp;<sp/>json);</highlight></codeline>
<codeline lineno="11476"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11477"><highlight class="normal"></highlight></codeline>
<codeline lineno="11478"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GetAllocationInfo(<ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>hAllocation,<sp/><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref>*<sp/>pAllocationInfo);</highlight></codeline>
<codeline lineno="11479"><highlight class="normal"></highlight></codeline>
<codeline lineno="11480"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>CreatePool(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_pool_create_info" kindref="compound">VmaPoolCreateInfo</ref>*<sp/>pCreateInfo,<sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref>*<sp/>pPool);</highlight></codeline>
<codeline lineno="11481"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>DestroyPool(<ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>pool);</highlight></codeline>
<codeline lineno="11482"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GetPoolStatistics(<ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>pool,<sp/><ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref>*<sp/>pPoolStats);</highlight></codeline>
<codeline lineno="11483"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>CalculatePoolStatistics(<ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>pool,<sp/><ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>*<sp/>pPoolStats);</highlight></codeline>
<codeline lineno="11484"><highlight class="normal"></highlight></codeline>
<codeline lineno="11485"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>SetCurrentFrameIndex(uint32_t<sp/>frameIndex);</highlight></codeline>
<codeline lineno="11486"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>GetCurrentFrameIndex()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_CurrentFrameIndex.load();<sp/>}</highlight></codeline>
<codeline lineno="11487"><highlight class="normal"></highlight></codeline>
<codeline lineno="11488"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>CheckPoolCorruption(<ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>hPool);</highlight></codeline>
<codeline lineno="11489"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>CheckCorruption(uint32_t<sp/>memoryTypeBits);</highlight></codeline>
<codeline lineno="11490"><highlight class="normal"></highlight></codeline>
<codeline lineno="11491"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Call<sp/>to<sp/>Vulkan<sp/>function<sp/>vkAllocateMemory<sp/>with<sp/>accompanying<sp/>bookkeeping.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11492"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>AllocateVulkanMemory(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkMemoryAllocateInfo*<sp/>pAllocateInfo,<sp/>VkDeviceMemory*<sp/>pMemory);</highlight></codeline>
<codeline lineno="11493"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Call<sp/>to<sp/>Vulkan<sp/>function<sp/>vkFreeMemory<sp/>with<sp/>accompanying<sp/>bookkeeping.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11494"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>FreeVulkanMemory(uint32_t<sp/>memoryType,<sp/>VkDeviceSize<sp/>size,<sp/>VkDeviceMemory<sp/>hMemory);</highlight></codeline>
<codeline lineno="11495"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Call<sp/>to<sp/>Vulkan<sp/>function<sp/>vkBindBufferMemory<sp/>or<sp/>vkBindBufferMemory2KHR.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11496"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>BindVulkanBuffer(</highlight></codeline>
<codeline lineno="11497"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceMemory<sp/>memory,</highlight></codeline>
<codeline lineno="11498"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>memoryOffset,</highlight></codeline>
<codeline lineno="11499"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkBuffer<sp/>buffer,</highlight></codeline>
<codeline lineno="11500"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pNext);</highlight></codeline>
<codeline lineno="11501"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Call<sp/>to<sp/>Vulkan<sp/>function<sp/>vkBindImageMemory<sp/>or<sp/>vkBindImageMemory2KHR.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11502"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>BindVulkanImage(</highlight></codeline>
<codeline lineno="11503"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceMemory<sp/>memory,</highlight></codeline>
<codeline lineno="11504"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>memoryOffset,</highlight></codeline>
<codeline lineno="11505"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkImage<sp/>image,</highlight></codeline>
<codeline lineno="11506"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pNext);</highlight></codeline>
<codeline lineno="11507"><highlight class="normal"></highlight></codeline>
<codeline lineno="11508"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>Map(<ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>hAllocation,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">**<sp/>ppData);</highlight></codeline>
<codeline lineno="11509"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>Unmap(<ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>hAllocation);</highlight></codeline>
<codeline lineno="11510"><highlight class="normal"></highlight></codeline>
<codeline lineno="11511"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>BindBufferMemory(</highlight></codeline>
<codeline lineno="11512"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>hAllocation,</highlight></codeline>
<codeline lineno="11513"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocationLocalOffset,</highlight></codeline>
<codeline lineno="11514"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkBuffer<sp/>hBuffer,</highlight></codeline>
<codeline lineno="11515"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pNext);</highlight></codeline>
<codeline lineno="11516"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>BindImageMemory(</highlight></codeline>
<codeline lineno="11517"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>hAllocation,</highlight></codeline>
<codeline lineno="11518"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocationLocalOffset,</highlight></codeline>
<codeline lineno="11519"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkImage<sp/>hImage,</highlight></codeline>
<codeline lineno="11520"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pNext);</highlight></codeline>
<codeline lineno="11521"><highlight class="normal"></highlight></codeline>
<codeline lineno="11522"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>FlushOrInvalidateAllocation(</highlight></codeline>
<codeline lineno="11523"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>hAllocation,</highlight></codeline>
<codeline lineno="11524"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>offset,<sp/>VkDeviceSize<sp/>size,</highlight></codeline>
<codeline lineno="11525"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_CACHE_OPERATION<sp/>op);</highlight></codeline>
<codeline lineno="11526"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>FlushOrInvalidateAllocations(</highlight></codeline>
<codeline lineno="11527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>allocationCount,</highlight></codeline>
<codeline lineno="11528"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>allocations,</highlight></codeline>
<codeline lineno="11529"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize*<sp/>offsets,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize*<sp/>sizes,</highlight></codeline>
<codeline lineno="11530"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_CACHE_OPERATION<sp/>op);</highlight></codeline>
<codeline lineno="11531"><highlight class="normal"></highlight></codeline>
<codeline lineno="11532"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>FillAllocation(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>hAllocation,<sp/>uint8_t<sp/>pattern);</highlight></codeline>
<codeline lineno="11533"><highlight class="normal"></highlight></codeline>
<codeline lineno="11534"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="11535"><highlight class="comment"><sp/><sp/><sp/><sp/>Returns<sp/>bit<sp/>mask<sp/>of<sp/>memory<sp/>types<sp/>that<sp/>can<sp/>support<sp/>defragmentation<sp/>on<sp/>GPU<sp/>as</highlight></codeline>
<codeline lineno="11536"><highlight class="comment"><sp/><sp/><sp/><sp/>they<sp/>support<sp/>creation<sp/>of<sp/>required<sp/>buffer<sp/>for<sp/>copy<sp/>operations.</highlight></codeline>
<codeline lineno="11537"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11538"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>GetGpuDefragmentationMemoryTypeBits();</highlight></codeline>
<codeline lineno="11539"><highlight class="normal"></highlight></codeline>
<codeline lineno="11540"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_EXTERNAL_MEMORY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11541"><highlight class="normal"><sp/><sp/><sp/><sp/>VkExternalMemoryHandleTypeFlagsKHR<sp/>GetExternalMemoryHandleTypeFlags(uint32_t<sp/>memTypeIndex)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="11542"><highlight class="keyword"><sp/><sp/><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="11543"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_TypeExternalMemoryHandleTypes[memTypeIndex];</highlight></codeline>
<codeline lineno="11544"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11545"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>VMA_EXTERNAL_MEMORY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11546"><highlight class="normal"></highlight></codeline>
<codeline lineno="11547"><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="11548"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>m_PreferredLargeHeapBlockSize;</highlight></codeline>
<codeline lineno="11549"><highlight class="normal"></highlight></codeline>
<codeline lineno="11550"><highlight class="normal"><sp/><sp/><sp/><sp/>VkPhysicalDevice<sp/>m_PhysicalDevice;</highlight></codeline>
<codeline lineno="11551"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ATOMIC_UINT32<sp/>m_CurrentFrameIndex;</highlight></codeline>
<codeline lineno="11552"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ATOMIC_UINT32<sp/>m_GpuDefragmentationMemoryTypeBits;<sp/></highlight><highlight class="comment">//<sp/>UINT32_MAX<sp/>means<sp/>uninitialized.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11553"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_EXTERNAL_MEMORY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11554"><highlight class="normal"><sp/><sp/><sp/><sp/>VkExternalMemoryHandleTypeFlagsKHR<sp/>m_TypeExternalMemoryHandleTypes[VK_MAX_MEMORY_TYPES];</highlight></codeline>
<codeline lineno="11555"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>VMA_EXTERNAL_MEMORY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11556"><highlight class="normal"></highlight></codeline>
<codeline lineno="11557"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_RW_MUTEX<sp/>m_PoolsMutex;</highlight></codeline>
<codeline lineno="11558"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VmaIntrusiveLinkedList&lt;VmaPoolListItemTraits&gt;<sp/>PoolList;</highlight></codeline>
<codeline lineno="11559"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Protected<sp/>by<sp/>m_PoolsMutex.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11560"><highlight class="normal"><sp/><sp/><sp/><sp/>PoolList<sp/>m_Pools;</highlight></codeline>
<codeline lineno="11561"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>m_NextPoolId;</highlight></codeline>
<codeline lineno="11562"><highlight class="normal"></highlight></codeline>
<codeline lineno="11563"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_vulkan_functions" kindref="compound">VmaVulkanFunctions</ref><sp/>m_VulkanFunctions;</highlight></codeline>
<codeline lineno="11564"><highlight class="normal"></highlight></codeline>
<codeline lineno="11565"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Global<sp/>bit<sp/>mask<sp/>AND-ed<sp/>with<sp/>any<sp/>memoryTypeBits<sp/>to<sp/>disallow<sp/>certain<sp/>memory<sp/>types.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11566"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>m_GlobalMemoryTypeBits;</highlight></codeline>
<codeline lineno="11567"><highlight class="normal"></highlight></codeline>
<codeline lineno="11568"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ImportVulkanFunctions(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_vulkan_functions" kindref="compound">VmaVulkanFunctions</ref>*<sp/>pVulkanFunctions);</highlight></codeline>
<codeline lineno="11569"><highlight class="normal"></highlight></codeline>
<codeline lineno="11570"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATIC_VULKAN_FUNCTIONS<sp/>==<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11571"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ImportVulkanFunctions_Static();</highlight></codeline>
<codeline lineno="11572"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11573"><highlight class="normal"></highlight></codeline>
<codeline lineno="11574"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ImportVulkanFunctions_Custom(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_vulkan_functions" kindref="compound">VmaVulkanFunctions</ref>*<sp/>pVulkanFunctions);</highlight></codeline>
<codeline lineno="11575"><highlight class="normal"></highlight></codeline>
<codeline lineno="11576"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_DYNAMIC_VULKAN_FUNCTIONS<sp/>==<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11577"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ImportVulkanFunctions_Dynamic();</highlight></codeline>
<codeline lineno="11578"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11579"><highlight class="normal"></highlight></codeline>
<codeline lineno="11580"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ValidateVulkanFunctions();</highlight></codeline>
<codeline lineno="11581"><highlight class="normal"></highlight></codeline>
<codeline lineno="11582"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>CalcPreferredBlockSize(uint32_t<sp/>memTypeIndex);</highlight></codeline>
<codeline lineno="11583"><highlight class="normal"></highlight></codeline>
<codeline lineno="11584"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>AllocateMemoryOfType(</highlight></codeline>
<codeline lineno="11585"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>pool,</highlight></codeline>
<codeline lineno="11586"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size,</highlight></codeline>
<codeline lineno="11587"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>alignment,</highlight></codeline>
<codeline lineno="11588"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>dedicatedPreferred,</highlight></codeline>
<codeline lineno="11589"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkBuffer<sp/>dedicatedBuffer,</highlight></codeline>
<codeline lineno="11590"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkImage<sp/>dedicatedImage,</highlight></codeline>
<codeline lineno="11591"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkFlags<sp/>dedicatedBufferImageUsage,</highlight></codeline>
<codeline lineno="11592"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>&amp;<sp/>createInfo,</highlight></codeline>
<codeline lineno="11593"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>memTypeIndex,</highlight></codeline>
<codeline lineno="11594"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>suballocType,</highlight></codeline>
<codeline lineno="11595"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaDedicatedAllocationList&amp;<sp/>dedicatedAllocations,</highlight></codeline>
<codeline lineno="11596"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaBlockVector&amp;<sp/>blockVector,</highlight></codeline>
<codeline lineno="11597"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>allocationCount,</highlight></codeline>
<codeline lineno="11598"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>pAllocations);</highlight></codeline>
<codeline lineno="11599"><highlight class="normal"></highlight></codeline>
<codeline lineno="11600"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Helper<sp/>function<sp/>only<sp/>to<sp/>be<sp/>used<sp/>inside<sp/>AllocateDedicatedMemory.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11601"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>AllocateDedicatedMemoryPage(</highlight></codeline>
<codeline lineno="11602"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>pool,</highlight></codeline>
<codeline lineno="11603"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size,</highlight></codeline>
<codeline lineno="11604"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>suballocType,</highlight></codeline>
<codeline lineno="11605"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>memTypeIndex,</highlight></codeline>
<codeline lineno="11606"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkMemoryAllocateInfo&amp;<sp/>allocInfo,</highlight></codeline>
<codeline lineno="11607"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>map,</highlight></codeline>
<codeline lineno="11608"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isUserDataString,</highlight></codeline>
<codeline lineno="11609"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isMappingAllowed,</highlight></codeline>
<codeline lineno="11610"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pUserData,</highlight></codeline>
<codeline lineno="11611"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>pAllocation);</highlight></codeline>
<codeline lineno="11612"><highlight class="normal"></highlight></codeline>
<codeline lineno="11613"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Allocates<sp/>and<sp/>registers<sp/>new<sp/>VkDeviceMemory<sp/>specifically<sp/>for<sp/>dedicated<sp/>allocations.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11614"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>AllocateDedicatedMemory(</highlight></codeline>
<codeline lineno="11615"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>pool,</highlight></codeline>
<codeline lineno="11616"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size,</highlight></codeline>
<codeline lineno="11617"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>suballocType,</highlight></codeline>
<codeline lineno="11618"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaDedicatedAllocationList&amp;<sp/>dedicatedAllocations,</highlight></codeline>
<codeline lineno="11619"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>memTypeIndex,</highlight></codeline>
<codeline lineno="11620"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>map,</highlight></codeline>
<codeline lineno="11621"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isUserDataString,</highlight></codeline>
<codeline lineno="11622"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isMappingAllowed,</highlight></codeline>
<codeline lineno="11623"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>canAliasMemory,</highlight></codeline>
<codeline lineno="11624"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pUserData,</highlight></codeline>
<codeline lineno="11625"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>priority,</highlight></codeline>
<codeline lineno="11626"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkBuffer<sp/>dedicatedBuffer,</highlight></codeline>
<codeline lineno="11627"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkImage<sp/>dedicatedImage,</highlight></codeline>
<codeline lineno="11628"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkFlags<sp/>dedicatedBufferImageUsage,</highlight></codeline>
<codeline lineno="11629"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>allocationCount,</highlight></codeline>
<codeline lineno="11630"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>pAllocations,</highlight></codeline>
<codeline lineno="11631"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pNextChain<sp/>=<sp/></highlight><highlight class="keyword">nullptr</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="11632"><highlight class="normal"></highlight></codeline>
<codeline lineno="11633"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>FreeDedicatedMemory(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>allocation);</highlight></codeline>
<codeline lineno="11634"><highlight class="normal"></highlight></codeline>
<codeline lineno="11635"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>CalcMemTypeParams(</highlight></codeline>
<codeline lineno="11636"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>&amp;<sp/>outCreateInfo,</highlight></codeline>
<codeline lineno="11637"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>memTypeIndex,</highlight></codeline>
<codeline lineno="11638"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size,</highlight></codeline>
<codeline lineno="11639"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>allocationCount);</highlight></codeline>
<codeline lineno="11640"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>CalcAllocationParams(</highlight></codeline>
<codeline lineno="11641"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>&amp;<sp/>outCreateInfo,</highlight></codeline>
<codeline lineno="11642"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>dedicatedRequired,</highlight></codeline>
<codeline lineno="11643"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>dedicatedPreferred);</highlight></codeline>
<codeline lineno="11644"><highlight class="normal"></highlight></codeline>
<codeline lineno="11645"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="11646"><highlight class="comment"><sp/><sp/><sp/><sp/>Calculates<sp/>and<sp/>returns<sp/>bit<sp/>mask<sp/>of<sp/>memory<sp/>types<sp/>that<sp/>can<sp/>support<sp/>defragmentation</highlight></codeline>
<codeline lineno="11647"><highlight class="comment"><sp/><sp/><sp/><sp/>on<sp/>GPU<sp/>as<sp/>they<sp/>support<sp/>creation<sp/>of<sp/>required<sp/>buffer<sp/>for<sp/>copy<sp/>operations.</highlight></codeline>
<codeline lineno="11648"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11649"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>CalculateGpuDefragmentationMemoryTypeBits()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="11650"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>CalculateGlobalMemoryTypeBits()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="11651"><highlight class="normal"></highlight></codeline>
<codeline lineno="11652"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>GetFlushOrInvalidateRange(</highlight></codeline>
<codeline lineno="11653"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="11654"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>offset,<sp/>VkDeviceSize<sp/>size,</highlight></codeline>
<codeline lineno="11655"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkMappedMemoryRange&amp;<sp/>outRange)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="11656"><highlight class="normal"></highlight></codeline>
<codeline lineno="11657"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_MEMORY_BUDGET</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11658"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>UpdateVulkanBudget();</highlight></codeline>
<codeline lineno="11659"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>VMA_MEMORY_BUDGET</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11660"><highlight class="normal">};</highlight></codeline>
<codeline lineno="11661"><highlight class="normal"></highlight></codeline>
<codeline lineno="11662"><highlight class="normal"></highlight></codeline>
<codeline lineno="11663"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_MEMORY_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11664"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>VmaMalloc(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>size,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>alignment)</highlight></codeline>
<codeline lineno="11665"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11666"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VmaMalloc(&amp;hAllocator-&gt;m_AllocationCallbacks,<sp/>size,<sp/>alignment);</highlight></codeline>
<codeline lineno="11667"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11668"><highlight class="normal"></highlight></codeline>
<codeline lineno="11669"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaFree(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>ptr)</highlight></codeline>
<codeline lineno="11670"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11671"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaFree(&amp;hAllocator-&gt;m_AllocationCallbacks,<sp/>ptr);</highlight></codeline>
<codeline lineno="11672"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11673"><highlight class="normal"></highlight></codeline>
<codeline lineno="11674"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="11675"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>T*<sp/>VmaAllocate(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator)</highlight></codeline>
<codeline lineno="11676"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11677"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(T*)VmaMalloc(hAllocator,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(T),<sp/>VMA_ALIGN_OF(T));</highlight></codeline>
<codeline lineno="11678"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11679"><highlight class="normal"></highlight></codeline>
<codeline lineno="11680"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="11681"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>T*<sp/>VmaAllocateArray(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>count)</highlight></codeline>
<codeline lineno="11682"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11683"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(T*)VmaMalloc(hAllocator,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(T)<sp/>*<sp/>count,<sp/>VMA_ALIGN_OF(T));</highlight></codeline>
<codeline lineno="11684"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11685"><highlight class="normal"></highlight></codeline>
<codeline lineno="11686"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="11687"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>vma_delete(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,<sp/>T*<sp/>ptr)</highlight></codeline>
<codeline lineno="11688"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11689"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(ptr<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="11690"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11691"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ptr-&gt;~T();</highlight></codeline>
<codeline lineno="11692"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaFree(hAllocator,<sp/>ptr);</highlight></codeline>
<codeline lineno="11693"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11694"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11695"><highlight class="normal"></highlight></codeline>
<codeline lineno="11696"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline lineno="11697"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>vma_delete_array(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,<sp/>T*<sp/>ptr,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>count)</highlight></codeline>
<codeline lineno="11698"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11699"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(ptr<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="11700"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11701"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>count;<sp/>i--;<sp/>)</highlight></codeline>
<codeline lineno="11702"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ptr[i].~T();</highlight></codeline>
<codeline lineno="11703"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaFree(hAllocator,<sp/>ptr);</highlight></codeline>
<codeline lineno="11704"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11705"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11706"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_MEMORY_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11707"><highlight class="normal"></highlight></codeline>
<codeline lineno="11708"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_DEVICE_MEMORY_BLOCK_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11709"><highlight class="normal">VmaDeviceMemoryBlock::VmaDeviceMemoryBlock(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator)</highlight></codeline>
<codeline lineno="11710"><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>m_pMetadata(VMA_NULL),</highlight></codeline>
<codeline lineno="11711"><highlight class="normal"><sp/><sp/><sp/><sp/>m_MemoryTypeIndex(UINT32_MAX),</highlight></codeline>
<codeline lineno="11712"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Id(0),</highlight></codeline>
<codeline lineno="11713"><highlight class="normal"><sp/><sp/><sp/><sp/>m_hMemory(VK_NULL_HANDLE),</highlight></codeline>
<codeline lineno="11714"><highlight class="normal"><sp/><sp/><sp/><sp/>m_MapCount(0),</highlight></codeline>
<codeline lineno="11715"><highlight class="normal"><sp/><sp/><sp/><sp/>m_pMappedData(VMA_NULL)<sp/>{}</highlight></codeline>
<codeline lineno="11716"><highlight class="normal"></highlight></codeline>
<codeline lineno="11717"><highlight class="normal">VmaDeviceMemoryBlock::~VmaDeviceMemoryBlock()</highlight></codeline>
<codeline lineno="11718"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11719"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_MapCount<sp/>==<sp/>0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;VkDeviceMemory<sp/>block<sp/>is<sp/>being<sp/>destroyed<sp/>while<sp/>it<sp/>is<sp/>still<sp/>mapped.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="11720"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_hMemory<sp/>==<sp/>VK_NULL_HANDLE);</highlight></codeline>
<codeline lineno="11721"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11722"><highlight class="normal"></highlight></codeline>
<codeline lineno="11723"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaDeviceMemoryBlock::Init(</highlight></codeline>
<codeline lineno="11724"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,</highlight></codeline>
<codeline lineno="11725"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>hParentPool,</highlight></codeline>
<codeline lineno="11726"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>newMemoryTypeIndex,</highlight></codeline>
<codeline lineno="11727"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceMemory<sp/>newMemory,</highlight></codeline>
<codeline lineno="11728"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>newSize,</highlight></codeline>
<codeline lineno="11729"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="11730"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>algorithm,</highlight></codeline>
<codeline lineno="11731"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>bufferImageGranularity)</highlight></codeline>
<codeline lineno="11732"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11733"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_hMemory<sp/>==<sp/>VK_NULL_HANDLE);</highlight></codeline>
<codeline lineno="11734"><highlight class="normal"></highlight></codeline>
<codeline lineno="11735"><highlight class="normal"><sp/><sp/><sp/><sp/>m_hParentPool<sp/>=<sp/>hParentPool;</highlight></codeline>
<codeline lineno="11736"><highlight class="normal"><sp/><sp/><sp/><sp/>m_MemoryTypeIndex<sp/>=<sp/>newMemoryTypeIndex;</highlight></codeline>
<codeline lineno="11737"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Id<sp/>=<sp/>id;</highlight></codeline>
<codeline lineno="11738"><highlight class="normal"><sp/><sp/><sp/><sp/>m_hMemory<sp/>=<sp/>newMemory;</highlight></codeline>
<codeline lineno="11739"><highlight class="normal"></highlight></codeline>
<codeline lineno="11740"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(algorithm)</highlight></codeline>
<codeline lineno="11741"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11742"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726" kindref="member">VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</ref>:</highlight></codeline>
<codeline lineno="11743"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pMetadata<sp/>=<sp/>vma_new(hAllocator,<sp/>VmaBlockMetadata_Linear)(hAllocator-&gt;GetAllocationCallbacks(),</highlight></codeline>
<codeline lineno="11744"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bufferImageGranularity,<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">);<sp/></highlight><highlight class="comment">//<sp/>isVirtual</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11745"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="11746"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="11747"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="11748"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Fall-through.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11749"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>0:</highlight></codeline>
<codeline lineno="11750"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pMetadata<sp/>=<sp/>vma_new(hAllocator,<sp/>VmaBlockMetadata_TLSF)(hAllocator-&gt;GetAllocationCallbacks(),</highlight></codeline>
<codeline lineno="11751"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bufferImageGranularity,<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">);<sp/></highlight><highlight class="comment">//<sp/>isVirtual</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11752"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11753"><highlight class="normal"><sp/><sp/><sp/><sp/>m_pMetadata-&gt;Init(newSize);</highlight></codeline>
<codeline lineno="11754"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11755"><highlight class="normal"></highlight></codeline>
<codeline lineno="11756"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaDeviceMemoryBlock::Destroy(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator)</highlight></codeline>
<codeline lineno="11757"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11758"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Define<sp/>macro<sp/>VMA_DEBUG_LOG<sp/>to<sp/>receive<sp/>the<sp/>list<sp/>of<sp/>the<sp/>unfreed<sp/>allocations</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11759"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!m_pMetadata-&gt;IsEmpty())</highlight></codeline>
<codeline lineno="11760"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pMetadata-&gt;DebugLogAllAllocations();</highlight></codeline>
<codeline lineno="11761"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>is<sp/>the<sp/>most<sp/>important<sp/>assert<sp/>in<sp/>the<sp/>entire<sp/>library.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11762"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Hitting<sp/>it<sp/>means<sp/>you<sp/>have<sp/>some<sp/>memory<sp/>leak<sp/>-<sp/>unreleased<sp/>VmaAllocation<sp/>objects.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11763"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_pMetadata-&gt;IsEmpty()<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Some<sp/>allocations<sp/>were<sp/>not<sp/>freed<sp/>before<sp/>destruction<sp/>of<sp/>this<sp/>memory<sp/>block!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="11764"><highlight class="normal"></highlight></codeline>
<codeline lineno="11765"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_hMemory<sp/>!=<sp/>VK_NULL_HANDLE);</highlight></codeline>
<codeline lineno="11766"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;FreeVulkanMemory(m_MemoryTypeIndex,<sp/>m_pMetadata-&gt;GetSize(),<sp/>m_hMemory);</highlight></codeline>
<codeline lineno="11767"><highlight class="normal"><sp/><sp/><sp/><sp/>m_hMemory<sp/>=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="11768"><highlight class="normal"></highlight></codeline>
<codeline lineno="11769"><highlight class="normal"><sp/><sp/><sp/><sp/>vma_delete(allocator,<sp/>m_pMetadata);</highlight></codeline>
<codeline lineno="11770"><highlight class="normal"><sp/><sp/><sp/><sp/>m_pMetadata<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="11771"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11772"><highlight class="normal"></highlight></codeline>
<codeline lineno="11773"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaDeviceMemoryBlock::PostFree(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator)</highlight></codeline>
<codeline lineno="11774"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11775"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_MappingHysteresis.PostFree())</highlight></codeline>
<codeline lineno="11776"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11777"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(m_MappingHysteresis.GetExtraMapping()<sp/>==<sp/>0);</highlight></codeline>
<codeline lineno="11778"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_MapCount<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="11779"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11780"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pMappedData<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="11781"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*hAllocator-&gt;GetVulkanFunctions().vkUnmapMemory)(hAllocator-&gt;m_hDevice,<sp/>m_hMemory);</highlight></codeline>
<codeline lineno="11782"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11783"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11784"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11785"><highlight class="normal"></highlight></codeline>
<codeline lineno="11786"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaDeviceMemoryBlock::Validate()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="11787"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="11788"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_VALIDATE((m_hMemory<sp/>!=<sp/>VK_NULL_HANDLE)<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="11789"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(m_pMetadata-&gt;GetSize()<sp/>!=<sp/>0));</highlight></codeline>
<codeline lineno="11790"><highlight class="normal"></highlight></codeline>
<codeline lineno="11791"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_pMetadata-&gt;Validate();</highlight></codeline>
<codeline lineno="11792"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11793"><highlight class="normal"></highlight></codeline>
<codeline lineno="11794"><highlight class="normal">VkResult<sp/>VmaDeviceMemoryBlock::CheckCorruption(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator)</highlight></codeline>
<codeline lineno="11795"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11796"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pData<sp/>=<sp/></highlight><highlight class="keyword">nullptr</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="11797"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>Map(hAllocator,<sp/>1,<sp/>&amp;pData);</highlight></codeline>
<codeline lineno="11798"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res<sp/>!=<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="11799"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11800"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="11801"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11802"><highlight class="normal"></highlight></codeline>
<codeline lineno="11803"><highlight class="normal"><sp/><sp/><sp/><sp/>res<sp/>=<sp/>m_pMetadata-&gt;CheckCorruption(pData);</highlight></codeline>
<codeline lineno="11804"><highlight class="normal"></highlight></codeline>
<codeline lineno="11805"><highlight class="normal"><sp/><sp/><sp/><sp/>Unmap(hAllocator,<sp/>1);</highlight></codeline>
<codeline lineno="11806"><highlight class="normal"></highlight></codeline>
<codeline lineno="11807"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="11808"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11809"><highlight class="normal"></highlight></codeline>
<codeline lineno="11810"><highlight class="normal">VkResult<sp/>VmaDeviceMemoryBlock::Map(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,<sp/>uint32_t<sp/>count,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">**<sp/>ppData)</highlight></codeline>
<codeline lineno="11811"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11812"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(count<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="11813"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11814"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="11815"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11816"><highlight class="normal"></highlight></codeline>
<codeline lineno="11817"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaMutexLock<sp/>lock(m_MapAndBindMutex,<sp/>hAllocator-&gt;m_UseMutex);</highlight></codeline>
<codeline lineno="11818"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>oldTotalMapCount<sp/>=<sp/>m_MapCount<sp/>+<sp/>m_MappingHysteresis.GetExtraMapping();</highlight></codeline>
<codeline lineno="11819"><highlight class="normal"><sp/><sp/><sp/><sp/>m_MappingHysteresis.PostMap();</highlight></codeline>
<codeline lineno="11820"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(oldTotalMapCount<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="11821"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11822"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_MapCount<sp/>+=<sp/>count;</highlight></codeline>
<codeline lineno="11823"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(m_pMappedData<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="11824"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ppData<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="11825"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11826"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*ppData<sp/>=<sp/>m_pMappedData;</highlight></codeline>
<codeline lineno="11827"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11828"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="11829"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11830"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11831"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11832"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkResult<sp/>result<sp/>=<sp/>(*hAllocator-&gt;GetVulkanFunctions().vkMapMemory)(</highlight></codeline>
<codeline lineno="11833"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>hAllocator-&gt;m_hDevice,</highlight></codeline>
<codeline lineno="11834"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_hMemory,</highlight></codeline>
<codeline lineno="11835"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/></highlight><highlight class="comment">//<sp/>offset</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11836"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VK_WHOLE_SIZE,</highlight></codeline>
<codeline lineno="11837"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/></highlight><highlight class="comment">//<sp/>flags</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11838"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;m_pMappedData);</highlight></codeline>
<codeline lineno="11839"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(result<sp/>==<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="11840"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11841"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ppData<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="11842"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11843"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*ppData<sp/>=<sp/>m_pMappedData;</highlight></codeline>
<codeline lineno="11844"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11845"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_MapCount<sp/>=<sp/>count;</highlight></codeline>
<codeline lineno="11846"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11847"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>result;</highlight></codeline>
<codeline lineno="11848"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11849"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11850"><highlight class="normal"></highlight></codeline>
<codeline lineno="11851"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaDeviceMemoryBlock::Unmap(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,<sp/>uint32_t<sp/>count)</highlight></codeline>
<codeline lineno="11852"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11853"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(count<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="11854"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11855"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="11856"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11857"><highlight class="normal"></highlight></codeline>
<codeline lineno="11858"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaMutexLock<sp/>lock(m_MapAndBindMutex,<sp/>hAllocator-&gt;m_UseMutex);</highlight></codeline>
<codeline lineno="11859"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_MapCount<sp/>&gt;=<sp/>count)</highlight></codeline>
<codeline lineno="11860"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11861"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_MapCount<sp/>-=<sp/>count;</highlight></codeline>
<codeline lineno="11862"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>totalMapCount<sp/>=<sp/>m_MapCount<sp/>+<sp/>m_MappingHysteresis.GetExtraMapping();</highlight></codeline>
<codeline lineno="11863"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(totalMapCount<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="11864"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11865"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pMappedData<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="11866"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*hAllocator-&gt;GetVulkanFunctions().vkUnmapMemory)(hAllocator-&gt;m_hDevice,<sp/>m_hMemory);</highlight></codeline>
<codeline lineno="11867"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11868"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_MappingHysteresis.PostUnmap();</highlight></codeline>
<codeline lineno="11869"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11870"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11871"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11872"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;VkDeviceMemory<sp/>block<sp/>is<sp/>being<sp/>unmapped<sp/>while<sp/>it<sp/>was<sp/>not<sp/>previously<sp/>mapped.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="11873"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11874"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11875"><highlight class="normal"></highlight></codeline>
<codeline lineno="11876"><highlight class="normal">VkResult<sp/>VmaDeviceMemoryBlock::WriteMagicValueAfterAllocation(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,<sp/>VkDeviceSize<sp/>allocOffset,<sp/>VkDeviceSize<sp/>allocSize)</highlight></codeline>
<codeline lineno="11877"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11878"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(VMA_DEBUG_MARGIN<sp/>&gt;<sp/>0<sp/>&amp;&amp;<sp/>VMA_DEBUG_MARGIN<sp/>%<sp/>4<sp/>==<sp/>0<sp/>&amp;&amp;<sp/>VMA_DEBUG_DETECT_CORRUPTION);</highlight></codeline>
<codeline lineno="11879"><highlight class="normal"></highlight></codeline>
<codeline lineno="11880"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pData;</highlight></codeline>
<codeline lineno="11881"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>Map(hAllocator,<sp/>1,<sp/>&amp;pData);</highlight></codeline>
<codeline lineno="11882"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res<sp/>!=<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="11883"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11884"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="11885"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11886"><highlight class="normal"></highlight></codeline>
<codeline lineno="11887"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaWriteMagicValue(pData,<sp/>allocOffset<sp/>+<sp/>allocSize);</highlight></codeline>
<codeline lineno="11888"><highlight class="normal"></highlight></codeline>
<codeline lineno="11889"><highlight class="normal"><sp/><sp/><sp/><sp/>Unmap(hAllocator,<sp/>1);</highlight></codeline>
<codeline lineno="11890"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="11891"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11892"><highlight class="normal"></highlight></codeline>
<codeline lineno="11893"><highlight class="normal">VkResult<sp/>VmaDeviceMemoryBlock::ValidateMagicValueAfterAllocation(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,<sp/>VkDeviceSize<sp/>allocOffset,<sp/>VkDeviceSize<sp/>allocSize)</highlight></codeline>
<codeline lineno="11894"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11895"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(VMA_DEBUG_MARGIN<sp/>&gt;<sp/>0<sp/>&amp;&amp;<sp/>VMA_DEBUG_MARGIN<sp/>%<sp/>4<sp/>==<sp/>0<sp/>&amp;&amp;<sp/>VMA_DEBUG_DETECT_CORRUPTION);</highlight></codeline>
<codeline lineno="11896"><highlight class="normal"></highlight></codeline>
<codeline lineno="11897"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pData;</highlight></codeline>
<codeline lineno="11898"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>Map(hAllocator,<sp/>1,<sp/>&amp;pData);</highlight></codeline>
<codeline lineno="11899"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res<sp/>!=<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="11900"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11901"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="11902"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11903"><highlight class="normal"></highlight></codeline>
<codeline lineno="11904"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!VmaValidateMagicValue(pData,<sp/>allocOffset<sp/>+<sp/>allocSize))</highlight></codeline>
<codeline lineno="11905"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11906"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;MEMORY<sp/>CORRUPTION<sp/>DETECTED<sp/>AFTER<sp/>FREED<sp/>ALLOCATION!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="11907"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11908"><highlight class="normal"></highlight></codeline>
<codeline lineno="11909"><highlight class="normal"><sp/><sp/><sp/><sp/>Unmap(hAllocator,<sp/>1);</highlight></codeline>
<codeline lineno="11910"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="11911"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11912"><highlight class="normal"></highlight></codeline>
<codeline lineno="11913"><highlight class="normal">VkResult<sp/>VmaDeviceMemoryBlock::BindBufferMemory(</highlight></codeline>
<codeline lineno="11914"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,</highlight></codeline>
<codeline lineno="11915"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>hAllocation,</highlight></codeline>
<codeline lineno="11916"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocationLocalOffset,</highlight></codeline>
<codeline lineno="11917"><highlight class="normal"><sp/><sp/><sp/><sp/>VkBuffer<sp/>hBuffer,</highlight></codeline>
<codeline lineno="11918"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pNext)</highlight></codeline>
<codeline lineno="11919"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11920"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(hAllocation-&gt;GetType()<sp/>==<sp/>VmaAllocation_T::ALLOCATION_TYPE_BLOCK<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="11921"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>hAllocation-&gt;GetBlock()<sp/>==<sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="11922"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocationLocalOffset<sp/>&lt;<sp/>hAllocation-&gt;GetSize()<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="11923"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;Invalid<sp/>allocationLocalOffset.<sp/>Did<sp/>you<sp/>forget<sp/>that<sp/>this<sp/>offset<sp/>is<sp/>relative<sp/>to<sp/>the<sp/>beginning<sp/>of<sp/>the<sp/>allocation,<sp/>not<sp/>the<sp/>whole<sp/>memory<sp/>block?&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="11924"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>memoryOffset<sp/>=<sp/>hAllocation-&gt;GetOffset()<sp/>+<sp/>allocationLocalOffset;</highlight></codeline>
<codeline lineno="11925"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>lock<sp/>is<sp/>important<sp/>so<sp/>that<sp/>we<sp/>don&apos;t<sp/>call<sp/>vkBind...<sp/>and/or<sp/>vkMap...<sp/>simultaneously<sp/>on<sp/>the<sp/>same<sp/>VkDeviceMemory<sp/>from<sp/>multiple<sp/>threads.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11926"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaMutexLock<sp/>lock(m_MapAndBindMutex,<sp/>hAllocator-&gt;m_UseMutex);</highlight></codeline>
<codeline lineno="11927"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>hAllocator-&gt;BindVulkanBuffer(m_hMemory,<sp/>memoryOffset,<sp/>hBuffer,<sp/>pNext);</highlight></codeline>
<codeline lineno="11928"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11929"><highlight class="normal"></highlight></codeline>
<codeline lineno="11930"><highlight class="normal">VkResult<sp/>VmaDeviceMemoryBlock::BindImageMemory(</highlight></codeline>
<codeline lineno="11931"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,</highlight></codeline>
<codeline lineno="11932"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>hAllocation,</highlight></codeline>
<codeline lineno="11933"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocationLocalOffset,</highlight></codeline>
<codeline lineno="11934"><highlight class="normal"><sp/><sp/><sp/><sp/>VkImage<sp/>hImage,</highlight></codeline>
<codeline lineno="11935"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pNext)</highlight></codeline>
<codeline lineno="11936"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11937"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(hAllocation-&gt;GetType()<sp/>==<sp/>VmaAllocation_T::ALLOCATION_TYPE_BLOCK<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="11938"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>hAllocation-&gt;GetBlock()<sp/>==<sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="11939"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocationLocalOffset<sp/>&lt;<sp/>hAllocation-&gt;GetSize()<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="11940"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;Invalid<sp/>allocationLocalOffset.<sp/>Did<sp/>you<sp/>forget<sp/>that<sp/>this<sp/>offset<sp/>is<sp/>relative<sp/>to<sp/>the<sp/>beginning<sp/>of<sp/>the<sp/>allocation,<sp/>not<sp/>the<sp/>whole<sp/>memory<sp/>block?&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="11941"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>memoryOffset<sp/>=<sp/>hAllocation-&gt;GetOffset()<sp/>+<sp/>allocationLocalOffset;</highlight></codeline>
<codeline lineno="11942"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>lock<sp/>is<sp/>important<sp/>so<sp/>that<sp/>we<sp/>don&apos;t<sp/>call<sp/>vkBind...<sp/>and/or<sp/>vkMap...<sp/>simultaneously<sp/>on<sp/>the<sp/>same<sp/>VkDeviceMemory<sp/>from<sp/>multiple<sp/>threads.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11943"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaMutexLock<sp/>lock(m_MapAndBindMutex,<sp/>hAllocator-&gt;m_UseMutex);</highlight></codeline>
<codeline lineno="11944"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>hAllocator-&gt;BindVulkanImage(m_hMemory,<sp/>memoryOffset,<sp/>hImage,<sp/>pNext);</highlight></codeline>
<codeline lineno="11945"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11946"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_DEVICE_MEMORY_BLOCK_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11947"><highlight class="normal"></highlight></codeline>
<codeline lineno="11948"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_ALLOCATION_T_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11949"><highlight class="normal">VmaAllocation_T::VmaAllocation_T(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>mappingAllowed)</highlight></codeline>
<codeline lineno="11950"><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>m_Alignment{<sp/>1<sp/>},</highlight></codeline>
<codeline lineno="11951"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Size{<sp/>0<sp/>},</highlight></codeline>
<codeline lineno="11952"><highlight class="normal"><sp/><sp/><sp/><sp/>m_pUserData{<sp/>VMA_NULL<sp/>},</highlight></codeline>
<codeline lineno="11953"><highlight class="normal"><sp/><sp/><sp/><sp/>m_pName{<sp/>VMA_NULL<sp/>},</highlight></codeline>
<codeline lineno="11954"><highlight class="normal"><sp/><sp/><sp/><sp/>m_MemoryTypeIndex{<sp/>0<sp/>},</highlight></codeline>
<codeline lineno="11955"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Type{<sp/>(uint8_t)ALLOCATION_TYPE_NONE<sp/>},</highlight></codeline>
<codeline lineno="11956"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SuballocationType{<sp/>(uint8_t)VMA_SUBALLOCATION_TYPE_UNKNOWN<sp/>},</highlight></codeline>
<codeline lineno="11957"><highlight class="normal"><sp/><sp/><sp/><sp/>m_MapCount{<sp/>0<sp/>},</highlight></codeline>
<codeline lineno="11958"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Flags{<sp/>0<sp/>}</highlight></codeline>
<codeline lineno="11959"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11960"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(mappingAllowed)</highlight></codeline>
<codeline lineno="11961"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Flags<sp/>|=<sp/>(uint8_t)FLAG_MAPPING_ALLOWED;</highlight></codeline>
<codeline lineno="11962"><highlight class="normal"></highlight></codeline>
<codeline lineno="11963"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11964"><highlight class="normal"><sp/><sp/><sp/><sp/>m_BufferImageUsage<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="11965"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11966"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11967"><highlight class="normal"></highlight></codeline>
<codeline lineno="11968"><highlight class="normal">VmaAllocation_T::~VmaAllocation_T()</highlight></codeline>
<codeline lineno="11969"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11970"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_MapCount<sp/>==<sp/>0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Allocation<sp/>was<sp/>not<sp/>unmapped<sp/>before<sp/>destruction.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="11971"><highlight class="normal"></highlight></codeline>
<codeline lineno="11972"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>if<sp/>owned<sp/>string<sp/>was<sp/>freed.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11973"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_pName<sp/>==<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="11974"><highlight class="normal">}</highlight></codeline>
<codeline lineno="11975"><highlight class="normal"></highlight></codeline>
<codeline lineno="11976"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocation_T::InitBlockAllocation(</highlight></codeline>
<codeline lineno="11977"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/>block,</highlight></codeline>
<codeline lineno="11978"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocHandle<sp/>allocHandle,</highlight></codeline>
<codeline lineno="11979"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>alignment,</highlight></codeline>
<codeline lineno="11980"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size,</highlight></codeline>
<codeline lineno="11981"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>memoryTypeIndex,</highlight></codeline>
<codeline lineno="11982"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>suballocationType,</highlight></codeline>
<codeline lineno="11983"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>mapped)</highlight></codeline>
<codeline lineno="11984"><highlight class="normal">{</highlight></codeline>
<codeline lineno="11985"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_Type<sp/>==<sp/>ALLOCATION_TYPE_NONE);</highlight></codeline>
<codeline lineno="11986"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(block<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="11987"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Type<sp/>=<sp/>(uint8_t)ALLOCATION_TYPE_BLOCK;</highlight></codeline>
<codeline lineno="11988"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Alignment<sp/>=<sp/>alignment;</highlight></codeline>
<codeline lineno="11989"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Size<sp/>=<sp/>size;</highlight></codeline>
<codeline lineno="11990"><highlight class="normal"><sp/><sp/><sp/><sp/>m_MemoryTypeIndex<sp/>=<sp/>memoryTypeIndex;</highlight></codeline>
<codeline lineno="11991"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(mapped)</highlight></codeline>
<codeline lineno="11992"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="11993"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(IsMappingAllowed()<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Mapping<sp/>is<sp/>not<sp/>allowed<sp/>on<sp/>this<sp/>allocation!<sp/>Please<sp/>use<sp/>one<sp/>of<sp/>the<sp/>new<sp/>VMA_ALLOCATION_CREATE_HOST_ACCESS_*<sp/>flags<sp/>when<sp/>creating<sp/>it.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="11994"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Flags<sp/>|=<sp/>(uint8_t)FLAG_PERSISTENT_MAP;</highlight></codeline>
<codeline lineno="11995"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="11996"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SuballocationType<sp/>=<sp/>(uint8_t)suballocationType;</highlight></codeline>
<codeline lineno="11997"><highlight class="normal"><sp/><sp/><sp/><sp/>m_BlockAllocation.m_Block<sp/>=<sp/>block;</highlight></codeline>
<codeline lineno="11998"><highlight class="normal"><sp/><sp/><sp/><sp/>m_BlockAllocation.m_AllocHandle<sp/>=<sp/>allocHandle;</highlight></codeline>
<codeline lineno="11999"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12000"><highlight class="normal"></highlight></codeline>
<codeline lineno="12001"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocation_T::InitDedicatedAllocation(</highlight></codeline>
<codeline lineno="12002"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>hParentPool,</highlight></codeline>
<codeline lineno="12003"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>memoryTypeIndex,</highlight></codeline>
<codeline lineno="12004"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceMemory<sp/>hMemory,</highlight></codeline>
<codeline lineno="12005"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>suballocationType,</highlight></codeline>
<codeline lineno="12006"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pMappedData,</highlight></codeline>
<codeline lineno="12007"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size)</highlight></codeline>
<codeline lineno="12008"><highlight class="normal">{</highlight></codeline>
<codeline lineno="12009"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_Type<sp/>==<sp/>ALLOCATION_TYPE_NONE);</highlight></codeline>
<codeline lineno="12010"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(hMemory<sp/>!=<sp/>VK_NULL_HANDLE);</highlight></codeline>
<codeline lineno="12011"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Type<sp/>=<sp/>(uint8_t)ALLOCATION_TYPE_DEDICATED;</highlight></codeline>
<codeline lineno="12012"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Alignment<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="12013"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Size<sp/>=<sp/>size;</highlight></codeline>
<codeline lineno="12014"><highlight class="normal"><sp/><sp/><sp/><sp/>m_MemoryTypeIndex<sp/>=<sp/>memoryTypeIndex;</highlight></codeline>
<codeline lineno="12015"><highlight class="normal"><sp/><sp/><sp/><sp/>m_SuballocationType<sp/>=<sp/>(uint8_t)suballocationType;</highlight></codeline>
<codeline lineno="12016"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pMappedData<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="12017"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12018"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(IsMappingAllowed()<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Mapping<sp/>is<sp/>not<sp/>allowed<sp/>on<sp/>this<sp/>allocation!<sp/>Please<sp/>use<sp/>one<sp/>of<sp/>the<sp/>new<sp/>VMA_ALLOCATION_CREATE_HOST_ACCESS_*<sp/>flags<sp/>when<sp/>creating<sp/>it.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="12019"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Flags<sp/>|=<sp/>(uint8_t)FLAG_PERSISTENT_MAP;</highlight></codeline>
<codeline lineno="12020"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12021"><highlight class="normal"><sp/><sp/><sp/><sp/>m_DedicatedAllocation.m_hParentPool<sp/>=<sp/>hParentPool;</highlight></codeline>
<codeline lineno="12022"><highlight class="normal"><sp/><sp/><sp/><sp/>m_DedicatedAllocation.m_hMemory<sp/>=<sp/>hMemory;</highlight></codeline>
<codeline lineno="12023"><highlight class="normal"><sp/><sp/><sp/><sp/>m_DedicatedAllocation.m_pMappedData<sp/>=<sp/>pMappedData;</highlight></codeline>
<codeline lineno="12024"><highlight class="normal"><sp/><sp/><sp/><sp/>m_DedicatedAllocation.m_Prev<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="12025"><highlight class="normal"><sp/><sp/><sp/><sp/>m_DedicatedAllocation.m_Next<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="12026"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12027"><highlight class="normal"></highlight></codeline>
<codeline lineno="12028"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocation_T::SetName(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>pName)</highlight></codeline>
<codeline lineno="12029"><highlight class="normal">{</highlight></codeline>
<codeline lineno="12030"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(pName<sp/>==<sp/>VMA_NULL<sp/>||<sp/>pName<sp/>!=<sp/>m_pName);</highlight></codeline>
<codeline lineno="12031"><highlight class="normal"></highlight></codeline>
<codeline lineno="12032"><highlight class="normal"><sp/><sp/><sp/><sp/>FreeName(hAllocator);</highlight></codeline>
<codeline lineno="12033"><highlight class="normal"></highlight></codeline>
<codeline lineno="12034"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(pName<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="12035"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pName<sp/>=<sp/>VmaCreateStringCopy(hAllocator-&gt;GetAllocationCallbacks(),<sp/>pName);</highlight></codeline>
<codeline lineno="12036"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12037"><highlight class="normal"></highlight></codeline>
<codeline lineno="12038"><highlight class="normal">uint8_t<sp/>VmaAllocation_T::SwapBlockAllocation(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,<sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>allocation)</highlight></codeline>
<codeline lineno="12039"><highlight class="normal">{</highlight></codeline>
<codeline lineno="12040"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocation<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="12041"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_Type<sp/>==<sp/>ALLOCATION_TYPE_BLOCK);</highlight></codeline>
<codeline lineno="12042"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocation-&gt;m_Type<sp/>==<sp/>ALLOCATION_TYPE_BLOCK);</highlight></codeline>
<codeline lineno="12043"><highlight class="normal"></highlight></codeline>
<codeline lineno="12044"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_MapCount<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="12045"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_BlockAllocation.m_Block-&gt;Unmap(hAllocator,<sp/>m_MapCount);</highlight></codeline>
<codeline lineno="12046"><highlight class="normal"></highlight></codeline>
<codeline lineno="12047"><highlight class="normal"><sp/><sp/><sp/><sp/>m_BlockAllocation.m_Block-&gt;m_pMetadata-&gt;SetAllocationUserData(m_BlockAllocation.m_AllocHandle,<sp/>allocation);</highlight></codeline>
<codeline lineno="12048"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_SWAP(m_BlockAllocation,<sp/>allocation-&gt;m_BlockAllocation);</highlight></codeline>
<codeline lineno="12049"><highlight class="normal"><sp/><sp/><sp/><sp/>m_BlockAllocation.m_Block-&gt;m_pMetadata-&gt;SetAllocationUserData(m_BlockAllocation.m_AllocHandle,<sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="12050"><highlight class="normal"></highlight></codeline>
<codeline lineno="12051"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12052"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_SWAP(m_BufferImageUsage,<sp/>allocation-&gt;m_BufferImageUsage);</highlight></codeline>
<codeline lineno="12053"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12054"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_MapCount;</highlight></codeline>
<codeline lineno="12055"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12056"><highlight class="normal"></highlight></codeline>
<codeline lineno="12057"><highlight class="normal">VmaAllocHandle<sp/>VmaAllocation_T::GetAllocHandle()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="12058"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="12059"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(m_Type)</highlight></codeline>
<codeline lineno="12060"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12061"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ALLOCATION_TYPE_BLOCK:</highlight></codeline>
<codeline lineno="12062"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_BlockAllocation.m_AllocHandle;</highlight></codeline>
<codeline lineno="12063"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ALLOCATION_TYPE_DEDICATED:</highlight></codeline>
<codeline lineno="12064"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="12065"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="12066"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="12067"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="12068"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12069"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12070"><highlight class="normal"></highlight></codeline>
<codeline lineno="12071"><highlight class="normal">VkDeviceSize<sp/>VmaAllocation_T::GetOffset()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="12072"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="12073"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(m_Type)</highlight></codeline>
<codeline lineno="12074"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12075"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ALLOCATION_TYPE_BLOCK:</highlight></codeline>
<codeline lineno="12076"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_BlockAllocation.m_Block-&gt;m_pMetadata-&gt;GetAllocationOffset(m_BlockAllocation.m_AllocHandle);</highlight></codeline>
<codeline lineno="12077"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ALLOCATION_TYPE_DEDICATED:</highlight></codeline>
<codeline lineno="12078"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="12079"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="12080"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="12081"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="12082"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12083"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12084"><highlight class="normal"></highlight></codeline>
<codeline lineno="12085"><highlight class="normal"><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>VmaAllocation_T::GetParentPool()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="12086"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="12087"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(m_Type)</highlight></codeline>
<codeline lineno="12088"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12089"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ALLOCATION_TYPE_BLOCK:</highlight></codeline>
<codeline lineno="12090"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_BlockAllocation.m_Block-&gt;GetParentPool();</highlight></codeline>
<codeline lineno="12091"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ALLOCATION_TYPE_DEDICATED:</highlight></codeline>
<codeline lineno="12092"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_DedicatedAllocation.m_hParentPool;</highlight></codeline>
<codeline lineno="12093"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="12094"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="12095"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="12096"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12097"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12098"><highlight class="normal"></highlight></codeline>
<codeline lineno="12099"><highlight class="normal">VkDeviceMemory<sp/>VmaAllocation_T::GetMemory()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="12100"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="12101"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(m_Type)</highlight></codeline>
<codeline lineno="12102"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12103"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ALLOCATION_TYPE_BLOCK:</highlight></codeline>
<codeline lineno="12104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_BlockAllocation.m_Block-&gt;GetDeviceMemory();</highlight></codeline>
<codeline lineno="12105"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ALLOCATION_TYPE_DEDICATED:</highlight></codeline>
<codeline lineno="12106"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_DedicatedAllocation.m_hMemory;</highlight></codeline>
<codeline lineno="12107"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="12108"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="12109"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="12110"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12111"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12112"><highlight class="normal"></highlight></codeline>
<codeline lineno="12113"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>VmaAllocation_T::GetMappedData()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="12114"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="12115"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(m_Type)</highlight></codeline>
<codeline lineno="12116"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12117"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ALLOCATION_TYPE_BLOCK:</highlight></codeline>
<codeline lineno="12118"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_MapCount<sp/>!=<sp/>0<sp/>||<sp/>IsPersistentMap())</highlight></codeline>
<codeline lineno="12119"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12120"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pBlockData<sp/>=<sp/>m_BlockAllocation.m_Block-&gt;GetMappedData();</highlight></codeline>
<codeline lineno="12121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(pBlockData<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="12122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*)pBlockData<sp/>+<sp/>GetOffset();</highlight></codeline>
<codeline lineno="12123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12124"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="12127"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12128"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="12129"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ALLOCATION_TYPE_DEDICATED:</highlight></codeline>
<codeline lineno="12130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT((m_DedicatedAllocation.m_pMappedData<sp/>!=<sp/>VMA_NULL)<sp/>==<sp/>(m_MapCount<sp/>!=<sp/>0<sp/>||<sp/>IsPersistentMap()));</highlight></codeline>
<codeline lineno="12131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_DedicatedAllocation.m_pMappedData;</highlight></codeline>
<codeline lineno="12132"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="12133"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="12134"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="12135"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12136"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12137"><highlight class="normal"></highlight></codeline>
<codeline lineno="12138"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocation_T::BlockAllocMap()</highlight></codeline>
<codeline lineno="12139"><highlight class="normal">{</highlight></codeline>
<codeline lineno="12140"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(GetType()<sp/>==<sp/>ALLOCATION_TYPE_BLOCK);</highlight></codeline>
<codeline lineno="12141"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(IsMappingAllowed()<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Mapping<sp/>is<sp/>not<sp/>allowed<sp/>on<sp/>this<sp/>allocation!<sp/>Please<sp/>use<sp/>one<sp/>of<sp/>the<sp/>new<sp/>VMA_ALLOCATION_CREATE_HOST_ACCESS_*<sp/>flags<sp/>when<sp/>creating<sp/>it.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="12142"><highlight class="normal"></highlight></codeline>
<codeline lineno="12143"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_MapCount<sp/>&lt;<sp/>0xFF)</highlight></codeline>
<codeline lineno="12144"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++m_MapCount;</highlight></codeline>
<codeline lineno="12146"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12147"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12148"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Allocation<sp/>mapped<sp/>too<sp/>many<sp/>times<sp/>simultaneously.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="12150"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12151"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12152"><highlight class="normal"></highlight></codeline>
<codeline lineno="12153"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocation_T::BlockAllocUnmap()</highlight></codeline>
<codeline lineno="12154"><highlight class="normal">{</highlight></codeline>
<codeline lineno="12155"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(GetType()<sp/>==<sp/>ALLOCATION_TYPE_BLOCK);</highlight></codeline>
<codeline lineno="12156"><highlight class="normal"></highlight></codeline>
<codeline lineno="12157"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_MapCount<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="12158"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12159"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--m_MapCount;</highlight></codeline>
<codeline lineno="12160"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12161"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12162"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12163"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Unmapping<sp/>allocation<sp/>not<sp/>previously<sp/>mapped.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="12164"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12165"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12166"><highlight class="normal"></highlight></codeline>
<codeline lineno="12167"><highlight class="normal">VkResult<sp/>VmaAllocation_T::DedicatedAllocMap(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">**<sp/>ppData)</highlight></codeline>
<codeline lineno="12168"><highlight class="normal">{</highlight></codeline>
<codeline lineno="12169"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(GetType()<sp/>==<sp/>ALLOCATION_TYPE_DEDICATED);</highlight></codeline>
<codeline lineno="12170"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(IsMappingAllowed()<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Mapping<sp/>is<sp/>not<sp/>allowed<sp/>on<sp/>this<sp/>allocation!<sp/>Please<sp/>use<sp/>one<sp/>of<sp/>the<sp/>new<sp/>VMA_ALLOCATION_CREATE_HOST_ACCESS_*<sp/>flags<sp/>when<sp/>creating<sp/>it.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="12171"><highlight class="normal"></highlight></codeline>
<codeline lineno="12172"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_MapCount<sp/>!=<sp/>0<sp/>||<sp/>IsPersistentMap())</highlight></codeline>
<codeline lineno="12173"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12174"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_MapCount<sp/>&lt;<sp/>0xFF)</highlight></codeline>
<codeline lineno="12175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12176"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(m_DedicatedAllocation.m_pMappedData<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="12177"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*ppData<sp/>=<sp/>m_DedicatedAllocation.m_pMappedData;</highlight></codeline>
<codeline lineno="12178"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++m_MapCount;</highlight></codeline>
<codeline lineno="12179"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="12180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12181"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Dedicated<sp/>allocation<sp/>mapped<sp/>too<sp/>many<sp/>times<sp/>simultaneously.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="12184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_MEMORY_MAP_FAILED;</highlight></codeline>
<codeline lineno="12185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12186"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12187"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12188"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12189"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkResult<sp/>result<sp/>=<sp/>(*hAllocator-&gt;GetVulkanFunctions().vkMapMemory)(</highlight></codeline>
<codeline lineno="12190"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>hAllocator-&gt;m_hDevice,</highlight></codeline>
<codeline lineno="12191"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_DedicatedAllocation.m_hMemory,</highlight></codeline>
<codeline lineno="12192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/></highlight><highlight class="comment">//<sp/>offset</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12193"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VK_WHOLE_SIZE,</highlight></codeline>
<codeline lineno="12194"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/></highlight><highlight class="comment">//<sp/>flags</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ppData);</highlight></codeline>
<codeline lineno="12196"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(result<sp/>==<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="12197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12198"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_DedicatedAllocation.m_pMappedData<sp/>=<sp/>*ppData;</highlight></codeline>
<codeline lineno="12199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_MapCount<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="12200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>result;</highlight></codeline>
<codeline lineno="12202"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12203"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12204"><highlight class="normal"></highlight></codeline>
<codeline lineno="12205"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocation_T::DedicatedAllocUnmap(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator)</highlight></codeline>
<codeline lineno="12206"><highlight class="normal">{</highlight></codeline>
<codeline lineno="12207"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(GetType()<sp/>==<sp/>ALLOCATION_TYPE_DEDICATED);</highlight></codeline>
<codeline lineno="12208"><highlight class="normal"></highlight></codeline>
<codeline lineno="12209"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_MapCount<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="12210"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12211"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--m_MapCount;</highlight></codeline>
<codeline lineno="12212"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_MapCount<sp/>==<sp/>0<sp/>&amp;&amp;<sp/>!IsPersistentMap())</highlight></codeline>
<codeline lineno="12213"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12214"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_DedicatedAllocation.m_pMappedData<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="12215"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*hAllocator-&gt;GetVulkanFunctions().vkUnmapMemory)(</highlight></codeline>
<codeline lineno="12216"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>hAllocator-&gt;m_hDevice,</highlight></codeline>
<codeline lineno="12217"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_DedicatedAllocation.m_hMemory);</highlight></codeline>
<codeline lineno="12218"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12219"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12220"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12221"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12222"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Unmapping<sp/>dedicated<sp/>allocation<sp/>not<sp/>previously<sp/>mapped.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="12223"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12224"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12225"><highlight class="normal"></highlight></codeline>
<codeline lineno="12226"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12227"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocation_T::InitBufferImageUsage(uint32_t<sp/>bufferImageUsage)</highlight></codeline>
<codeline lineno="12228"><highlight class="normal">{</highlight></codeline>
<codeline lineno="12229"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_BufferImageUsage<sp/>==<sp/>0);</highlight></codeline>
<codeline lineno="12230"><highlight class="normal"><sp/><sp/><sp/><sp/>m_BufferImageUsage<sp/>=<sp/>bufferImageUsage;</highlight></codeline>
<codeline lineno="12231"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12232"><highlight class="normal"></highlight></codeline>
<codeline lineno="12233"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocation_T::PrintParameters(</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>VmaJsonWriter&amp;<sp/>json)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="12234"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="12235"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;Type&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="12236"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteString(VMA_SUBALLOCATION_TYPE_NAMES[m_SuballocationType]);</highlight></codeline>
<codeline lineno="12237"><highlight class="normal"></highlight></codeline>
<codeline lineno="12238"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;Size&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="12239"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteNumber(m_Size);</highlight></codeline>
<codeline lineno="12240"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;Usage&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="12241"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteNumber(m_BufferImageUsage);</highlight></codeline>
<codeline lineno="12242"><highlight class="normal"></highlight></codeline>
<codeline lineno="12243"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_pUserData<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="12244"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12245"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;CustomData&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="12246"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.BeginString();</highlight></codeline>
<codeline lineno="12247"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.ContinueString_Pointer(m_pUserData);</highlight></codeline>
<codeline lineno="12248"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.EndString();</highlight></codeline>
<codeline lineno="12249"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12250"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_pName<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="12251"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12252"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;Name&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="12253"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(m_pName);</highlight></codeline>
<codeline lineno="12254"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12255"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12256"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12257"><highlight class="normal"></highlight></codeline>
<codeline lineno="12258"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocation_T::FreeName(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator)</highlight></codeline>
<codeline lineno="12259"><highlight class="normal">{</highlight></codeline>
<codeline lineno="12260"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_pName)</highlight></codeline>
<codeline lineno="12261"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12262"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaFreeString(hAllocator-&gt;GetAllocationCallbacks(),<sp/>m_pName);</highlight></codeline>
<codeline lineno="12263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pName<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="12264"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12265"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12266"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_ALLOCATION_T_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12267"><highlight class="normal"></highlight></codeline>
<codeline lineno="12268"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_BLOCK_VECTOR_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12269"><highlight class="normal">VmaBlockVector::VmaBlockVector(</highlight></codeline>
<codeline lineno="12270"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,</highlight></codeline>
<codeline lineno="12271"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>hParentPool,</highlight></codeline>
<codeline lineno="12272"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>memoryTypeIndex,</highlight></codeline>
<codeline lineno="12273"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>preferredBlockSize,</highlight></codeline>
<codeline lineno="12274"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>minBlockCount,</highlight></codeline>
<codeline lineno="12275"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>maxBlockCount,</highlight></codeline>
<codeline lineno="12276"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>bufferImageGranularity,</highlight></codeline>
<codeline lineno="12277"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>explicitBlockSize,</highlight></codeline>
<codeline lineno="12278"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>algorithm,</highlight></codeline>
<codeline lineno="12279"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>priority,</highlight></codeline>
<codeline lineno="12280"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>minAllocationAlignment,</highlight></codeline>
<codeline lineno="12281"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pMemoryAllocateNext)</highlight></codeline>
<codeline lineno="12282"><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>m_hAllocator(hAllocator),</highlight></codeline>
<codeline lineno="12283"><highlight class="normal"><sp/><sp/><sp/><sp/>m_hParentPool(hParentPool),</highlight></codeline>
<codeline lineno="12284"><highlight class="normal"><sp/><sp/><sp/><sp/>m_MemoryTypeIndex(memoryTypeIndex),</highlight></codeline>
<codeline lineno="12285"><highlight class="normal"><sp/><sp/><sp/><sp/>m_PreferredBlockSize(preferredBlockSize),</highlight></codeline>
<codeline lineno="12286"><highlight class="normal"><sp/><sp/><sp/><sp/>m_MinBlockCount(minBlockCount),</highlight></codeline>
<codeline lineno="12287"><highlight class="normal"><sp/><sp/><sp/><sp/>m_MaxBlockCount(maxBlockCount),</highlight></codeline>
<codeline lineno="12288"><highlight class="normal"><sp/><sp/><sp/><sp/>m_BufferImageGranularity(bufferImageGranularity),</highlight></codeline>
<codeline lineno="12289"><highlight class="normal"><sp/><sp/><sp/><sp/>m_ExplicitBlockSize(explicitBlockSize),</highlight></codeline>
<codeline lineno="12290"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Algorithm(algorithm),</highlight></codeline>
<codeline lineno="12291"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Priority(priority),</highlight></codeline>
<codeline lineno="12292"><highlight class="normal"><sp/><sp/><sp/><sp/>m_MinAllocationAlignment(minAllocationAlignment),</highlight></codeline>
<codeline lineno="12293"><highlight class="normal"><sp/><sp/><sp/><sp/>m_pMemoryAllocateNext(pMemoryAllocateNext),</highlight></codeline>
<codeline lineno="12294"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Blocks(VmaStlAllocator&lt;VmaDeviceMemoryBlock*&gt;(hAllocator-&gt;GetAllocationCallbacks())),</highlight></codeline>
<codeline lineno="12295"><highlight class="normal"><sp/><sp/><sp/><sp/>m_NextBlockId(0)<sp/>{}</highlight></codeline>
<codeline lineno="12296"><highlight class="normal"></highlight></codeline>
<codeline lineno="12297"><highlight class="normal">VmaBlockVector::~VmaBlockVector()</highlight></codeline>
<codeline lineno="12298"><highlight class="normal">{</highlight></codeline>
<codeline lineno="12299"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>m_Blocks.size();<sp/>i--;<sp/>)</highlight></codeline>
<codeline lineno="12300"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12301"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Blocks[i]-&gt;Destroy(m_hAllocator);</highlight></codeline>
<codeline lineno="12302"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vma_delete(m_hAllocator,<sp/>m_Blocks[i]);</highlight></codeline>
<codeline lineno="12303"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12304"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12305"><highlight class="normal"></highlight></codeline>
<codeline lineno="12306"><highlight class="normal">VkResult<sp/>VmaBlockVector::CreateMinBlocks()</highlight></codeline>
<codeline lineno="12307"><highlight class="normal">{</highlight></codeline>
<codeline lineno="12308"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>m_MinBlockCount;<sp/>++i)</highlight></codeline>
<codeline lineno="12309"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12310"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>CreateBlock(m_PreferredBlockSize,<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="12311"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res<sp/>!=<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="12312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12313"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="12314"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12315"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12316"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="12317"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12318"><highlight class="normal"></highlight></codeline>
<codeline lineno="12319"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockVector::AddStatistics(<ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref>&amp;<sp/>inoutStats)</highlight></codeline>
<codeline lineno="12320"><highlight class="normal">{</highlight></codeline>
<codeline lineno="12321"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaMutexLockRead<sp/>lock(m_Mutex,<sp/>m_hAllocator-&gt;m_UseMutex);</highlight></codeline>
<codeline lineno="12322"><highlight class="normal"></highlight></codeline>
<codeline lineno="12323"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>blockCount<sp/>=<sp/>m_Blocks.size();</highlight></codeline>
<codeline lineno="12324"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(uint32_t<sp/>blockIndex<sp/>=<sp/>0;<sp/>blockIndex<sp/>&lt;<sp/>blockCount;<sp/>++blockIndex)</highlight></codeline>
<codeline lineno="12325"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaDeviceMemoryBlock*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>pBlock<sp/>=<sp/>m_Blocks[blockIndex];</highlight></codeline>
<codeline lineno="12327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(pBlock);</highlight></codeline>
<codeline lineno="12328"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(pBlock-&gt;Validate());</highlight></codeline>
<codeline lineno="12329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pBlock-&gt;m_pMetadata-&gt;AddStatistics(inoutStats);</highlight></codeline>
<codeline lineno="12330"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12331"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12332"><highlight class="normal"></highlight></codeline>
<codeline lineno="12333"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockVector::AddDetailedStatistics(<ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>&amp;<sp/>inoutStats)</highlight></codeline>
<codeline lineno="12334"><highlight class="normal">{</highlight></codeline>
<codeline lineno="12335"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaMutexLockRead<sp/>lock(m_Mutex,<sp/>m_hAllocator-&gt;m_UseMutex);</highlight></codeline>
<codeline lineno="12336"><highlight class="normal"></highlight></codeline>
<codeline lineno="12337"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>blockCount<sp/>=<sp/>m_Blocks.size();</highlight></codeline>
<codeline lineno="12338"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(uint32_t<sp/>blockIndex<sp/>=<sp/>0;<sp/>blockIndex<sp/>&lt;<sp/>blockCount;<sp/>++blockIndex)</highlight></codeline>
<codeline lineno="12339"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VmaDeviceMemoryBlock*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>pBlock<sp/>=<sp/>m_Blocks[blockIndex];</highlight></codeline>
<codeline lineno="12341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(pBlock);</highlight></codeline>
<codeline lineno="12342"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(pBlock-&gt;Validate());</highlight></codeline>
<codeline lineno="12343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pBlock-&gt;m_pMetadata-&gt;AddDetailedStatistics(inoutStats);</highlight></codeline>
<codeline lineno="12344"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12345"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12346"><highlight class="normal"></highlight></codeline>
<codeline lineno="12347"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaBlockVector::IsEmpty()</highlight></codeline>
<codeline lineno="12348"><highlight class="normal">{</highlight></codeline>
<codeline lineno="12349"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaMutexLockRead<sp/>lock(m_Mutex,<sp/>m_hAllocator-&gt;m_UseMutex);</highlight></codeline>
<codeline lineno="12350"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>m_Blocks.empty();</highlight></codeline>
<codeline lineno="12351"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12352"><highlight class="normal"></highlight></codeline>
<codeline lineno="12353"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaBlockVector::IsCorruptionDetectionEnabled()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="12354"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="12355"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>requiredMemFlags<sp/>=<sp/>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT<sp/>|<sp/>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;</highlight></codeline>
<codeline lineno="12356"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(VMA_DEBUG_DETECT_CORRUPTION<sp/>!=<sp/>0)<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="12357"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(VMA_DEBUG_MARGIN<sp/>&gt;<sp/>0)<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="12358"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(m_Algorithm<sp/>==<sp/>0<sp/>||<sp/>m_Algorithm<sp/>==<sp/><ref refid="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726" kindref="member">VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</ref>)<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="12359"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(m_hAllocator-&gt;m_MemProps.memoryTypes[m_MemoryTypeIndex].propertyFlags<sp/>&amp;<sp/>requiredMemFlags)<sp/>==<sp/>requiredMemFlags;</highlight></codeline>
<codeline lineno="12360"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12361"><highlight class="normal"></highlight></codeline>
<codeline lineno="12362"><highlight class="normal">VkResult<sp/>VmaBlockVector::Allocate(</highlight></codeline>
<codeline lineno="12363"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size,</highlight></codeline>
<codeline lineno="12364"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>alignment,</highlight></codeline>
<codeline lineno="12365"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>&amp;<sp/>createInfo,</highlight></codeline>
<codeline lineno="12366"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>suballocType,</highlight></codeline>
<codeline lineno="12367"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>allocationCount,</highlight></codeline>
<codeline lineno="12368"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>pAllocations)</highlight></codeline>
<codeline lineno="12369"><highlight class="normal">{</highlight></codeline>
<codeline lineno="12370"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>allocIndex;</highlight></codeline>
<codeline lineno="12371"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="12372"><highlight class="normal"></highlight></codeline>
<codeline lineno="12373"><highlight class="normal"><sp/><sp/><sp/><sp/>alignment<sp/>=<sp/>VMA_MAX(alignment,<sp/>m_MinAllocationAlignment);</highlight></codeline>
<codeline lineno="12374"><highlight class="normal"></highlight></codeline>
<codeline lineno="12375"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(IsCorruptionDetectionEnabled())</highlight></codeline>
<codeline lineno="12376"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12377"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size<sp/>=<sp/>VmaAlignUp&lt;VkDeviceSize&gt;(size,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(VMA_CORRUPTION_DETECTION_MAGIC_VALUE));</highlight></codeline>
<codeline lineno="12378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alignment<sp/>=<sp/>VmaAlignUp&lt;VkDeviceSize&gt;(alignment,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(VMA_CORRUPTION_DETECTION_MAGIC_VALUE));</highlight></codeline>
<codeline lineno="12379"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12380"><highlight class="normal"></highlight></codeline>
<codeline lineno="12381"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12382"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaMutexLockWrite<sp/>lock(m_Mutex,<sp/>m_hAllocator-&gt;m_UseMutex);</highlight></codeline>
<codeline lineno="12383"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(allocIndex<sp/>=<sp/>0;<sp/>allocIndex<sp/>&lt;<sp/>allocationCount;<sp/>++allocIndex)</highlight></codeline>
<codeline lineno="12384"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12385"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>AllocatePage(</highlight></codeline>
<codeline lineno="12386"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size,</highlight></codeline>
<codeline lineno="12387"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alignment,</highlight></codeline>
<codeline lineno="12388"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>createInfo,</highlight></codeline>
<codeline lineno="12389"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocType,</highlight></codeline>
<codeline lineno="12390"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocations<sp/>+<sp/>allocIndex);</highlight></codeline>
<codeline lineno="12391"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res<sp/>!=<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="12392"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12393"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="12394"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12395"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12396"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12397"><highlight class="normal"></highlight></codeline>
<codeline lineno="12398"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res<sp/>!=<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="12399"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12400"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Free<sp/>all<sp/>already<sp/>created<sp/>allocations.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12401"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(allocIndex--)</highlight></codeline>
<codeline lineno="12402"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Free(pAllocations[allocIndex]);</highlight></codeline>
<codeline lineno="12403"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memset(pAllocations,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>)<sp/>*<sp/>allocationCount);</highlight></codeline>
<codeline lineno="12404"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12405"><highlight class="normal"></highlight></codeline>
<codeline lineno="12406"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="12407"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12408"><highlight class="normal"></highlight></codeline>
<codeline lineno="12409"><highlight class="normal">VkResult<sp/>VmaBlockVector::AllocatePage(</highlight></codeline>
<codeline lineno="12410"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size,</highlight></codeline>
<codeline lineno="12411"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>alignment,</highlight></codeline>
<codeline lineno="12412"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>&amp;<sp/>createInfo,</highlight></codeline>
<codeline lineno="12413"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>suballocType,</highlight></codeline>
<codeline lineno="12414"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>pAllocation)</highlight></codeline>
<codeline lineno="12415"><highlight class="normal">{</highlight></codeline>
<codeline lineno="12416"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isUpperAddress<sp/>=<sp/>(createInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a42ba3a2d2c7117953210b7c3ef8da0df" kindref="member">VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT</ref>)<sp/>!=<sp/>0;</highlight></codeline>
<codeline lineno="12417"><highlight class="normal"></highlight></codeline>
<codeline lineno="12418"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>freeMemory;</highlight></codeline>
<codeline lineno="12419"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12420"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>heapIndex<sp/>=<sp/>m_hAllocator-&gt;MemoryTypeIndexToHeapIndex(m_MemoryTypeIndex);</highlight></codeline>
<codeline lineno="12421"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_budget" kindref="compound">VmaBudget</ref><sp/>heapBudget<sp/>=<sp/>{};</highlight></codeline>
<codeline lineno="12422"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_hAllocator-&gt;GetHeapBudgets(&amp;heapBudget,<sp/>heapIndex,<sp/>1);</highlight></codeline>
<codeline lineno="12423"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>freeMemory<sp/>=<sp/>(heapBudget.<ref refid="struct_vma_budget_1a84dd1ecca8b0110259eb206dbadb11f6" kindref="member">usage</ref><sp/>&lt;<sp/>heapBudget.<ref refid="struct_vma_budget_1ab82e1d1754c2d210d0bdf90220bc6cdd" kindref="member">budget</ref>)<sp/>?<sp/>(heapBudget.<ref refid="struct_vma_budget_1ab82e1d1754c2d210d0bdf90220bc6cdd" kindref="member">budget</ref><sp/>-<sp/>heapBudget.<ref refid="struct_vma_budget_1a84dd1ecca8b0110259eb206dbadb11f6" kindref="member">usage</ref>)<sp/>:<sp/>0;</highlight></codeline>
<codeline lineno="12424"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12425"><highlight class="normal"></highlight></codeline>
<codeline lineno="12426"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>canFallbackToDedicated<sp/>=<sp/>!HasExplicitBlockSize()<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="12427"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(createInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a89759603401014eb325eb22a3839f2ff" kindref="member">VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</ref>)<sp/>==<sp/>0;</highlight></codeline>
<codeline lineno="12428"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>canCreateNewBlock<sp/>=</highlight></codeline>
<codeline lineno="12429"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>((createInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a89759603401014eb325eb22a3839f2ff" kindref="member">VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</ref>)<sp/>==<sp/>0)<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="12430"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(m_Blocks.size()<sp/>&lt;<sp/>m_MaxBlockCount)<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="12431"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(freeMemory<sp/>&gt;=<sp/>size<sp/>||<sp/>!canFallbackToDedicated);</highlight></codeline>
<codeline lineno="12432"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>strategy<sp/>=<sp/>createInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8e16845d81ae3d27c47106d4770d5c7e" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MASK</ref>;</highlight></codeline>
<codeline lineno="12433"><highlight class="normal"></highlight></codeline>
<codeline lineno="12434"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Upper<sp/>address<sp/>can<sp/>only<sp/>be<sp/>used<sp/>with<sp/>linear<sp/>allocator<sp/>and<sp/>within<sp/>single<sp/>memory<sp/>block.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12435"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(isUpperAddress<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="12436"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(m_Algorithm<sp/>!=<sp/><ref refid="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726" kindref="member">VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</ref><sp/>||<sp/>m_MaxBlockCount<sp/>&gt;<sp/>1))</highlight></codeline>
<codeline lineno="12437"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12438"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_FEATURE_NOT_PRESENT;</highlight></codeline>
<codeline lineno="12439"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12440"><highlight class="normal"></highlight></codeline>
<codeline lineno="12441"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Early<sp/>reject:<sp/>requested<sp/>allocation<sp/>size<sp/>is<sp/>larger<sp/>that<sp/>maximum<sp/>block<sp/>size<sp/>for<sp/>this<sp/>block<sp/>vector.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12442"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(size<sp/>+<sp/>VMA_DEBUG_MARGIN<sp/>&gt;<sp/>m_PreferredBlockSize)</highlight></codeline>
<codeline lineno="12443"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12444"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_OUT_OF_DEVICE_MEMORY;</highlight></codeline>
<codeline lineno="12445"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12446"><highlight class="normal"></highlight></codeline>
<codeline lineno="12447"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>1.<sp/>Search<sp/>existing<sp/>allocations.<sp/>Try<sp/>to<sp/>allocate.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12448"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_Algorithm<sp/>==<sp/><ref refid="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726" kindref="member">VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</ref>)</highlight></codeline>
<codeline lineno="12449"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12450"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Use<sp/>only<sp/>last<sp/>block.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12451"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!m_Blocks.empty())</highlight></codeline>
<codeline lineno="12452"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12453"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>pCurrBlock<sp/>=<sp/>m_Blocks.back();</highlight></codeline>
<codeline lineno="12454"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(pCurrBlock);</highlight></codeline>
<codeline lineno="12455"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>AllocateFromBlock(</highlight></codeline>
<codeline lineno="12456"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pCurrBlock,<sp/>size,<sp/>alignment,<sp/>createInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref>,<sp/>createInfo.<ref refid="struct_vma_allocation_create_info_1a74e2eb74b3772b657c59473ce605058a" kindref="member">pUserData</ref>,<sp/>suballocType,<sp/>strategy,<sp/>pAllocation);</highlight></codeline>
<codeline lineno="12457"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res<sp/>==<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="12458"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12459"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/>Returned<sp/>from<sp/>last<sp/>block<sp/>#%u&quot;</highlight><highlight class="normal">,<sp/>pCurrBlock-&gt;GetId());</highlight></codeline>
<codeline lineno="12460"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IncrementallySortBlocks();</highlight></codeline>
<codeline lineno="12461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="12462"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12463"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12464"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12465"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12466"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12467"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(strategy<sp/>!=<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a0729e932b7ea170e3a128cad96c5cf6d" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</ref>)<sp/></highlight><highlight class="comment">//<sp/>MIN_MEMORY<sp/>or<sp/>default</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12468"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12469"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isHostVisible<sp/>=</highlight></codeline>
<codeline lineno="12470"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(m_hAllocator-&gt;m_MemProps.memoryTypes[m_MemoryTypeIndex].propertyFlags<sp/>&amp;<sp/>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)<sp/>!=<sp/>0;</highlight></codeline>
<codeline lineno="12471"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(isHostVisible)</highlight></codeline>
<codeline lineno="12472"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12473"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isMappingAllowed<sp/>=<sp/>(createInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;</highlight></codeline>
<codeline lineno="12474"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(<ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</ref><sp/>|<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</ref>))<sp/>!=<sp/>0;</highlight></codeline>
<codeline lineno="12475"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="12476"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>For<sp/>non-mappable<sp/>allocations,<sp/>check<sp/>blocks<sp/>that<sp/>are<sp/>not<sp/>mapped<sp/>first.</highlight></codeline>
<codeline lineno="12477"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>For<sp/>mappable<sp/>allocations,<sp/>check<sp/>blocks<sp/>that<sp/>are<sp/>already<sp/>mapped<sp/>first.</highlight></codeline>
<codeline lineno="12478"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>This<sp/>way,<sp/>having<sp/>many<sp/>blocks,<sp/>we<sp/>will<sp/>separate<sp/>mappable<sp/>and<sp/>non-mappable<sp/>allocations,</highlight></codeline>
<codeline lineno="12479"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>hopefully<sp/>limiting<sp/>the<sp/>number<sp/>of<sp/>blocks<sp/>that<sp/>are<sp/>mapped,<sp/>which<sp/>will<sp/>help<sp/>tools<sp/>like<sp/>RenderDoc.</highlight></codeline>
<codeline lineno="12480"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12481"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>mappingI<sp/>=<sp/>0;<sp/>mappingI<sp/>&lt;<sp/>2;<sp/>++mappingI)</highlight></codeline>
<codeline lineno="12482"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12483"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Forward<sp/>order<sp/>in<sp/>m_Blocks<sp/>-<sp/>prefer<sp/>blocks<sp/>with<sp/>smallest<sp/>amount<sp/>of<sp/>free<sp/>space.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12484"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>blockIndex<sp/>=<sp/>0;<sp/>blockIndex<sp/>&lt;<sp/>m_Blocks.size();<sp/>++blockIndex)</highlight></codeline>
<codeline lineno="12485"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12486"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>pCurrBlock<sp/>=<sp/>m_Blocks[blockIndex];</highlight></codeline>
<codeline lineno="12487"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(pCurrBlock);</highlight></codeline>
<codeline lineno="12488"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isBlockMapped<sp/>=<sp/>pCurrBlock-&gt;GetMappedData()<sp/>!=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="12489"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">((mappingI<sp/>==<sp/>0)<sp/>==<sp/>(isMappingAllowed<sp/>==<sp/>isBlockMapped))</highlight></codeline>
<codeline lineno="12490"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12491"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>AllocateFromBlock(</highlight></codeline>
<codeline lineno="12492"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pCurrBlock,<sp/>size,<sp/>alignment,<sp/>createInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref>,<sp/>createInfo.<ref refid="struct_vma_allocation_create_info_1a74e2eb74b3772b657c59473ce605058a" kindref="member">pUserData</ref>,<sp/>suballocType,<sp/>strategy,<sp/>pAllocation);</highlight></codeline>
<codeline lineno="12493"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res<sp/>==<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="12494"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12495"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/>Returned<sp/>from<sp/>existing<sp/>block<sp/>#%u&quot;</highlight><highlight class="normal">,<sp/>pCurrBlock-&gt;GetId());</highlight></codeline>
<codeline lineno="12496"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IncrementallySortBlocks();</highlight></codeline>
<codeline lineno="12497"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="12498"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12499"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12500"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12501"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12502"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12503"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12504"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12505"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Forward<sp/>order<sp/>in<sp/>m_Blocks<sp/>-<sp/>prefer<sp/>blocks<sp/>with<sp/>smallest<sp/>amount<sp/>of<sp/>free<sp/>space.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12506"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>blockIndex<sp/>=<sp/>0;<sp/>blockIndex<sp/>&lt;<sp/>m_Blocks.size();<sp/>++blockIndex)</highlight></codeline>
<codeline lineno="12507"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12508"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>pCurrBlock<sp/>=<sp/>m_Blocks[blockIndex];</highlight></codeline>
<codeline lineno="12509"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(pCurrBlock);</highlight></codeline>
<codeline lineno="12510"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>AllocateFromBlock(</highlight></codeline>
<codeline lineno="12511"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pCurrBlock,<sp/>size,<sp/>alignment,<sp/>createInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref>,<sp/>createInfo.<ref refid="struct_vma_allocation_create_info_1a74e2eb74b3772b657c59473ce605058a" kindref="member">pUserData</ref>,<sp/>suballocType,<sp/>strategy,<sp/>pAllocation);</highlight></codeline>
<codeline lineno="12512"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res<sp/>==<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="12513"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12514"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/>Returned<sp/>from<sp/>existing<sp/>block<sp/>#%u&quot;</highlight><highlight class="normal">,<sp/>pCurrBlock-&gt;GetId());</highlight></codeline>
<codeline lineno="12515"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IncrementallySortBlocks();</highlight></codeline>
<codeline lineno="12516"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="12517"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12518"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12519"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12520"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12521"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="comment">//<sp/>VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12522"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12523"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Backward<sp/>order<sp/>in<sp/>m_Blocks<sp/>-<sp/>prefer<sp/>blocks<sp/>with<sp/>largest<sp/>amount<sp/>of<sp/>free<sp/>space.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12524"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>blockIndex<sp/>=<sp/>m_Blocks.size();<sp/>blockIndex--;<sp/>)</highlight></codeline>
<codeline lineno="12525"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12526"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>pCurrBlock<sp/>=<sp/>m_Blocks[blockIndex];</highlight></codeline>
<codeline lineno="12527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(pCurrBlock);</highlight></codeline>
<codeline lineno="12528"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>AllocateFromBlock(pCurrBlock,<sp/>size,<sp/>alignment,<sp/>createInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref>,<sp/>createInfo.<ref refid="struct_vma_allocation_create_info_1a74e2eb74b3772b657c59473ce605058a" kindref="member">pUserData</ref>,<sp/>suballocType,<sp/>strategy,<sp/>pAllocation);</highlight></codeline>
<codeline lineno="12529"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res<sp/>==<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="12530"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12531"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/>Returned<sp/>from<sp/>existing<sp/>block<sp/>#%u&quot;</highlight><highlight class="normal">,<sp/>pCurrBlock-&gt;GetId());</highlight></codeline>
<codeline lineno="12532"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IncrementallySortBlocks();</highlight></codeline>
<codeline lineno="12533"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="12534"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12535"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12536"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12537"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12538"><highlight class="normal"></highlight></codeline>
<codeline lineno="12539"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>2.<sp/>Try<sp/>to<sp/>create<sp/>new<sp/>block.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12540"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(canCreateNewBlock)</highlight></codeline>
<codeline lineno="12541"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12542"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Calculate<sp/>optimal<sp/>size<sp/>for<sp/>new<sp/>block.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12543"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>newBlockSize<sp/>=<sp/>m_PreferredBlockSize;</highlight></codeline>
<codeline lineno="12544"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>newBlockSizeShift<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="12545"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>NEW_BLOCK_SIZE_SHIFT_MAX<sp/>=<sp/>3;</highlight></codeline>
<codeline lineno="12546"><highlight class="normal"></highlight></codeline>
<codeline lineno="12547"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!m_ExplicitBlockSize)</highlight></codeline>
<codeline lineno="12548"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12549"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Allocate<sp/>1/8,<sp/>1/4,<sp/>1/2<sp/>as<sp/>first<sp/>blocks.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12550"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>maxExistingBlockSize<sp/>=<sp/>CalcMaxBlockSize();</highlight></codeline>
<codeline lineno="12551"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(uint32_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>NEW_BLOCK_SIZE_SHIFT_MAX;<sp/>++i)</highlight></codeline>
<codeline lineno="12552"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12553"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>smallerNewBlockSize<sp/>=<sp/>newBlockSize<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="12554"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(smallerNewBlockSize<sp/>&gt;<sp/>maxExistingBlockSize<sp/>&amp;&amp;<sp/>smallerNewBlockSize<sp/>&gt;=<sp/>size<sp/>*<sp/>2)</highlight></codeline>
<codeline lineno="12555"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12556"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newBlockSize<sp/>=<sp/>smallerNewBlockSize;</highlight></codeline>
<codeline lineno="12557"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++newBlockSizeShift;</highlight></codeline>
<codeline lineno="12558"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12559"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12560"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12561"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="12562"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12563"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12564"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12565"><highlight class="normal"></highlight></codeline>
<codeline lineno="12566"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>newBlockIndex<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="12567"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>(newBlockSize<sp/>&lt;=<sp/>freeMemory<sp/>||<sp/>!canFallbackToDedicated)<sp/>?</highlight></codeline>
<codeline lineno="12568"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CreateBlock(newBlockSize,<sp/>&amp;newBlockIndex)<sp/>:<sp/>VK_ERROR_OUT_OF_DEVICE_MEMORY;</highlight></codeline>
<codeline lineno="12569"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Allocation<sp/>of<sp/>this<sp/>size<sp/>failed?<sp/>Try<sp/>1/2,<sp/>1/4,<sp/>1/8<sp/>of<sp/>m_PreferredBlockSize.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12570"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!m_ExplicitBlockSize)</highlight></codeline>
<codeline lineno="12571"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12572"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(res<sp/>&lt;<sp/>0<sp/>&amp;&amp;<sp/>newBlockSizeShift<sp/>&lt;<sp/>NEW_BLOCK_SIZE_SHIFT_MAX)</highlight></codeline>
<codeline lineno="12573"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12574"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>smallerNewBlockSize<sp/>=<sp/>newBlockSize<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="12575"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(smallerNewBlockSize<sp/>&gt;=<sp/>size)</highlight></codeline>
<codeline lineno="12576"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12577"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newBlockSize<sp/>=<sp/>smallerNewBlockSize;</highlight></codeline>
<codeline lineno="12578"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++newBlockSizeShift;</highlight></codeline>
<codeline lineno="12579"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>(newBlockSize<sp/>&lt;=<sp/>freeMemory<sp/>||<sp/>!canFallbackToDedicated)<sp/>?</highlight></codeline>
<codeline lineno="12580"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CreateBlock(newBlockSize,<sp/>&amp;newBlockIndex)<sp/>:<sp/>VK_ERROR_OUT_OF_DEVICE_MEMORY;</highlight></codeline>
<codeline lineno="12581"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12582"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12583"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12584"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="12585"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12586"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12587"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12588"><highlight class="normal"></highlight></codeline>
<codeline lineno="12589"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res<sp/>==<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="12590"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12591"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>pBlock<sp/>=<sp/>m_Blocks[newBlockIndex];</highlight></codeline>
<codeline lineno="12592"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(pBlock-&gt;m_pMetadata-&gt;GetSize()<sp/>&gt;=<sp/>size);</highlight></codeline>
<codeline lineno="12593"><highlight class="normal"></highlight></codeline>
<codeline lineno="12594"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>AllocateFromBlock(</highlight></codeline>
<codeline lineno="12595"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pBlock,<sp/>size,<sp/>alignment,<sp/>createInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref>,<sp/>createInfo.<ref refid="struct_vma_allocation_create_info_1a74e2eb74b3772b657c59473ce605058a" kindref="member">pUserData</ref>,<sp/>suballocType,<sp/>strategy,<sp/>pAllocation);</highlight></codeline>
<codeline lineno="12596"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res<sp/>==<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="12597"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12598"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/>Created<sp/>new<sp/>block<sp/>#%u<sp/>Size=%llu&quot;</highlight><highlight class="normal">,<sp/>pBlock-&gt;GetId(),<sp/>newBlockSize);</highlight></codeline>
<codeline lineno="12599"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IncrementallySortBlocks();</highlight></codeline>
<codeline lineno="12600"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="12601"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12602"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12603"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12604"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Allocation<sp/>from<sp/>new<sp/>block<sp/>failed,<sp/>possibly<sp/>due<sp/>to<sp/>VMA_DEBUG_MARGIN<sp/>or<sp/>alignment.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12605"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_OUT_OF_DEVICE_MEMORY;</highlight></codeline>
<codeline lineno="12606"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12607"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12608"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12609"><highlight class="normal"></highlight></codeline>
<codeline lineno="12610"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_OUT_OF_DEVICE_MEMORY;</highlight></codeline>
<codeline lineno="12611"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12612"><highlight class="normal"></highlight></codeline>
<codeline lineno="12613"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockVector::Free(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>hAllocation)</highlight></codeline>
<codeline lineno="12614"><highlight class="normal">{</highlight></codeline>
<codeline lineno="12615"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/>pBlockToDelete<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="12616"><highlight class="normal"></highlight></codeline>
<codeline lineno="12617"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>budgetExceeded<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="12618"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12619"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>heapIndex<sp/>=<sp/>m_hAllocator-&gt;MemoryTypeIndexToHeapIndex(m_MemoryTypeIndex);</highlight></codeline>
<codeline lineno="12620"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_budget" kindref="compound">VmaBudget</ref><sp/>heapBudget<sp/>=<sp/>{};</highlight></codeline>
<codeline lineno="12621"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_hAllocator-&gt;GetHeapBudgets(&amp;heapBudget,<sp/>heapIndex,<sp/>1);</highlight></codeline>
<codeline lineno="12622"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>budgetExceeded<sp/>=<sp/>heapBudget.<ref refid="struct_vma_budget_1a84dd1ecca8b0110259eb206dbadb11f6" kindref="member">usage</ref><sp/>&gt;=<sp/>heapBudget.<ref refid="struct_vma_budget_1ab82e1d1754c2d210d0bdf90220bc6cdd" kindref="member">budget</ref>;</highlight></codeline>
<codeline lineno="12623"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12624"><highlight class="normal"></highlight></codeline>
<codeline lineno="12625"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Scope<sp/>for<sp/>lock.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12626"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12627"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaMutexLockWrite<sp/>lock(m_Mutex,<sp/>m_hAllocator-&gt;m_UseMutex);</highlight></codeline>
<codeline lineno="12628"><highlight class="normal"></highlight></codeline>
<codeline lineno="12629"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/>pBlock<sp/>=<sp/>hAllocation-&gt;GetBlock();</highlight></codeline>
<codeline lineno="12630"><highlight class="normal"></highlight></codeline>
<codeline lineno="12631"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(IsCorruptionDetectionEnabled())</highlight></codeline>
<codeline lineno="12632"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12633"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>pBlock-&gt;ValidateMagicValueAfterAllocation(m_hAllocator,<sp/>hAllocation-&gt;GetOffset(),<sp/>hAllocation-&gt;GetSize());</highlight></codeline>
<codeline lineno="12634"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(res<sp/>==<sp/>VK_SUCCESS<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Couldn&apos;t<sp/>map<sp/>block<sp/>memory<sp/>to<sp/>validate<sp/>magic<sp/>value.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="12635"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12636"><highlight class="normal"></highlight></codeline>
<codeline lineno="12637"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(hAllocation-&gt;IsPersistentMap())</highlight></codeline>
<codeline lineno="12638"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12639"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pBlock-&gt;Unmap(m_hAllocator,<sp/>1);</highlight></codeline>
<codeline lineno="12640"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12641"><highlight class="normal"></highlight></codeline>
<codeline lineno="12642"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>hadEmptyBlockBeforeFree<sp/>=<sp/>HasEmptyBlock();</highlight></codeline>
<codeline lineno="12643"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pBlock-&gt;m_pMetadata-&gt;Free(hAllocation-&gt;GetAllocHandle());</highlight></codeline>
<codeline lineno="12644"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pBlock-&gt;PostFree(m_hAllocator);</highlight></codeline>
<codeline lineno="12645"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(pBlock-&gt;Validate());</highlight></codeline>
<codeline lineno="12646"><highlight class="normal"></highlight></codeline>
<codeline lineno="12647"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;<sp/><sp/>Freed<sp/>from<sp/>MemoryTypeIndex=%u&quot;</highlight><highlight class="normal">,<sp/>m_MemoryTypeIndex);</highlight></codeline>
<codeline lineno="12648"><highlight class="normal"></highlight></codeline>
<codeline lineno="12649"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>canDeleteBlock<sp/>=<sp/>m_Blocks.size()<sp/>&gt;<sp/>m_MinBlockCount;</highlight></codeline>
<codeline lineno="12650"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>pBlock<sp/>became<sp/>empty<sp/>after<sp/>this<sp/>deallocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12651"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(pBlock-&gt;m_pMetadata-&gt;IsEmpty())</highlight></codeline>
<codeline lineno="12652"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12653"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Already<sp/>had<sp/>empty<sp/>block.<sp/>We<sp/>don&apos;t<sp/>want<sp/>to<sp/>have<sp/>two,<sp/>so<sp/>delete<sp/>this<sp/>one.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12654"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((hadEmptyBlockBeforeFree<sp/>||<sp/>budgetExceeded)<sp/>&amp;&amp;<sp/>canDeleteBlock)</highlight></codeline>
<codeline lineno="12655"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12656"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pBlockToDelete<sp/>=<sp/>pBlock;</highlight></codeline>
<codeline lineno="12657"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Remove(pBlock);</highlight></codeline>
<codeline lineno="12658"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12659"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>else:<sp/>We<sp/>now<sp/>have<sp/>one<sp/>empty<sp/>block<sp/>-<sp/>leave<sp/>it.<sp/>A<sp/>hysteresis<sp/>to<sp/>avoid<sp/>allocating<sp/>whole<sp/>block<sp/>back<sp/>and<sp/>forth.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12660"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12661"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>pBlock<sp/>didn&apos;t<sp/>become<sp/>empty,<sp/>but<sp/>we<sp/>have<sp/>another<sp/>empty<sp/>block<sp/>-<sp/>find<sp/>and<sp/>free<sp/>that<sp/>one.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12662"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>(This<sp/>is<sp/>optional,<sp/>heuristics.)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12663"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(hadEmptyBlockBeforeFree<sp/>&amp;&amp;<sp/>canDeleteBlock)</highlight></codeline>
<codeline lineno="12664"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12665"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/>pLastBlock<sp/>=<sp/>m_Blocks.back();</highlight></codeline>
<codeline lineno="12666"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(pLastBlock-&gt;m_pMetadata-&gt;IsEmpty())</highlight></codeline>
<codeline lineno="12667"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12668"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pBlockToDelete<sp/>=<sp/>pLastBlock;</highlight></codeline>
<codeline lineno="12669"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Blocks.pop_back();</highlight></codeline>
<codeline lineno="12670"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12671"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12672"><highlight class="normal"></highlight></codeline>
<codeline lineno="12673"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IncrementallySortBlocks();</highlight></codeline>
<codeline lineno="12674"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12675"><highlight class="normal"></highlight></codeline>
<codeline lineno="12676"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Destruction<sp/>of<sp/>a<sp/>free<sp/>block.<sp/>Deferred<sp/>until<sp/>this<sp/>point,<sp/>outside<sp/>of<sp/>mutex</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12677"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>lock,<sp/>for<sp/>performance<sp/>reason.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12678"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(pBlockToDelete<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="12679"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12680"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/>Deleted<sp/>empty<sp/>block<sp/>#%u&quot;</highlight><highlight class="normal">,<sp/>pBlockToDelete-&gt;GetId());</highlight></codeline>
<codeline lineno="12681"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pBlockToDelete-&gt;Destroy(m_hAllocator);</highlight></codeline>
<codeline lineno="12682"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vma_delete(m_hAllocator,<sp/>pBlockToDelete);</highlight></codeline>
<codeline lineno="12683"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12684"><highlight class="normal"></highlight></codeline>
<codeline lineno="12685"><highlight class="normal"><sp/><sp/><sp/><sp/>m_hAllocator-&gt;m_Budget.RemoveAllocation(m_hAllocator-&gt;MemoryTypeIndexToHeapIndex(m_MemoryTypeIndex),<sp/>hAllocation-&gt;GetSize());</highlight></codeline>
<codeline lineno="12686"><highlight class="normal"><sp/><sp/><sp/><sp/>m_hAllocator-&gt;m_AllocationObjectAllocator.Free(hAllocation);</highlight></codeline>
<codeline lineno="12687"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12688"><highlight class="normal"></highlight></codeline>
<codeline lineno="12689"><highlight class="normal">VkDeviceSize<sp/>VmaBlockVector::CalcMaxBlockSize()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="12690"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="12691"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>result<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="12692"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>m_Blocks.size();<sp/>i--;<sp/>)</highlight></codeline>
<codeline lineno="12693"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12694"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>VMA_MAX(result,<sp/>m_Blocks[i]-&gt;m_pMetadata-&gt;GetSize());</highlight></codeline>
<codeline lineno="12695"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(result<sp/>&gt;=<sp/>m_PreferredBlockSize)</highlight></codeline>
<codeline lineno="12696"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12697"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="12698"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12699"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12700"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>result;</highlight></codeline>
<codeline lineno="12701"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12702"><highlight class="normal"></highlight></codeline>
<codeline lineno="12703"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockVector::Remove(VmaDeviceMemoryBlock*<sp/>pBlock)</highlight></codeline>
<codeline lineno="12704"><highlight class="normal">{</highlight></codeline>
<codeline lineno="12705"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(uint32_t<sp/>blockIndex<sp/>=<sp/>0;<sp/>blockIndex<sp/>&lt;<sp/>m_Blocks.size();<sp/>++blockIndex)</highlight></codeline>
<codeline lineno="12706"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12707"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_Blocks[blockIndex]<sp/>==<sp/>pBlock)</highlight></codeline>
<codeline lineno="12708"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12709"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaVectorRemove(m_Blocks,<sp/>blockIndex);</highlight></codeline>
<codeline lineno="12710"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="12711"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12712"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12713"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="12714"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12715"><highlight class="normal"></highlight></codeline>
<codeline lineno="12716"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockVector::IncrementallySortBlocks()</highlight></codeline>
<codeline lineno="12717"><highlight class="normal">{</highlight></codeline>
<codeline lineno="12718"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!m_IncrementalSort)</highlight></codeline>
<codeline lineno="12719"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="12720"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_Algorithm<sp/>!=<sp/><ref refid="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726" kindref="member">VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</ref>)</highlight></codeline>
<codeline lineno="12721"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12722"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Bubble<sp/>sort<sp/>only<sp/>until<sp/>first<sp/>swap.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12723"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>1;<sp/>i<sp/>&lt;<sp/>m_Blocks.size();<sp/>++i)</highlight></codeline>
<codeline lineno="12724"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12725"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_Blocks[i<sp/>-<sp/>1]-&gt;m_pMetadata-&gt;GetSumFreeSize()<sp/>&gt;<sp/>m_Blocks[i]-&gt;m_pMetadata-&gt;GetSumFreeSize())</highlight></codeline>
<codeline lineno="12726"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12727"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_SWAP(m_Blocks[i<sp/>-<sp/>1],<sp/>m_Blocks[i]);</highlight></codeline>
<codeline lineno="12728"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="12729"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12730"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12731"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12732"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12733"><highlight class="normal"></highlight></codeline>
<codeline lineno="12734"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockVector::SortByFreeSize()</highlight></codeline>
<codeline lineno="12735"><highlight class="normal">{</highlight></codeline>
<codeline lineno="12736"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_SORT(m_Blocks.begin(),<sp/>m_Blocks.end(),</highlight></codeline>
<codeline lineno="12737"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[](</highlight><highlight class="keyword">auto</highlight><highlight class="normal">*<sp/>b1,<sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">*<sp/>b2)</highlight></codeline>
<codeline lineno="12738"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12739"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>b1-&gt;m_pMetadata-&gt;GetSumFreeSize()<sp/>&lt;<sp/>b2-&gt;m_pMetadata-&gt;GetSumFreeSize();</highlight></codeline>
<codeline lineno="12740"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline lineno="12741"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12742"><highlight class="normal"></highlight></codeline>
<codeline lineno="12743"><highlight class="normal">VkResult<sp/>VmaBlockVector::AllocateFromBlock(</highlight></codeline>
<codeline lineno="12744"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/>pBlock,</highlight></codeline>
<codeline lineno="12745"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size,</highlight></codeline>
<codeline lineno="12746"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>alignment,</highlight></codeline>
<codeline lineno="12747"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ga5225e5e11f8376f6a31a1791f3d6e817" kindref="member">VmaAllocationCreateFlags</ref><sp/>allocFlags,</highlight></codeline>
<codeline lineno="12748"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pUserData,</highlight></codeline>
<codeline lineno="12749"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>suballocType,</highlight></codeline>
<codeline lineno="12750"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>strategy,</highlight></codeline>
<codeline lineno="12751"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>pAllocation)</highlight></codeline>
<codeline lineno="12752"><highlight class="normal">{</highlight></codeline>
<codeline lineno="12753"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isUpperAddress<sp/>=<sp/>(allocFlags<sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a42ba3a2d2c7117953210b7c3ef8da0df" kindref="member">VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT</ref>)<sp/>!=<sp/>0;</highlight></codeline>
<codeline lineno="12754"><highlight class="normal"></highlight></codeline>
<codeline lineno="12755"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocationRequest<sp/>currRequest<sp/>=<sp/>{};</highlight></codeline>
<codeline lineno="12756"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(pBlock-&gt;m_pMetadata-&gt;CreateAllocationRequest(</highlight></codeline>
<codeline lineno="12757"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size,</highlight></codeline>
<codeline lineno="12758"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alignment,</highlight></codeline>
<codeline lineno="12759"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>isUpperAddress,</highlight></codeline>
<codeline lineno="12760"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocType,</highlight></codeline>
<codeline lineno="12761"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>strategy,</highlight></codeline>
<codeline lineno="12762"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;currRequest))</highlight></codeline>
<codeline lineno="12763"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12764"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>CommitAllocationRequest(currRequest,<sp/>pBlock,<sp/>alignment,<sp/>allocFlags,<sp/>pUserData,<sp/>suballocType,<sp/>pAllocation);</highlight></codeline>
<codeline lineno="12765"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12766"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_OUT_OF_DEVICE_MEMORY;</highlight></codeline>
<codeline lineno="12767"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12768"><highlight class="normal"></highlight></codeline>
<codeline lineno="12769"><highlight class="normal">VkResult<sp/>VmaBlockVector::CommitAllocationRequest(</highlight></codeline>
<codeline lineno="12770"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocationRequest&amp;<sp/>allocRequest,</highlight></codeline>
<codeline lineno="12771"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/>pBlock,</highlight></codeline>
<codeline lineno="12772"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>alignment,</highlight></codeline>
<codeline lineno="12773"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ga5225e5e11f8376f6a31a1791f3d6e817" kindref="member">VmaAllocationCreateFlags</ref><sp/>allocFlags,</highlight></codeline>
<codeline lineno="12774"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pUserData,</highlight></codeline>
<codeline lineno="12775"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>suballocType,</highlight></codeline>
<codeline lineno="12776"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>pAllocation)</highlight></codeline>
<codeline lineno="12777"><highlight class="normal">{</highlight></codeline>
<codeline lineno="12778"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>mapped<sp/>=<sp/>(allocFlags<sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" kindref="member">VMA_ALLOCATION_CREATE_MAPPED_BIT</ref>)<sp/>!=<sp/>0;</highlight></codeline>
<codeline lineno="12779"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isUserDataString<sp/>=<sp/>(allocFlags<sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597aa6f24f821cd6a7c5e4a443f7bf59c520" kindref="member">VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</ref>)<sp/>!=<sp/>0;</highlight></codeline>
<codeline lineno="12780"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isMappingAllowed<sp/>=<sp/>(allocFlags<sp/>&amp;</highlight></codeline>
<codeline lineno="12781"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(<ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</ref><sp/>|<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</ref>))<sp/>!=<sp/>0;</highlight></codeline>
<codeline lineno="12782"><highlight class="normal"></highlight></codeline>
<codeline lineno="12783"><highlight class="normal"><sp/><sp/><sp/><sp/>pBlock-&gt;PostAlloc();</highlight></codeline>
<codeline lineno="12784"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Allocate<sp/>from<sp/>pCurrBlock.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12785"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(mapped)</highlight></codeline>
<codeline lineno="12786"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12787"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>pBlock-&gt;Map(m_hAllocator,<sp/>1,<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="12788"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res<sp/>!=<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="12789"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12790"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="12791"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12792"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12793"><highlight class="normal"></highlight></codeline>
<codeline lineno="12794"><highlight class="normal"><sp/><sp/><sp/><sp/>*pAllocation<sp/>=<sp/>m_hAllocator-&gt;m_AllocationObjectAllocator.Allocate(isMappingAllowed);</highlight></codeline>
<codeline lineno="12795"><highlight class="normal"><sp/><sp/><sp/><sp/>pBlock-&gt;m_pMetadata-&gt;Alloc(allocRequest,<sp/>suballocType,<sp/>*pAllocation);</highlight></codeline>
<codeline lineno="12796"><highlight class="normal"><sp/><sp/><sp/><sp/>(*pAllocation)-&gt;InitBlockAllocation(</highlight></codeline>
<codeline lineno="12797"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pBlock,</highlight></codeline>
<codeline lineno="12798"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocRequest.allocHandle,</highlight></codeline>
<codeline lineno="12799"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alignment,</highlight></codeline>
<codeline lineno="12800"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocRequest.size,<sp/></highlight><highlight class="comment">//<sp/>Not<sp/>size,<sp/>as<sp/>actual<sp/>allocation<sp/>size<sp/>may<sp/>be<sp/>larger<sp/>than<sp/>requested!</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12801"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_MemoryTypeIndex,</highlight></codeline>
<codeline lineno="12802"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocType,</highlight></codeline>
<codeline lineno="12803"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mapped);</highlight></codeline>
<codeline lineno="12804"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_HEAVY_ASSERT(pBlock-&gt;Validate());</highlight></codeline>
<codeline lineno="12805"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(isUserDataString)</highlight></codeline>
<codeline lineno="12806"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*pAllocation)-&gt;SetName(m_hAllocator,<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*)pUserData);</highlight></codeline>
<codeline lineno="12807"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12808"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*pAllocation)-&gt;SetUserData(m_hAllocator,<sp/>pUserData);</highlight></codeline>
<codeline lineno="12809"><highlight class="normal"><sp/><sp/><sp/><sp/>m_hAllocator-&gt;m_Budget.AddAllocation(m_hAllocator-&gt;MemoryTypeIndexToHeapIndex(m_MemoryTypeIndex),<sp/>allocRequest.size);</highlight></codeline>
<codeline lineno="12810"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(VMA_DEBUG_INITIALIZE_ALLOCATIONS)</highlight></codeline>
<codeline lineno="12811"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12812"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_hAllocator-&gt;FillAllocation(*pAllocation,<sp/>VMA_ALLOCATION_FILL_PATTERN_CREATED);</highlight></codeline>
<codeline lineno="12813"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12814"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(IsCorruptionDetectionEnabled())</highlight></codeline>
<codeline lineno="12815"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12816"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>pBlock-&gt;WriteMagicValueAfterAllocation(m_hAllocator,<sp/>(*pAllocation)-&gt;GetOffset(),<sp/>allocRequest.size);</highlight></codeline>
<codeline lineno="12817"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(res<sp/>==<sp/>VK_SUCCESS<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Couldn&apos;t<sp/>map<sp/>block<sp/>memory<sp/>to<sp/>write<sp/>magic<sp/>value.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="12818"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12819"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="12820"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12821"><highlight class="normal"></highlight></codeline>
<codeline lineno="12822"><highlight class="normal">VkResult<sp/>VmaBlockVector::CreateBlock(VkDeviceSize<sp/>blockSize,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal">*<sp/>pNewBlockIndex)</highlight></codeline>
<codeline lineno="12823"><highlight class="normal">{</highlight></codeline>
<codeline lineno="12824"><highlight class="normal"><sp/><sp/><sp/><sp/>VkMemoryAllocateInfo<sp/>allocInfo<sp/>=<sp/>{<sp/>VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO<sp/>};</highlight></codeline>
<codeline lineno="12825"><highlight class="normal"><sp/><sp/><sp/><sp/>allocInfo.pNext<sp/>=<sp/>m_pMemoryAllocateNext;</highlight></codeline>
<codeline lineno="12826"><highlight class="normal"><sp/><sp/><sp/><sp/>allocInfo.memoryTypeIndex<sp/>=<sp/>m_MemoryTypeIndex;</highlight></codeline>
<codeline lineno="12827"><highlight class="normal"><sp/><sp/><sp/><sp/>allocInfo.allocationSize<sp/>=<sp/>blockSize;</highlight></codeline>
<codeline lineno="12828"><highlight class="normal"></highlight></codeline>
<codeline lineno="12829"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_BUFFER_DEVICE_ADDRESS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12830"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Every<sp/>standalone<sp/>block<sp/>can<sp/>potentially<sp/>contain<sp/>a<sp/>buffer<sp/>with<sp/>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT<sp/>-<sp/>always<sp/>enable<sp/>the<sp/>feature.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12831"><highlight class="normal"><sp/><sp/><sp/><sp/>VkMemoryAllocateFlagsInfoKHR<sp/>allocFlagsInfo<sp/>=<sp/>{<sp/>VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR<sp/>};</highlight></codeline>
<codeline lineno="12832"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_hAllocator-&gt;m_UseKhrBufferDeviceAddress)</highlight></codeline>
<codeline lineno="12833"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12834"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocFlagsInfo.flags<sp/>=<sp/>VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR;</highlight></codeline>
<codeline lineno="12835"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaPnextChainPushFront(&amp;allocInfo,<sp/>&amp;allocFlagsInfo);</highlight></codeline>
<codeline lineno="12836"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12837"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>VMA_BUFFER_DEVICE_ADDRESS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12838"><highlight class="normal"></highlight></codeline>
<codeline lineno="12839"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_MEMORY_PRIORITY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12840"><highlight class="normal"><sp/><sp/><sp/><sp/>VkMemoryPriorityAllocateInfoEXT<sp/>priorityInfo<sp/>=<sp/>{<sp/>VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT<sp/>};</highlight></codeline>
<codeline lineno="12841"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_hAllocator-&gt;m_UseExtMemoryPriority)</highlight></codeline>
<codeline lineno="12842"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12843"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(m_Priority<sp/>&gt;=<sp/>0.f<sp/>&amp;&amp;<sp/>m_Priority<sp/>&lt;=<sp/>1.f);</highlight></codeline>
<codeline lineno="12844"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>priorityInfo.priority<sp/>=<sp/>m_Priority;</highlight></codeline>
<codeline lineno="12845"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaPnextChainPushFront(&amp;allocInfo,<sp/>&amp;priorityInfo);</highlight></codeline>
<codeline lineno="12846"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12847"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>VMA_MEMORY_PRIORITY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12848"><highlight class="normal"></highlight></codeline>
<codeline lineno="12849"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_EXTERNAL_MEMORY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12850"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Attach<sp/>VkExportMemoryAllocateInfoKHR<sp/>if<sp/>necessary.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12851"><highlight class="normal"><sp/><sp/><sp/><sp/>VkExportMemoryAllocateInfoKHR<sp/>exportMemoryAllocInfo<sp/>=<sp/>{<sp/>VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR<sp/>};</highlight></codeline>
<codeline lineno="12852"><highlight class="normal"><sp/><sp/><sp/><sp/>exportMemoryAllocInfo.handleTypes<sp/>=<sp/>m_hAllocator-&gt;GetExternalMemoryHandleTypeFlags(m_MemoryTypeIndex);</highlight></codeline>
<codeline lineno="12853"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(exportMemoryAllocInfo.handleTypes<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="12854"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12855"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaPnextChainPushFront(&amp;allocInfo,<sp/>&amp;exportMemoryAllocInfo);</highlight></codeline>
<codeline lineno="12856"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12857"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>VMA_EXTERNAL_MEMORY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12858"><highlight class="normal"></highlight></codeline>
<codeline lineno="12859"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceMemory<sp/>mem<sp/>=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="12860"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>m_hAllocator-&gt;AllocateVulkanMemory(&amp;allocInfo,<sp/>&amp;mem);</highlight></codeline>
<codeline lineno="12861"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res<sp/>&lt;<sp/>0)</highlight></codeline>
<codeline lineno="12862"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12863"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="12864"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12865"><highlight class="normal"></highlight></codeline>
<codeline lineno="12866"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>New<sp/>VkDeviceMemory<sp/>successfully<sp/>created.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12867"><highlight class="normal"></highlight></codeline>
<codeline lineno="12868"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>new<sp/>Allocation<sp/>for<sp/>it.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12869"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>pBlock<sp/>=<sp/>vma_new(m_hAllocator,<sp/>VmaDeviceMemoryBlock)(m_hAllocator);</highlight></codeline>
<codeline lineno="12870"><highlight class="normal"><sp/><sp/><sp/><sp/>pBlock-&gt;Init(</highlight></codeline>
<codeline lineno="12871"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_hAllocator,</highlight></codeline>
<codeline lineno="12872"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_hParentPool,</highlight></codeline>
<codeline lineno="12873"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_MemoryTypeIndex,</highlight></codeline>
<codeline lineno="12874"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mem,</highlight></codeline>
<codeline lineno="12875"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocInfo.allocationSize,</highlight></codeline>
<codeline lineno="12876"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_NextBlockId++,</highlight></codeline>
<codeline lineno="12877"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Algorithm,</highlight></codeline>
<codeline lineno="12878"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_BufferImageGranularity);</highlight></codeline>
<codeline lineno="12879"><highlight class="normal"></highlight></codeline>
<codeline lineno="12880"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Blocks.push_back(pBlock);</highlight></codeline>
<codeline lineno="12881"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(pNewBlockIndex<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="12882"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12883"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pNewBlockIndex<sp/>=<sp/>m_Blocks.size()<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="12884"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12885"><highlight class="normal"></highlight></codeline>
<codeline lineno="12886"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="12887"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12888"><highlight class="normal"></highlight></codeline>
<codeline lineno="12889"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaBlockVector::HasEmptyBlock()</highlight></codeline>
<codeline lineno="12890"><highlight class="normal">{</highlight></codeline>
<codeline lineno="12891"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index<sp/>=<sp/>0,<sp/>count<sp/>=<sp/>m_Blocks.size();<sp/>index<sp/>&lt;<sp/>count;<sp/>++index)</highlight></codeline>
<codeline lineno="12892"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12893"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>pBlock<sp/>=<sp/>m_Blocks[index];</highlight></codeline>
<codeline lineno="12894"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(pBlock-&gt;m_pMetadata-&gt;IsEmpty())</highlight></codeline>
<codeline lineno="12895"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12896"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="12897"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12898"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12899"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="12900"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12901"><highlight class="normal"></highlight></codeline>
<codeline lineno="12902"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12903"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaBlockVector::PrintDetailedMap(</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>VmaJsonWriter&amp;<sp/>json)</highlight></codeline>
<codeline lineno="12904"><highlight class="normal">{</highlight></codeline>
<codeline lineno="12905"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaMutexLockRead<sp/>lock(m_Mutex,<sp/>m_hAllocator-&gt;m_UseMutex);</highlight></codeline>
<codeline lineno="12906"><highlight class="normal"></highlight></codeline>
<codeline lineno="12907"><highlight class="normal"></highlight></codeline>
<codeline lineno="12908"><highlight class="normal"><sp/><sp/><sp/><sp/>json.BeginObject();</highlight></codeline>
<codeline lineno="12909"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>m_Blocks.size();<sp/>++i)</highlight></codeline>
<codeline lineno="12910"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12911"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.BeginString();</highlight></codeline>
<codeline lineno="12912"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.ContinueString(m_Blocks[i]-&gt;GetId());</highlight></codeline>
<codeline lineno="12913"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.EndString();</highlight></codeline>
<codeline lineno="12914"><highlight class="normal"></highlight></codeline>
<codeline lineno="12915"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.BeginObject();</highlight></codeline>
<codeline lineno="12916"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;MapRefCount&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="12917"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteNumber(m_Blocks[i]-&gt;GetMapRefCount());</highlight></codeline>
<codeline lineno="12918"><highlight class="normal"></highlight></codeline>
<codeline lineno="12919"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Blocks[i]-&gt;m_pMetadata-&gt;PrintDetailedMap(json);</highlight></codeline>
<codeline lineno="12920"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.EndObject();</highlight></codeline>
<codeline lineno="12921"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12922"><highlight class="normal"><sp/><sp/><sp/><sp/>json.EndObject();</highlight></codeline>
<codeline lineno="12923"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12924"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12925"><highlight class="normal"></highlight></codeline>
<codeline lineno="12926"><highlight class="normal">VkResult<sp/>VmaBlockVector::CheckCorruption()</highlight></codeline>
<codeline lineno="12927"><highlight class="normal">{</highlight></codeline>
<codeline lineno="12928"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!IsCorruptionDetectionEnabled())</highlight></codeline>
<codeline lineno="12929"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12930"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_FEATURE_NOT_PRESENT;</highlight></codeline>
<codeline lineno="12931"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12932"><highlight class="normal"></highlight></codeline>
<codeline lineno="12933"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaMutexLockRead<sp/>lock(m_Mutex,<sp/>m_hAllocator-&gt;m_UseMutex);</highlight></codeline>
<codeline lineno="12934"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(uint32_t<sp/>blockIndex<sp/>=<sp/>0;<sp/>blockIndex<sp/>&lt;<sp/>m_Blocks.size();<sp/>++blockIndex)</highlight></codeline>
<codeline lineno="12935"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12936"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>pBlock<sp/>=<sp/>m_Blocks[blockIndex];</highlight></codeline>
<codeline lineno="12937"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(pBlock);</highlight></codeline>
<codeline lineno="12938"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>pBlock-&gt;CheckCorruption(m_hAllocator);</highlight></codeline>
<codeline lineno="12939"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res<sp/>!=<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="12940"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12941"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="12942"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12943"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12944"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="12945"><highlight class="normal">}</highlight></codeline>
<codeline lineno="12946"><highlight class="normal"></highlight></codeline>
<codeline lineno="12947"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_BLOCK_VECTOR_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12948"><highlight class="normal"></highlight></codeline>
<codeline lineno="12949"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_DEFRAGMENTATION_CONTEXT_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12950"><highlight class="normal">VmaDefragmentationContext_T::VmaDefragmentationContext_T(</highlight></codeline>
<codeline lineno="12951"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,</highlight></codeline>
<codeline lineno="12952"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_defragmentation_info" kindref="compound">VmaDefragmentationInfo</ref>&amp;<sp/>info)</highlight></codeline>
<codeline lineno="12953"><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>m_MaxPassBytes(info.maxBytesPerPass<sp/>==<sp/>0<sp/>?<sp/>VK_WHOLE_SIZE<sp/>:<sp/>info.maxBytesPerPass),</highlight></codeline>
<codeline lineno="12954"><highlight class="normal"><sp/><sp/><sp/><sp/>m_MaxPassAllocations(info.maxAllocationsPerPass<sp/>==<sp/>0<sp/>?<sp/>UINT32_MAX<sp/>:<sp/>info.maxAllocationsPerPass),</highlight></codeline>
<codeline lineno="12955"><highlight class="normal"><sp/><sp/><sp/><sp/>m_MoveAllocator(hAllocator-&gt;GetAllocationCallbacks()),</highlight></codeline>
<codeline lineno="12956"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Moves(m_MoveAllocator)</highlight></codeline>
<codeline lineno="12957"><highlight class="normal">{</highlight></codeline>
<codeline lineno="12958"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Algorithm<sp/>=<sp/>info.<ref refid="struct_vma_defragmentation_info_1a3e23080c978ecf3abb3180f5b2069da7" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50cabcbbdb3bfd53c4c3ab4eaeb5fd4894e9" kindref="member">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_MASK</ref>;</highlight></codeline>
<codeline lineno="12959"><highlight class="normal"></highlight></codeline>
<codeline lineno="12960"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(info.<ref refid="struct_vma_defragmentation_info_1a3302955190e6b5f0d8103698753de949" kindref="member">pool</ref><sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="12961"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12962"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_BlockVectorCount<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="12963"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_PoolBlockVector<sp/>=<sp/>&amp;info.<ref refid="struct_vma_defragmentation_info_1a3302955190e6b5f0d8103698753de949" kindref="member">pool</ref>-&gt;m_BlockVector;</highlight></codeline>
<codeline lineno="12964"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pBlockVectors<sp/>=<sp/>&amp;m_PoolBlockVector;</highlight></codeline>
<codeline lineno="12965"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_PoolBlockVector-&gt;SetIncrementalSort(</highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="12966"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_PoolBlockVector-&gt;SortByFreeSize();</highlight></codeline>
<codeline lineno="12967"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12968"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12969"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12970"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_BlockVectorCount<sp/>=<sp/>hAllocator-&gt;GetMemoryTypeCount();</highlight></codeline>
<codeline lineno="12971"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_PoolBlockVector<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="12972"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pBlockVectors<sp/>=<sp/>hAllocator-&gt;m_pBlockVectors;</highlight></codeline>
<codeline lineno="12973"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(uint32_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>m_BlockVectorCount;<sp/>++i)</highlight></codeline>
<codeline lineno="12974"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12975"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaBlockVector*<sp/>vector<sp/>=<sp/>m_pBlockVectors[i];</highlight></codeline>
<codeline lineno="12976"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(vector<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="12977"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12978"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vector-&gt;SetIncrementalSort(</highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="12979"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vector-&gt;SortByFreeSize();</highlight></codeline>
<codeline lineno="12980"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12981"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12982"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12983"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="12984"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(m_Algorithm)</highlight></codeline>
<codeline lineno="12985"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12986"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>0:<sp/></highlight><highlight class="comment">//<sp/>Default<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12987"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Algorithm<sp/>=<sp/><ref refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50caec35a4138111605a6ff32ca61aa871b6" kindref="member">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT</ref>;</highlight></codeline>
<codeline lineno="12988"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50caec35a4138111605a6ff32ca61aa871b6" kindref="member">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT</ref>:</highlight></codeline>
<codeline lineno="12989"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12990"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_AlgorithmState<sp/>=<sp/>vma_new_array(hAllocator,<sp/>StateBalanced,<sp/>m_BlockVectorCount);</highlight></codeline>
<codeline lineno="12991"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="12992"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12993"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50cae45a9469e5337731627758671741e412" kindref="member">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT</ref>:</highlight></codeline>
<codeline lineno="12994"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12995"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(hAllocator-&gt;GetBufferImageGranularity()<sp/>&gt;<sp/>1)</highlight></codeline>
<codeline lineno="12996"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="12997"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_AlgorithmState<sp/>=<sp/>vma_new_array(hAllocator,<sp/>StateExtensive,<sp/>m_BlockVectorCount);</highlight></codeline>
<codeline lineno="12998"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="12999"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13000"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13001"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13002"><highlight class="normal">}</highlight></codeline>
<codeline lineno="13003"><highlight class="normal"></highlight></codeline>
<codeline lineno="13004"><highlight class="normal">VmaDefragmentationContext_T::~VmaDefragmentationContext_T()</highlight></codeline>
<codeline lineno="13005"><highlight class="normal">{</highlight></codeline>
<codeline lineno="13006"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_PoolBlockVector<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="13007"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13008"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_PoolBlockVector-&gt;SetIncrementalSort(</highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="13009"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13010"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13011"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13012"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(uint32_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>m_BlockVectorCount;<sp/>++i)</highlight></codeline>
<codeline lineno="13013"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13014"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaBlockVector*<sp/>vector<sp/>=<sp/>m_pBlockVectors[i];</highlight></codeline>
<codeline lineno="13015"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(vector<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="13016"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vector-&gt;SetIncrementalSort(</highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="13017"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13018"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13019"><highlight class="normal"></highlight></codeline>
<codeline lineno="13020"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_AlgorithmState)</highlight></codeline>
<codeline lineno="13021"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13022"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(m_Algorithm)</highlight></codeline>
<codeline lineno="13023"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13024"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50caec35a4138111605a6ff32ca61aa871b6" kindref="member">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT</ref>:</highlight></codeline>
<codeline lineno="13025"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vma_delete_array(m_MoveAllocator.m_pCallbacks,<sp/></highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal">StateBalanced*</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(m_AlgorithmState),<sp/>m_BlockVectorCount);</highlight></codeline>
<codeline lineno="13026"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13027"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50cae45a9469e5337731627758671741e412" kindref="member">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT</ref>:</highlight></codeline>
<codeline lineno="13028"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vma_delete_array(m_MoveAllocator.m_pCallbacks,<sp/></highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal">StateExtensive*</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(m_AlgorithmState),<sp/>m_BlockVectorCount);</highlight></codeline>
<codeline lineno="13029"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13030"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="13031"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="13032"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13033"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13034"><highlight class="normal">}</highlight></codeline>
<codeline lineno="13035"><highlight class="normal"></highlight></codeline>
<codeline lineno="13036"><highlight class="normal">VkResult<sp/>VmaDefragmentationContext_T::DefragmentPassBegin(<ref refid="struct_vma_defragmentation_pass_move_info" kindref="compound">VmaDefragmentationPassMoveInfo</ref>&amp;<sp/>moveInfo)</highlight></codeline>
<codeline lineno="13037"><highlight class="normal">{</highlight></codeline>
<codeline lineno="13038"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_PoolBlockVector<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="13039"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13040"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaMutexLockWrite<sp/>lock(m_PoolBlockVector-&gt;GetMutex(),<sp/>m_PoolBlockVector-&gt;GetAllocator()-&gt;m_UseMutex);</highlight></codeline>
<codeline lineno="13041"><highlight class="normal"></highlight></codeline>
<codeline lineno="13042"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_PoolBlockVector-&gt;GetBlockCount()<sp/>&gt;<sp/>1)</highlight></codeline>
<codeline lineno="13043"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ComputeDefragmentation(*m_PoolBlockVector,<sp/>0);</highlight></codeline>
<codeline lineno="13044"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_PoolBlockVector-&gt;GetBlockCount()<sp/>==<sp/>1)</highlight></codeline>
<codeline lineno="13045"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ReallocWithinBlock(*m_PoolBlockVector,<sp/>m_PoolBlockVector-&gt;GetBlock(0));</highlight></codeline>
<codeline lineno="13046"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13047"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13048"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13049"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(uint32_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>m_BlockVectorCount;<sp/>++i)</highlight></codeline>
<codeline lineno="13050"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13051"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_pBlockVectors[i]<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="13052"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13053"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaMutexLockWrite<sp/>lock(m_pBlockVectors[i]-&gt;GetMutex(),<sp/>m_pBlockVectors[i]-&gt;GetAllocator()-&gt;m_UseMutex);</highlight></codeline>
<codeline lineno="13054"><highlight class="normal"></highlight></codeline>
<codeline lineno="13055"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_pBlockVectors[i]-&gt;GetBlockCount()<sp/>&gt;<sp/>1)</highlight></codeline>
<codeline lineno="13056"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13057"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ComputeDefragmentation(*m_pBlockVectors[i],<sp/>i))</highlight></codeline>
<codeline lineno="13058"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13059"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13060"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_pBlockVectors[i]-&gt;GetBlockCount()<sp/>==<sp/>1)</highlight></codeline>
<codeline lineno="13061"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13062"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ReallocWithinBlock(*m_pBlockVectors[i],<sp/>m_pBlockVectors[i]-&gt;GetBlock(0)))</highlight></codeline>
<codeline lineno="13063"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13064"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13065"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13066"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13067"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13068"><highlight class="normal"></highlight></codeline>
<codeline lineno="13069"><highlight class="normal"><sp/><sp/><sp/><sp/>moveInfo.<ref refid="struct_vma_defragmentation_pass_move_info_1a1b3e18c23f9691f35baf183e615c4408" kindref="member">moveCount</ref><sp/>=<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">uint32_t</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(m_Moves.size());</highlight></codeline>
<codeline lineno="13070"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(moveInfo.<ref refid="struct_vma_defragmentation_pass_move_info_1a1b3e18c23f9691f35baf183e615c4408" kindref="member">moveCount</ref><sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="13071"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13072"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>moveInfo.pMoves<sp/>=<sp/>m_Moves.data();</highlight></codeline>
<codeline lineno="13073"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_INCOMPLETE;</highlight></codeline>
<codeline lineno="13074"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13075"><highlight class="normal"></highlight></codeline>
<codeline lineno="13076"><highlight class="normal"><sp/><sp/><sp/><sp/>moveInfo.pMoves<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="13077"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="13078"><highlight class="normal">}</highlight></codeline>
<codeline lineno="13079"><highlight class="normal"></highlight></codeline>
<codeline lineno="13080"><highlight class="normal">VkResult<sp/>VmaDefragmentationContext_T::DefragmentPassEnd(<ref refid="struct_vma_defragmentation_pass_move_info" kindref="compound">VmaDefragmentationPassMoveInfo</ref>&amp;<sp/>moveInfo)</highlight></codeline>
<codeline lineno="13081"><highlight class="normal">{</highlight></codeline>
<codeline lineno="13082"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(moveInfo.<ref refid="struct_vma_defragmentation_pass_move_info_1a1b3e18c23f9691f35baf183e615c4408" kindref="member">moveCount</ref><sp/>&gt;<sp/>0<sp/>?<sp/>moveInfo.pMoves<sp/>!=<sp/>VMA_NULL<sp/>:<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="13083"><highlight class="normal"></highlight></codeline>
<codeline lineno="13084"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>result<sp/>=<sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="13085"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaStlAllocator&lt;FragmentedBlock&gt;<sp/>blockAllocator(m_MoveAllocator.m_pCallbacks);</highlight></codeline>
<codeline lineno="13086"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaVector&lt;FragmentedBlock,<sp/>VmaStlAllocator&lt;FragmentedBlock&gt;&gt;<sp/>immovableBlocks(blockAllocator);</highlight></codeline>
<codeline lineno="13087"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaVector&lt;FragmentedBlock,<sp/>VmaStlAllocator&lt;FragmentedBlock&gt;&gt;<sp/>mappedBlocks(blockAllocator);</highlight></codeline>
<codeline lineno="13088"><highlight class="normal"></highlight></codeline>
<codeline lineno="13089"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref><sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="13090"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(uint32_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>moveInfo.<ref refid="struct_vma_defragmentation_pass_move_info_1a1b3e18c23f9691f35baf183e615c4408" kindref="member">moveCount</ref>;<sp/>++i)</highlight></codeline>
<codeline lineno="13091"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13092"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_defragmentation_move" kindref="compound">VmaDefragmentationMove</ref>&amp;<sp/>move<sp/>=<sp/>moveInfo.pMoves[i];</highlight></codeline>
<codeline lineno="13093"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>prevCount<sp/>=<sp/>0,<sp/>currentCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="13094"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>freedBlockSize<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="13095"><highlight class="normal"></highlight></codeline>
<codeline lineno="13096"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>vectorIndex;</highlight></codeline>
<codeline lineno="13097"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaBlockVector*<sp/>vector;</highlight></codeline>
<codeline lineno="13098"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_PoolBlockVector<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="13099"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13100"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vectorIndex<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="13101"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vector<sp/>=<sp/>m_PoolBlockVector;</highlight></codeline>
<codeline lineno="13102"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13105"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vectorIndex<sp/>=<sp/>move.<ref refid="struct_vma_defragmentation_move_1a51c1ff05d7c1290499c4af2ffe238df5" kindref="member">srcAllocation</ref>-&gt;GetMemoryTypeIndex();</highlight></codeline>
<codeline lineno="13106"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vector<sp/>=<sp/>m_pBlockVectors[vectorIndex];</highlight></codeline>
<codeline lineno="13107"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(vector<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="13108"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13109"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="13110"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(move.<ref refid="struct_vma_defragmentation_move_1a20996a4686c9246dff77b375ac4a91e2" kindref="member">operation</ref>)</highlight></codeline>
<codeline lineno="13111"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13112"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1ggada9e3861caf96f08894b0bcc160ec257ad4a06ac46c4cb1c67b0ebc1edfab9f18" kindref="member">VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY</ref>:</highlight></codeline>
<codeline lineno="13113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13114"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint8_t<sp/>mapCount<sp/>=<sp/>move.<ref refid="struct_vma_defragmentation_move_1a51c1ff05d7c1290499c4af2ffe238df5" kindref="member">srcAllocation</ref>-&gt;SwapBlockAllocation(vector-&gt;m_hAllocator,<sp/>move.<ref refid="struct_vma_defragmentation_move_1a4568ef03127bffa6000fe811205aeda4" kindref="member">dstTmpAllocation</ref>);</highlight></codeline>
<codeline lineno="13115"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(mapCount<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="13116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref><sp/>=<sp/>vector-&gt;m_hAllocator;</highlight></codeline>
<codeline lineno="13118"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/>newMapBlock<sp/>=<sp/>move.<ref refid="struct_vma_defragmentation_move_1a51c1ff05d7c1290499c4af2ffe238df5" kindref="member">srcAllocation</ref>-&gt;GetBlock();</highlight></codeline>
<codeline lineno="13119"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>notPresent<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13120"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(FragmentedBlock&amp;<sp/>block<sp/>:<sp/>mappedBlocks)</highlight></codeline>
<codeline lineno="13121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(block.block<sp/>==<sp/>newMapBlock)</highlight></codeline>
<codeline lineno="13123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13124"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>notPresent<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block.data<sp/>+=<sp/>mapCount;</highlight></codeline>
<codeline lineno="13126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13127"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13128"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13129"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(notPresent)</highlight></codeline>
<codeline lineno="13130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mappedBlocks.push_back({<sp/>mapCount,<sp/>newMapBlock<sp/>});</highlight></codeline>
<codeline lineno="13131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13132"><highlight class="normal"></highlight></codeline>
<codeline lineno="13133"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Scope<sp/>for<sp/>locks,<sp/>Free<sp/>have<sp/>it&apos;s<sp/>own<sp/>lock</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13134"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13135"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaMutexLockRead<sp/>lock(vector-&gt;GetMutex(),<sp/>vector-&gt;GetAllocator()-&gt;m_UseMutex);</highlight></codeline>
<codeline lineno="13136"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prevCount<sp/>=<sp/>vector-&gt;GetBlockCount();</highlight></codeline>
<codeline lineno="13137"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>freedBlockSize<sp/>=<sp/>move.<ref refid="struct_vma_defragmentation_move_1a4568ef03127bffa6000fe811205aeda4" kindref="member">dstTmpAllocation</ref>-&gt;GetBlock()-&gt;m_pMetadata-&gt;GetSize();</highlight></codeline>
<codeline lineno="13138"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13139"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vector-&gt;Free(move.<ref refid="struct_vma_defragmentation_move_1a4568ef03127bffa6000fe811205aeda4" kindref="member">dstTmpAllocation</ref>);</highlight></codeline>
<codeline lineno="13140"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13141"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaMutexLockRead<sp/>lock(vector-&gt;GetMutex(),<sp/>vector-&gt;GetAllocator()-&gt;m_UseMutex);</highlight></codeline>
<codeline lineno="13142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>currentCount<sp/>=<sp/>vector-&gt;GetBlockCount();</highlight></codeline>
<codeline lineno="13143"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13144"><highlight class="normal"></highlight></codeline>
<codeline lineno="13145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>VK_INCOMPLETE;</highlight></codeline>
<codeline lineno="13146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1ggada9e3861caf96f08894b0bcc160ec257ad25bc6f816b226b4fd5170e845f218d2" kindref="member">VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE</ref>:</highlight></codeline>
<codeline lineno="13149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13150"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_PassStats.bytesMoved<sp/>-=<sp/>move.<ref refid="struct_vma_defragmentation_move_1a51c1ff05d7c1290499c4af2ffe238df5" kindref="member">srcAllocation</ref>-&gt;GetSize();</highlight></codeline>
<codeline lineno="13151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--m_PassStats.allocationsMoved;</highlight></codeline>
<codeline lineno="13152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vector-&gt;Free(move.<ref refid="struct_vma_defragmentation_move_1a4568ef03127bffa6000fe811205aeda4" kindref="member">dstTmpAllocation</ref>);</highlight></codeline>
<codeline lineno="13153"><highlight class="normal"></highlight></codeline>
<codeline lineno="13154"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/>newBlock<sp/>=<sp/>move.<ref refid="struct_vma_defragmentation_move_1a51c1ff05d7c1290499c4af2ffe238df5" kindref="member">srcAllocation</ref>-&gt;GetBlock();</highlight></codeline>
<codeline lineno="13155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>notPresent<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13156"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FragmentedBlock&amp;<sp/>block<sp/>:<sp/>immovableBlocks)</highlight></codeline>
<codeline lineno="13157"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(block.block<sp/>==<sp/>newBlock)</highlight></codeline>
<codeline lineno="13159"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13160"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>notPresent<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13161"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13162"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13163"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13164"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(notPresent)</highlight></codeline>
<codeline lineno="13165"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>immovableBlocks.push_back({<sp/>vectorIndex,<sp/>newBlock<sp/>});</highlight></codeline>
<codeline lineno="13166"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13168"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1ggada9e3861caf96f08894b0bcc160ec257a9786f8492a9be2c03bd26395e352ab85" kindref="member">VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY</ref>:</highlight></codeline>
<codeline lineno="13169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13170"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_PassStats.bytesMoved<sp/>-=<sp/>move.<ref refid="struct_vma_defragmentation_move_1a51c1ff05d7c1290499c4af2ffe238df5" kindref="member">srcAllocation</ref>-&gt;GetSize();</highlight></codeline>
<codeline lineno="13171"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--m_PassStats.allocationsMoved;</highlight></codeline>
<codeline lineno="13172"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Scope<sp/>for<sp/>locks,<sp/>Free<sp/>have<sp/>it&apos;s<sp/>own<sp/>lock</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13174"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaMutexLockRead<sp/>lock(vector-&gt;GetMutex(),<sp/>vector-&gt;GetAllocator()-&gt;m_UseMutex);</highlight></codeline>
<codeline lineno="13175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prevCount<sp/>=<sp/>vector-&gt;GetBlockCount();</highlight></codeline>
<codeline lineno="13176"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>freedBlockSize<sp/>=<sp/>move.<ref refid="struct_vma_defragmentation_move_1a51c1ff05d7c1290499c4af2ffe238df5" kindref="member">srcAllocation</ref>-&gt;GetBlock()-&gt;m_pMetadata-&gt;GetSize();</highlight></codeline>
<codeline lineno="13177"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13178"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vector-&gt;Free(move.<ref refid="struct_vma_defragmentation_move_1a51c1ff05d7c1290499c4af2ffe238df5" kindref="member">srcAllocation</ref>);</highlight></codeline>
<codeline lineno="13179"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaMutexLockRead<sp/>lock(vector-&gt;GetMutex(),<sp/>vector-&gt;GetAllocator()-&gt;m_UseMutex);</highlight></codeline>
<codeline lineno="13181"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>currentCount<sp/>=<sp/>vector-&gt;GetBlockCount();</highlight></codeline>
<codeline lineno="13182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>freedBlockSize<sp/>*=<sp/>prevCount<sp/>-<sp/>currentCount;</highlight></codeline>
<codeline lineno="13184"><highlight class="normal"></highlight></codeline>
<codeline lineno="13185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>dstBlockSize;</highlight></codeline>
<codeline lineno="13186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13187"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaMutexLockRead<sp/>lock(vector-&gt;GetMutex(),<sp/>vector-&gt;GetAllocator()-&gt;m_UseMutex);</highlight></codeline>
<codeline lineno="13188"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dstBlockSize<sp/>=<sp/>move.<ref refid="struct_vma_defragmentation_move_1a4568ef03127bffa6000fe811205aeda4" kindref="member">dstTmpAllocation</ref>-&gt;GetBlock()-&gt;m_pMetadata-&gt;GetSize();</highlight></codeline>
<codeline lineno="13189"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13190"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vector-&gt;Free(move.<ref refid="struct_vma_defragmentation_move_1a4568ef03127bffa6000fe811205aeda4" kindref="member">dstTmpAllocation</ref>);</highlight></codeline>
<codeline lineno="13191"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaMutexLockRead<sp/>lock(vector-&gt;GetMutex(),<sp/>vector-&gt;GetAllocator()-&gt;m_UseMutex);</highlight></codeline>
<codeline lineno="13193"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>freedBlockSize<sp/>+=<sp/>dstBlockSize<sp/>*<sp/>(currentCount<sp/>-<sp/>vector-&gt;GetBlockCount());</highlight></codeline>
<codeline lineno="13194"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>currentCount<sp/>=<sp/>vector-&gt;GetBlockCount();</highlight></codeline>
<codeline lineno="13195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13196"><highlight class="normal"></highlight></codeline>
<codeline lineno="13197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>VK_INCOMPLETE;</highlight></codeline>
<codeline lineno="13198"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="13201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="13202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13203"><highlight class="normal"></highlight></codeline>
<codeline lineno="13204"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(prevCount<sp/>&gt;<sp/>currentCount)</highlight></codeline>
<codeline lineno="13205"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13206"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>freedBlocks<sp/>=<sp/>prevCount<sp/>-<sp/>currentCount;</highlight></codeline>
<codeline lineno="13207"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_PassStats.deviceMemoryBlocksFreed<sp/>+=<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">uint32_t</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(freedBlocks);</highlight></codeline>
<codeline lineno="13208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_PassStats.bytesFreed<sp/>+=<sp/>freedBlockSize;</highlight></codeline>
<codeline lineno="13209"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13210"><highlight class="normal"></highlight></codeline>
<codeline lineno="13211"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(m_Algorithm)</highlight></codeline>
<codeline lineno="13212"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13213"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50cae45a9469e5337731627758671741e412" kindref="member">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT</ref>:</highlight></codeline>
<codeline lineno="13214"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13215"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_AlgorithmState<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="13216"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13217"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Avoid<sp/>unnecessary<sp/>tries<sp/>to<sp/>allocate<sp/>when<sp/>new<sp/>free<sp/>block<sp/>is<sp/>avaiable</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13218"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>StateExtensive&amp;<sp/>state<sp/>=<sp/></highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal">StateExtensive*</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(m_AlgorithmState)[vectorIndex];</highlight></codeline>
<codeline lineno="13219"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(state.firstFreeBlock<sp/>!=<sp/>SIZE_MAX)</highlight></codeline>
<codeline lineno="13220"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13221"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>diff<sp/>=<sp/>prevCount<sp/>-<sp/>currentCount;</highlight></codeline>
<codeline lineno="13222"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(state.firstFreeBlock<sp/>&gt;=<sp/>diff)</highlight></codeline>
<codeline lineno="13223"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13224"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>state.firstFreeBlock<sp/>-=<sp/>diff;</highlight></codeline>
<codeline lineno="13225"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(state.firstFreeBlock<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="13226"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>state.firstFreeBlock<sp/>-=<sp/>vector-&gt;GetBlock(state.firstFreeBlock<sp/>-<sp/>1)-&gt;m_pMetadata-&gt;IsEmpty();</highlight></codeline>
<codeline lineno="13227"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13228"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13229"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>state.firstFreeBlock<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="13230"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13231"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13232"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13233"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13234"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13235"><highlight class="normal"><sp/><sp/><sp/><sp/>moveInfo.<ref refid="struct_vma_defragmentation_pass_move_info_1a1b3e18c23f9691f35baf183e615c4408" kindref="member">moveCount</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="13236"><highlight class="normal"><sp/><sp/><sp/><sp/>moveInfo.pMoves<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="13237"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Moves.clear();</highlight></codeline>
<codeline lineno="13238"><highlight class="normal"></highlight></codeline>
<codeline lineno="13239"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Update<sp/>stats</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13240"><highlight class="normal"><sp/><sp/><sp/><sp/>m_GlobalStats.allocationsMoved<sp/>+=<sp/>m_PassStats.allocationsMoved;</highlight></codeline>
<codeline lineno="13241"><highlight class="normal"><sp/><sp/><sp/><sp/>m_GlobalStats.bytesFreed<sp/>+=<sp/>m_PassStats.bytesFreed;</highlight></codeline>
<codeline lineno="13242"><highlight class="normal"><sp/><sp/><sp/><sp/>m_GlobalStats.bytesMoved<sp/>+=<sp/>m_PassStats.bytesMoved;</highlight></codeline>
<codeline lineno="13243"><highlight class="normal"><sp/><sp/><sp/><sp/>m_GlobalStats.deviceMemoryBlocksFreed<sp/>+=<sp/>m_PassStats.deviceMemoryBlocksFreed;</highlight></codeline>
<codeline lineno="13244"><highlight class="normal"><sp/><sp/><sp/><sp/>m_PassStats<sp/>=<sp/>{<sp/>0<sp/>};</highlight></codeline>
<codeline lineno="13245"><highlight class="normal"></highlight></codeline>
<codeline lineno="13246"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Move<sp/>blocks<sp/>with<sp/>immovable<sp/>allocations<sp/>according<sp/>to<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13247"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(immovableBlocks.size()<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="13248"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13249"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(m_Algorithm)</highlight></codeline>
<codeline lineno="13250"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13251"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50cae45a9469e5337731627758671741e412" kindref="member">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT</ref>:</highlight></codeline>
<codeline lineno="13252"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13253"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_AlgorithmState<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="13254"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13255"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>swapped<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13256"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Move<sp/>to<sp/>the<sp/>start<sp/>of<sp/>free<sp/>blocks<sp/>range</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13257"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FragmentedBlock&amp;<sp/>block<sp/>:<sp/>immovableBlocks)</highlight></codeline>
<codeline lineno="13258"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13259"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>StateExtensive&amp;<sp/>state<sp/>=<sp/></highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal">StateExtensive*</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(m_AlgorithmState)[block.data];</highlight></codeline>
<codeline lineno="13260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(state.operation<sp/>!=<sp/>StateExtensive::Operation::Cleanup)</highlight></codeline>
<codeline lineno="13261"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13262"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaBlockVector*<sp/>vector<sp/>=<sp/>m_pBlockVectors[block.data];</highlight></codeline>
<codeline lineno="13263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaMutexLockWrite<sp/>lock(vector-&gt;GetMutex(),<sp/>vector-&gt;GetAllocator()-&gt;m_UseMutex);</highlight></codeline>
<codeline lineno="13264"><highlight class="normal"></highlight></codeline>
<codeline lineno="13265"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0,<sp/>count<sp/>=<sp/>vector-&gt;GetBlockCount()<sp/>-<sp/>m_ImmovableBlockCount;<sp/>i<sp/>&lt;<sp/>count;<sp/>++i)</highlight></codeline>
<codeline lineno="13266"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13267"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(vector-&gt;GetBlock(i)<sp/>==<sp/>block.block)</highlight></codeline>
<codeline lineno="13268"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13269"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_SWAP(vector-&gt;m_Blocks[i],<sp/>vector-&gt;m_Blocks[vector-&gt;GetBlockCount()<sp/>-<sp/>++m_ImmovableBlockCount]);</highlight></codeline>
<codeline lineno="13270"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(state.firstFreeBlock<sp/>!=<sp/>SIZE_MAX)</highlight></codeline>
<codeline lineno="13271"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13272"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(i<sp/>&lt;<sp/>state.firstFreeBlock<sp/>-<sp/>1)</highlight></codeline>
<codeline lineno="13273"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13274"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(state.firstFreeBlock<sp/>&gt;<sp/>1)</highlight></codeline>
<codeline lineno="13275"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_SWAP(vector-&gt;m_Blocks[i],<sp/>vector-&gt;m_Blocks[--state.firstFreeBlock]);</highlight></codeline>
<codeline lineno="13276"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13277"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--state.firstFreeBlock;</highlight></codeline>
<codeline lineno="13278"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13279"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13280"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>swapped<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13281"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13282"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13283"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13284"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13285"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13286"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(swapped)</highlight></codeline>
<codeline lineno="13287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>VK_INCOMPLETE;</highlight></codeline>
<codeline lineno="13288"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13289"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13290"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13291"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="13292"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13293"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Move<sp/>to<sp/>the<sp/>begining</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13294"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FragmentedBlock&amp;<sp/>block<sp/>:<sp/>immovableBlocks)</highlight></codeline>
<codeline lineno="13295"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13296"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaBlockVector*<sp/>vector<sp/>=<sp/>m_pBlockVectors[block.data];</highlight></codeline>
<codeline lineno="13297"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaMutexLockWrite<sp/>lock(vector-&gt;GetMutex(),<sp/>vector-&gt;GetAllocator()-&gt;m_UseMutex);</highlight></codeline>
<codeline lineno="13298"><highlight class="normal"></highlight></codeline>
<codeline lineno="13299"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>m_ImmovableBlockCount;<sp/>i<sp/>&lt;<sp/>vector-&gt;GetBlockCount();<sp/>++i)</highlight></codeline>
<codeline lineno="13300"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13301"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(vector-&gt;GetBlock(i)<sp/>==<sp/>block.block)</highlight></codeline>
<codeline lineno="13302"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13303"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_SWAP(vector-&gt;m_Blocks[i],<sp/>vector-&gt;m_Blocks[m_ImmovableBlockCount++]);</highlight></codeline>
<codeline lineno="13304"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13305"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13306"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13307"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13308"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13309"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13310"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13311"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13312"><highlight class="normal"></highlight></codeline>
<codeline lineno="13313"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Bulk-map<sp/>destination<sp/>blocks</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13314"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FragmentedBlock&amp;<sp/>block<sp/>:<sp/>mappedBlocks)</highlight></codeline>
<codeline lineno="13315"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13316"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>block.block-&gt;Map(allocator,<sp/>block.data,<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="13317"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(res<sp/>==<sp/>VK_SUCCESS);</highlight></codeline>
<codeline lineno="13318"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13319"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>result;</highlight></codeline>
<codeline lineno="13320"><highlight class="normal">}</highlight></codeline>
<codeline lineno="13321"><highlight class="normal"></highlight></codeline>
<codeline lineno="13322"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaDefragmentationContext_T::ComputeDefragmentation(VmaBlockVector&amp;<sp/>vector,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index)</highlight></codeline>
<codeline lineno="13323"><highlight class="normal">{</highlight></codeline>
<codeline lineno="13324"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(m_Algorithm)</highlight></codeline>
<codeline lineno="13325"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13326"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50ca2e6469bcf5a094776ceb5d118263f04b" kindref="member">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT</ref>:</highlight></codeline>
<codeline lineno="13327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ComputeDefragmentation_Fast(vector);</highlight></codeline>
<codeline lineno="13328"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="13329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="13330"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50caec35a4138111605a6ff32ca61aa871b6" kindref="member">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT</ref>:</highlight></codeline>
<codeline lineno="13331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ComputeDefragmentation_Balanced(vector,<sp/>index,<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="13332"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50cafa162eac5be800bcdd4011427a71156d" kindref="member">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT</ref>:</highlight></codeline>
<codeline lineno="13333"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ComputeDefragmentation_Full(vector);</highlight></codeline>
<codeline lineno="13334"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50cae45a9469e5337731627758671741e412" kindref="member">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT</ref>:</highlight></codeline>
<codeline lineno="13335"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ComputeDefragmentation_Extensive(vector,<sp/>index);</highlight></codeline>
<codeline lineno="13336"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13337"><highlight class="normal">}</highlight></codeline>
<codeline lineno="13338"><highlight class="normal"></highlight></codeline>
<codeline lineno="13339"><highlight class="normal">VmaDefragmentationContext_T::MoveAllocationData<sp/>VmaDefragmentationContext_T::GetMoveData(</highlight></codeline>
<codeline lineno="13340"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaAllocHandle<sp/>handle,<sp/>VmaBlockMetadata*<sp/>metadata)</highlight></codeline>
<codeline lineno="13341"><highlight class="normal">{</highlight></codeline>
<codeline lineno="13342"><highlight class="normal"><sp/><sp/><sp/><sp/>MoveAllocationData<sp/>moveData;</highlight></codeline>
<codeline lineno="13343"><highlight class="normal"><sp/><sp/><sp/><sp/>moveData.move.srcAllocation<sp/>=<sp/>(<ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>)metadata-&gt;GetAllocationUserData(handle);</highlight></codeline>
<codeline lineno="13344"><highlight class="normal"><sp/><sp/><sp/><sp/>moveData.size<sp/>=<sp/>moveData.move.srcAllocation-&gt;GetSize();</highlight></codeline>
<codeline lineno="13345"><highlight class="normal"><sp/><sp/><sp/><sp/>moveData.alignment<sp/>=<sp/>moveData.move.srcAllocation-&gt;GetAlignment();</highlight></codeline>
<codeline lineno="13346"><highlight class="normal"><sp/><sp/><sp/><sp/>moveData.type<sp/>=<sp/>moveData.move.srcAllocation-&gt;GetSuballocationType();</highlight></codeline>
<codeline lineno="13347"><highlight class="normal"><sp/><sp/><sp/><sp/>moveData.flags<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="13348"><highlight class="normal"></highlight></codeline>
<codeline lineno="13349"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(moveData.move.srcAllocation-&gt;IsPersistentMap())</highlight></codeline>
<codeline lineno="13350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>moveData.flags<sp/>|=<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" kindref="member">VMA_ALLOCATION_CREATE_MAPPED_BIT</ref>;</highlight></codeline>
<codeline lineno="13351"><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(moveData.move.srcAllocation-&gt;IsMappingAllowed())</highlight></codeline>
<codeline lineno="13352"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>moveData.flags<sp/>|=<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</ref><sp/>|<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</ref>;</highlight></codeline>
<codeline lineno="13353"><highlight class="normal"></highlight></codeline>
<codeline lineno="13354"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>moveData;</highlight></codeline>
<codeline lineno="13355"><highlight class="normal">}</highlight></codeline>
<codeline lineno="13356"><highlight class="normal"></highlight></codeline>
<codeline lineno="13357"><highlight class="normal">VmaDefragmentationContext_T::CounterStatus<sp/>VmaDefragmentationContext_T::CheckCounters(VkDeviceSize<sp/>bytes)</highlight></codeline>
<codeline lineno="13358"><highlight class="normal">{</highlight></codeline>
<codeline lineno="13359"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Ignore<sp/>allocation<sp/>if<sp/>will<sp/>exceed<sp/>max<sp/>size<sp/>for<sp/>copy</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13360"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(m_PassStats.bytesMoved<sp/>+<sp/>bytes<sp/>&gt;<sp/>m_MaxPassBytes)</highlight></codeline>
<codeline lineno="13361"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13362"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(++m_IgnoredAllocs<sp/>&lt;<sp/>MAX_ALLOCS_TO_IGNORE)</highlight></codeline>
<codeline lineno="13363"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>CounterStatus::Ignore;</highlight></codeline>
<codeline lineno="13364"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13365"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>CounterStatus::End;</highlight></codeline>
<codeline lineno="13366"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13367"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>CounterStatus::Pass;</highlight></codeline>
<codeline lineno="13368"><highlight class="normal">}</highlight></codeline>
<codeline lineno="13369"><highlight class="normal"></highlight></codeline>
<codeline lineno="13370"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaDefragmentationContext_T::IncrementCounters(VkDeviceSize<sp/>bytes)</highlight></codeline>
<codeline lineno="13371"><highlight class="normal">{</highlight></codeline>
<codeline lineno="13372"><highlight class="normal"><sp/><sp/><sp/><sp/>m_PassStats.bytesMoved<sp/>+=<sp/>bytes;</highlight></codeline>
<codeline lineno="13373"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Early<sp/>return<sp/>when<sp/>max<sp/>found</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13374"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(++m_PassStats.allocationsMoved<sp/>&gt;=<sp/>m_MaxPassAllocations<sp/>||<sp/>m_PassStats.bytesMoved<sp/>&gt;=<sp/>m_MaxPassBytes)</highlight></codeline>
<codeline lineno="13375"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13376"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(m_PassStats.allocationsMoved<sp/>==<sp/>m_MaxPassAllocations<sp/>||</highlight></codeline>
<codeline lineno="13377"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_PassStats.bytesMoved<sp/>==<sp/>m_MaxPassBytes<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Exceeded<sp/>maximal<sp/>pass<sp/>threshold!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="13378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13379"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13380"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13381"><highlight class="normal">}</highlight></codeline>
<codeline lineno="13382"><highlight class="normal"></highlight></codeline>
<codeline lineno="13383"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaDefragmentationContext_T::ReallocWithinBlock(VmaBlockVector&amp;<sp/>vector,<sp/>VmaDeviceMemoryBlock*<sp/>block)</highlight></codeline>
<codeline lineno="13384"><highlight class="normal">{</highlight></codeline>
<codeline lineno="13385"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaBlockMetadata*<sp/>metadata<sp/>=<sp/>block-&gt;m_pMetadata;</highlight></codeline>
<codeline lineno="13386"><highlight class="normal"></highlight></codeline>
<codeline lineno="13387"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(VmaAllocHandle<sp/>handle<sp/>=<sp/>metadata-&gt;GetAllocationListBegin();</highlight></codeline>
<codeline lineno="13388"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>handle<sp/>!=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="13389"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>handle<sp/>=<sp/>metadata-&gt;GetNextAllocation(handle))</highlight></codeline>
<codeline lineno="13390"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13391"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MoveAllocationData<sp/>moveData<sp/>=<sp/>GetMoveData(handle,<sp/>metadata);</highlight></codeline>
<codeline lineno="13392"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Ignore<sp/>newly<sp/>created<sp/>allocations<sp/>by<sp/>defragmentation<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13393"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(moveData.move.srcAllocation-&gt;GetUserData()<sp/>==<sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="13394"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13395"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(CheckCounters(moveData.move.srcAllocation-&gt;GetSize()))</highlight></codeline>
<codeline lineno="13396"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13397"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>CounterStatus::Ignore:</highlight></codeline>
<codeline lineno="13398"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13399"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>CounterStatus::End:</highlight></codeline>
<codeline lineno="13400"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13401"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="13402"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="13403"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>CounterStatus::Pass:</highlight></codeline>
<codeline lineno="13404"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13405"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13406"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="13407"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>offset<sp/>=<sp/>moveData.move.srcAllocation-&gt;GetOffset();</highlight></codeline>
<codeline lineno="13408"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(offset<sp/>!=<sp/>0<sp/>&amp;&amp;<sp/>metadata-&gt;GetSumFreeSize()<sp/>&gt;=<sp/>moveData.size)</highlight></codeline>
<codeline lineno="13409"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13410"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAllocationRequest<sp/>request<sp/>=<sp/>{};</highlight></codeline>
<codeline lineno="13411"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(metadata-&gt;CreateAllocationRequest(</highlight></codeline>
<codeline lineno="13412"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>moveData.size,</highlight></codeline>
<codeline lineno="13413"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>moveData.alignment,</highlight></codeline>
<codeline lineno="13414"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="13415"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>moveData.type,</highlight></codeline>
<codeline lineno="13416"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8099acedc0d04cdccaaddcfe37fd227d" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</ref>,</highlight></codeline>
<codeline lineno="13417"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;request))</highlight></codeline>
<codeline lineno="13418"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13419"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(metadata-&gt;GetAllocationOffset(request.allocHandle)<sp/>&lt;<sp/>offset)</highlight></codeline>
<codeline lineno="13420"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13421"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(vector.CommitAllocationRequest(</highlight></codeline>
<codeline lineno="13422"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>request,</highlight></codeline>
<codeline lineno="13423"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block,</highlight></codeline>
<codeline lineno="13424"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>moveData.alignment,</highlight></codeline>
<codeline lineno="13425"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>moveData.flags,</highlight></codeline>
<codeline lineno="13426"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="13427"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>moveData.type,</highlight></codeline>
<codeline lineno="13428"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;moveData.move.dstTmpAllocation)<sp/>==<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="13429"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13430"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Moves.push_back(moveData.move);</highlight></codeline>
<codeline lineno="13431"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(IncrementCounters(moveData.size))</highlight></codeline>
<codeline lineno="13432"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13433"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13434"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13435"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13436"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13437"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13438"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13439"><highlight class="normal">}</highlight></codeline>
<codeline lineno="13440"><highlight class="normal"></highlight></codeline>
<codeline lineno="13441"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaDefragmentationContext_T::AllocInOtherBlock(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>start,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>end,<sp/>MoveAllocationData&amp;<sp/>data,<sp/>VmaBlockVector&amp;<sp/>vector)</highlight></codeline>
<codeline lineno="13442"><highlight class="normal">{</highlight></codeline>
<codeline lineno="13443"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(;<sp/>start<sp/>&lt;<sp/>end;<sp/>++start)</highlight></codeline>
<codeline lineno="13444"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13445"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/>dstBlock<sp/>=<sp/>vector.GetBlock(start);</highlight></codeline>
<codeline lineno="13446"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(dstBlock-&gt;m_pMetadata-&gt;GetSumFreeSize()<sp/>&gt;=<sp/>data.size)</highlight></codeline>
<codeline lineno="13447"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13448"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(vector.AllocateFromBlock(dstBlock,</highlight></codeline>
<codeline lineno="13449"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data.size,</highlight></codeline>
<codeline lineno="13450"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data.alignment,</highlight></codeline>
<codeline lineno="13451"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data.flags,</highlight></codeline>
<codeline lineno="13452"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="13453"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data.type,</highlight></codeline>
<codeline lineno="13454"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,</highlight></codeline>
<codeline lineno="13455"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;data.move.dstTmpAllocation)<sp/>==<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="13456"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13457"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Moves.push_back(data.move);</highlight></codeline>
<codeline lineno="13458"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(IncrementCounters(data.size))</highlight></codeline>
<codeline lineno="13459"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13460"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13462"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13463"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13464"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13465"><highlight class="normal">}</highlight></codeline>
<codeline lineno="13466"><highlight class="normal"></highlight></codeline>
<codeline lineno="13467"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaDefragmentationContext_T::ComputeDefragmentation_Fast(VmaBlockVector&amp;<sp/>vector)</highlight></codeline>
<codeline lineno="13468"><highlight class="normal">{</highlight></codeline>
<codeline lineno="13469"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Move<sp/>only<sp/>between<sp/>blocks</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13470"><highlight class="normal"></highlight></codeline>
<codeline lineno="13471"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>through<sp/>allocations<sp/>in<sp/>last<sp/>blocks<sp/>and<sp/>try<sp/>to<sp/>fit<sp/>them<sp/>inside<sp/>first<sp/>ones</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13472"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>vector.GetBlockCount()<sp/>-<sp/>1;<sp/>i<sp/>&gt;<sp/>m_ImmovableBlockCount;<sp/>--i)</highlight></codeline>
<codeline lineno="13473"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13474"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaBlockMetadata*<sp/>metadata<sp/>=<sp/>vector.GetBlock(i)-&gt;m_pMetadata;</highlight></codeline>
<codeline lineno="13475"><highlight class="normal"></highlight></codeline>
<codeline lineno="13476"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(VmaAllocHandle<sp/>handle<sp/>=<sp/>metadata-&gt;GetAllocationListBegin();</highlight></codeline>
<codeline lineno="13477"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>handle<sp/>!=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="13478"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>handle<sp/>=<sp/>metadata-&gt;GetNextAllocation(handle))</highlight></codeline>
<codeline lineno="13479"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13480"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MoveAllocationData<sp/>moveData<sp/>=<sp/>GetMoveData(handle,<sp/>metadata);</highlight></codeline>
<codeline lineno="13481"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Ignore<sp/>newly<sp/>created<sp/>allocations<sp/>by<sp/>defragmentation<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13482"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(moveData.move.srcAllocation-&gt;GetUserData()<sp/>==<sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="13483"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13484"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(CheckCounters(moveData.move.srcAllocation-&gt;GetSize()))</highlight></codeline>
<codeline lineno="13485"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13486"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>CounterStatus::Ignore:</highlight></codeline>
<codeline lineno="13487"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13488"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>CounterStatus::End:</highlight></codeline>
<codeline lineno="13489"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13490"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="13491"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="13492"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>CounterStatus::Pass:</highlight></codeline>
<codeline lineno="13493"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13494"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13495"><highlight class="normal"></highlight></codeline>
<codeline lineno="13496"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>all<sp/>previous<sp/>blocks<sp/>for<sp/>free<sp/>space</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13497"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(AllocInOtherBlock(0,<sp/>i,<sp/>moveData,<sp/>vector))</highlight></codeline>
<codeline lineno="13498"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13499"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13500"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13501"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13502"><highlight class="normal">}</highlight></codeline>
<codeline lineno="13503"><highlight class="normal"></highlight></codeline>
<codeline lineno="13504"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaDefragmentationContext_T::ComputeDefragmentation_Balanced(VmaBlockVector&amp;<sp/>vector,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>update)</highlight></codeline>
<codeline lineno="13505"><highlight class="normal">{</highlight></codeline>
<codeline lineno="13506"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>over<sp/>every<sp/>allocation<sp/>and<sp/>try<sp/>to<sp/>fit<sp/>it<sp/>in<sp/>previous<sp/>blocks<sp/>at<sp/>lowest<sp/>offsets,</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13507"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>if<sp/>not<sp/>possible:<sp/>realloc<sp/>within<sp/>single<sp/>block<sp/>to<sp/>minimize<sp/>offset<sp/>(exclude<sp/>offset<sp/>==<sp/>0),</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13508"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>but<sp/>only<sp/>if<sp/>there<sp/>are<sp/>noticable<sp/>gaps<sp/>between<sp/>them<sp/>(some<sp/>heuristic,<sp/>ex.<sp/>average<sp/>size<sp/>of<sp/>allocation<sp/>in<sp/>block)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13509"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_AlgorithmState<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="13510"><highlight class="normal"></highlight></codeline>
<codeline lineno="13511"><highlight class="normal"><sp/><sp/><sp/><sp/>StateBalanced&amp;<sp/>vectorState<sp/>=<sp/></highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal">StateBalanced*</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(m_AlgorithmState)[index];</highlight></codeline>
<codeline lineno="13512"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(update<sp/>&amp;&amp;<sp/>vectorState.avgAllocSize<sp/>==<sp/>UINT64_MAX)</highlight></codeline>
<codeline lineno="13513"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UpdateVectorStatistics(vector,<sp/>vectorState);</highlight></codeline>
<codeline lineno="13514"><highlight class="normal"></highlight></codeline>
<codeline lineno="13515"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>startMoveCount<sp/>=<sp/>m_Moves.size();</highlight></codeline>
<codeline lineno="13516"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>minimalFreeRegion<sp/>=<sp/>vectorState.avgFreeSize<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="13517"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>vector.GetBlockCount()<sp/>-<sp/>1;<sp/>i<sp/>&gt;<sp/>m_ImmovableBlockCount;<sp/>--i)</highlight></codeline>
<codeline lineno="13518"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13519"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/>block<sp/>=<sp/>vector.GetBlock(i);</highlight></codeline>
<codeline lineno="13520"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaBlockMetadata*<sp/>metadata<sp/>=<sp/>block-&gt;m_pMetadata;</highlight></codeline>
<codeline lineno="13521"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>prevFreeRegionSize<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="13522"><highlight class="normal"></highlight></codeline>
<codeline lineno="13523"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(VmaAllocHandle<sp/>handle<sp/>=<sp/>metadata-&gt;GetAllocationListBegin();</highlight></codeline>
<codeline lineno="13524"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>handle<sp/>!=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="13525"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>handle<sp/>=<sp/>metadata-&gt;GetNextAllocation(handle))</highlight></codeline>
<codeline lineno="13526"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MoveAllocationData<sp/>moveData<sp/>=<sp/>GetMoveData(handle,<sp/>metadata);</highlight></codeline>
<codeline lineno="13528"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Ignore<sp/>newly<sp/>created<sp/>allocations<sp/>by<sp/>defragmentation<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13529"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(moveData.move.srcAllocation-&gt;GetUserData()<sp/>==<sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="13530"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13531"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(CheckCounters(moveData.move.srcAllocation-&gt;GetSize()))</highlight></codeline>
<codeline lineno="13532"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13533"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>CounterStatus::Ignore:</highlight></codeline>
<codeline lineno="13534"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13535"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>CounterStatus::End:</highlight></codeline>
<codeline lineno="13536"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13537"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="13538"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="13539"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>CounterStatus::Pass:</highlight></codeline>
<codeline lineno="13540"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13541"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13542"><highlight class="normal"></highlight></codeline>
<codeline lineno="13543"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>all<sp/>previous<sp/>blocks<sp/>for<sp/>free<sp/>space</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13544"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>prevMoveCount<sp/>=<sp/>m_Moves.size();</highlight></codeline>
<codeline lineno="13545"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(AllocInOtherBlock(0,<sp/>i,<sp/>moveData,<sp/>vector))</highlight></codeline>
<codeline lineno="13546"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13547"><highlight class="normal"></highlight></codeline>
<codeline lineno="13548"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>nextFreeRegionSize<sp/>=<sp/>metadata-&gt;GetNextFreeRegionSize(handle);</highlight></codeline>
<codeline lineno="13549"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>no<sp/>room<sp/>found<sp/>then<sp/>realloc<sp/>within<sp/>block<sp/>for<sp/>lower<sp/>offset</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13550"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>offset<sp/>=<sp/>moveData.move.srcAllocation-&gt;GetOffset();</highlight></codeline>
<codeline lineno="13551"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(prevMoveCount<sp/>==<sp/>m_Moves.size()<sp/>&amp;&amp;<sp/>offset<sp/>!=<sp/>0<sp/>&amp;&amp;<sp/>metadata-&gt;GetSumFreeSize()<sp/>&gt;=<sp/>moveData.size)</highlight></codeline>
<codeline lineno="13552"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13553"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>if<sp/>realloc<sp/>will<sp/>make<sp/>sense</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13554"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(prevFreeRegionSize<sp/>&gt;=<sp/>minimalFreeRegion<sp/>||</highlight></codeline>
<codeline lineno="13555"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nextFreeRegionSize<sp/>&gt;=<sp/>minimalFreeRegion<sp/>||</highlight></codeline>
<codeline lineno="13556"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>moveData.size<sp/>&lt;=<sp/>vectorState.avgFreeSize<sp/>||</highlight></codeline>
<codeline lineno="13557"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>moveData.size<sp/>&lt;=<sp/>vectorState.avgAllocSize)</highlight></codeline>
<codeline lineno="13558"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13559"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAllocationRequest<sp/>request<sp/>=<sp/>{};</highlight></codeline>
<codeline lineno="13560"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(metadata-&gt;CreateAllocationRequest(</highlight></codeline>
<codeline lineno="13561"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>moveData.size,</highlight></codeline>
<codeline lineno="13562"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>moveData.alignment,</highlight></codeline>
<codeline lineno="13563"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="13564"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>moveData.type,</highlight></codeline>
<codeline lineno="13565"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8099acedc0d04cdccaaddcfe37fd227d" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</ref>,</highlight></codeline>
<codeline lineno="13566"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;request))</highlight></codeline>
<codeline lineno="13567"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13568"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(metadata-&gt;GetAllocationOffset(request.allocHandle)<sp/>&lt;<sp/>offset)</highlight></codeline>
<codeline lineno="13569"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13570"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(vector.CommitAllocationRequest(</highlight></codeline>
<codeline lineno="13571"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>request,</highlight></codeline>
<codeline lineno="13572"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block,</highlight></codeline>
<codeline lineno="13573"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>moveData.alignment,</highlight></codeline>
<codeline lineno="13574"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>moveData.flags,</highlight></codeline>
<codeline lineno="13575"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="13576"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>moveData.type,</highlight></codeline>
<codeline lineno="13577"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;moveData.move.dstTmpAllocation)<sp/>==<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="13578"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13579"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Moves.push_back(moveData.move);</highlight></codeline>
<codeline lineno="13580"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(IncrementCounters(moveData.size))</highlight></codeline>
<codeline lineno="13581"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13582"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13583"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13584"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13585"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13586"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13587"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prevFreeRegionSize<sp/>=<sp/>nextFreeRegionSize;</highlight></codeline>
<codeline lineno="13588"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13589"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13590"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="13591"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>No<sp/>moves<sp/>perfomed,<sp/>update<sp/>statistics<sp/>to<sp/>current<sp/>vector<sp/>state</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13592"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(startMoveCount<sp/>==<sp/>m_Moves.size()<sp/>&amp;&amp;<sp/>!update)</highlight></codeline>
<codeline lineno="13593"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13594"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vectorState.avgAllocSize<sp/>=<sp/>UINT64_MAX;</highlight></codeline>
<codeline lineno="13595"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ComputeDefragmentation_Balanced(vector,<sp/>index,<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="13596"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13597"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13598"><highlight class="normal">}</highlight></codeline>
<codeline lineno="13599"><highlight class="normal"></highlight></codeline>
<codeline lineno="13600"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaDefragmentationContext_T::ComputeDefragmentation_Full(VmaBlockVector&amp;<sp/>vector)</highlight></codeline>
<codeline lineno="13601"><highlight class="normal">{</highlight></codeline>
<codeline lineno="13602"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Go<sp/>over<sp/>every<sp/>allocation<sp/>and<sp/>try<sp/>to<sp/>fit<sp/>it<sp/>in<sp/>previous<sp/>blocks<sp/>at<sp/>lowest<sp/>offsets,</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13603"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>if<sp/>not<sp/>possible:<sp/>realloc<sp/>within<sp/>single<sp/>block<sp/>to<sp/>minimize<sp/>offset<sp/>(exclude<sp/>offset<sp/>==<sp/>0)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13604"><highlight class="normal"></highlight></codeline>
<codeline lineno="13605"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>vector.GetBlockCount()<sp/>-<sp/>1;<sp/>i<sp/>&gt;<sp/>m_ImmovableBlockCount;<sp/>--i)</highlight></codeline>
<codeline lineno="13606"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13607"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/>block<sp/>=<sp/>vector.GetBlock(i);</highlight></codeline>
<codeline lineno="13608"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaBlockMetadata*<sp/>metadata<sp/>=<sp/>block-&gt;m_pMetadata;</highlight></codeline>
<codeline lineno="13609"><highlight class="normal"></highlight></codeline>
<codeline lineno="13610"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(VmaAllocHandle<sp/>handle<sp/>=<sp/>metadata-&gt;GetAllocationListBegin();</highlight></codeline>
<codeline lineno="13611"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>handle<sp/>!=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="13612"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>handle<sp/>=<sp/>metadata-&gt;GetNextAllocation(handle))</highlight></codeline>
<codeline lineno="13613"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13614"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MoveAllocationData<sp/>moveData<sp/>=<sp/>GetMoveData(handle,<sp/>metadata);</highlight></codeline>
<codeline lineno="13615"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Ignore<sp/>newly<sp/>created<sp/>allocations<sp/>by<sp/>defragmentation<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13616"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(moveData.move.srcAllocation-&gt;GetUserData()<sp/>==<sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="13617"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13618"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(CheckCounters(moveData.move.srcAllocation-&gt;GetSize()))</highlight></codeline>
<codeline lineno="13619"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13620"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>CounterStatus::Ignore:</highlight></codeline>
<codeline lineno="13621"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13622"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>CounterStatus::End:</highlight></codeline>
<codeline lineno="13623"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13624"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="13625"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="13626"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>CounterStatus::Pass:</highlight></codeline>
<codeline lineno="13627"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13628"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13629"><highlight class="normal"></highlight></codeline>
<codeline lineno="13630"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>all<sp/>previous<sp/>blocks<sp/>for<sp/>free<sp/>space</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13631"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>prevMoveCount<sp/>=<sp/>m_Moves.size();</highlight></codeline>
<codeline lineno="13632"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(AllocInOtherBlock(0,<sp/>i,<sp/>moveData,<sp/>vector))</highlight></codeline>
<codeline lineno="13633"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13634"><highlight class="normal"></highlight></codeline>
<codeline lineno="13635"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>no<sp/>room<sp/>found<sp/>then<sp/>realloc<sp/>within<sp/>block<sp/>for<sp/>lower<sp/>offset</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13636"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>offset<sp/>=<sp/>moveData.move.srcAllocation-&gt;GetOffset();</highlight></codeline>
<codeline lineno="13637"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(prevMoveCount<sp/>==<sp/>m_Moves.size()<sp/>&amp;&amp;<sp/>offset<sp/>!=<sp/>0<sp/>&amp;&amp;<sp/>metadata-&gt;GetSumFreeSize()<sp/>&gt;=<sp/>moveData.size)</highlight></codeline>
<codeline lineno="13638"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13639"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAllocationRequest<sp/>request<sp/>=<sp/>{};</highlight></codeline>
<codeline lineno="13640"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(metadata-&gt;CreateAllocationRequest(</highlight></codeline>
<codeline lineno="13641"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>moveData.size,</highlight></codeline>
<codeline lineno="13642"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>moveData.alignment,</highlight></codeline>
<codeline lineno="13643"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="13644"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>moveData.type,</highlight></codeline>
<codeline lineno="13645"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8099acedc0d04cdccaaddcfe37fd227d" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</ref>,</highlight></codeline>
<codeline lineno="13646"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;request))</highlight></codeline>
<codeline lineno="13647"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13648"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(metadata-&gt;GetAllocationOffset(request.allocHandle)<sp/>&lt;<sp/>offset)</highlight></codeline>
<codeline lineno="13649"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13650"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(vector.CommitAllocationRequest(</highlight></codeline>
<codeline lineno="13651"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>request,</highlight></codeline>
<codeline lineno="13652"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block,</highlight></codeline>
<codeline lineno="13653"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>moveData.alignment,</highlight></codeline>
<codeline lineno="13654"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>moveData.flags,</highlight></codeline>
<codeline lineno="13655"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="13656"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>moveData.type,</highlight></codeline>
<codeline lineno="13657"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;moveData.move.dstTmpAllocation)<sp/>==<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="13658"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13659"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Moves.push_back(moveData.move);</highlight></codeline>
<codeline lineno="13660"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(IncrementCounters(moveData.size))</highlight></codeline>
<codeline lineno="13661"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13662"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13663"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13664"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13665"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13666"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13667"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13668"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13669"><highlight class="normal">}</highlight></codeline>
<codeline lineno="13670"><highlight class="normal"></highlight></codeline>
<codeline lineno="13671"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaDefragmentationContext_T::ComputeDefragmentation_Extensive(VmaBlockVector&amp;<sp/>vector,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index)</highlight></codeline>
<codeline lineno="13672"><highlight class="normal">{</highlight></codeline>
<codeline lineno="13673"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>First<sp/>free<sp/>single<sp/>block,<sp/>then<sp/>populate<sp/>it<sp/>to<sp/>the<sp/>brim,<sp/>then<sp/>free<sp/>another<sp/>block,<sp/>and<sp/>so<sp/>on</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13674"><highlight class="normal"></highlight></codeline>
<codeline lineno="13675"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Fallback<sp/>to<sp/>previous<sp/>algorithm<sp/>since<sp/>without<sp/>granularity<sp/>conflicts<sp/>it<sp/>can<sp/>achieve<sp/>max<sp/>packing</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13676"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(vector.m_BufferImageGranularity<sp/>==<sp/>1)</highlight></codeline>
<codeline lineno="13677"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ComputeDefragmentation_Full(vector);</highlight></codeline>
<codeline lineno="13678"><highlight class="normal"></highlight></codeline>
<codeline lineno="13679"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_AlgorithmState<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="13680"><highlight class="normal"></highlight></codeline>
<codeline lineno="13681"><highlight class="normal"><sp/><sp/><sp/><sp/>StateExtensive&amp;<sp/>vectorState<sp/>=<sp/></highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="normal">StateExtensive*</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(m_AlgorithmState)[index];</highlight></codeline>
<codeline lineno="13682"><highlight class="normal"></highlight></codeline>
<codeline lineno="13683"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>texturePresent<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">,<sp/>bufferPresent<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">,<sp/>otherPresent<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13684"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(vectorState.operation)</highlight></codeline>
<codeline lineno="13685"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13686"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>StateExtensive::Operation::Done:<sp/></highlight><highlight class="comment">//<sp/>Vector<sp/>defragmented</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13687"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13688"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>StateExtensive::Operation::FindFreeBlockBuffer:</highlight></codeline>
<codeline lineno="13689"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>StateExtensive::Operation::FindFreeBlockTexture:</highlight></codeline>
<codeline lineno="13690"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>StateExtensive::Operation::FindFreeBlockAll:</highlight></codeline>
<codeline lineno="13691"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13692"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>No<sp/>free<sp/>blocks,<sp/>have<sp/>to<sp/>clear<sp/>last<sp/>one</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13693"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>last<sp/>=<sp/>(vectorState.firstFreeBlock<sp/>==<sp/>SIZE_MAX<sp/>?<sp/>vector.GetBlockCount()<sp/>:<sp/>vectorState.firstFreeBlock)<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="13694"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaBlockMetadata*<sp/>freeMetadata<sp/>=<sp/>vector.GetBlock(last)-&gt;m_pMetadata;</highlight></codeline>
<codeline lineno="13695"><highlight class="normal"></highlight></codeline>
<codeline lineno="13696"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>prevMoveCount<sp/>=<sp/>m_Moves.size();</highlight></codeline>
<codeline lineno="13697"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(VmaAllocHandle<sp/>handle<sp/>=<sp/>freeMetadata-&gt;GetAllocationListBegin();</highlight></codeline>
<codeline lineno="13698"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>handle<sp/>!=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="13699"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>handle<sp/>=<sp/>freeMetadata-&gt;GetNextAllocation(handle))</highlight></codeline>
<codeline lineno="13700"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13701"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MoveAllocationData<sp/>moveData<sp/>=<sp/>GetMoveData(handle,<sp/>freeMetadata);</highlight></codeline>
<codeline lineno="13702"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(CheckCounters(moveData.move.srcAllocation-&gt;GetSize()))</highlight></codeline>
<codeline lineno="13703"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13704"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>CounterStatus::Ignore:</highlight></codeline>
<codeline lineno="13705"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13706"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>CounterStatus::End:</highlight></codeline>
<codeline lineno="13707"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13708"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="13709"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="13710"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>CounterStatus::Pass:</highlight></codeline>
<codeline lineno="13711"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13712"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13713"><highlight class="normal"></highlight></codeline>
<codeline lineno="13714"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>all<sp/>previous<sp/>blocks<sp/>for<sp/>free<sp/>space</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13715"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(AllocInOtherBlock(0,<sp/>last,<sp/>moveData,<sp/>vector))</highlight></codeline>
<codeline lineno="13716"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13717"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Full<sp/>clear<sp/>performed<sp/>already</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13718"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(prevMoveCount<sp/>!=<sp/>m_Moves.size()<sp/>&amp;&amp;<sp/>freeMetadata-&gt;GetNextAllocation(handle)<sp/>==<sp/>VK_NULL_HANDLE)</highlight></codeline>
<codeline lineno="13719"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal">*</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(m_AlgorithmState)[index]<sp/>=<sp/>last;</highlight></codeline>
<codeline lineno="13720"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13721"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13722"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13723"><highlight class="normal"></highlight></codeline>
<codeline lineno="13724"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(prevMoveCount<sp/>==<sp/>m_Moves.size())</highlight></codeline>
<codeline lineno="13725"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13726"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Cannot<sp/>perform<sp/>full<sp/>clear,<sp/>have<sp/>to<sp/>move<sp/>data<sp/>in<sp/>other<sp/>blocks<sp/>around</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13727"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(last<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="13728"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13729"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>last<sp/>-<sp/>1;<sp/>i;<sp/>--i)</highlight></codeline>
<codeline lineno="13730"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13731"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ReallocWithinBlock(vector,<sp/>vector.GetBlock(i)))</highlight></codeline>
<codeline lineno="13732"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13733"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13734"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13735"><highlight class="normal"></highlight></codeline>
<codeline lineno="13736"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(prevMoveCount<sp/>==<sp/>m_Moves.size())</highlight></codeline>
<codeline lineno="13737"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13738"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>No<sp/>possible<sp/>reallocs<sp/>within<sp/>blocks,<sp/>try<sp/>to<sp/>move<sp/>them<sp/>around<sp/>fast</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13739"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ComputeDefragmentation_Fast(vector);</highlight></codeline>
<codeline lineno="13740"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13741"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13742"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13743"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13744"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(vectorState.operation)</highlight></codeline>
<codeline lineno="13745"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13746"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>StateExtensive::Operation::FindFreeBlockBuffer:</highlight></codeline>
<codeline lineno="13747"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vectorState.operation<sp/>=<sp/>StateExtensive::Operation::MoveBuffers;</highlight></codeline>
<codeline lineno="13748"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13749"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="13750"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="13751"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>StateExtensive::Operation::FindFreeBlockTexture:</highlight></codeline>
<codeline lineno="13752"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vectorState.operation<sp/>=<sp/>StateExtensive::Operation::MoveTextures;</highlight></codeline>
<codeline lineno="13753"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13754"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>StateExtensive::Operation::FindFreeBlockAll:</highlight></codeline>
<codeline lineno="13755"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vectorState.operation<sp/>=<sp/>StateExtensive::Operation::MoveAll;</highlight></codeline>
<codeline lineno="13756"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13757"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13758"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vectorState.firstFreeBlock<sp/>=<sp/>last;</highlight></codeline>
<codeline lineno="13759"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Nothing<sp/>done,<sp/>block<sp/>found<sp/>without<sp/>reallocations,<sp/>can<sp/>perform<sp/>another<sp/>reallocs<sp/>in<sp/>same<sp/>pass</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13760"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(prevMoveCount<sp/>==<sp/>m_Moves.size())</highlight></codeline>
<codeline lineno="13761"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ComputeDefragmentation_Extensive(vector,<sp/>index);</highlight></codeline>
<codeline lineno="13762"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13763"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13764"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13765"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>StateExtensive::Operation::MoveTextures:</highlight></codeline>
<codeline lineno="13766"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13767"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(MoveDataToFreeBlocks(VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL,<sp/>vector,</highlight></codeline>
<codeline lineno="13768"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vectorState.firstFreeBlock,<sp/>texturePresent,<sp/>bufferPresent,<sp/>otherPresent))</highlight></codeline>
<codeline lineno="13769"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13770"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(texturePresent)</highlight></codeline>
<codeline lineno="13771"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13772"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vectorState.operation<sp/>=<sp/>StateExtensive::Operation::FindFreeBlockTexture;</highlight></codeline>
<codeline lineno="13773"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ComputeDefragmentation_Extensive(vector,<sp/>index);</highlight></codeline>
<codeline lineno="13774"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13775"><highlight class="normal"></highlight></codeline>
<codeline lineno="13776"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!bufferPresent<sp/>&amp;&amp;<sp/>!otherPresent)</highlight></codeline>
<codeline lineno="13777"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13778"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vectorState.operation<sp/>=<sp/>StateExtensive::Operation::Cleanup;</highlight></codeline>
<codeline lineno="13779"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13780"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13781"><highlight class="normal"></highlight></codeline>
<codeline lineno="13782"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>No<sp/>more<sp/>textures<sp/>to<sp/>move,<sp/>check<sp/>buffers</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13783"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vectorState.operation<sp/>=<sp/>StateExtensive::Operation::MoveBuffers;</highlight></codeline>
<codeline lineno="13784"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bufferPresent<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13785"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>otherPresent<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13786"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13787"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13788"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13789"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13790"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>StateExtensive::Operation::MoveBuffers:</highlight></codeline>
<codeline lineno="13791"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13792"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(MoveDataToFreeBlocks(VMA_SUBALLOCATION_TYPE_BUFFER,<sp/>vector,</highlight></codeline>
<codeline lineno="13793"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vectorState.firstFreeBlock,<sp/>texturePresent,<sp/>bufferPresent,<sp/>otherPresent))</highlight></codeline>
<codeline lineno="13794"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13795"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(bufferPresent)</highlight></codeline>
<codeline lineno="13796"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13797"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vectorState.operation<sp/>=<sp/>StateExtensive::Operation::FindFreeBlockBuffer;</highlight></codeline>
<codeline lineno="13798"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ComputeDefragmentation_Extensive(vector,<sp/>index);</highlight></codeline>
<codeline lineno="13799"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13800"><highlight class="normal"></highlight></codeline>
<codeline lineno="13801"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!otherPresent)</highlight></codeline>
<codeline lineno="13802"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13803"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vectorState.operation<sp/>=<sp/>StateExtensive::Operation::Cleanup;</highlight></codeline>
<codeline lineno="13804"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13805"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13806"><highlight class="normal"></highlight></codeline>
<codeline lineno="13807"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>No<sp/>more<sp/>buffers<sp/>to<sp/>move,<sp/>check<sp/>all<sp/>others</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13808"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vectorState.operation<sp/>=<sp/>StateExtensive::Operation::MoveAll;</highlight></codeline>
<codeline lineno="13809"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>otherPresent<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13810"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13811"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13812"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13813"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13814"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>StateExtensive::Operation::MoveAll:</highlight></codeline>
<codeline lineno="13815"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13816"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(MoveDataToFreeBlocks(VMA_SUBALLOCATION_TYPE_FREE,<sp/>vector,</highlight></codeline>
<codeline lineno="13817"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vectorState.firstFreeBlock,<sp/>texturePresent,<sp/>bufferPresent,<sp/>otherPresent))</highlight></codeline>
<codeline lineno="13818"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13819"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(otherPresent)</highlight></codeline>
<codeline lineno="13820"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13821"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vectorState.operation<sp/>=<sp/>StateExtensive::Operation::FindFreeBlockBuffer;</highlight></codeline>
<codeline lineno="13822"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ComputeDefragmentation_Extensive(vector,<sp/>index);</highlight></codeline>
<codeline lineno="13823"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13824"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Everything<sp/>moved</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13825"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vectorState.operation<sp/>=<sp/>StateExtensive::Operation::Cleanup;</highlight></codeline>
<codeline lineno="13826"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13827"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13828"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13829"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13830"><highlight class="normal"></highlight></codeline>
<codeline lineno="13831"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(vectorState.operation<sp/>==<sp/>StateExtensive::Operation::Cleanup)</highlight></codeline>
<codeline lineno="13832"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13833"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>All<sp/>other<sp/>work<sp/>done,<sp/>pack<sp/>data<sp/>in<sp/>blocks<sp/>even<sp/>tighter<sp/>if<sp/>possible</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13834"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>prevMoveCount<sp/>=<sp/>m_Moves.size();</highlight></codeline>
<codeline lineno="13835"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>vector.GetBlockCount();<sp/>++i)</highlight></codeline>
<codeline lineno="13836"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13837"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ReallocWithinBlock(vector,<sp/>vector.GetBlock(i)))</highlight></codeline>
<codeline lineno="13838"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13839"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13840"><highlight class="normal"></highlight></codeline>
<codeline lineno="13841"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(prevMoveCount<sp/>==<sp/>m_Moves.size())</highlight></codeline>
<codeline lineno="13842"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vectorState.operation<sp/>=<sp/>StateExtensive::Operation::Done;</highlight></codeline>
<codeline lineno="13843"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13844"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13845"><highlight class="normal">}</highlight></codeline>
<codeline lineno="13846"><highlight class="normal"></highlight></codeline>
<codeline lineno="13847"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaDefragmentationContext_T::UpdateVectorStatistics(VmaBlockVector&amp;<sp/>vector,<sp/>StateBalanced&amp;<sp/>state)</highlight></codeline>
<codeline lineno="13848"><highlight class="normal">{</highlight></codeline>
<codeline lineno="13849"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>allocCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="13850"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>freeCount<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="13851"><highlight class="normal"><sp/><sp/><sp/><sp/>state.avgFreeSize<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="13852"><highlight class="normal"><sp/><sp/><sp/><sp/>state.avgAllocSize<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="13853"><highlight class="normal"></highlight></codeline>
<codeline lineno="13854"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>vector.GetBlockCount();<sp/>++i)</highlight></codeline>
<codeline lineno="13855"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13856"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaBlockMetadata*<sp/>metadata<sp/>=<sp/>vector.GetBlock(i)-&gt;m_pMetadata;</highlight></codeline>
<codeline lineno="13857"><highlight class="normal"></highlight></codeline>
<codeline lineno="13858"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocCount<sp/>+=<sp/>metadata-&gt;GetAllocationCount();</highlight></codeline>
<codeline lineno="13859"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>freeCount<sp/>+=<sp/>metadata-&gt;GetFreeRegionsCount();</highlight></codeline>
<codeline lineno="13860"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>state.avgFreeSize<sp/>+=<sp/>metadata-&gt;GetSumFreeSize();</highlight></codeline>
<codeline lineno="13861"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>state.avgAllocSize<sp/>+=<sp/>metadata-&gt;GetSize();</highlight></codeline>
<codeline lineno="13862"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13863"><highlight class="normal"></highlight></codeline>
<codeline lineno="13864"><highlight class="normal"><sp/><sp/><sp/><sp/>state.avgAllocSize<sp/>=<sp/>(state.avgAllocSize<sp/>-<sp/>state.avgFreeSize)<sp/>/<sp/>allocCount;</highlight></codeline>
<codeline lineno="13865"><highlight class="normal"><sp/><sp/><sp/><sp/>state.avgFreeSize<sp/>/=<sp/>freeCount;</highlight></codeline>
<codeline lineno="13866"><highlight class="normal">}</highlight></codeline>
<codeline lineno="13867"><highlight class="normal"></highlight></codeline>
<codeline lineno="13868"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaDefragmentationContext_T::MoveDataToFreeBlocks(VmaSuballocationType<sp/>currentType,<sp/></highlight></codeline>
<codeline lineno="13869"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaBlockVector&amp;<sp/>vector,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>firstFreeBlock,</highlight></codeline>
<codeline lineno="13870"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">&amp;<sp/>texturePresent,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">&amp;<sp/>bufferPresent,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">&amp;<sp/>otherPresent)</highlight></codeline>
<codeline lineno="13871"><highlight class="normal">{</highlight></codeline>
<codeline lineno="13872"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>prevMoveCount<sp/>=<sp/>m_Moves.size();</highlight></codeline>
<codeline lineno="13873"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>firstFreeBlock<sp/>;<sp/>i;)</highlight></codeline>
<codeline lineno="13874"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13875"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/>block<sp/>=<sp/>vector.GetBlock(--i);</highlight></codeline>
<codeline lineno="13876"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaBlockMetadata*<sp/>metadata<sp/>=<sp/>block-&gt;m_pMetadata;</highlight></codeline>
<codeline lineno="13877"><highlight class="normal"></highlight></codeline>
<codeline lineno="13878"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(VmaAllocHandle<sp/>handle<sp/>=<sp/>metadata-&gt;GetAllocationListBegin();</highlight></codeline>
<codeline lineno="13879"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>handle<sp/>!=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="13880"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>handle<sp/>=<sp/>metadata-&gt;GetNextAllocation(handle))</highlight></codeline>
<codeline lineno="13881"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13882"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MoveAllocationData<sp/>moveData<sp/>=<sp/>GetMoveData(handle,<sp/>metadata);</highlight></codeline>
<codeline lineno="13883"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Ignore<sp/>newly<sp/>created<sp/>allocations<sp/>by<sp/>defragmentation<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13884"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(moveData.move.srcAllocation-&gt;GetUserData()<sp/>==<sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="13885"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13886"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(CheckCounters(moveData.move.srcAllocation-&gt;GetSize()))</highlight></codeline>
<codeline lineno="13887"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13888"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>CounterStatus::Ignore:</highlight></codeline>
<codeline lineno="13889"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13890"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>CounterStatus::End:</highlight></codeline>
<codeline lineno="13891"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13892"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="13893"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="13894"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>CounterStatus::Pass:</highlight></codeline>
<codeline lineno="13895"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13896"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13897"><highlight class="normal"></highlight></codeline>
<codeline lineno="13898"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Move<sp/>only<sp/>single<sp/>type<sp/>of<sp/>resources<sp/>at<sp/>once</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13899"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!VmaIsBufferImageGranularityConflict(moveData.type,<sp/>currentType))</highlight></codeline>
<codeline lineno="13900"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13901"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Try<sp/>to<sp/>fit<sp/>allocation<sp/>into<sp/>free<sp/>blocks</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13902"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(AllocInOtherBlock(firstFreeBlock,<sp/>vector.GetBlockCount(),<sp/>moveData,<sp/>vector))</highlight></codeline>
<codeline lineno="13903"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13904"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13905"><highlight class="normal"></highlight></codeline>
<codeline lineno="13906"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!VmaIsBufferImageGranularityConflict(moveData.type,<sp/>VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL))</highlight></codeline>
<codeline lineno="13907"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>texturePresent<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13908"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!VmaIsBufferImageGranularityConflict(moveData.type,<sp/>VMA_SUBALLOCATION_TYPE_BUFFER))</highlight></codeline>
<codeline lineno="13909"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bufferPresent<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13910"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13911"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>otherPresent<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13912"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13913"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13914"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>prevMoveCount<sp/>==<sp/>m_Moves.size();</highlight></codeline>
<codeline lineno="13915"><highlight class="normal">}</highlight></codeline>
<codeline lineno="13916"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_DEFRAGMENTATION_CONTEXT_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13917"><highlight class="normal"></highlight></codeline>
<codeline lineno="13918"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_POOL_T_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13919"><highlight class="normal">VmaPool_T::VmaPool_T(</highlight></codeline>
<codeline lineno="13920"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>hAllocator,</highlight></codeline>
<codeline lineno="13921"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_pool_create_info" kindref="compound">VmaPoolCreateInfo</ref>&amp;<sp/>createInfo,</highlight></codeline>
<codeline lineno="13922"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>preferredBlockSize)</highlight></codeline>
<codeline lineno="13923"><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>m_BlockVector(</highlight></codeline>
<codeline lineno="13924"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>hAllocator,</highlight></codeline>
<codeline lineno="13925"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>this,<sp/></highlight><highlight class="comment">//<sp/>hParentPool</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13926"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>createInfo.memoryTypeIndex,</highlight></codeline>
<codeline lineno="13927"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>createInfo.blockSize<sp/>!=<sp/>0<sp/>?<sp/>createInfo.blockSize<sp/>:<sp/>preferredBlockSize,</highlight></codeline>
<codeline lineno="13928"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>createInfo.minBlockCount,</highlight></codeline>
<codeline lineno="13929"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>createInfo.maxBlockCount,</highlight></codeline>
<codeline lineno="13930"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(createInfo.flags&amp;<sp/><ref refid="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7a9f1a499508a8edb4e8ba40aa0290a3d2" kindref="member">VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT</ref>)<sp/>!=<sp/>0<sp/>?<sp/>1<sp/>:<sp/>hAllocator-&gt;GetBufferImageGranularity(),</highlight></codeline>
<codeline lineno="13931"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>createInfo.blockSize<sp/>!=<sp/>0,<sp/></highlight><highlight class="comment">//<sp/>explicitBlockSize</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13932"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>createInfo.flags<sp/>&amp;<sp/><ref refid="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7af4d270f8f42517a0f70037ceb6ac1d9c" kindref="member">VMA_POOL_CREATE_ALGORITHM_MASK</ref>,<sp/></highlight><highlight class="comment">//<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13933"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>createInfo.priority,</highlight></codeline>
<codeline lineno="13934"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_MAX(hAllocator-&gt;GetMemoryTypeMinAlignment(createInfo.memoryTypeIndex),<sp/>createInfo.minAllocationAlignment),</highlight></codeline>
<codeline lineno="13935"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>createInfo.pMemoryAllocateNext),</highlight></codeline>
<codeline lineno="13936"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Id(0),</highlight></codeline>
<codeline lineno="13937"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Name(VMA_NULL)<sp/>{}</highlight></codeline>
<codeline lineno="13938"><highlight class="normal"></highlight></codeline>
<codeline lineno="13939"><highlight class="normal">VmaPool_T::~VmaPool_T()</highlight></codeline>
<codeline lineno="13940"><highlight class="normal">{</highlight></codeline>
<codeline lineno="13941"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_PrevPool<sp/>==<sp/>VMA_NULL<sp/>&amp;&amp;<sp/>m_NextPool<sp/>==<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="13942"><highlight class="normal">}</highlight></codeline>
<codeline lineno="13943"><highlight class="normal"></highlight></codeline>
<codeline lineno="13944"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaPool_T::SetName(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>pName)</highlight></codeline>
<codeline lineno="13945"><highlight class="normal">{</highlight></codeline>
<codeline lineno="13946"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>allocs<sp/>=<sp/>m_BlockVector.GetAllocator()-&gt;GetAllocationCallbacks();</highlight></codeline>
<codeline lineno="13947"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaFreeString(allocs,<sp/>m_Name);</highlight></codeline>
<codeline lineno="13948"><highlight class="normal"></highlight></codeline>
<codeline lineno="13949"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(pName<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="13950"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13951"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Name<sp/>=<sp/>VmaCreateStringCopy(allocs,<sp/>pName);</highlight></codeline>
<codeline lineno="13952"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13953"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13954"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13955"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Name<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="13956"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13957"><highlight class="normal">}</highlight></codeline>
<codeline lineno="13958"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_POOL_T_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13959"><highlight class="normal"></highlight></codeline>
<codeline lineno="13960"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_ALLOCATOR_T_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13961"><highlight class="normal">VmaAllocator_T::VmaAllocator_T(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocator_create_info" kindref="compound">VmaAllocatorCreateInfo</ref>*<sp/>pCreateInfo)<sp/>:</highlight></codeline>
<codeline lineno="13962"><highlight class="normal"><sp/><sp/><sp/><sp/>m_UseMutex((pCreateInfo-&gt;flags<sp/>&amp;<sp/><ref refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7ca4816ddaed324ba110172ca608a20f29d" kindref="member">VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT</ref>)<sp/>==<sp/>0),</highlight></codeline>
<codeline lineno="13963"><highlight class="normal"><sp/><sp/><sp/><sp/>m_VulkanApiVersion(pCreateInfo-&gt;vulkanApiVersion<sp/>!=<sp/>0<sp/>?<sp/>pCreateInfo-&gt;vulkanApiVersion<sp/>:<sp/>VK_API_VERSION_1_0),</highlight></codeline>
<codeline lineno="13964"><highlight class="normal"><sp/><sp/><sp/><sp/>m_UseKhrDedicatedAllocation((pCreateInfo-&gt;flags<sp/>&amp;<sp/><ref refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7cace7da7cc6e71a625dfa763c55a597878" kindref="member">VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT</ref>)<sp/>!=<sp/>0),</highlight></codeline>
<codeline lineno="13965"><highlight class="normal"><sp/><sp/><sp/><sp/>m_UseKhrBindMemory2((pCreateInfo-&gt;flags<sp/>&amp;<sp/><ref refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7ca8fb75bf07cd184ab903596295e863dee" kindref="member">VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</ref>)<sp/>!=<sp/>0),</highlight></codeline>
<codeline lineno="13966"><highlight class="normal"><sp/><sp/><sp/><sp/>m_UseExtMemoryBudget((pCreateInfo-&gt;flags<sp/>&amp;<sp/><ref refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7ca4d4687863f7bd4b418c6006dc04400b0" kindref="member">VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT</ref>)<sp/>!=<sp/>0),</highlight></codeline>
<codeline lineno="13967"><highlight class="normal"><sp/><sp/><sp/><sp/>m_UseAmdDeviceCoherentMemory((pCreateInfo-&gt;flags<sp/>&amp;<sp/><ref refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7ca2acce4886d8078552efa38878413970f" kindref="member">VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT</ref>)<sp/>!=<sp/>0),</highlight></codeline>
<codeline lineno="13968"><highlight class="normal"><sp/><sp/><sp/><sp/>m_UseKhrBufferDeviceAddress((pCreateInfo-&gt;flags<sp/>&amp;<sp/><ref refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7ca5f1b28b0414319d1687e1f2b30ab0089" kindref="member">VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT</ref>)<sp/>!=<sp/>0),</highlight></codeline>
<codeline lineno="13969"><highlight class="normal"><sp/><sp/><sp/><sp/>m_UseExtMemoryPriority((pCreateInfo-&gt;flags<sp/>&amp;<sp/><ref refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7caffdd7a5169be3dbd7cbf6b3619e4f78a" kindref="member">VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT</ref>)<sp/>!=<sp/>0),</highlight></codeline>
<codeline lineno="13970"><highlight class="normal"><sp/><sp/><sp/><sp/>m_hDevice(pCreateInfo-&gt;device),</highlight></codeline>
<codeline lineno="13971"><highlight class="normal"><sp/><sp/><sp/><sp/>m_hInstance(pCreateInfo-&gt;instance),</highlight></codeline>
<codeline lineno="13972"><highlight class="normal"><sp/><sp/><sp/><sp/>m_AllocationCallbacksSpecified(pCreateInfo-&gt;pAllocationCallbacks<sp/>!=<sp/>VMA_NULL),</highlight></codeline>
<codeline lineno="13973"><highlight class="normal"><sp/><sp/><sp/><sp/>m_AllocationCallbacks(pCreateInfo-&gt;pAllocationCallbacks<sp/>?</highlight></codeline>
<codeline lineno="13974"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pCreateInfo-&gt;pAllocationCallbacks<sp/>:<sp/>VmaEmptyAllocationCallbacks),</highlight></codeline>
<codeline lineno="13975"><highlight class="normal"><sp/><sp/><sp/><sp/>m_AllocationObjectAllocator(&amp;m_AllocationCallbacks),</highlight></codeline>
<codeline lineno="13976"><highlight class="normal"><sp/><sp/><sp/><sp/>m_HeapSizeLimitMask(0),</highlight></codeline>
<codeline lineno="13977"><highlight class="normal"><sp/><sp/><sp/><sp/>m_DeviceMemoryCount(0),</highlight></codeline>
<codeline lineno="13978"><highlight class="normal"><sp/><sp/><sp/><sp/>m_PreferredLargeHeapBlockSize(0),</highlight></codeline>
<codeline lineno="13979"><highlight class="normal"><sp/><sp/><sp/><sp/>m_PhysicalDevice(pCreateInfo-&gt;physicalDevice),</highlight></codeline>
<codeline lineno="13980"><highlight class="normal"><sp/><sp/><sp/><sp/>m_GpuDefragmentationMemoryTypeBits(UINT32_MAX),</highlight></codeline>
<codeline lineno="13981"><highlight class="normal"><sp/><sp/><sp/><sp/>m_NextPoolId(0),</highlight></codeline>
<codeline lineno="13982"><highlight class="normal"><sp/><sp/><sp/><sp/>m_GlobalMemoryTypeBits(UINT32_MAX)</highlight></codeline>
<codeline lineno="13983"><highlight class="normal">{</highlight></codeline>
<codeline lineno="13984"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_VulkanApiVersion<sp/>&gt;=<sp/>VK_MAKE_VERSION(1,<sp/>1,<sp/>0))</highlight></codeline>
<codeline lineno="13985"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13986"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_UseKhrDedicatedAllocation<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13987"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_UseKhrBindMemory2<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="13988"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13989"><highlight class="normal"></highlight></codeline>
<codeline lineno="13990"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(VMA_DEBUG_DETECT_CORRUPTION)</highlight></codeline>
<codeline lineno="13991"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="13992"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Needs<sp/>to<sp/>be<sp/>multiply<sp/>of<sp/>uint32_t<sp/>size<sp/>because<sp/>we<sp/>are<sp/>going<sp/>to<sp/>write<sp/>VMA_CORRUPTION_DETECTION_MAGIC_VALUE<sp/>to<sp/>it.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13993"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(VMA_DEBUG_MARGIN<sp/>%<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(uint32_t)<sp/>==<sp/>0);</highlight></codeline>
<codeline lineno="13994"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="13995"><highlight class="normal"></highlight></codeline>
<codeline lineno="13996"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(pCreateInfo-&gt;<ref refid="struct_vma_allocator_create_info_1ad09ce637aa92cb7c8c2a742943668087" kindref="member">physicalDevice</ref><sp/>&amp;&amp;<sp/>pCreateInfo-&gt;<ref refid="struct_vma_allocator_create_info_1ac35aa355d3bfcbf6bb2eb88ccf68125c" kindref="member">device</ref><sp/>&amp;&amp;<sp/>pCreateInfo-&gt;<ref refid="struct_vma_allocator_create_info_1aa2d4e3d86e6828834a56cf9f9406149a" kindref="member">instance</ref>);</highlight></codeline>
<codeline lineno="13997"><highlight class="normal"></highlight></codeline>
<codeline lineno="13998"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_VulkanApiVersion<sp/>&lt;<sp/>VK_MAKE_VERSION(1,<sp/>1,<sp/>0))</highlight></codeline>
<codeline lineno="13999"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14000"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>!(VMA_DEDICATED_ALLOCATION)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14001"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">((pCreateInfo-&gt;<ref refid="struct_vma_allocator_create_info_1a392ea2ecbaff93f91a7c49f735ad4346" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7cace7da7cc6e71a625dfa763c55a597878" kindref="member">VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT</ref>)<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="14002"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14003"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT<sp/>set<sp/>but<sp/>required<sp/>extensions<sp/>are<sp/>disabled<sp/>by<sp/>preprocessor<sp/>macros.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14004"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14005"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14006"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>!(VMA_BIND_MEMORY2)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14007"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">((pCreateInfo-&gt;<ref refid="struct_vma_allocator_create_info_1a392ea2ecbaff93f91a7c49f735ad4346" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7ca8fb75bf07cd184ab903596295e863dee" kindref="member">VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</ref>)<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="14008"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14009"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT<sp/>set<sp/>but<sp/>required<sp/>extension<sp/>is<sp/>disabled<sp/>by<sp/>preprocessor<sp/>macros.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14010"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14011"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14012"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14013"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>!(VMA_MEMORY_BUDGET)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14014"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">((pCreateInfo-&gt;<ref refid="struct_vma_allocator_create_info_1a392ea2ecbaff93f91a7c49f735ad4346" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7ca4d4687863f7bd4b418c6006dc04400b0" kindref="member">VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT</ref>)<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="14015"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14016"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT<sp/>set<sp/>but<sp/>required<sp/>extension<sp/>is<sp/>disabled<sp/>by<sp/>preprocessor<sp/>macros.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14017"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14018"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14019"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>!(VMA_BUFFER_DEVICE_ADDRESS)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14020"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_UseKhrBufferDeviceAddress)</highlight></codeline>
<codeline lineno="14021"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14022"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT<sp/>is<sp/>set<sp/>but<sp/>required<sp/>extension<sp/>or<sp/>Vulkan<sp/>1.2<sp/>is<sp/>not<sp/>available<sp/>in<sp/>your<sp/>Vulkan<sp/>header<sp/>or<sp/>its<sp/>support<sp/>in<sp/>VMA<sp/>has<sp/>been<sp/>disabled<sp/>by<sp/>a<sp/>preprocessor<sp/>macro.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14023"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14024"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14025"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_VULKAN_VERSION<sp/>&lt;<sp/>1002000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14026"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_VulkanApiVersion<sp/>&gt;=<sp/>VK_MAKE_VERSION(1,<sp/>2,<sp/>0))</highlight></codeline>
<codeline lineno="14027"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14028"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;vulkanApiVersion<sp/>&gt;=<sp/>VK_API_VERSION_1_2<sp/>but<sp/>required<sp/>Vulkan<sp/>version<sp/>is<sp/>disabled<sp/>by<sp/>preprocessor<sp/>macros.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14029"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14030"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14031"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_VULKAN_VERSION<sp/>&lt;<sp/>1001000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14032"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_VulkanApiVersion<sp/>&gt;=<sp/>VK_MAKE_VERSION(1,<sp/>1,<sp/>0))</highlight></codeline>
<codeline lineno="14033"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14034"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;vulkanApiVersion<sp/>&gt;=<sp/>VK_API_VERSION_1_1<sp/>but<sp/>required<sp/>Vulkan<sp/>version<sp/>is<sp/>disabled<sp/>by<sp/>preprocessor<sp/>macros.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14035"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14036"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14037"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>!(VMA_MEMORY_PRIORITY)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14038"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_UseExtMemoryPriority)</highlight></codeline>
<codeline lineno="14039"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14040"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT<sp/>is<sp/>set<sp/>but<sp/>required<sp/>extension<sp/>is<sp/>not<sp/>available<sp/>in<sp/>your<sp/>Vulkan<sp/>header<sp/>or<sp/>its<sp/>support<sp/>in<sp/>VMA<sp/>has<sp/>been<sp/>disabled<sp/>by<sp/>a<sp/>preprocessor<sp/>macro.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14041"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14042"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14043"><highlight class="normal"></highlight></codeline>
<codeline lineno="14044"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(&amp;m_DeviceMemoryCallbacks,<sp/>0<sp/>,</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(m_DeviceMemoryCallbacks));</highlight></codeline>
<codeline lineno="14045"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(&amp;m_PhysicalDeviceProperties,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(m_PhysicalDeviceProperties));</highlight></codeline>
<codeline lineno="14046"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(&amp;m_MemProps,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(m_MemProps));</highlight></codeline>
<codeline lineno="14047"><highlight class="normal"></highlight></codeline>
<codeline lineno="14048"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(&amp;m_pBlockVectors,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(m_pBlockVectors));</highlight></codeline>
<codeline lineno="14049"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(&amp;m_VulkanFunctions,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(m_VulkanFunctions));</highlight></codeline>
<codeline lineno="14050"><highlight class="normal"></highlight></codeline>
<codeline lineno="14051"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_EXTERNAL_MEMORY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14052"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(&amp;m_TypeExternalMemoryHandleTypes,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(m_TypeExternalMemoryHandleTypes));</highlight></codeline>
<codeline lineno="14053"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>VMA_EXTERNAL_MEMORY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14054"><highlight class="normal"></highlight></codeline>
<codeline lineno="14055"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pCreateInfo-&gt;<ref refid="struct_vma_allocator_create_info_1afbb24551124b16bdaa29f92eb96b8c56" kindref="member">pDeviceMemoryCallbacks</ref><sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="14056"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14057"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_DeviceMemoryCallbacks.<ref refid="struct_vma_device_memory_callbacks_1a84102b94fa445b59a8b02b44e7dcb43f" kindref="member">pUserData</ref><sp/>=<sp/>pCreateInfo-&gt;<ref refid="struct_vma_allocator_create_info_1afbb24551124b16bdaa29f92eb96b8c56" kindref="member">pDeviceMemoryCallbacks</ref>-&gt;<ref refid="struct_vma_device_memory_callbacks_1a84102b94fa445b59a8b02b44e7dcb43f" kindref="member">pUserData</ref>;</highlight></codeline>
<codeline lineno="14058"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_DeviceMemoryCallbacks.<ref refid="struct_vma_device_memory_callbacks_1ac02066cbe29d1f2f97c68c8c462ee3d5" kindref="member">pfnAllocate</ref><sp/>=<sp/>pCreateInfo-&gt;<ref refid="struct_vma_allocator_create_info_1afbb24551124b16bdaa29f92eb96b8c56" kindref="member">pDeviceMemoryCallbacks</ref>-&gt;<ref refid="struct_vma_device_memory_callbacks_1ac02066cbe29d1f2f97c68c8c462ee3d5" kindref="member">pfnAllocate</ref>;</highlight></codeline>
<codeline lineno="14059"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_DeviceMemoryCallbacks.<ref refid="struct_vma_device_memory_callbacks_1a74348a8b9bdb165535e010ed195bfdb9" kindref="member">pfnFree</ref><sp/>=<sp/>pCreateInfo-&gt;<ref refid="struct_vma_allocator_create_info_1afbb24551124b16bdaa29f92eb96b8c56" kindref="member">pDeviceMemoryCallbacks</ref>-&gt;<ref refid="struct_vma_device_memory_callbacks_1a74348a8b9bdb165535e010ed195bfdb9" kindref="member">pfnFree</ref>;</highlight></codeline>
<codeline lineno="14060"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14061"><highlight class="normal"></highlight></codeline>
<codeline lineno="14062"><highlight class="normal"><sp/><sp/><sp/><sp/>ImportVulkanFunctions(pCreateInfo-&gt;<ref refid="struct_vma_allocator_create_info_1a5e45da0879451e58bee2f3a975f228f5" kindref="member">pVulkanFunctions</ref>);</highlight></codeline>
<codeline lineno="14063"><highlight class="normal"></highlight></codeline>
<codeline lineno="14064"><highlight class="normal"><sp/><sp/><sp/><sp/>(*m_VulkanFunctions.vkGetPhysicalDeviceProperties)(m_PhysicalDevice,<sp/>&amp;m_PhysicalDeviceProperties);</highlight></codeline>
<codeline lineno="14065"><highlight class="normal"><sp/><sp/><sp/><sp/>(*m_VulkanFunctions.vkGetPhysicalDeviceMemoryProperties)(m_PhysicalDevice,<sp/>&amp;m_MemProps);</highlight></codeline>
<codeline lineno="14066"><highlight class="normal"></highlight></codeline>
<codeline lineno="14067"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(VmaIsPow2(VMA_MIN_ALIGNMENT));</highlight></codeline>
<codeline lineno="14068"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(VmaIsPow2(VMA_DEBUG_MIN_BUFFER_IMAGE_GRANULARITY));</highlight></codeline>
<codeline lineno="14069"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(VmaIsPow2(m_PhysicalDeviceProperties.limits.bufferImageGranularity));</highlight></codeline>
<codeline lineno="14070"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(VmaIsPow2(m_PhysicalDeviceProperties.limits.nonCoherentAtomSize));</highlight></codeline>
<codeline lineno="14071"><highlight class="normal"></highlight></codeline>
<codeline lineno="14072"><highlight class="normal"><sp/><sp/><sp/><sp/>m_PreferredLargeHeapBlockSize<sp/>=<sp/>(pCreateInfo-&gt;<ref refid="struct_vma_allocator_create_info_1a8e4714298e3121cdd8b214a1ae7a637a" kindref="member">preferredLargeHeapBlockSize</ref><sp/>!=<sp/>0)<sp/>?</highlight></codeline>
<codeline lineno="14073"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pCreateInfo-&gt;<ref refid="struct_vma_allocator_create_info_1a8e4714298e3121cdd8b214a1ae7a637a" kindref="member">preferredLargeHeapBlockSize</ref><sp/>:<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">VkDeviceSize</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(VMA_DEFAULT_LARGE_HEAP_BLOCK_SIZE);</highlight></codeline>
<codeline lineno="14074"><highlight class="normal"></highlight></codeline>
<codeline lineno="14075"><highlight class="normal"><sp/><sp/><sp/><sp/>m_GlobalMemoryTypeBits<sp/>=<sp/>CalculateGlobalMemoryTypeBits();</highlight></codeline>
<codeline lineno="14076"><highlight class="normal"></highlight></codeline>
<codeline lineno="14077"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_EXTERNAL_MEMORY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14078"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pCreateInfo-&gt;pTypeExternalMemoryHandleTypes<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="14079"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14080"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(m_TypeExternalMemoryHandleTypes,<sp/>pCreateInfo-&gt;pTypeExternalMemoryHandleTypes,</highlight></codeline>
<codeline lineno="14081"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(VkExternalMemoryHandleTypeFlagsKHR)<sp/>*<sp/>GetMemoryTypeCount());</highlight></codeline>
<codeline lineno="14082"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14083"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>VMA_EXTERNAL_MEMORY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14084"><highlight class="normal"></highlight></codeline>
<codeline lineno="14085"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pCreateInfo-&gt;pHeapSizeLimit<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="14086"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14087"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(uint32_t<sp/>heapIndex<sp/>=<sp/>0;<sp/>heapIndex<sp/>&lt;<sp/>GetMemoryHeapCount();<sp/>++heapIndex)</highlight></codeline>
<codeline lineno="14088"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14089"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>limit<sp/>=<sp/>pCreateInfo-&gt;pHeapSizeLimit[heapIndex];</highlight></codeline>
<codeline lineno="14090"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(limit<sp/>!=<sp/>VK_WHOLE_SIZE)</highlight></codeline>
<codeline lineno="14091"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14092"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_HeapSizeLimitMask<sp/>|=<sp/>1u<sp/>&lt;&lt;<sp/>heapIndex;</highlight></codeline>
<codeline lineno="14093"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(limit<sp/>&lt;<sp/>m_MemProps.memoryHeaps[heapIndex].size)</highlight></codeline>
<codeline lineno="14094"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14095"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_MemProps.memoryHeaps[heapIndex].size<sp/>=<sp/>limit;</highlight></codeline>
<codeline lineno="14096"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14097"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14098"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14099"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14100"><highlight class="normal"></highlight></codeline>
<codeline lineno="14101"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(uint32_t<sp/>memTypeIndex<sp/>=<sp/>0;<sp/>memTypeIndex<sp/>&lt;<sp/>GetMemoryTypeCount();<sp/>++memTypeIndex)</highlight></codeline>
<codeline lineno="14102"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>only<sp/>supported<sp/>types</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">((m_GlobalMemoryTypeBits<sp/>&amp;<sp/>(1u<sp/>&lt;&lt;<sp/>memTypeIndex))<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="14105"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14106"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>preferredBlockSize<sp/>=<sp/>CalcPreferredBlockSize(memTypeIndex);</highlight></codeline>
<codeline lineno="14107"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_pBlockVectors[memTypeIndex]<sp/>=<sp/>vma_new(</highlight><highlight class="keyword">this</highlight><highlight class="normal">,<sp/>VmaBlockVector)(</highlight></codeline>
<codeline lineno="14108"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="14109"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VK_NULL_HANDLE,<sp/></highlight><highlight class="comment">//<sp/>hParentPool</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14110"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memTypeIndex,</highlight></codeline>
<codeline lineno="14111"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>preferredBlockSize,</highlight></codeline>
<codeline lineno="14112"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,</highlight></codeline>
<codeline lineno="14113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SIZE_MAX,</highlight></codeline>
<codeline lineno="14114"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>GetBufferImageGranularity(),</highlight></codeline>
<codeline lineno="14115"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">,<sp/></highlight><highlight class="comment">//<sp/>explicitBlockSize</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/></highlight><highlight class="comment">//<sp/>algorithm</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0.5f,<sp/></highlight><highlight class="comment">//<sp/>priority<sp/>(0.5<sp/>is<sp/>the<sp/>default<sp/>per<sp/>Vulkan<sp/>spec)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14118"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>GetMemoryTypeMinAlignment(memTypeIndex),<sp/></highlight><highlight class="comment">//<sp/>minAllocationAlignment</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14119"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_NULL);<sp/></highlight><highlight class="comment">//<sp/>//<sp/>pMemoryAllocateNext</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14120"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>No<sp/>need<sp/>to<sp/>call<sp/>m_pBlockVectors[memTypeIndex][blockVectorTypeIndex]-&gt;CreateMinBlocks<sp/>here,</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>becase<sp/>minBlockCount<sp/>is<sp/>0.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14123"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14124"><highlight class="normal">}</highlight></codeline>
<codeline lineno="14125"><highlight class="normal"></highlight></codeline>
<codeline lineno="14126"><highlight class="normal">VkResult<sp/>VmaAllocator_T::Init(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocator_create_info" kindref="compound">VmaAllocatorCreateInfo</ref>*<sp/>pCreateInfo)</highlight></codeline>
<codeline lineno="14127"><highlight class="normal">{</highlight></codeline>
<codeline lineno="14128"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="14129"><highlight class="normal"></highlight></codeline>
<codeline lineno="14130"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_MEMORY_BUDGET</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14131"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_UseExtMemoryBudget)</highlight></codeline>
<codeline lineno="14132"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14133"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UpdateVulkanBudget();</highlight></codeline>
<codeline lineno="14134"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14135"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>VMA_MEMORY_BUDGET</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14136"><highlight class="normal"></highlight></codeline>
<codeline lineno="14137"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="14138"><highlight class="normal">}</highlight></codeline>
<codeline lineno="14139"><highlight class="normal"></highlight></codeline>
<codeline lineno="14140"><highlight class="normal">VmaAllocator_T::~VmaAllocator_T()</highlight></codeline>
<codeline lineno="14141"><highlight class="normal">{</highlight></codeline>
<codeline lineno="14142"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_Pools.IsEmpty());</highlight></codeline>
<codeline lineno="14143"><highlight class="normal"></highlight></codeline>
<codeline lineno="14144"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>memTypeIndex<sp/>=<sp/>GetMemoryTypeCount();<sp/>memTypeIndex--;<sp/>)</highlight></codeline>
<codeline lineno="14145"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vma_delete(</highlight><highlight class="keyword">this</highlight><highlight class="normal">,<sp/>m_pBlockVectors[memTypeIndex]);</highlight></codeline>
<codeline lineno="14147"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14148"><highlight class="normal">}</highlight></codeline>
<codeline lineno="14149"><highlight class="normal"></highlight></codeline>
<codeline lineno="14150"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocator_T::ImportVulkanFunctions(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_vulkan_functions" kindref="compound">VmaVulkanFunctions</ref>*<sp/>pVulkanFunctions)</highlight></codeline>
<codeline lineno="14151"><highlight class="normal">{</highlight></codeline>
<codeline lineno="14152"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATIC_VULKAN_FUNCTIONS<sp/>==<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14153"><highlight class="normal"><sp/><sp/><sp/><sp/>ImportVulkanFunctions_Static();</highlight></codeline>
<codeline lineno="14154"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14155"><highlight class="normal"></highlight></codeline>
<codeline lineno="14156"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pVulkanFunctions<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="14157"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ImportVulkanFunctions_Custom(pVulkanFunctions);</highlight></codeline>
<codeline lineno="14159"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14160"><highlight class="normal"></highlight></codeline>
<codeline lineno="14161"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_DYNAMIC_VULKAN_FUNCTIONS<sp/>==<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14162"><highlight class="normal"><sp/><sp/><sp/><sp/>ImportVulkanFunctions_Dynamic();</highlight></codeline>
<codeline lineno="14163"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14164"><highlight class="normal"></highlight></codeline>
<codeline lineno="14165"><highlight class="normal"><sp/><sp/><sp/><sp/>ValidateVulkanFunctions();</highlight></codeline>
<codeline lineno="14166"><highlight class="normal">}</highlight></codeline>
<codeline lineno="14167"><highlight class="normal"></highlight></codeline>
<codeline lineno="14168"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATIC_VULKAN_FUNCTIONS<sp/>==<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14169"><highlight class="normal"></highlight></codeline>
<codeline lineno="14170"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocator_T::ImportVulkanFunctions_Static()</highlight></codeline>
<codeline lineno="14171"><highlight class="normal">{</highlight></codeline>
<codeline lineno="14172"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Vulkan<sp/>1.0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14173"><highlight class="normal"><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkGetInstanceProcAddr<sp/>=<sp/>(PFN_vkGetInstanceProcAddr)vkGetInstanceProcAddr;</highlight></codeline>
<codeline lineno="14174"><highlight class="normal"><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkGetDeviceProcAddr<sp/>=<sp/>(PFN_vkGetDeviceProcAddr)vkGetDeviceProcAddr;</highlight></codeline>
<codeline lineno="14175"><highlight class="normal"><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkGetPhysicalDeviceProperties<sp/>=<sp/>(PFN_vkGetPhysicalDeviceProperties)vkGetPhysicalDeviceProperties;</highlight></codeline>
<codeline lineno="14176"><highlight class="normal"><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkGetPhysicalDeviceMemoryProperties<sp/>=<sp/>(PFN_vkGetPhysicalDeviceMemoryProperties)vkGetPhysicalDeviceMemoryProperties;</highlight></codeline>
<codeline lineno="14177"><highlight class="normal"><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkAllocateMemory<sp/>=<sp/>(PFN_vkAllocateMemory)vkAllocateMemory;</highlight></codeline>
<codeline lineno="14178"><highlight class="normal"><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkFreeMemory<sp/>=<sp/>(PFN_vkFreeMemory)vkFreeMemory;</highlight></codeline>
<codeline lineno="14179"><highlight class="normal"><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkMapMemory<sp/>=<sp/>(PFN_vkMapMemory)vkMapMemory;</highlight></codeline>
<codeline lineno="14180"><highlight class="normal"><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkUnmapMemory<sp/>=<sp/>(PFN_vkUnmapMemory)vkUnmapMemory;</highlight></codeline>
<codeline lineno="14181"><highlight class="normal"><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkFlushMappedMemoryRanges<sp/>=<sp/>(PFN_vkFlushMappedMemoryRanges)vkFlushMappedMemoryRanges;</highlight></codeline>
<codeline lineno="14182"><highlight class="normal"><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkInvalidateMappedMemoryRanges<sp/>=<sp/>(PFN_vkInvalidateMappedMemoryRanges)vkInvalidateMappedMemoryRanges;</highlight></codeline>
<codeline lineno="14183"><highlight class="normal"><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkBindBufferMemory<sp/>=<sp/>(PFN_vkBindBufferMemory)vkBindBufferMemory;</highlight></codeline>
<codeline lineno="14184"><highlight class="normal"><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkBindImageMemory<sp/>=<sp/>(PFN_vkBindImageMemory)vkBindImageMemory;</highlight></codeline>
<codeline lineno="14185"><highlight class="normal"><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkGetBufferMemoryRequirements<sp/>=<sp/>(PFN_vkGetBufferMemoryRequirements)vkGetBufferMemoryRequirements;</highlight></codeline>
<codeline lineno="14186"><highlight class="normal"><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkGetImageMemoryRequirements<sp/>=<sp/>(PFN_vkGetImageMemoryRequirements)vkGetImageMemoryRequirements;</highlight></codeline>
<codeline lineno="14187"><highlight class="normal"><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkCreateBuffer<sp/>=<sp/>(PFN_vkCreateBuffer)vkCreateBuffer;</highlight></codeline>
<codeline lineno="14188"><highlight class="normal"><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkDestroyBuffer<sp/>=<sp/>(PFN_vkDestroyBuffer)vkDestroyBuffer;</highlight></codeline>
<codeline lineno="14189"><highlight class="normal"><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkCreateImage<sp/>=<sp/>(PFN_vkCreateImage)vkCreateImage;</highlight></codeline>
<codeline lineno="14190"><highlight class="normal"><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkDestroyImage<sp/>=<sp/>(PFN_vkDestroyImage)vkDestroyImage;</highlight></codeline>
<codeline lineno="14191"><highlight class="normal"><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkCmdCopyBuffer<sp/>=<sp/>(PFN_vkCmdCopyBuffer)vkCmdCopyBuffer;</highlight></codeline>
<codeline lineno="14192"><highlight class="normal"></highlight></codeline>
<codeline lineno="14193"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Vulkan<sp/>1.1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14194"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1001000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14195"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_VulkanApiVersion<sp/>&gt;=<sp/>VK_MAKE_VERSION(1,<sp/>1,<sp/>0))</highlight></codeline>
<codeline lineno="14196"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkGetBufferMemoryRequirements2KHR<sp/>=<sp/>(PFN_vkGetBufferMemoryRequirements2)vkGetBufferMemoryRequirements2;</highlight></codeline>
<codeline lineno="14198"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkGetImageMemoryRequirements2KHR<sp/>=<sp/>(PFN_vkGetImageMemoryRequirements2)vkGetImageMemoryRequirements2;</highlight></codeline>
<codeline lineno="14199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkBindBufferMemory2KHR<sp/>=<sp/>(PFN_vkBindBufferMemory2)vkBindBufferMemory2;</highlight></codeline>
<codeline lineno="14200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkBindImageMemory2KHR<sp/>=<sp/>(PFN_vkBindImageMemory2)vkBindImageMemory2;</highlight></codeline>
<codeline lineno="14201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkGetPhysicalDeviceMemoryProperties2KHR<sp/>=<sp/>(PFN_vkGetPhysicalDeviceMemoryProperties2)vkGetPhysicalDeviceMemoryProperties2;</highlight></codeline>
<codeline lineno="14202"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14203"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14204"><highlight class="normal"></highlight></codeline>
<codeline lineno="14205"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1003000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14206"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_VulkanApiVersion<sp/>&gt;=<sp/>VK_MAKE_VERSION(1,<sp/>3,<sp/>0))</highlight></codeline>
<codeline lineno="14207"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkGetDeviceBufferMemoryRequirements<sp/>=<sp/>(PFN_vkGetDeviceBufferMemoryRequirements)vkGetDeviceBufferMemoryRequirements;</highlight></codeline>
<codeline lineno="14209"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkGetDeviceImageMemoryRequirements<sp/>=<sp/>(PFN_vkGetDeviceImageMemoryRequirements)vkGetDeviceImageMemoryRequirements;</highlight></codeline>
<codeline lineno="14210"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14211"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14212"><highlight class="normal">}</highlight></codeline>
<codeline lineno="14213"><highlight class="normal"></highlight></codeline>
<codeline lineno="14214"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>VMA_STATIC_VULKAN_FUNCTIONS<sp/>==<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14215"><highlight class="normal"></highlight></codeline>
<codeline lineno="14216"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocator_T::ImportVulkanFunctions_Custom(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_vulkan_functions" kindref="compound">VmaVulkanFunctions</ref>*<sp/>pVulkanFunctions)</highlight></codeline>
<codeline lineno="14217"><highlight class="normal">{</highlight></codeline>
<codeline lineno="14218"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(pVulkanFunctions<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="14219"><highlight class="normal"></highlight></codeline>
<codeline lineno="14220"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>VMA_COPY_IF_NOT_NULL(funcName)<sp/>\</highlight></codeline>
<codeline lineno="14221"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>if(pVulkanFunctions-&gt;funcName<sp/>!=<sp/>VMA_NULL)<sp/>m_VulkanFunctions.funcName<sp/>=<sp/>pVulkanFunctions-&gt;funcName;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14222"><highlight class="normal"></highlight></codeline>
<codeline lineno="14223"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_COPY_IF_NOT_NULL(vkGetInstanceProcAddr);</highlight></codeline>
<codeline lineno="14224"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_COPY_IF_NOT_NULL(vkGetDeviceProcAddr);</highlight></codeline>
<codeline lineno="14225"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_COPY_IF_NOT_NULL(vkGetPhysicalDeviceProperties);</highlight></codeline>
<codeline lineno="14226"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_COPY_IF_NOT_NULL(vkGetPhysicalDeviceMemoryProperties);</highlight></codeline>
<codeline lineno="14227"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_COPY_IF_NOT_NULL(vkAllocateMemory);</highlight></codeline>
<codeline lineno="14228"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_COPY_IF_NOT_NULL(vkFreeMemory);</highlight></codeline>
<codeline lineno="14229"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_COPY_IF_NOT_NULL(vkMapMemory);</highlight></codeline>
<codeline lineno="14230"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_COPY_IF_NOT_NULL(vkUnmapMemory);</highlight></codeline>
<codeline lineno="14231"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_COPY_IF_NOT_NULL(vkFlushMappedMemoryRanges);</highlight></codeline>
<codeline lineno="14232"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_COPY_IF_NOT_NULL(vkInvalidateMappedMemoryRanges);</highlight></codeline>
<codeline lineno="14233"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_COPY_IF_NOT_NULL(vkBindBufferMemory);</highlight></codeline>
<codeline lineno="14234"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_COPY_IF_NOT_NULL(vkBindImageMemory);</highlight></codeline>
<codeline lineno="14235"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_COPY_IF_NOT_NULL(vkGetBufferMemoryRequirements);</highlight></codeline>
<codeline lineno="14236"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_COPY_IF_NOT_NULL(vkGetImageMemoryRequirements);</highlight></codeline>
<codeline lineno="14237"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_COPY_IF_NOT_NULL(vkCreateBuffer);</highlight></codeline>
<codeline lineno="14238"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_COPY_IF_NOT_NULL(vkDestroyBuffer);</highlight></codeline>
<codeline lineno="14239"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_COPY_IF_NOT_NULL(vkCreateImage);</highlight></codeline>
<codeline lineno="14240"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_COPY_IF_NOT_NULL(vkDestroyImage);</highlight></codeline>
<codeline lineno="14241"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_COPY_IF_NOT_NULL(vkCmdCopyBuffer);</highlight></codeline>
<codeline lineno="14242"><highlight class="normal"></highlight></codeline>
<codeline lineno="14243"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_DEDICATED_ALLOCATION<sp/>||<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1001000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14244"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_COPY_IF_NOT_NULL(vkGetBufferMemoryRequirements2KHR);</highlight></codeline>
<codeline lineno="14245"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_COPY_IF_NOT_NULL(vkGetImageMemoryRequirements2KHR);</highlight></codeline>
<codeline lineno="14246"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14247"><highlight class="normal"></highlight></codeline>
<codeline lineno="14248"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_BIND_MEMORY2<sp/>||<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1001000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14249"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_COPY_IF_NOT_NULL(vkBindBufferMemory2KHR);</highlight></codeline>
<codeline lineno="14250"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_COPY_IF_NOT_NULL(vkBindImageMemory2KHR);</highlight></codeline>
<codeline lineno="14251"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14252"><highlight class="normal"></highlight></codeline>
<codeline lineno="14253"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_MEMORY_BUDGET</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14254"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_COPY_IF_NOT_NULL(vkGetPhysicalDeviceMemoryProperties2KHR);</highlight></codeline>
<codeline lineno="14255"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14256"><highlight class="normal"></highlight></codeline>
<codeline lineno="14257"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1003000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14258"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_COPY_IF_NOT_NULL(vkGetDeviceBufferMemoryRequirements);</highlight></codeline>
<codeline lineno="14259"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_COPY_IF_NOT_NULL(vkGetDeviceImageMemoryRequirements);</highlight></codeline>
<codeline lineno="14260"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14261"><highlight class="normal"></highlight></codeline>
<codeline lineno="14262"><highlight class="normal"></highlight><highlight class="preprocessor">#undef<sp/>VMA_COPY_IF_NOT_NULL</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14263"><highlight class="normal">}</highlight></codeline>
<codeline lineno="14264"><highlight class="normal"></highlight></codeline>
<codeline lineno="14265"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_DYNAMIC_VULKAN_FUNCTIONS<sp/>==<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14266"><highlight class="normal"></highlight></codeline>
<codeline lineno="14267"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocator_T::ImportVulkanFunctions_Dynamic()</highlight></codeline>
<codeline lineno="14268"><highlight class="normal">{</highlight></codeline>
<codeline lineno="14269"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_VulkanFunctions.vkGetInstanceProcAddr<sp/>&amp;&amp;<sp/>m_VulkanFunctions.vkGetDeviceProcAddr<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="14270"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;To<sp/>use<sp/>VMA_DYNAMIC_VULKAN_FUNCTIONS<sp/>in<sp/>new<sp/>versions<sp/>of<sp/>VMA<sp/>you<sp/>now<sp/>have<sp/>to<sp/>pass<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14271"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;VmaVulkanFunctions::vkGetInstanceProcAddr<sp/>and<sp/>vkGetDeviceProcAddr<sp/>as<sp/>VmaAllocatorCreateInfo::pVulkanFunctions.<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14272"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;Other<sp/>members<sp/>can<sp/>be<sp/>null.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14273"><highlight class="normal"></highlight></codeline>
<codeline lineno="14274"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>VMA_FETCH_INSTANCE_FUNC(memberName,<sp/>functionPointerType,<sp/>functionNameString)<sp/>\</highlight></codeline>
<codeline lineno="14275"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>if(m_VulkanFunctions.memberName<sp/>==<sp/>VMA_NULL)<sp/>\</highlight></codeline>
<codeline lineno="14276"><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_VulkanFunctions.memberName<sp/>=<sp/>\</highlight></codeline>
<codeline lineno="14277"><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(functionPointerType)m_VulkanFunctions.vkGetInstanceProcAddr(m_hInstance,<sp/>functionNameString);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14278"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>VMA_FETCH_DEVICE_FUNC(memberName,<sp/>functionPointerType,<sp/>functionNameString)<sp/>\</highlight></codeline>
<codeline lineno="14279"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>if(m_VulkanFunctions.memberName<sp/>==<sp/>VMA_NULL)<sp/>\</highlight></codeline>
<codeline lineno="14280"><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_VulkanFunctions.memberName<sp/>=<sp/>\</highlight></codeline>
<codeline lineno="14281"><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(functionPointerType)m_VulkanFunctions.vkGetDeviceProcAddr(m_hDevice,<sp/>functionNameString);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14282"><highlight class="normal"></highlight></codeline>
<codeline lineno="14283"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_FETCH_INSTANCE_FUNC(vkGetPhysicalDeviceProperties,<sp/>PFN_vkGetPhysicalDeviceProperties,<sp/></highlight><highlight class="stringliteral">&quot;vkGetPhysicalDeviceProperties&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14284"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_FETCH_INSTANCE_FUNC(vkGetPhysicalDeviceMemoryProperties,<sp/>PFN_vkGetPhysicalDeviceMemoryProperties,<sp/></highlight><highlight class="stringliteral">&quot;vkGetPhysicalDeviceMemoryProperties&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14285"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_FETCH_DEVICE_FUNC(vkAllocateMemory,<sp/>PFN_vkAllocateMemory,<sp/></highlight><highlight class="stringliteral">&quot;vkAllocateMemory&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14286"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_FETCH_DEVICE_FUNC(vkFreeMemory,<sp/>PFN_vkFreeMemory,<sp/></highlight><highlight class="stringliteral">&quot;vkFreeMemory&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14287"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_FETCH_DEVICE_FUNC(vkMapMemory,<sp/>PFN_vkMapMemory,<sp/></highlight><highlight class="stringliteral">&quot;vkMapMemory&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14288"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_FETCH_DEVICE_FUNC(vkUnmapMemory,<sp/>PFN_vkUnmapMemory,<sp/></highlight><highlight class="stringliteral">&quot;vkUnmapMemory&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14289"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_FETCH_DEVICE_FUNC(vkFlushMappedMemoryRanges,<sp/>PFN_vkFlushMappedMemoryRanges,<sp/></highlight><highlight class="stringliteral">&quot;vkFlushMappedMemoryRanges&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14290"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_FETCH_DEVICE_FUNC(vkInvalidateMappedMemoryRanges,<sp/>PFN_vkInvalidateMappedMemoryRanges,<sp/></highlight><highlight class="stringliteral">&quot;vkInvalidateMappedMemoryRanges&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14291"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_FETCH_DEVICE_FUNC(vkBindBufferMemory,<sp/>PFN_vkBindBufferMemory,<sp/></highlight><highlight class="stringliteral">&quot;vkBindBufferMemory&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14292"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_FETCH_DEVICE_FUNC(vkBindImageMemory,<sp/>PFN_vkBindImageMemory,<sp/></highlight><highlight class="stringliteral">&quot;vkBindImageMemory&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14293"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_FETCH_DEVICE_FUNC(vkGetBufferMemoryRequirements,<sp/>PFN_vkGetBufferMemoryRequirements,<sp/></highlight><highlight class="stringliteral">&quot;vkGetBufferMemoryRequirements&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14294"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_FETCH_DEVICE_FUNC(vkGetImageMemoryRequirements,<sp/>PFN_vkGetImageMemoryRequirements,<sp/></highlight><highlight class="stringliteral">&quot;vkGetImageMemoryRequirements&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14295"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_FETCH_DEVICE_FUNC(vkCreateBuffer,<sp/>PFN_vkCreateBuffer,<sp/></highlight><highlight class="stringliteral">&quot;vkCreateBuffer&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14296"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_FETCH_DEVICE_FUNC(vkDestroyBuffer,<sp/>PFN_vkDestroyBuffer,<sp/></highlight><highlight class="stringliteral">&quot;vkDestroyBuffer&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14297"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_FETCH_DEVICE_FUNC(vkCreateImage,<sp/>PFN_vkCreateImage,<sp/></highlight><highlight class="stringliteral">&quot;vkCreateImage&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14298"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_FETCH_DEVICE_FUNC(vkDestroyImage,<sp/>PFN_vkDestroyImage,<sp/></highlight><highlight class="stringliteral">&quot;vkDestroyImage&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14299"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_FETCH_DEVICE_FUNC(vkCmdCopyBuffer,<sp/>PFN_vkCmdCopyBuffer,<sp/></highlight><highlight class="stringliteral">&quot;vkCmdCopyBuffer&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14300"><highlight class="normal"></highlight></codeline>
<codeline lineno="14301"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1001000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14302"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_VulkanApiVersion<sp/>&gt;=<sp/>VK_MAKE_VERSION(1,<sp/>1,<sp/>0))</highlight></codeline>
<codeline lineno="14303"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14304"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_FETCH_DEVICE_FUNC(vkGetBufferMemoryRequirements2KHR,<sp/>PFN_vkGetBufferMemoryRequirements2,<sp/></highlight><highlight class="stringliteral">&quot;vkGetBufferMemoryRequirements2&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14305"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_FETCH_DEVICE_FUNC(vkGetImageMemoryRequirements2KHR,<sp/>PFN_vkGetImageMemoryRequirements2,<sp/></highlight><highlight class="stringliteral">&quot;vkGetImageMemoryRequirements2&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14306"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_FETCH_DEVICE_FUNC(vkBindBufferMemory2KHR,<sp/>PFN_vkBindBufferMemory2,<sp/></highlight><highlight class="stringliteral">&quot;vkBindBufferMemory2&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14307"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_FETCH_DEVICE_FUNC(vkBindImageMemory2KHR,<sp/>PFN_vkBindImageMemory2,<sp/></highlight><highlight class="stringliteral">&quot;vkBindImageMemory2&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14308"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_FETCH_INSTANCE_FUNC(vkGetPhysicalDeviceMemoryProperties2KHR,<sp/>PFN_vkGetPhysicalDeviceMemoryProperties2,<sp/></highlight><highlight class="stringliteral">&quot;vkGetPhysicalDeviceMemoryProperties2&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14309"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14310"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14311"><highlight class="normal"></highlight></codeline>
<codeline lineno="14312"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_DEDICATED_ALLOCATION</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14313"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_UseKhrDedicatedAllocation)</highlight></codeline>
<codeline lineno="14314"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14315"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_FETCH_DEVICE_FUNC(vkGetBufferMemoryRequirements2KHR,<sp/>PFN_vkGetBufferMemoryRequirements2KHR,<sp/></highlight><highlight class="stringliteral">&quot;vkGetBufferMemoryRequirements2KHR&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14316"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_FETCH_DEVICE_FUNC(vkGetImageMemoryRequirements2KHR,<sp/>PFN_vkGetImageMemoryRequirements2KHR,<sp/></highlight><highlight class="stringliteral">&quot;vkGetImageMemoryRequirements2KHR&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14317"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14318"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14319"><highlight class="normal"></highlight></codeline>
<codeline lineno="14320"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_BIND_MEMORY2</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14321"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_UseKhrBindMemory2)</highlight></codeline>
<codeline lineno="14322"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14323"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_FETCH_DEVICE_FUNC(vkBindBufferMemory2KHR,<sp/>PFN_vkBindBufferMemory2KHR,<sp/></highlight><highlight class="stringliteral">&quot;vkBindBufferMemory2KHR&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14324"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_FETCH_DEVICE_FUNC(vkBindImageMemory2KHR,<sp/>PFN_vkBindImageMemory2KHR,<sp/></highlight><highlight class="stringliteral">&quot;vkBindImageMemory2KHR&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14325"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14326"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>VMA_BIND_MEMORY2</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14327"><highlight class="normal"></highlight></codeline>
<codeline lineno="14328"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_MEMORY_BUDGET</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14329"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_UseExtMemoryBudget)</highlight></codeline>
<codeline lineno="14330"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_FETCH_INSTANCE_FUNC(vkGetPhysicalDeviceMemoryProperties2KHR,<sp/>PFN_vkGetPhysicalDeviceMemoryProperties2KHR,<sp/></highlight><highlight class="stringliteral">&quot;vkGetPhysicalDeviceMemoryProperties2KHR&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14332"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14333"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>VMA_MEMORY_BUDGET</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14334"><highlight class="normal"></highlight></codeline>
<codeline lineno="14335"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1003000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14336"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_VulkanApiVersion<sp/>&gt;=<sp/>VK_MAKE_VERSION(1,<sp/>3,<sp/>0))</highlight></codeline>
<codeline lineno="14337"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14338"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_FETCH_DEVICE_FUNC(vkGetDeviceBufferMemoryRequirements,<sp/>PFN_vkGetDeviceBufferMemoryRequirements,<sp/></highlight><highlight class="stringliteral">&quot;vkGetDeviceBufferMemoryRequirements&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14339"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_FETCH_DEVICE_FUNC(vkGetDeviceImageMemoryRequirements,<sp/>PFN_vkGetDeviceImageMemoryRequirements,<sp/></highlight><highlight class="stringliteral">&quot;vkGetDeviceImageMemoryRequirements&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14340"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14341"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14342"><highlight class="normal"></highlight></codeline>
<codeline lineno="14343"><highlight class="normal"></highlight><highlight class="preprocessor">#undef<sp/>VMA_FETCH_DEVICE_FUNC</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14344"><highlight class="normal"></highlight><highlight class="preprocessor">#undef<sp/>VMA_FETCH_INSTANCE_FUNC</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14345"><highlight class="normal">}</highlight></codeline>
<codeline lineno="14346"><highlight class="normal"></highlight></codeline>
<codeline lineno="14347"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>VMA_DYNAMIC_VULKAN_FUNCTIONS<sp/>==<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14348"><highlight class="normal"></highlight></codeline>
<codeline lineno="14349"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocator_T::ValidateVulkanFunctions()</highlight></codeline>
<codeline lineno="14350"><highlight class="normal">{</highlight></codeline>
<codeline lineno="14351"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_VulkanFunctions.vkGetPhysicalDeviceProperties<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="14352"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_VulkanFunctions.vkGetPhysicalDeviceMemoryProperties<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="14353"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_VulkanFunctions.vkAllocateMemory<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="14354"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_VulkanFunctions.vkFreeMemory<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="14355"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_VulkanFunctions.vkMapMemory<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="14356"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_VulkanFunctions.vkUnmapMemory<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="14357"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_VulkanFunctions.vkFlushMappedMemoryRanges<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="14358"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_VulkanFunctions.vkInvalidateMappedMemoryRanges<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="14359"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_VulkanFunctions.vkBindBufferMemory<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="14360"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_VulkanFunctions.vkBindImageMemory<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="14361"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_VulkanFunctions.vkGetBufferMemoryRequirements<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="14362"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_VulkanFunctions.vkGetImageMemoryRequirements<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="14363"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_VulkanFunctions.vkCreateBuffer<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="14364"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_VulkanFunctions.vkDestroyBuffer<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="14365"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_VulkanFunctions.vkCreateImage<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="14366"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_VulkanFunctions.vkDestroyImage<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="14367"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_VulkanFunctions.vkCmdCopyBuffer<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="14368"><highlight class="normal"></highlight></codeline>
<codeline lineno="14369"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_DEDICATED_ALLOCATION<sp/>||<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1001000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14370"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_VulkanApiVersion<sp/>&gt;=<sp/>VK_MAKE_VERSION(1,<sp/>1,<sp/>0)<sp/>||<sp/>m_UseKhrDedicatedAllocation)</highlight></codeline>
<codeline lineno="14371"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(m_VulkanFunctions.vkGetBufferMemoryRequirements2KHR<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="14373"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(m_VulkanFunctions.vkGetImageMemoryRequirements2KHR<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="14374"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14375"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14376"><highlight class="normal"></highlight></codeline>
<codeline lineno="14377"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_BIND_MEMORY2<sp/>||<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1001000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14378"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_VulkanApiVersion<sp/>&gt;=<sp/>VK_MAKE_VERSION(1,<sp/>1,<sp/>0)<sp/>||<sp/>m_UseKhrBindMemory2)</highlight></codeline>
<codeline lineno="14379"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14380"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(m_VulkanFunctions.vkBindBufferMemory2KHR<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="14381"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(m_VulkanFunctions.vkBindImageMemory2KHR<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="14382"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14383"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14384"><highlight class="normal"></highlight></codeline>
<codeline lineno="14385"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_MEMORY_BUDGET<sp/>||<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1001000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14386"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_UseExtMemoryBudget<sp/>||<sp/>m_VulkanApiVersion<sp/>&gt;=<sp/>VK_MAKE_VERSION(1,<sp/>1,<sp/>0))</highlight></codeline>
<codeline lineno="14387"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14388"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(m_VulkanFunctions.vkGetPhysicalDeviceMemoryProperties2KHR<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="14389"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14390"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14391"><highlight class="normal"></highlight></codeline>
<codeline lineno="14392"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1003000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14393"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_VulkanApiVersion<sp/>&gt;=<sp/>VK_MAKE_VERSION(1,<sp/>3,<sp/>0))</highlight></codeline>
<codeline lineno="14394"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14395"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(m_VulkanFunctions.vkGetDeviceBufferMemoryRequirements<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="14396"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(m_VulkanFunctions.vkGetDeviceImageMemoryRequirements<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="14397"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14398"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14399"><highlight class="normal">}</highlight></codeline>
<codeline lineno="14400"><highlight class="normal"></highlight></codeline>
<codeline lineno="14401"><highlight class="normal">VkDeviceSize<sp/>VmaAllocator_T::CalcPreferredBlockSize(uint32_t<sp/>memTypeIndex)</highlight></codeline>
<codeline lineno="14402"><highlight class="normal">{</highlight></codeline>
<codeline lineno="14403"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>heapIndex<sp/>=<sp/>MemoryTypeIndexToHeapIndex(memTypeIndex);</highlight></codeline>
<codeline lineno="14404"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>heapSize<sp/>=<sp/>m_MemProps.memoryHeaps[heapIndex].size;</highlight></codeline>
<codeline lineno="14405"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isSmallHeap<sp/>=<sp/>heapSize<sp/>&lt;=<sp/>VMA_SMALL_HEAP_MAX_SIZE;</highlight></codeline>
<codeline lineno="14406"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VmaAlignUp(isSmallHeap<sp/>?<sp/>(heapSize<sp/>/<sp/>8)<sp/>:<sp/>m_PreferredLargeHeapBlockSize,<sp/>(VkDeviceSize)32);</highlight></codeline>
<codeline lineno="14407"><highlight class="normal">}</highlight></codeline>
<codeline lineno="14408"><highlight class="normal"></highlight></codeline>
<codeline lineno="14409"><highlight class="normal">VkResult<sp/>VmaAllocator_T::AllocateMemoryOfType(</highlight></codeline>
<codeline lineno="14410"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>pool,</highlight></codeline>
<codeline lineno="14411"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size,</highlight></codeline>
<codeline lineno="14412"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>alignment,</highlight></codeline>
<codeline lineno="14413"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>dedicatedPreferred,</highlight></codeline>
<codeline lineno="14414"><highlight class="normal"><sp/><sp/><sp/><sp/>VkBuffer<sp/>dedicatedBuffer,</highlight></codeline>
<codeline lineno="14415"><highlight class="normal"><sp/><sp/><sp/><sp/>VkImage<sp/>dedicatedImage,</highlight></codeline>
<codeline lineno="14416"><highlight class="normal"><sp/><sp/><sp/><sp/>VkFlags<sp/>dedicatedBufferImageUsage,</highlight></codeline>
<codeline lineno="14417"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>&amp;<sp/>createInfo,</highlight></codeline>
<codeline lineno="14418"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>memTypeIndex,</highlight></codeline>
<codeline lineno="14419"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>suballocType,</highlight></codeline>
<codeline lineno="14420"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaDedicatedAllocationList&amp;<sp/>dedicatedAllocations,</highlight></codeline>
<codeline lineno="14421"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaBlockVector&amp;<sp/>blockVector,</highlight></codeline>
<codeline lineno="14422"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>allocationCount,</highlight></codeline>
<codeline lineno="14423"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>pAllocations)</highlight></codeline>
<codeline lineno="14424"><highlight class="normal">{</highlight></codeline>
<codeline lineno="14425"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(pAllocations<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="14426"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;<sp/><sp/>AllocateMemory:<sp/>MemoryTypeIndex=%u,<sp/>AllocationCount=%zu,<sp/>Size=%llu&quot;</highlight><highlight class="normal">,<sp/>memTypeIndex,<sp/>allocationCount,<sp/>size);</highlight></codeline>
<codeline lineno="14427"><highlight class="normal"></highlight></codeline>
<codeline lineno="14428"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref><sp/>finalCreateInfo<sp/>=<sp/>createInfo;</highlight></codeline>
<codeline lineno="14429"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>CalcMemTypeParams(</highlight></codeline>
<codeline lineno="14430"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>finalCreateInfo,</highlight></codeline>
<codeline lineno="14431"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memTypeIndex,</highlight></codeline>
<codeline lineno="14432"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size,</highlight></codeline>
<codeline lineno="14433"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocationCount);</highlight></codeline>
<codeline lineno="14434"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>!=<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="14435"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="14436"><highlight class="normal"></highlight></codeline>
<codeline lineno="14437"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">((finalCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" kindref="member">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</ref>)<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="14438"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14439"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>AllocateDedicatedMemory(</highlight></codeline>
<codeline lineno="14440"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pool,</highlight></codeline>
<codeline lineno="14441"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size,</highlight></codeline>
<codeline lineno="14442"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocType,</highlight></codeline>
<codeline lineno="14443"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dedicatedAllocations,</highlight></codeline>
<codeline lineno="14444"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memTypeIndex,</highlight></codeline>
<codeline lineno="14445"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(finalCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" kindref="member">VMA_ALLOCATION_CREATE_MAPPED_BIT</ref>)<sp/>!=<sp/>0,</highlight></codeline>
<codeline lineno="14446"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(finalCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597aa6f24f821cd6a7c5e4a443f7bf59c520" kindref="member">VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</ref>)<sp/>!=<sp/>0,</highlight></codeline>
<codeline lineno="14447"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(finalCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;</highlight></codeline>
<codeline lineno="14448"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(<ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</ref><sp/>|<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</ref>))<sp/>!=<sp/>0,</highlight></codeline>
<codeline lineno="14449"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(finalCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597afb0ee060cd733aaa5e249704ff589ad6" kindref="member">VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT</ref>)<sp/>!=<sp/>0,</highlight></codeline>
<codeline lineno="14450"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>finalCreateInfo.<ref refid="struct_vma_allocation_create_info_1a74e2eb74b3772b657c59473ce605058a" kindref="member">pUserData</ref>,</highlight></codeline>
<codeline lineno="14451"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>finalCreateInfo.<ref refid="struct_vma_allocation_create_info_1a983d39e1a2e63649d78a960aa2fdd0f7" kindref="member">priority</ref>,</highlight></codeline>
<codeline lineno="14452"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dedicatedBuffer,</highlight></codeline>
<codeline lineno="14453"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dedicatedImage,</highlight></codeline>
<codeline lineno="14454"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dedicatedBufferImageUsage,</highlight></codeline>
<codeline lineno="14455"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocationCount,</highlight></codeline>
<codeline lineno="14456"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocations,</highlight></codeline>
<codeline lineno="14457"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>blockVector.GetAllocationNextPtr());</highlight></codeline>
<codeline lineno="14458"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14459"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14460"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>canAllocateDedicated<sp/>=</highlight></codeline>
<codeline lineno="14462"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(finalCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a89759603401014eb325eb22a3839f2ff" kindref="member">VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</ref>)<sp/>==<sp/>0<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="14463"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(pool<sp/>==<sp/>VK_NULL_HANDLE<sp/>||<sp/>!blockVector.HasExplicitBlockSize());</highlight></codeline>
<codeline lineno="14464"><highlight class="normal"></highlight></codeline>
<codeline lineno="14465"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(canAllocateDedicated)</highlight></codeline>
<codeline lineno="14466"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14467"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Heuristics:<sp/>Allocate<sp/>dedicated<sp/>memory<sp/>if<sp/>requested<sp/>size<sp/>if<sp/>greater<sp/>than<sp/>half<sp/>of<sp/>preferred<sp/>block<sp/>size.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14468"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(size<sp/>&gt;<sp/>blockVector.GetPreferredBlockSize()<sp/>/<sp/>2)</highlight></codeline>
<codeline lineno="14469"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14470"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dedicatedPreferred<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="14471"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14472"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Protection<sp/>against<sp/>creating<sp/>each<sp/>allocation<sp/>as<sp/>dedicated<sp/>when<sp/>we<sp/>reach<sp/>or<sp/>exceed<sp/>heap<sp/>size/budget,</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14473"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>which<sp/>can<sp/>quickly<sp/>deplete<sp/>maxMemoryAllocationCount:<sp/>Don&apos;t<sp/>prefer<sp/>dedicated<sp/>allocations<sp/>when<sp/>above</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14474"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>3/4<sp/>of<sp/>the<sp/>maximum<sp/>allocation<sp/>count.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14475"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_DeviceMemoryCount.load()<sp/>&gt;<sp/>m_PhysicalDeviceProperties.limits.maxMemoryAllocationCount<sp/>*<sp/>3<sp/>/<sp/>4)</highlight></codeline>
<codeline lineno="14476"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14477"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dedicatedPreferred<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="14478"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14479"><highlight class="normal"></highlight></codeline>
<codeline lineno="14480"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(dedicatedPreferred)</highlight></codeline>
<codeline lineno="14481"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14482"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>AllocateDedicatedMemory(</highlight></codeline>
<codeline lineno="14483"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pool,</highlight></codeline>
<codeline lineno="14484"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size,</highlight></codeline>
<codeline lineno="14485"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocType,</highlight></codeline>
<codeline lineno="14486"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dedicatedAllocations,</highlight></codeline>
<codeline lineno="14487"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memTypeIndex,</highlight></codeline>
<codeline lineno="14488"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(finalCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" kindref="member">VMA_ALLOCATION_CREATE_MAPPED_BIT</ref>)<sp/>!=<sp/>0,</highlight></codeline>
<codeline lineno="14489"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(finalCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597aa6f24f821cd6a7c5e4a443f7bf59c520" kindref="member">VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</ref>)<sp/>!=<sp/>0,</highlight></codeline>
<codeline lineno="14490"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(finalCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;</highlight></codeline>
<codeline lineno="14491"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(<ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</ref><sp/>|<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</ref>))<sp/>!=<sp/>0,</highlight></codeline>
<codeline lineno="14492"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(finalCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597afb0ee060cd733aaa5e249704ff589ad6" kindref="member">VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT</ref>)<sp/>!=<sp/>0,</highlight></codeline>
<codeline lineno="14493"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>finalCreateInfo.<ref refid="struct_vma_allocation_create_info_1a74e2eb74b3772b657c59473ce605058a" kindref="member">pUserData</ref>,</highlight></codeline>
<codeline lineno="14494"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>finalCreateInfo.<ref refid="struct_vma_allocation_create_info_1a983d39e1a2e63649d78a960aa2fdd0f7" kindref="member">priority</ref>,</highlight></codeline>
<codeline lineno="14495"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dedicatedBuffer,</highlight></codeline>
<codeline lineno="14496"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dedicatedImage,</highlight></codeline>
<codeline lineno="14497"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dedicatedBufferImageUsage,</highlight></codeline>
<codeline lineno="14498"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocationCount,</highlight></codeline>
<codeline lineno="14499"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocations,</highlight></codeline>
<codeline lineno="14500"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>blockVector.GetAllocationNextPtr());</highlight></codeline>
<codeline lineno="14501"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>==<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="14502"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14503"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Succeeded:<sp/>AllocateDedicatedMemory<sp/>function<sp/>already<sp/>filld<sp/>pMemory,<sp/>nothing<sp/>more<sp/>to<sp/>do<sp/>here.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14504"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/>Allocated<sp/>as<sp/>DedicatedMemory&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14505"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="14506"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14507"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14508"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14509"><highlight class="normal"></highlight></codeline>
<codeline lineno="14510"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>blockVector.Allocate(</highlight></codeline>
<codeline lineno="14511"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size,</highlight></codeline>
<codeline lineno="14512"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>alignment,</highlight></codeline>
<codeline lineno="14513"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>finalCreateInfo,</highlight></codeline>
<codeline lineno="14514"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocType,</highlight></codeline>
<codeline lineno="14515"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocationCount,</highlight></codeline>
<codeline lineno="14516"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocations);</highlight></codeline>
<codeline lineno="14517"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>==<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="14518"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="14519"><highlight class="normal"></highlight></codeline>
<codeline lineno="14520"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Try<sp/>dedicated<sp/>memory.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14521"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(canAllocateDedicated<sp/>&amp;&amp;<sp/>!dedicatedPreferred)</highlight></codeline>
<codeline lineno="14522"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14523"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>AllocateDedicatedMemory(</highlight></codeline>
<codeline lineno="14524"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pool,</highlight></codeline>
<codeline lineno="14525"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size,</highlight></codeline>
<codeline lineno="14526"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocType,</highlight></codeline>
<codeline lineno="14527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dedicatedAllocations,</highlight></codeline>
<codeline lineno="14528"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memTypeIndex,</highlight></codeline>
<codeline lineno="14529"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(finalCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" kindref="member">VMA_ALLOCATION_CREATE_MAPPED_BIT</ref>)<sp/>!=<sp/>0,</highlight></codeline>
<codeline lineno="14530"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(finalCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597aa6f24f821cd6a7c5e4a443f7bf59c520" kindref="member">VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</ref>)<sp/>!=<sp/>0,</highlight></codeline>
<codeline lineno="14531"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(finalCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;</highlight></codeline>
<codeline lineno="14532"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(<ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</ref><sp/>|<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</ref>))<sp/>!=<sp/>0,</highlight></codeline>
<codeline lineno="14533"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(finalCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597afb0ee060cd733aaa5e249704ff589ad6" kindref="member">VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT</ref>)<sp/>!=<sp/>0,</highlight></codeline>
<codeline lineno="14534"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>finalCreateInfo.<ref refid="struct_vma_allocation_create_info_1a74e2eb74b3772b657c59473ce605058a" kindref="member">pUserData</ref>,</highlight></codeline>
<codeline lineno="14535"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>finalCreateInfo.<ref refid="struct_vma_allocation_create_info_1a983d39e1a2e63649d78a960aa2fdd0f7" kindref="member">priority</ref>,</highlight></codeline>
<codeline lineno="14536"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dedicatedBuffer,</highlight></codeline>
<codeline lineno="14537"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dedicatedImage,</highlight></codeline>
<codeline lineno="14538"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dedicatedBufferImageUsage,</highlight></codeline>
<codeline lineno="14539"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocationCount,</highlight></codeline>
<codeline lineno="14540"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocations,</highlight></codeline>
<codeline lineno="14541"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>blockVector.GetAllocationNextPtr());</highlight></codeline>
<codeline lineno="14542"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>==<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="14543"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14544"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Succeeded:<sp/>AllocateDedicatedMemory<sp/>function<sp/>already<sp/>filld<sp/>pMemory,<sp/>nothing<sp/>more<sp/>to<sp/>do<sp/>here.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14545"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/>Allocated<sp/>as<sp/>DedicatedMemory&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14546"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="14547"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14548"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14549"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Everything<sp/>failed:<sp/>Return<sp/>error<sp/>code.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14550"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/>vkAllocateMemory<sp/>FAILED&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14551"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="14552"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14553"><highlight class="normal">}</highlight></codeline>
<codeline lineno="14554"><highlight class="normal"></highlight></codeline>
<codeline lineno="14555"><highlight class="normal">VkResult<sp/>VmaAllocator_T::AllocateDedicatedMemory(</highlight></codeline>
<codeline lineno="14556"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>pool,</highlight></codeline>
<codeline lineno="14557"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size,</highlight></codeline>
<codeline lineno="14558"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>suballocType,</highlight></codeline>
<codeline lineno="14559"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaDedicatedAllocationList&amp;<sp/>dedicatedAllocations,</highlight></codeline>
<codeline lineno="14560"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>memTypeIndex,</highlight></codeline>
<codeline lineno="14561"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>map,</highlight></codeline>
<codeline lineno="14562"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isUserDataString,</highlight></codeline>
<codeline lineno="14563"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isMappingAllowed,</highlight></codeline>
<codeline lineno="14564"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>canAliasMemory,</highlight></codeline>
<codeline lineno="14565"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pUserData,</highlight></codeline>
<codeline lineno="14566"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>priority,</highlight></codeline>
<codeline lineno="14567"><highlight class="normal"><sp/><sp/><sp/><sp/>VkBuffer<sp/>dedicatedBuffer,</highlight></codeline>
<codeline lineno="14568"><highlight class="normal"><sp/><sp/><sp/><sp/>VkImage<sp/>dedicatedImage,</highlight></codeline>
<codeline lineno="14569"><highlight class="normal"><sp/><sp/><sp/><sp/>VkFlags<sp/>dedicatedBufferImageUsage,</highlight></codeline>
<codeline lineno="14570"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>allocationCount,</highlight></codeline>
<codeline lineno="14571"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>pAllocations,</highlight></codeline>
<codeline lineno="14572"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pNextChain)</highlight></codeline>
<codeline lineno="14573"><highlight class="normal">{</highlight></codeline>
<codeline lineno="14574"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocationCount<sp/>&gt;<sp/>0<sp/>&amp;&amp;<sp/>pAllocations);</highlight></codeline>
<codeline lineno="14575"><highlight class="normal"></highlight></codeline>
<codeline lineno="14576"><highlight class="normal"><sp/><sp/><sp/><sp/>VkMemoryAllocateInfo<sp/>allocInfo<sp/>=<sp/>{<sp/>VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO<sp/>};</highlight></codeline>
<codeline lineno="14577"><highlight class="normal"><sp/><sp/><sp/><sp/>allocInfo.memoryTypeIndex<sp/>=<sp/>memTypeIndex;</highlight></codeline>
<codeline lineno="14578"><highlight class="normal"><sp/><sp/><sp/><sp/>allocInfo.allocationSize<sp/>=<sp/>size;</highlight></codeline>
<codeline lineno="14579"><highlight class="normal"><sp/><sp/><sp/><sp/>allocInfo.pNext<sp/>=<sp/>pNextChain;</highlight></codeline>
<codeline lineno="14580"><highlight class="normal"></highlight></codeline>
<codeline lineno="14581"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_DEDICATED_ALLOCATION<sp/>||<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1001000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14582"><highlight class="normal"><sp/><sp/><sp/><sp/>VkMemoryDedicatedAllocateInfoKHR<sp/>dedicatedAllocInfo<sp/>=<sp/>{<sp/>VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR<sp/>};</highlight></codeline>
<codeline lineno="14583"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!canAliasMemory)</highlight></codeline>
<codeline lineno="14584"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14585"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_UseKhrDedicatedAllocation<sp/>||<sp/>m_VulkanApiVersion<sp/>&gt;=<sp/>VK_MAKE_VERSION(1,<sp/>1,<sp/>0))</highlight></codeline>
<codeline lineno="14586"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14587"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(dedicatedBuffer<sp/>!=<sp/>VK_NULL_HANDLE)</highlight></codeline>
<codeline lineno="14588"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14589"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(dedicatedImage<sp/>==<sp/>VK_NULL_HANDLE);</highlight></codeline>
<codeline lineno="14590"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dedicatedAllocInfo.buffer<sp/>=<sp/>dedicatedBuffer;</highlight></codeline>
<codeline lineno="14591"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaPnextChainPushFront(&amp;allocInfo,<sp/>&amp;dedicatedAllocInfo);</highlight></codeline>
<codeline lineno="14592"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14593"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(dedicatedImage<sp/>!=<sp/>VK_NULL_HANDLE)</highlight></codeline>
<codeline lineno="14594"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14595"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dedicatedAllocInfo.image<sp/>=<sp/>dedicatedImage;</highlight></codeline>
<codeline lineno="14596"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaPnextChainPushFront(&amp;allocInfo,<sp/>&amp;dedicatedAllocInfo);</highlight></codeline>
<codeline lineno="14597"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14598"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14599"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14600"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>VMA_DEDICATED_ALLOCATION<sp/>||<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1001000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14601"><highlight class="normal"></highlight></codeline>
<codeline lineno="14602"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_BUFFER_DEVICE_ADDRESS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14603"><highlight class="normal"><sp/><sp/><sp/><sp/>VkMemoryAllocateFlagsInfoKHR<sp/>allocFlagsInfo<sp/>=<sp/>{<sp/>VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR<sp/>};</highlight></codeline>
<codeline lineno="14604"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_UseKhrBufferDeviceAddress)</highlight></codeline>
<codeline lineno="14605"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14606"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>canContainBufferWithDeviceAddress<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="14607"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(dedicatedBuffer<sp/>!=<sp/>VK_NULL_HANDLE)</highlight></codeline>
<codeline lineno="14608"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14609"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>canContainBufferWithDeviceAddress<sp/>=<sp/>dedicatedBufferImageUsage<sp/>==<sp/>UINT32_MAX<sp/>||<sp/></highlight><highlight class="comment">//<sp/>Usage<sp/>flags<sp/>unknown</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14610"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(dedicatedBufferImageUsage<sp/>&amp;<sp/>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT)<sp/>!=<sp/>0;</highlight></codeline>
<codeline lineno="14611"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14612"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(dedicatedImage<sp/>!=<sp/>VK_NULL_HANDLE)</highlight></codeline>
<codeline lineno="14613"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14614"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>canContainBufferWithDeviceAddress<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="14615"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14616"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(canContainBufferWithDeviceAddress)</highlight></codeline>
<codeline lineno="14617"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14618"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocFlagsInfo.flags<sp/>=<sp/>VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR;</highlight></codeline>
<codeline lineno="14619"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaPnextChainPushFront(&amp;allocInfo,<sp/>&amp;allocFlagsInfo);</highlight></codeline>
<codeline lineno="14620"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14621"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14622"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>VMA_BUFFER_DEVICE_ADDRESS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14623"><highlight class="normal"></highlight></codeline>
<codeline lineno="14624"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_MEMORY_PRIORITY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14625"><highlight class="normal"><sp/><sp/><sp/><sp/>VkMemoryPriorityAllocateInfoEXT<sp/>priorityInfo<sp/>=<sp/>{<sp/>VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT<sp/>};</highlight></codeline>
<codeline lineno="14626"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_UseExtMemoryPriority)</highlight></codeline>
<codeline lineno="14627"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14628"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(priority<sp/>&gt;=<sp/>0.f<sp/>&amp;&amp;<sp/>priority<sp/>&lt;=<sp/>1.f);</highlight></codeline>
<codeline lineno="14629"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>priorityInfo.priority<sp/>=<sp/>priority;</highlight></codeline>
<codeline lineno="14630"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaPnextChainPushFront(&amp;allocInfo,<sp/>&amp;priorityInfo);</highlight></codeline>
<codeline lineno="14631"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14632"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>VMA_MEMORY_PRIORITY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14633"><highlight class="normal"></highlight></codeline>
<codeline lineno="14634"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_EXTERNAL_MEMORY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14635"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Attach<sp/>VkExportMemoryAllocateInfoKHR<sp/>if<sp/>necessary.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14636"><highlight class="normal"><sp/><sp/><sp/><sp/>VkExportMemoryAllocateInfoKHR<sp/>exportMemoryAllocInfo<sp/>=<sp/>{<sp/>VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR<sp/>};</highlight></codeline>
<codeline lineno="14637"><highlight class="normal"><sp/><sp/><sp/><sp/>exportMemoryAllocInfo.handleTypes<sp/>=<sp/>GetExternalMemoryHandleTypeFlags(memTypeIndex);</highlight></codeline>
<codeline lineno="14638"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(exportMemoryAllocInfo.handleTypes<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="14639"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14640"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaPnextChainPushFront(&amp;allocInfo,<sp/>&amp;exportMemoryAllocInfo);</highlight></codeline>
<codeline lineno="14641"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14642"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>VMA_EXTERNAL_MEMORY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14643"><highlight class="normal"></highlight></codeline>
<codeline lineno="14644"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>allocIndex;</highlight></codeline>
<codeline lineno="14645"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="14646"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(allocIndex<sp/>=<sp/>0;<sp/>allocIndex<sp/>&lt;<sp/>allocationCount;<sp/>++allocIndex)</highlight></codeline>
<codeline lineno="14647"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14648"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>AllocateDedicatedMemoryPage(</highlight></codeline>
<codeline lineno="14649"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pool,</highlight></codeline>
<codeline lineno="14650"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size,</highlight></codeline>
<codeline lineno="14651"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocType,</highlight></codeline>
<codeline lineno="14652"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memTypeIndex,</highlight></codeline>
<codeline lineno="14653"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocInfo,</highlight></codeline>
<codeline lineno="14654"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>map,</highlight></codeline>
<codeline lineno="14655"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>isUserDataString,</highlight></codeline>
<codeline lineno="14656"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>isMappingAllowed,</highlight></codeline>
<codeline lineno="14657"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pUserData,</highlight></codeline>
<codeline lineno="14658"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocations<sp/>+<sp/>allocIndex);</highlight></codeline>
<codeline lineno="14659"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>!=<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="14660"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14661"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="14662"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14663"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14664"><highlight class="normal"></highlight></codeline>
<codeline lineno="14665"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>==<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="14666"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14667"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(allocIndex<sp/>=<sp/>0;<sp/>allocIndex<sp/>&lt;<sp/>allocationCount;<sp/>++allocIndex)</highlight></codeline>
<codeline lineno="14668"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14669"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dedicatedAllocations.Register(pAllocations[allocIndex]);</highlight></codeline>
<codeline lineno="14670"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14671"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/>Allocated<sp/>DedicatedMemory<sp/>Count=%zu,<sp/>MemoryTypeIndex=#%u&quot;</highlight><highlight class="normal">,<sp/>allocationCount,<sp/>memTypeIndex);</highlight></codeline>
<codeline lineno="14672"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14673"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14674"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14675"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Free<sp/>all<sp/>already<sp/>created<sp/>allocations.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14676"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal">(allocIndex--)</highlight></codeline>
<codeline lineno="14677"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14678"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>currAlloc<sp/>=<sp/>pAllocations[allocIndex];</highlight></codeline>
<codeline lineno="14679"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceMemory<sp/>hMemory<sp/>=<sp/>currAlloc-&gt;GetMemory();</highlight></codeline>
<codeline lineno="14680"><highlight class="normal"></highlight></codeline>
<codeline lineno="14681"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="14682"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>There<sp/>is<sp/>no<sp/>need<sp/>to<sp/>call<sp/>this,<sp/>because<sp/>Vulkan<sp/>spec<sp/>allows<sp/>to<sp/>skip<sp/>vkUnmapMemory</highlight></codeline>
<codeline lineno="14683"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>before<sp/>vkFreeMemory.</highlight></codeline>
<codeline lineno="14684"><highlight class="comment"></highlight></codeline>
<codeline lineno="14685"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if(currAlloc-&gt;GetMappedData()<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="14686"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14687"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*m_VulkanFunctions.vkUnmapMemory)(m_hDevice,<sp/>hMemory);</highlight></codeline>
<codeline lineno="14688"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14689"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14690"><highlight class="normal"></highlight></codeline>
<codeline lineno="14691"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FreeVulkanMemory(memTypeIndex,<sp/>currAlloc-&gt;GetSize(),<sp/>hMemory);</highlight></codeline>
<codeline lineno="14692"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Budget.RemoveAllocation(MemoryTypeIndexToHeapIndex(memTypeIndex),<sp/>currAlloc-&gt;GetSize());</highlight></codeline>
<codeline lineno="14693"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_AllocationObjectAllocator.Free(currAlloc);</highlight></codeline>
<codeline lineno="14694"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14695"><highlight class="normal"></highlight></codeline>
<codeline lineno="14696"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memset(pAllocations,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>)<sp/>*<sp/>allocationCount);</highlight></codeline>
<codeline lineno="14697"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14698"><highlight class="normal"></highlight></codeline>
<codeline lineno="14699"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="14700"><highlight class="normal">}</highlight></codeline>
<codeline lineno="14701"><highlight class="normal"></highlight></codeline>
<codeline lineno="14702"><highlight class="normal">VkResult<sp/>VmaAllocator_T::AllocateDedicatedMemoryPage(</highlight></codeline>
<codeline lineno="14703"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>pool,</highlight></codeline>
<codeline lineno="14704"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size,</highlight></codeline>
<codeline lineno="14705"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>suballocType,</highlight></codeline>
<codeline lineno="14706"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>memTypeIndex,</highlight></codeline>
<codeline lineno="14707"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkMemoryAllocateInfo&amp;<sp/>allocInfo,</highlight></codeline>
<codeline lineno="14708"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>map,</highlight></codeline>
<codeline lineno="14709"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isUserDataString,</highlight></codeline>
<codeline lineno="14710"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>isMappingAllowed,</highlight></codeline>
<codeline lineno="14711"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pUserData,</highlight></codeline>
<codeline lineno="14712"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>pAllocation)</highlight></codeline>
<codeline lineno="14713"><highlight class="normal">{</highlight></codeline>
<codeline lineno="14714"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceMemory<sp/>hMemory<sp/>=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="14715"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>AllocateVulkanMemory(&amp;allocInfo,<sp/>&amp;hMemory);</highlight></codeline>
<codeline lineno="14716"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>&lt;<sp/>0)</highlight></codeline>
<codeline lineno="14717"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14718"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/>vkAllocateMemory<sp/>FAILED&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14719"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="14720"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14721"><highlight class="normal"></highlight></codeline>
<codeline lineno="14722"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pMappedData<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="14723"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(map)</highlight></codeline>
<codeline lineno="14724"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14725"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>(*m_VulkanFunctions.vkMapMemory)(</highlight></codeline>
<codeline lineno="14726"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_hDevice,</highlight></codeline>
<codeline lineno="14727"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>hMemory,</highlight></codeline>
<codeline lineno="14728"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,</highlight></codeline>
<codeline lineno="14729"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VK_WHOLE_SIZE,</highlight></codeline>
<codeline lineno="14730"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,</highlight></codeline>
<codeline lineno="14731"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;pMappedData);</highlight></codeline>
<codeline lineno="14732"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>&lt;<sp/>0)</highlight></codeline>
<codeline lineno="14733"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14734"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/>vkMapMemory<sp/>FAILED&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14735"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FreeVulkanMemory(memTypeIndex,<sp/>size,<sp/>hMemory);</highlight></codeline>
<codeline lineno="14736"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="14737"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14738"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14739"><highlight class="normal"></highlight></codeline>
<codeline lineno="14740"><highlight class="normal"><sp/><sp/><sp/><sp/>*pAllocation<sp/>=<sp/>m_AllocationObjectAllocator.Allocate(isMappingAllowed);</highlight></codeline>
<codeline lineno="14741"><highlight class="normal"><sp/><sp/><sp/><sp/>(*pAllocation)-&gt;InitDedicatedAllocation(pool,<sp/>memTypeIndex,<sp/>hMemory,<sp/>suballocType,<sp/>pMappedData,<sp/>size);</highlight></codeline>
<codeline lineno="14742"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(isUserDataString)</highlight></codeline>
<codeline lineno="14743"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*pAllocation)-&gt;SetName(</highlight><highlight class="keyword">this</highlight><highlight class="normal">,<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*)pUserData);</highlight></codeline>
<codeline lineno="14744"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14745"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*pAllocation)-&gt;SetUserData(</highlight><highlight class="keyword">this</highlight><highlight class="normal">,<sp/>pUserData);</highlight></codeline>
<codeline lineno="14746"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Budget.AddAllocation(MemoryTypeIndexToHeapIndex(memTypeIndex),<sp/>size);</highlight></codeline>
<codeline lineno="14747"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(VMA_DEBUG_INITIALIZE_ALLOCATIONS)</highlight></codeline>
<codeline lineno="14748"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14749"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FillAllocation(*pAllocation,<sp/>VMA_ALLOCATION_FILL_PATTERN_CREATED);</highlight></codeline>
<codeline lineno="14750"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14751"><highlight class="normal"></highlight></codeline>
<codeline lineno="14752"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="14753"><highlight class="normal">}</highlight></codeline>
<codeline lineno="14754"><highlight class="normal"></highlight></codeline>
<codeline lineno="14755"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocator_T::GetBufferMemoryRequirements(</highlight></codeline>
<codeline lineno="14756"><highlight class="normal"><sp/><sp/><sp/><sp/>VkBuffer<sp/>hBuffer,</highlight></codeline>
<codeline lineno="14757"><highlight class="normal"><sp/><sp/><sp/><sp/>VkMemoryRequirements&amp;<sp/>memReq,</highlight></codeline>
<codeline lineno="14758"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">&amp;<sp/>requiresDedicatedAllocation,</highlight></codeline>
<codeline lineno="14759"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">&amp;<sp/>prefersDedicatedAllocation)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="14760"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="14761"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_DEDICATED_ALLOCATION<sp/>||<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1001000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14762"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_UseKhrDedicatedAllocation<sp/>||<sp/>m_VulkanApiVersion<sp/>&gt;=<sp/>VK_MAKE_VERSION(1,<sp/>1,<sp/>0))</highlight></codeline>
<codeline lineno="14763"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14764"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkBufferMemoryRequirementsInfo2KHR<sp/>memReqInfo<sp/>=<sp/>{<sp/>VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR<sp/>};</highlight></codeline>
<codeline lineno="14765"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memReqInfo.buffer<sp/>=<sp/>hBuffer;</highlight></codeline>
<codeline lineno="14766"><highlight class="normal"></highlight></codeline>
<codeline lineno="14767"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkMemoryDedicatedRequirementsKHR<sp/>memDedicatedReq<sp/>=<sp/>{<sp/>VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR<sp/>};</highlight></codeline>
<codeline lineno="14768"><highlight class="normal"></highlight></codeline>
<codeline lineno="14769"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkMemoryRequirements2KHR<sp/>memReq2<sp/>=<sp/>{<sp/>VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR<sp/>};</highlight></codeline>
<codeline lineno="14770"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaPnextChainPushFront(&amp;memReq2,<sp/>&amp;memDedicatedReq);</highlight></codeline>
<codeline lineno="14771"><highlight class="normal"></highlight></codeline>
<codeline lineno="14772"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*m_VulkanFunctions.vkGetBufferMemoryRequirements2KHR)(m_hDevice,<sp/>&amp;memReqInfo,<sp/>&amp;memReq2);</highlight></codeline>
<codeline lineno="14773"><highlight class="normal"></highlight></codeline>
<codeline lineno="14774"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memReq<sp/>=<sp/>memReq2.memoryRequirements;</highlight></codeline>
<codeline lineno="14775"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>requiresDedicatedAllocation<sp/>=<sp/>(memDedicatedReq.requiresDedicatedAllocation<sp/>!=<sp/>VK_FALSE);</highlight></codeline>
<codeline lineno="14776"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prefersDedicatedAllocation<sp/><sp/>=<sp/>(memDedicatedReq.prefersDedicatedAllocation<sp/><sp/>!=<sp/>VK_FALSE);</highlight></codeline>
<codeline lineno="14777"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14778"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14779"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>VMA_DEDICATED_ALLOCATION<sp/>||<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1001000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14780"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14781"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*m_VulkanFunctions.vkGetBufferMemoryRequirements)(m_hDevice,<sp/>hBuffer,<sp/>&amp;memReq);</highlight></codeline>
<codeline lineno="14782"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>requiresDedicatedAllocation<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="14783"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prefersDedicatedAllocation<sp/><sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="14784"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14785"><highlight class="normal">}</highlight></codeline>
<codeline lineno="14786"><highlight class="normal"></highlight></codeline>
<codeline lineno="14787"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocator_T::GetImageMemoryRequirements(</highlight></codeline>
<codeline lineno="14788"><highlight class="normal"><sp/><sp/><sp/><sp/>VkImage<sp/>hImage,</highlight></codeline>
<codeline lineno="14789"><highlight class="normal"><sp/><sp/><sp/><sp/>VkMemoryRequirements&amp;<sp/>memReq,</highlight></codeline>
<codeline lineno="14790"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">&amp;<sp/>requiresDedicatedAllocation,</highlight></codeline>
<codeline lineno="14791"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">&amp;<sp/>prefersDedicatedAllocation)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="14792"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="14793"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_DEDICATED_ALLOCATION<sp/>||<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1001000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14794"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_UseKhrDedicatedAllocation<sp/>||<sp/>m_VulkanApiVersion<sp/>&gt;=<sp/>VK_MAKE_VERSION(1,<sp/>1,<sp/>0))</highlight></codeline>
<codeline lineno="14795"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14796"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkImageMemoryRequirementsInfo2KHR<sp/>memReqInfo<sp/>=<sp/>{<sp/>VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR<sp/>};</highlight></codeline>
<codeline lineno="14797"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memReqInfo.image<sp/>=<sp/>hImage;</highlight></codeline>
<codeline lineno="14798"><highlight class="normal"></highlight></codeline>
<codeline lineno="14799"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkMemoryDedicatedRequirementsKHR<sp/>memDedicatedReq<sp/>=<sp/>{<sp/>VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR<sp/>};</highlight></codeline>
<codeline lineno="14800"><highlight class="normal"></highlight></codeline>
<codeline lineno="14801"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkMemoryRequirements2KHR<sp/>memReq2<sp/>=<sp/>{<sp/>VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR<sp/>};</highlight></codeline>
<codeline lineno="14802"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaPnextChainPushFront(&amp;memReq2,<sp/>&amp;memDedicatedReq);</highlight></codeline>
<codeline lineno="14803"><highlight class="normal"></highlight></codeline>
<codeline lineno="14804"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*m_VulkanFunctions.vkGetImageMemoryRequirements2KHR)(m_hDevice,<sp/>&amp;memReqInfo,<sp/>&amp;memReq2);</highlight></codeline>
<codeline lineno="14805"><highlight class="normal"></highlight></codeline>
<codeline lineno="14806"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memReq<sp/>=<sp/>memReq2.memoryRequirements;</highlight></codeline>
<codeline lineno="14807"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>requiresDedicatedAllocation<sp/>=<sp/>(memDedicatedReq.requiresDedicatedAllocation<sp/>!=<sp/>VK_FALSE);</highlight></codeline>
<codeline lineno="14808"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prefersDedicatedAllocation<sp/><sp/>=<sp/>(memDedicatedReq.prefersDedicatedAllocation<sp/><sp/>!=<sp/>VK_FALSE);</highlight></codeline>
<codeline lineno="14809"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14810"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14811"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>VMA_DEDICATED_ALLOCATION<sp/>||<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1001000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14812"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14813"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*m_VulkanFunctions.vkGetImageMemoryRequirements)(m_hDevice,<sp/>hImage,<sp/>&amp;memReq);</highlight></codeline>
<codeline lineno="14814"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>requiresDedicatedAllocation<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="14815"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prefersDedicatedAllocation<sp/><sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="14816"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14817"><highlight class="normal">}</highlight></codeline>
<codeline lineno="14818"><highlight class="normal"></highlight></codeline>
<codeline lineno="14819"><highlight class="normal">VkResult<sp/>VmaAllocator_T::FindMemoryTypeIndex(</highlight></codeline>
<codeline lineno="14820"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>memoryTypeBits,</highlight></codeline>
<codeline lineno="14821"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>*<sp/>pAllocationCreateInfo,</highlight></codeline>
<codeline lineno="14822"><highlight class="normal"><sp/><sp/><sp/><sp/>VkFlags<sp/>bufImgUsage,</highlight></codeline>
<codeline lineno="14823"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t*<sp/>pMemoryTypeIndex)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="14824"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="14825"><highlight class="normal"><sp/><sp/><sp/><sp/>memoryTypeBits<sp/>&amp;=<sp/>GetGlobalMemoryTypeBits();</highlight></codeline>
<codeline lineno="14826"><highlight class="normal"></highlight></codeline>
<codeline lineno="14827"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pAllocationCreateInfo-&gt;<ref refid="struct_vma_allocation_create_info_1a3bf940c0271d85d6ba32a4d820075055" kindref="member">memoryTypeBits</ref><sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="14828"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14829"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memoryTypeBits<sp/>&amp;=<sp/>pAllocationCreateInfo-&gt;<ref refid="struct_vma_allocation_create_info_1a3bf940c0271d85d6ba32a4d820075055" kindref="member">memoryTypeBits</ref>;</highlight></codeline>
<codeline lineno="14830"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14831"><highlight class="normal"></highlight></codeline>
<codeline lineno="14832"><highlight class="normal"><sp/><sp/><sp/><sp/>VkMemoryPropertyFlags<sp/>requiredFlags<sp/>=<sp/>0,<sp/>preferredFlags<sp/>=<sp/>0,<sp/>notPreferredFlags<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="14833"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!FindMemoryPreferences(</highlight></codeline>
<codeline lineno="14834"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IsIntegratedGpu(),</highlight></codeline>
<codeline lineno="14835"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pAllocationCreateInfo,</highlight></codeline>
<codeline lineno="14836"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bufImgUsage,</highlight></codeline>
<codeline lineno="14837"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>requiredFlags,<sp/>preferredFlags,<sp/>notPreferredFlags))</highlight></codeline>
<codeline lineno="14838"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14839"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_FEATURE_NOT_PRESENT;</highlight></codeline>
<codeline lineno="14840"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14841"><highlight class="normal"></highlight></codeline>
<codeline lineno="14842"><highlight class="normal"><sp/><sp/><sp/><sp/>*pMemoryTypeIndex<sp/>=<sp/>UINT32_MAX;</highlight></codeline>
<codeline lineno="14843"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>minCost<sp/>=<sp/>UINT32_MAX;</highlight></codeline>
<codeline lineno="14844"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(uint32_t<sp/>memTypeIndex<sp/>=<sp/>0,<sp/>memTypeBit<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="14845"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memTypeIndex<sp/>&lt;<sp/>GetMemoryTypeCount();</highlight></codeline>
<codeline lineno="14846"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++memTypeIndex,<sp/>memTypeBit<sp/>&lt;&lt;=<sp/>1)</highlight></codeline>
<codeline lineno="14847"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14848"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>memory<sp/>type<sp/>is<sp/>acceptable<sp/>according<sp/>to<sp/>memoryTypeBits<sp/>bitmask.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14849"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">((memTypeBit<sp/>&amp;<sp/>memoryTypeBits)<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="14850"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14851"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkMemoryPropertyFlags<sp/>currFlags<sp/>=</highlight></codeline>
<codeline lineno="14852"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_MemProps.memoryTypes[memTypeIndex].propertyFlags;</highlight></codeline>
<codeline lineno="14853"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>memory<sp/>type<sp/>contains<sp/>requiredFlags.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14854"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">((requiredFlags<sp/>&amp;<sp/>~currFlags)<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="14855"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14856"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Calculate<sp/>cost<sp/>as<sp/>number<sp/>of<sp/>bits<sp/>from<sp/>preferredFlags<sp/>not<sp/>present<sp/>in<sp/>this<sp/>memory<sp/>type.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14857"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>currCost<sp/>=<sp/>VMA_COUNT_BITS_SET(preferredFlags<sp/>&amp;<sp/>~currFlags)<sp/>+</highlight></codeline>
<codeline lineno="14858"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_COUNT_BITS_SET(currFlags<sp/>&amp;<sp/>notPreferredFlags);</highlight></codeline>
<codeline lineno="14859"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Remember<sp/>memory<sp/>type<sp/>with<sp/>lowest<sp/>cost.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14860"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(currCost<sp/>&lt;<sp/>minCost)</highlight></codeline>
<codeline lineno="14861"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14862"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pMemoryTypeIndex<sp/>=<sp/>memTypeIndex;</highlight></codeline>
<codeline lineno="14863"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(currCost<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="14864"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14865"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="14866"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14867"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>minCost<sp/>=<sp/>currCost;</highlight></codeline>
<codeline lineno="14868"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14869"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14870"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14871"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14872"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(*pMemoryTypeIndex<sp/>!=<sp/>UINT32_MAX)<sp/>?<sp/>VK_SUCCESS<sp/>:<sp/>VK_ERROR_FEATURE_NOT_PRESENT;</highlight></codeline>
<codeline lineno="14873"><highlight class="normal">}</highlight></codeline>
<codeline lineno="14874"><highlight class="normal"></highlight></codeline>
<codeline lineno="14875"><highlight class="normal">VkResult<sp/>VmaAllocator_T::CalcMemTypeParams(</highlight></codeline>
<codeline lineno="14876"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>&amp;<sp/>inoutCreateInfo,</highlight></codeline>
<codeline lineno="14877"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>memTypeIndex,</highlight></codeline>
<codeline lineno="14878"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size,</highlight></codeline>
<codeline lineno="14879"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>allocationCount)</highlight></codeline>
<codeline lineno="14880"><highlight class="normal">{</highlight></codeline>
<codeline lineno="14881"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>memory<sp/>type<sp/>is<sp/>not<sp/>HOST_VISIBLE,<sp/>disable<sp/>MAPPED.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14882"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">((inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" kindref="member">VMA_ALLOCATION_CREATE_MAPPED_BIT</ref>)<sp/>!=<sp/>0<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="14883"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(m_MemProps.memoryTypes[memTypeIndex].propertyFlags<sp/>&amp;<sp/>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="14884"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14885"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;=<sp/>~VMA_ALLOCATION_CREATE_MAPPED_BIT;</highlight></codeline>
<codeline lineno="14886"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14887"><highlight class="normal"></highlight></codeline>
<codeline lineno="14888"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">((inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" kindref="member">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</ref>)<sp/>!=<sp/>0<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="14889"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597ab8b1764f3e9022368e440c057783b92d" kindref="member">VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT</ref>)<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="14890"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14891"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>heapIndex<sp/>=<sp/>MemoryTypeIndexToHeapIndex(memTypeIndex);</highlight></codeline>
<codeline lineno="14892"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_budget" kindref="compound">VmaBudget</ref><sp/>heapBudget<sp/>=<sp/>{};</highlight></codeline>
<codeline lineno="14893"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>GetHeapBudgets(&amp;heapBudget,<sp/>heapIndex,<sp/>1);</highlight></codeline>
<codeline lineno="14894"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(heapBudget.<ref refid="struct_vma_budget_1a84dd1ecca8b0110259eb206dbadb11f6" kindref="member">usage</ref><sp/>+<sp/>size<sp/>*<sp/>allocationCount<sp/>&gt;<sp/>heapBudget.<ref refid="struct_vma_budget_1ab82e1d1754c2d210d0bdf90220bc6cdd" kindref="member">budget</ref>)</highlight></codeline>
<codeline lineno="14895"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14896"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_OUT_OF_DEVICE_MEMORY;</highlight></codeline>
<codeline lineno="14897"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14898"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14899"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="14900"><highlight class="normal">}</highlight></codeline>
<codeline lineno="14901"><highlight class="normal"></highlight></codeline>
<codeline lineno="14902"><highlight class="normal">VkResult<sp/>VmaAllocator_T::CalcAllocationParams(</highlight></codeline>
<codeline lineno="14903"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>&amp;<sp/>inoutCreateInfo,</highlight></codeline>
<codeline lineno="14904"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>dedicatedRequired,</highlight></codeline>
<codeline lineno="14905"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>dedicatedPreferred)</highlight></codeline>
<codeline lineno="14906"><highlight class="normal">{</highlight></codeline>
<codeline lineno="14907"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT((inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;</highlight></codeline>
<codeline lineno="14908"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(<ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</ref><sp/>|<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</ref>))<sp/>!=</highlight></codeline>
<codeline lineno="14909"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(<ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</ref><sp/>|<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</ref>)<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="14910"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;Specifying<sp/>both<sp/>flags<sp/>VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT<sp/>and<sp/>VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT<sp/>is<sp/>incorrect.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14911"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT((((inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11337f96eacf34c1016c339eac165cad" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</ref>)<sp/>==<sp/>0<sp/>||</highlight></codeline>
<codeline lineno="14912"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/>(<ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</ref><sp/>|<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</ref>))<sp/>!=<sp/>0))<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="14913"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;Specifying<sp/>VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT<sp/>requires<sp/>also<sp/>VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT<sp/>or<sp/>VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14914"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1accb8b06b1f677d858cb9af20705fa910" kindref="member">usage</ref><sp/>==<sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e" kindref="member">VMA_MEMORY_USAGE_AUTO</ref><sp/>||<sp/>inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1accb8b06b1f677d858cb9af20705fa910" kindref="member">usage</ref><sp/>==<sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305ccae2adb696d6a73c18bb20c23666661327" kindref="member">VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE</ref><sp/>||<sp/>inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1accb8b06b1f677d858cb9af20705fa910" kindref="member">usage</ref><sp/>==<sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca9b422585242160b8ed3418310ee6664d" kindref="member">VMA_MEMORY_USAGE_AUTO_PREFER_HOST</ref>)</highlight></codeline>
<codeline lineno="14915"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14916"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">((inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" kindref="member">VMA_ALLOCATION_CREATE_MAPPED_BIT</ref>)<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="14917"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14918"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT((inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/>(<ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</ref><sp/>|<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</ref>))<sp/>!=<sp/>0<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="14919"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;When<sp/>using<sp/>VMA_ALLOCATION_CREATE_MAPPED_BIT<sp/>and<sp/>usage<sp/>=<sp/>VMA_MEMORY_USAGE_AUTO*,<sp/>you<sp/>must<sp/>also<sp/>specify<sp/>VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT<sp/>or<sp/>VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14920"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14921"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14922"><highlight class="normal"></highlight></codeline>
<codeline lineno="14923"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>memory<sp/>is<sp/>lazily<sp/>allocated,<sp/>it<sp/>should<sp/>be<sp/>always<sp/>dedicated.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14924"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(dedicatedRequired<sp/>||</highlight></codeline>
<codeline lineno="14925"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1accb8b06b1f677d858cb9af20705fa910" kindref="member">usage</ref><sp/>==<sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca835333d9072db63a653818030e17614d" kindref="member">VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED</ref>)</highlight></codeline>
<codeline lineno="14926"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14927"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>|=<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" kindref="member">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</ref>;</highlight></codeline>
<codeline lineno="14928"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14929"><highlight class="normal"></highlight></codeline>
<codeline lineno="14930"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1ad5aa903b9be1fa934abf2dd6c650fca6" kindref="member">pool</ref><sp/>!=<sp/>VK_NULL_HANDLE)</highlight></codeline>
<codeline lineno="14931"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14932"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1ad5aa903b9be1fa934abf2dd6c650fca6" kindref="member">pool</ref>-&gt;m_BlockVector.HasExplicitBlockSize()<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="14933"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" kindref="member">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</ref>)<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="14934"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14935"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Specifying<sp/>VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT<sp/>while<sp/>current<sp/>custom<sp/>pool<sp/>doesn&apos;t<sp/>support<sp/>dedicated<sp/>allocations.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14936"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_FEATURE_NOT_PRESENT;</highlight></codeline>
<codeline lineno="14937"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14938"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1a983d39e1a2e63649d78a960aa2fdd0f7" kindref="member">priority</ref><sp/>=<sp/>inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1ad5aa903b9be1fa934abf2dd6c650fca6" kindref="member">pool</ref>-&gt;m_BlockVector.GetPriority();</highlight></codeline>
<codeline lineno="14939"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14940"><highlight class="normal"></highlight></codeline>
<codeline lineno="14941"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">((inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" kindref="member">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</ref>)<sp/>!=<sp/>0<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="14942"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a89759603401014eb325eb22a3839f2ff" kindref="member">VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</ref>)<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="14943"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14944"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Specifying<sp/>VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT<sp/>together<sp/>with<sp/>VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT<sp/>makes<sp/>no<sp/>sense.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="14945"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_FEATURE_NOT_PRESENT;</highlight></codeline>
<codeline lineno="14946"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14947"><highlight class="normal"></highlight></codeline>
<codeline lineno="14948"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(VMA_DEBUG_ALWAYS_DEDICATED_MEMORY<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="14949"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a89759603401014eb325eb22a3839f2ff" kindref="member">VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</ref>)<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="14950"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14951"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>|=<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" kindref="member">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</ref>;</highlight></codeline>
<codeline lineno="14952"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14953"><highlight class="normal"></highlight></codeline>
<codeline lineno="14954"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Non-auto<sp/>USAGE<sp/>values<sp/>imply<sp/>HOST_ACCESS<sp/>flags.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14955"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>And<sp/>so<sp/>does<sp/>VMA_MEMORY_USAGE_UNKNOWN<sp/>because<sp/>it<sp/>is<sp/>used<sp/>with<sp/>custom<sp/>pools.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14956"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Which<sp/>specific<sp/>flag<sp/>is<sp/>used<sp/>doesn&apos;t<sp/>matter.<sp/>They<sp/>change<sp/>things<sp/>only<sp/>when<sp/>used<sp/>with<sp/>VMA_MEMORY_USAGE_AUTO*.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14957"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Otherwise<sp/>they<sp/>just<sp/>protect<sp/>from<sp/>assert<sp/>on<sp/>mapping.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14958"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1accb8b06b1f677d858cb9af20705fa910" kindref="member">usage</ref><sp/>!=<sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e" kindref="member">VMA_MEMORY_USAGE_AUTO</ref><sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="14959"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1accb8b06b1f677d858cb9af20705fa910" kindref="member">usage</ref><sp/>!=<sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305ccae2adb696d6a73c18bb20c23666661327" kindref="member">VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE</ref><sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="14960"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1accb8b06b1f677d858cb9af20705fa910" kindref="member">usage</ref><sp/>!=<sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca9b422585242160b8ed3418310ee6664d" kindref="member">VMA_MEMORY_USAGE_AUTO_PREFER_HOST</ref>)</highlight></codeline>
<codeline lineno="14961"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14962"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">((inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/>(<ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</ref><sp/>|<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</ref>))<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="14963"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14964"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inoutCreateInfo.<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>|=<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</ref>;</highlight></codeline>
<codeline lineno="14965"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14966"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14967"><highlight class="normal"></highlight></codeline>
<codeline lineno="14968"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="14969"><highlight class="normal">}</highlight></codeline>
<codeline lineno="14970"><highlight class="normal"></highlight></codeline>
<codeline lineno="14971"><highlight class="normal">VkResult<sp/>VmaAllocator_T::AllocateMemory(</highlight></codeline>
<codeline lineno="14972"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkMemoryRequirements&amp;<sp/>vkMemReq,</highlight></codeline>
<codeline lineno="14973"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>requiresDedicatedAllocation,</highlight></codeline>
<codeline lineno="14974"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>prefersDedicatedAllocation,</highlight></codeline>
<codeline lineno="14975"><highlight class="normal"><sp/><sp/><sp/><sp/>VkBuffer<sp/>dedicatedBuffer,</highlight></codeline>
<codeline lineno="14976"><highlight class="normal"><sp/><sp/><sp/><sp/>VkImage<sp/>dedicatedImage,</highlight></codeline>
<codeline lineno="14977"><highlight class="normal"><sp/><sp/><sp/><sp/>VkFlags<sp/>dedicatedBufferImageUsage,</highlight></codeline>
<codeline lineno="14978"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>&amp;<sp/>createInfo,</highlight></codeline>
<codeline lineno="14979"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>suballocType,</highlight></codeline>
<codeline lineno="14980"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>allocationCount,</highlight></codeline>
<codeline lineno="14981"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>pAllocations)</highlight></codeline>
<codeline lineno="14982"><highlight class="normal">{</highlight></codeline>
<codeline lineno="14983"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(pAllocations,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>)<sp/>*<sp/>allocationCount);</highlight></codeline>
<codeline lineno="14984"><highlight class="normal"></highlight></codeline>
<codeline lineno="14985"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(VmaIsPow2(vkMemReq.alignment));</highlight></codeline>
<codeline lineno="14986"><highlight class="normal"></highlight></codeline>
<codeline lineno="14987"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(vkMemReq.size<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="14988"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14989"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_INITIALIZATION_FAILED;</highlight></codeline>
<codeline lineno="14990"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="14991"><highlight class="normal"></highlight></codeline>
<codeline lineno="14992"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref><sp/>createInfoFinal<sp/>=<sp/>createInfo;</highlight></codeline>
<codeline lineno="14993"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>CalcAllocationParams(createInfoFinal,<sp/>requiresDedicatedAllocation,<sp/>prefersDedicatedAllocation);</highlight></codeline>
<codeline lineno="14994"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>!=<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="14995"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="14996"><highlight class="normal"></highlight></codeline>
<codeline lineno="14997"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(createInfoFinal.<ref refid="struct_vma_allocation_create_info_1ad5aa903b9be1fa934abf2dd6c650fca6" kindref="member">pool</ref><sp/>!=<sp/>VK_NULL_HANDLE)</highlight></codeline>
<codeline lineno="14998"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="14999"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaBlockVector&amp;<sp/>blockVector<sp/>=<sp/>createInfoFinal.<ref refid="struct_vma_allocation_create_info_1ad5aa903b9be1fa934abf2dd6c650fca6" kindref="member">pool</ref>-&gt;m_BlockVector;</highlight></codeline>
<codeline lineno="15000"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>AllocateMemoryOfType(</highlight></codeline>
<codeline lineno="15001"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>createInfoFinal.<ref refid="struct_vma_allocation_create_info_1ad5aa903b9be1fa934abf2dd6c650fca6" kindref="member">pool</ref>,</highlight></codeline>
<codeline lineno="15002"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vkMemReq.size,</highlight></codeline>
<codeline lineno="15003"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vkMemReq.alignment,</highlight></codeline>
<codeline lineno="15004"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prefersDedicatedAllocation,</highlight></codeline>
<codeline lineno="15005"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dedicatedBuffer,</highlight></codeline>
<codeline lineno="15006"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dedicatedImage,</highlight></codeline>
<codeline lineno="15007"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dedicatedBufferImageUsage,</highlight></codeline>
<codeline lineno="15008"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>createInfoFinal,</highlight></codeline>
<codeline lineno="15009"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>blockVector.GetMemoryTypeIndex(),</highlight></codeline>
<codeline lineno="15010"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocType,</highlight></codeline>
<codeline lineno="15011"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>createInfoFinal.<ref refid="struct_vma_allocation_create_info_1ad5aa903b9be1fa934abf2dd6c650fca6" kindref="member">pool</ref>-&gt;m_DedicatedAllocations,</highlight></codeline>
<codeline lineno="15012"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>blockVector,</highlight></codeline>
<codeline lineno="15013"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocationCount,</highlight></codeline>
<codeline lineno="15014"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocations);</highlight></codeline>
<codeline lineno="15015"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15016"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15017"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15018"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Bit<sp/>mask<sp/>of<sp/>memory<sp/>Vulkan<sp/>types<sp/>acceptable<sp/>for<sp/>this<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15019"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>memoryTypeBits<sp/>=<sp/>vkMemReq.memoryTypeBits;</highlight></codeline>
<codeline lineno="15020"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>memTypeIndex<sp/>=<sp/>UINT32_MAX;</highlight></codeline>
<codeline lineno="15021"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>FindMemoryTypeIndex(memoryTypeBits,<sp/>&amp;createInfoFinal,<sp/>dedicatedBufferImageUsage,<sp/>&amp;memTypeIndex);</highlight></codeline>
<codeline lineno="15022"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Can&apos;t<sp/>find<sp/>any<sp/>single<sp/>memory<sp/>type<sp/>matching<sp/>requirements.<sp/>res<sp/>is<sp/>VK_ERROR_FEATURE_NOT_PRESENT.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15023"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>!=<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="15024"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="15025"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15026"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15027"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaBlockVector*<sp/>blockVector<sp/>=<sp/>m_pBlockVectors[memTypeIndex];</highlight></codeline>
<codeline lineno="15028"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(blockVector<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Trying<sp/>to<sp/>use<sp/>unsupported<sp/>memory<sp/>type!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="15029"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>AllocateMemoryOfType(</highlight></codeline>
<codeline lineno="15030"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VK_NULL_HANDLE,</highlight></codeline>
<codeline lineno="15031"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vkMemReq.size,</highlight></codeline>
<codeline lineno="15032"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vkMemReq.alignment,</highlight></codeline>
<codeline lineno="15033"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>requiresDedicatedAllocation<sp/>||<sp/>prefersDedicatedAllocation,</highlight></codeline>
<codeline lineno="15034"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dedicatedBuffer,</highlight></codeline>
<codeline lineno="15035"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dedicatedImage,</highlight></codeline>
<codeline lineno="15036"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dedicatedBufferImageUsage,</highlight></codeline>
<codeline lineno="15037"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>createInfoFinal,</highlight></codeline>
<codeline lineno="15038"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memTypeIndex,</highlight></codeline>
<codeline lineno="15039"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocType,</highlight></codeline>
<codeline lineno="15040"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_DedicatedAllocations[memTypeIndex],</highlight></codeline>
<codeline lineno="15041"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*blockVector,</highlight></codeline>
<codeline lineno="15042"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocationCount,</highlight></codeline>
<codeline lineno="15043"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocations);</highlight></codeline>
<codeline lineno="15044"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Allocation<sp/>succeeded</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15045"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>==<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="15046"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="15047"><highlight class="normal"></highlight></codeline>
<codeline lineno="15048"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Remove<sp/>old<sp/>memTypeIndex<sp/>from<sp/>list<sp/>of<sp/>possibilities.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15049"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memoryTypeBits<sp/>&amp;=<sp/>~(1u<sp/>&lt;&lt;<sp/>memTypeIndex);</highlight></codeline>
<codeline lineno="15050"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Find<sp/>alternative<sp/>memTypeIndex.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15051"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>FindMemoryTypeIndex(memoryTypeBits,<sp/>&amp;createInfoFinal,<sp/>dedicatedBufferImageUsage,<sp/>&amp;memTypeIndex);</highlight></codeline>
<codeline lineno="15052"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal">(res<sp/>==<sp/>VK_SUCCESS);</highlight></codeline>
<codeline lineno="15053"><highlight class="normal"></highlight></codeline>
<codeline lineno="15054"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>No<sp/>other<sp/>matching<sp/>memory<sp/>type<sp/>index<sp/>could<sp/>be<sp/>found.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15055"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Not<sp/>returning<sp/>res,<sp/>which<sp/>is<sp/>VK_ERROR_FEATURE_NOT_PRESENT,<sp/>because<sp/>we<sp/>already<sp/>failed<sp/>to<sp/>allocate<sp/>once.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15056"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_OUT_OF_DEVICE_MEMORY;</highlight></codeline>
<codeline lineno="15057"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15058"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15059"><highlight class="normal"></highlight></codeline>
<codeline lineno="15060"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocator_T::FreeMemory(</highlight></codeline>
<codeline lineno="15061"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>allocationCount,</highlight></codeline>
<codeline lineno="15062"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>pAllocations)</highlight></codeline>
<codeline lineno="15063"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15064"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(pAllocations);</highlight></codeline>
<codeline lineno="15065"><highlight class="normal"></highlight></codeline>
<codeline lineno="15066"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>allocIndex<sp/>=<sp/>allocationCount;<sp/>allocIndex--;<sp/>)</highlight></codeline>
<codeline lineno="15067"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15068"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>allocation<sp/>=<sp/>pAllocations[allocIndex];</highlight></codeline>
<codeline lineno="15069"><highlight class="normal"></highlight></codeline>
<codeline lineno="15070"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(allocation<sp/>!=<sp/>VK_NULL_HANDLE)</highlight></codeline>
<codeline lineno="15071"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15072"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(VMA_DEBUG_INITIALIZE_ALLOCATIONS)</highlight></codeline>
<codeline lineno="15073"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15074"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FillAllocation(allocation,<sp/>VMA_ALLOCATION_FILL_PATTERN_DESTROYED);</highlight></codeline>
<codeline lineno="15075"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15076"><highlight class="normal"></highlight></codeline>
<codeline lineno="15077"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocation-&gt;FreeName(</highlight><highlight class="keyword">this</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="15078"><highlight class="normal"></highlight></codeline>
<codeline lineno="15079"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal">(allocation-&gt;GetType())</highlight></codeline>
<codeline lineno="15080"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15081"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VmaAllocation_T::ALLOCATION_TYPE_BLOCK:</highlight></codeline>
<codeline lineno="15082"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15083"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaBlockVector*<sp/>pBlockVector<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="15084"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>hPool<sp/>=<sp/>allocation-&gt;GetParentPool();</highlight></codeline>
<codeline lineno="15085"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(hPool<sp/>!=<sp/>VK_NULL_HANDLE)</highlight></codeline>
<codeline lineno="15086"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15087"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pBlockVector<sp/>=<sp/>&amp;hPool-&gt;m_BlockVector;</highlight></codeline>
<codeline lineno="15088"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15089"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15090"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15091"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>memTypeIndex<sp/>=<sp/>allocation-&gt;GetMemoryTypeIndex();</highlight></codeline>
<codeline lineno="15092"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pBlockVector<sp/>=<sp/>m_pBlockVectors[memTypeIndex];</highlight></codeline>
<codeline lineno="15093"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(pBlockVector<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Trying<sp/>to<sp/>free<sp/>memory<sp/>of<sp/>unsupported<sp/>type!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="15094"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15095"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pBlockVector-&gt;Free(allocation);</highlight></codeline>
<codeline lineno="15096"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15097"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="15098"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VmaAllocation_T::ALLOCATION_TYPE_DEDICATED:</highlight></codeline>
<codeline lineno="15099"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FreeDedicatedMemory(allocation);</highlight></codeline>
<codeline lineno="15100"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="15101"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="15102"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="15103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15105"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15106"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15107"><highlight class="normal"></highlight></codeline>
<codeline lineno="15108"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocator_T::CalculateStatistics(<ref refid="struct_vma_total_statistics" kindref="compound">VmaTotalStatistics</ref>*<sp/>pStats)</highlight></codeline>
<codeline lineno="15109"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15110"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Initialize.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15111"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaClearDetailedStatistics(pStats-&gt;<ref refid="struct_vma_total_statistics_1a76f1935f7101883f5bb2a03b6c5649d2" kindref="member">total</ref>);</highlight></codeline>
<codeline lineno="15112"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(uint32_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>VK_MAX_MEMORY_TYPES;<sp/>++i)</highlight></codeline>
<codeline lineno="15113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaClearDetailedStatistics(pStats-&gt;<ref refid="struct_vma_total_statistics_1acb70e5b7fe543813ed8ba9282640969d" kindref="member">memoryType</ref>[i]);</highlight></codeline>
<codeline lineno="15114"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(uint32_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>VK_MAX_MEMORY_HEAPS;<sp/>++i)</highlight></codeline>
<codeline lineno="15115"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaClearDetailedStatistics(pStats-&gt;<ref refid="struct_vma_total_statistics_1a39beeba5b3a2e7cfe5f5e2331a2705ce" kindref="member">memoryHeap</ref>[i]);</highlight></codeline>
<codeline lineno="15116"><highlight class="normal"></highlight></codeline>
<codeline lineno="15117"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Process<sp/>default<sp/>pools.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15118"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(uint32_t<sp/>memTypeIndex<sp/>=<sp/>0;<sp/>memTypeIndex<sp/>&lt;<sp/>GetMemoryTypeCount();<sp/>++memTypeIndex)</highlight></codeline>
<codeline lineno="15119"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15120"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaBlockVector*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>pBlockVector<sp/>=<sp/>m_pBlockVectors[memTypeIndex];</highlight></codeline>
<codeline lineno="15121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(pBlockVector<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="15122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pBlockVector-&gt;AddDetailedStatistics(pStats-&gt;<ref refid="struct_vma_total_statistics_1acb70e5b7fe543813ed8ba9282640969d" kindref="member">memoryType</ref>[memTypeIndex]);</highlight></codeline>
<codeline lineno="15123"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15124"><highlight class="normal"></highlight></codeline>
<codeline lineno="15125"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Process<sp/>custom<sp/>pools.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15126"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15127"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaMutexLockRead<sp/>lock(m_PoolsMutex,<sp/>m_UseMutex);</highlight></codeline>
<codeline lineno="15128"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(<ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>pool<sp/>=<sp/>m_Pools.Front();<sp/>pool<sp/>!=<sp/>VMA_NULL;<sp/>pool<sp/>=<sp/>m_Pools.GetNext(pool))</highlight></codeline>
<codeline lineno="15129"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaBlockVector&amp;<sp/>blockVector<sp/>=<sp/>pool-&gt;m_BlockVector;</highlight></codeline>
<codeline lineno="15131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>memTypeIndex<sp/>=<sp/>blockVector.GetMemoryTypeIndex();</highlight></codeline>
<codeline lineno="15132"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>blockVector.AddDetailedStatistics(pStats-&gt;<ref refid="struct_vma_total_statistics_1acb70e5b7fe543813ed8ba9282640969d" kindref="member">memoryType</ref>[memTypeIndex]);</highlight></codeline>
<codeline lineno="15133"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pool-&gt;m_DedicatedAllocations.AddDetailedStatistics(pStats-&gt;<ref refid="struct_vma_total_statistics_1acb70e5b7fe543813ed8ba9282640969d" kindref="member">memoryType</ref>[memTypeIndex]);</highlight></codeline>
<codeline lineno="15134"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15135"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15136"><highlight class="normal"></highlight></codeline>
<codeline lineno="15137"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Process<sp/>dedicated<sp/>allocations.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15138"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(uint32_t<sp/>memTypeIndex<sp/>=<sp/>0;<sp/>memTypeIndex<sp/>&lt;<sp/>GetMemoryTypeCount();<sp/>++memTypeIndex)</highlight></codeline>
<codeline lineno="15139"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15140"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_DedicatedAllocations[memTypeIndex].AddDetailedStatistics(pStats-&gt;<ref refid="struct_vma_total_statistics_1acb70e5b7fe543813ed8ba9282640969d" kindref="member">memoryType</ref>[memTypeIndex]);</highlight></codeline>
<codeline lineno="15141"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15142"><highlight class="normal"></highlight></codeline>
<codeline lineno="15143"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Sum<sp/>from<sp/>memory<sp/>types<sp/>to<sp/>memory<sp/>heaps.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15144"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(uint32_t<sp/>memTypeIndex<sp/>=<sp/>0;<sp/>memTypeIndex<sp/>&lt;<sp/>GetMemoryTypeCount();<sp/>++memTypeIndex)</highlight></codeline>
<codeline lineno="15145"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>memHeapIndex<sp/>=<sp/>m_MemProps.memoryTypes[memTypeIndex].heapIndex;</highlight></codeline>
<codeline lineno="15147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAddDetailedStatistics(pStats-&gt;<ref refid="struct_vma_total_statistics_1a39beeba5b3a2e7cfe5f5e2331a2705ce" kindref="member">memoryHeap</ref>[memHeapIndex],<sp/>pStats-&gt;<ref refid="struct_vma_total_statistics_1acb70e5b7fe543813ed8ba9282640969d" kindref="member">memoryType</ref>[memTypeIndex]);</highlight></codeline>
<codeline lineno="15148"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15149"><highlight class="normal"></highlight></codeline>
<codeline lineno="15150"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Sum<sp/>from<sp/>memory<sp/>heaps<sp/>to<sp/>total.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15151"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(uint32_t<sp/>memHeapIndex<sp/>=<sp/>0;<sp/>memHeapIndex<sp/>&lt;<sp/>GetMemoryHeapCount();<sp/>++memHeapIndex)</highlight></codeline>
<codeline lineno="15152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAddDetailedStatistics(pStats-&gt;<ref refid="struct_vma_total_statistics_1a76f1935f7101883f5bb2a03b6c5649d2" kindref="member">total</ref>,<sp/>pStats-&gt;<ref refid="struct_vma_total_statistics_1a39beeba5b3a2e7cfe5f5e2331a2705ce" kindref="member">memoryHeap</ref>[memHeapIndex]);</highlight></codeline>
<codeline lineno="15153"><highlight class="normal"></highlight></codeline>
<codeline lineno="15154"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(pStats-&gt;<ref refid="struct_vma_total_statistics_1a76f1935f7101883f5bb2a03b6c5649d2" kindref="member">total</ref>.<ref refid="struct_vma_detailed_statistics_1a13efbdb35bd1291191d275f43e96d360" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1ab0ff76e50f58f9f54b6f265e5bf5dde2" kindref="member">allocationCount</ref><sp/>==<sp/>0<sp/>||</highlight></codeline>
<codeline lineno="15155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pStats-&gt;<ref refid="struct_vma_total_statistics_1a76f1935f7101883f5bb2a03b6c5649d2" kindref="member">total</ref>.<ref refid="struct_vma_detailed_statistics_1a06b2add24eed3449a66ff151979a0201" kindref="member">allocationSizeMax</ref><sp/>&gt;=<sp/>pStats-&gt;<ref refid="struct_vma_total_statistics_1a76f1935f7101883f5bb2a03b6c5649d2" kindref="member">total</ref>.<ref refid="struct_vma_detailed_statistics_1a6fb397e7487e10f2a52e241577d2a2b8" kindref="member">allocationSizeMin</ref>);</highlight></codeline>
<codeline lineno="15156"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(pStats-&gt;<ref refid="struct_vma_total_statistics_1a76f1935f7101883f5bb2a03b6c5649d2" kindref="member">total</ref>.<ref refid="struct_vma_detailed_statistics_1ab721bf04892e8b67802d4ddb7734638a" kindref="member">unusedRangeCount</ref><sp/>==<sp/>0<sp/>||</highlight></codeline>
<codeline lineno="15157"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pStats-&gt;<ref refid="struct_vma_total_statistics_1a76f1935f7101883f5bb2a03b6c5649d2" kindref="member">total</ref>.<ref refid="struct_vma_detailed_statistics_1af98943b5da98cf441ffa04b67914c78c" kindref="member">unusedRangeSizeMax</ref><sp/>&gt;=<sp/>pStats-&gt;<ref refid="struct_vma_total_statistics_1a76f1935f7101883f5bb2a03b6c5649d2" kindref="member">total</ref>.<ref refid="struct_vma_detailed_statistics_1a830eda847ed735d0e91da25cfcf797a4" kindref="member">unusedRangeSizeMin</ref>);</highlight></codeline>
<codeline lineno="15158"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15159"><highlight class="normal"></highlight></codeline>
<codeline lineno="15160"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocator_T::GetHeapBudgets(<ref refid="struct_vma_budget" kindref="compound">VmaBudget</ref>*<sp/>outBudgets,<sp/>uint32_t<sp/>firstHeap,<sp/>uint32_t<sp/>heapCount)</highlight></codeline>
<codeline lineno="15161"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15162"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_MEMORY_BUDGET</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15163"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_UseExtMemoryBudget)</highlight></codeline>
<codeline lineno="15164"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15165"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_Budget.m_OperationsSinceBudgetFetch<sp/>&lt;<sp/>30)</highlight></codeline>
<codeline lineno="15166"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaMutexLockRead<sp/>lockRead(m_Budget.m_BudgetMutex,<sp/>m_UseMutex);</highlight></codeline>
<codeline lineno="15168"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(uint32_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>heapCount;<sp/>++i,<sp/>++outBudgets)</highlight></codeline>
<codeline lineno="15169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15170"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>heapIndex<sp/>=<sp/>firstHeap<sp/>+<sp/>i;</highlight></codeline>
<codeline lineno="15171"><highlight class="normal"></highlight></codeline>
<codeline lineno="15172"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outBudgets-&gt;<ref refid="struct_vma_budget_1a6d15ab3a798fd62d9efa3a1e1f83bf54" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1a309179d5853a6a7cd534df497ee43957" kindref="member">blockCount</ref><sp/>=<sp/>m_Budget.m_BlockCount[heapIndex];</highlight></codeline>
<codeline lineno="15173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outBudgets-&gt;<ref refid="struct_vma_budget_1a6d15ab3a798fd62d9efa3a1e1f83bf54" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1ab0ff76e50f58f9f54b6f265e5bf5dde2" kindref="member">allocationCount</ref><sp/>=<sp/>m_Budget.m_AllocationCount[heapIndex];</highlight></codeline>
<codeline lineno="15174"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outBudgets-&gt;<ref refid="struct_vma_budget_1a6d15ab3a798fd62d9efa3a1e1f83bf54" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1a2afbc1c7aa8ad7bbb8de06215ba7e5c4" kindref="member">blockBytes</ref><sp/>=<sp/>m_Budget.m_BlockBytes[heapIndex];</highlight></codeline>
<codeline lineno="15175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outBudgets-&gt;<ref refid="struct_vma_budget_1a6d15ab3a798fd62d9efa3a1e1f83bf54" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1a21db06eba3422f87a2b4b4703d879c16" kindref="member">allocationBytes</ref><sp/>=<sp/>m_Budget.m_AllocationBytes[heapIndex];</highlight></codeline>
<codeline lineno="15176"><highlight class="normal"></highlight></codeline>
<codeline lineno="15177"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_Budget.m_VulkanUsage[heapIndex]<sp/>+<sp/>outBudgets-&gt;<ref refid="struct_vma_budget_1a6d15ab3a798fd62d9efa3a1e1f83bf54" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1a2afbc1c7aa8ad7bbb8de06215ba7e5c4" kindref="member">blockBytes</ref><sp/>&gt;<sp/>m_Budget.m_BlockBytesAtBudgetFetch[heapIndex])</highlight></codeline>
<codeline lineno="15178"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15179"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outBudgets-&gt;<ref refid="struct_vma_budget_1a84dd1ecca8b0110259eb206dbadb11f6" kindref="member">usage</ref><sp/>=<sp/>m_Budget.m_VulkanUsage[heapIndex]<sp/>+</highlight></codeline>
<codeline lineno="15180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outBudgets-&gt;<ref refid="struct_vma_budget_1a6d15ab3a798fd62d9efa3a1e1f83bf54" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1a2afbc1c7aa8ad7bbb8de06215ba7e5c4" kindref="member">blockBytes</ref><sp/>-<sp/>m_Budget.m_BlockBytesAtBudgetFetch[heapIndex];</highlight></codeline>
<codeline lineno="15181"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outBudgets-&gt;<ref refid="struct_vma_budget_1a84dd1ecca8b0110259eb206dbadb11f6" kindref="member">usage</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="15185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15186"><highlight class="normal"></highlight></codeline>
<codeline lineno="15187"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Have<sp/>to<sp/>take<sp/>MIN<sp/>with<sp/>heap<sp/>size<sp/>because<sp/>explicit<sp/>HeapSizeLimit<sp/>is<sp/>included<sp/>in<sp/>it.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15188"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outBudgets-&gt;<ref refid="struct_vma_budget_1ab82e1d1754c2d210d0bdf90220bc6cdd" kindref="member">budget</ref><sp/>=<sp/>VMA_MIN(</highlight></codeline>
<codeline lineno="15189"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Budget.m_VulkanBudget[heapIndex],<sp/>m_MemProps.memoryHeaps[heapIndex].size);</highlight></codeline>
<codeline lineno="15190"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15191"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15193"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15194"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UpdateVulkanBudget();<sp/></highlight><highlight class="comment">//<sp/>Outside<sp/>of<sp/>mutex<sp/>lock</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>GetHeapBudgets(outBudgets,<sp/>firstHeap,<sp/>heapCount);<sp/></highlight><highlight class="comment">//<sp/>Recursion</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15196"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15197"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15198"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15199"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15200"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(uint32_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>heapCount;<sp/>++i,<sp/>++outBudgets)</highlight></codeline>
<codeline lineno="15202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15203"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>heapIndex<sp/>=<sp/>firstHeap<sp/>+<sp/>i;</highlight></codeline>
<codeline lineno="15204"><highlight class="normal"></highlight></codeline>
<codeline lineno="15205"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outBudgets-&gt;<ref refid="struct_vma_budget_1a6d15ab3a798fd62d9efa3a1e1f83bf54" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1a309179d5853a6a7cd534df497ee43957" kindref="member">blockCount</ref><sp/>=<sp/>m_Budget.m_BlockCount[heapIndex];</highlight></codeline>
<codeline lineno="15206"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outBudgets-&gt;<ref refid="struct_vma_budget_1a6d15ab3a798fd62d9efa3a1e1f83bf54" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1ab0ff76e50f58f9f54b6f265e5bf5dde2" kindref="member">allocationCount</ref><sp/>=<sp/>m_Budget.m_AllocationCount[heapIndex];</highlight></codeline>
<codeline lineno="15207"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outBudgets-&gt;<ref refid="struct_vma_budget_1a6d15ab3a798fd62d9efa3a1e1f83bf54" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1a2afbc1c7aa8ad7bbb8de06215ba7e5c4" kindref="member">blockBytes</ref><sp/>=<sp/>m_Budget.m_BlockBytes[heapIndex];</highlight></codeline>
<codeline lineno="15208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outBudgets-&gt;<ref refid="struct_vma_budget_1a6d15ab3a798fd62d9efa3a1e1f83bf54" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1a21db06eba3422f87a2b4b4703d879c16" kindref="member">allocationBytes</ref><sp/>=<sp/>m_Budget.m_AllocationBytes[heapIndex];</highlight></codeline>
<codeline lineno="15209"><highlight class="normal"></highlight></codeline>
<codeline lineno="15210"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outBudgets-&gt;<ref refid="struct_vma_budget_1a84dd1ecca8b0110259eb206dbadb11f6" kindref="member">usage</ref><sp/>=<sp/>outBudgets-&gt;<ref refid="struct_vma_budget_1a6d15ab3a798fd62d9efa3a1e1f83bf54" kindref="member">statistics</ref>.<ref refid="struct_vma_statistics_1a2afbc1c7aa8ad7bbb8de06215ba7e5c4" kindref="member">blockBytes</ref>;</highlight></codeline>
<codeline lineno="15211"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outBudgets-&gt;<ref refid="struct_vma_budget_1ab82e1d1754c2d210d0bdf90220bc6cdd" kindref="member">budget</ref><sp/>=<sp/>m_MemProps.memoryHeaps[heapIndex].size<sp/>*<sp/>8<sp/>/<sp/>10;<sp/></highlight><highlight class="comment">//<sp/>80%<sp/>heuristics.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15212"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15213"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15214"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15215"><highlight class="normal"></highlight></codeline>
<codeline lineno="15216"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocator_T::GetAllocationInfo(<ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>hAllocation,<sp/><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref>*<sp/>pAllocationInfo)</highlight></codeline>
<codeline lineno="15217"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15218"><highlight class="normal"><sp/><sp/><sp/><sp/>pAllocationInfo-&gt;<ref refid="struct_vma_allocation_info_1a7f6b0aa58c135e488e6b40a388dad9d5" kindref="member">memoryType</ref><sp/>=<sp/>hAllocation-&gt;GetMemoryTypeIndex();</highlight></codeline>
<codeline lineno="15219"><highlight class="normal"><sp/><sp/><sp/><sp/>pAllocationInfo-&gt;<ref refid="struct_vma_allocation_info_1abaf12cc4e13fbe5208ca6e5bb1a21c19" kindref="member">deviceMemory</ref><sp/>=<sp/>hAllocation-&gt;GetMemory();</highlight></codeline>
<codeline lineno="15220"><highlight class="normal"><sp/><sp/><sp/><sp/>pAllocationInfo-&gt;<ref refid="struct_vma_allocation_info_1a4a3c732388dbdc7a23f9365b00825268" kindref="member">offset</ref><sp/>=<sp/>hAllocation-&gt;GetOffset();</highlight></codeline>
<codeline lineno="15221"><highlight class="normal"><sp/><sp/><sp/><sp/>pAllocationInfo-&gt;<ref refid="struct_vma_allocation_info_1aac76d113a6a5ccbb09fea00fb25fd18f" kindref="member">size</ref><sp/>=<sp/>hAllocation-&gt;GetSize();</highlight></codeline>
<codeline lineno="15222"><highlight class="normal"><sp/><sp/><sp/><sp/>pAllocationInfo-&gt;<ref refid="struct_vma_allocation_info_1a17a39eb34201a610347acb91b38eca79" kindref="member">pMappedData</ref><sp/>=<sp/>hAllocation-&gt;GetMappedData();</highlight></codeline>
<codeline lineno="15223"><highlight class="normal"><sp/><sp/><sp/><sp/>pAllocationInfo-&gt;<ref refid="struct_vma_allocation_info_1ad0ea9d64dd733ffd7beff7af6d289ad0" kindref="member">pUserData</ref><sp/>=<sp/>hAllocation-&gt;GetUserData();</highlight></codeline>
<codeline lineno="15224"><highlight class="normal"><sp/><sp/><sp/><sp/>pAllocationInfo-&gt;<ref refid="struct_vma_allocation_info_1ad82b9dfb58e5415da0ee8521c1fbf429" kindref="member">pName</ref><sp/>=<sp/>hAllocation-&gt;GetName();</highlight></codeline>
<codeline lineno="15225"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15226"><highlight class="normal"></highlight></codeline>
<codeline lineno="15227"><highlight class="normal">VkResult<sp/>VmaAllocator_T::CreatePool(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_pool_create_info" kindref="compound">VmaPoolCreateInfo</ref>*<sp/>pCreateInfo,<sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref>*<sp/>pPool)</highlight></codeline>
<codeline lineno="15228"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15229"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;<sp/><sp/>CreatePool:<sp/>MemoryTypeIndex=%u,<sp/>flags=%u&quot;</highlight><highlight class="normal">,<sp/>pCreateInfo-&gt;<ref refid="struct_vma_pool_create_info_1a596fa76b685d3f1f688f84a709a5b319" kindref="member">memoryTypeIndex</ref>,<sp/>pCreateInfo-&gt;<ref refid="struct_vma_pool_create_info_1a8405139f63d078340ae74513a59f5446" kindref="member">flags</ref>);</highlight></codeline>
<codeline lineno="15230"><highlight class="normal"></highlight></codeline>
<codeline lineno="15231"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool_create_info" kindref="compound">VmaPoolCreateInfo</ref><sp/>newCreateInfo<sp/>=<sp/>*pCreateInfo;</highlight></codeline>
<codeline lineno="15232"><highlight class="normal"></highlight></codeline>
<codeline lineno="15233"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Protection<sp/>against<sp/>uninitialized<sp/>new<sp/>structure<sp/>member.<sp/>If<sp/>garbage<sp/>data<sp/>are<sp/>left<sp/>there,<sp/>this<sp/>pointer<sp/>dereference<sp/>would<sp/>crash.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15234"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pCreateInfo-&gt;<ref refid="struct_vma_pool_create_info_1a4e264310c10272ba393c0ba2111ce416" kindref="member">pMemoryAllocateNext</ref>)</highlight></codeline>
<codeline lineno="15235"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15236"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(((</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkBaseInStructure*)pCreateInfo-&gt;<ref refid="struct_vma_pool_create_info_1a4e264310c10272ba393c0ba2111ce416" kindref="member">pMemoryAllocateNext</ref>)-&gt;sType<sp/>!=<sp/>0);</highlight></codeline>
<codeline lineno="15237"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15238"><highlight class="normal"></highlight></codeline>
<codeline lineno="15239"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(newCreateInfo.<ref refid="struct_vma_pool_create_info_1ae41142f2834fcdc82baa4883c187b75c" kindref="member">maxBlockCount</ref><sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="15240"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15241"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newCreateInfo.<ref refid="struct_vma_pool_create_info_1ae41142f2834fcdc82baa4883c187b75c" kindref="member">maxBlockCount</ref><sp/>=<sp/>SIZE_MAX;</highlight></codeline>
<codeline lineno="15242"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15243"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(newCreateInfo.<ref refid="struct_vma_pool_create_info_1ad8006fb803185c0a699d30f3e9a865ae" kindref="member">minBlockCount</ref><sp/>&gt;<sp/>newCreateInfo.<ref refid="struct_vma_pool_create_info_1ae41142f2834fcdc82baa4883c187b75c" kindref="member">maxBlockCount</ref>)</highlight></codeline>
<codeline lineno="15244"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15245"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_INITIALIZATION_FAILED;</highlight></codeline>
<codeline lineno="15246"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15247"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Memory<sp/>type<sp/>index<sp/>out<sp/>of<sp/>range<sp/>or<sp/>forbidden.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15248"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pCreateInfo-&gt;<ref refid="struct_vma_pool_create_info_1a596fa76b685d3f1f688f84a709a5b319" kindref="member">memoryTypeIndex</ref><sp/>&gt;=<sp/>GetMemoryTypeCount()<sp/>||</highlight></codeline>
<codeline lineno="15249"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>((1u<sp/>&lt;&lt;<sp/>pCreateInfo-&gt;<ref refid="struct_vma_pool_create_info_1a596fa76b685d3f1f688f84a709a5b319" kindref="member">memoryTypeIndex</ref>)<sp/>&amp;<sp/>m_GlobalMemoryTypeBits)<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="15250"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15251"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_FEATURE_NOT_PRESENT;</highlight></codeline>
<codeline lineno="15252"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15253"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(newCreateInfo.<ref refid="struct_vma_pool_create_info_1ade3eca546f0c6ab4e8fbf20eb6d854cb" kindref="member">minAllocationAlignment</ref><sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="15254"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15255"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(VmaIsPow2(newCreateInfo.<ref refid="struct_vma_pool_create_info_1ade3eca546f0c6ab4e8fbf20eb6d854cb" kindref="member">minAllocationAlignment</ref>));</highlight></codeline>
<codeline lineno="15256"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15257"><highlight class="normal"></highlight></codeline>
<codeline lineno="15258"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>preferredBlockSize<sp/>=<sp/>CalcPreferredBlockSize(newCreateInfo.<ref refid="struct_vma_pool_create_info_1a596fa76b685d3f1f688f84a709a5b319" kindref="member">memoryTypeIndex</ref>);</highlight></codeline>
<codeline lineno="15259"><highlight class="normal"></highlight></codeline>
<codeline lineno="15260"><highlight class="normal"><sp/><sp/><sp/><sp/>*pPool<sp/>=<sp/>vma_new(</highlight><highlight class="keyword">this</highlight><highlight class="normal">,<sp/>VmaPool_T)(</highlight><highlight class="keyword">this</highlight><highlight class="normal">,<sp/>newCreateInfo,<sp/>preferredBlockSize);</highlight></codeline>
<codeline lineno="15261"><highlight class="normal"></highlight></codeline>
<codeline lineno="15262"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>(*pPool)-&gt;m_BlockVector.CreateMinBlocks();</highlight></codeline>
<codeline lineno="15263"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>!=<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="15264"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15265"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vma_delete(</highlight><highlight class="keyword">this</highlight><highlight class="normal">,<sp/>*pPool);</highlight></codeline>
<codeline lineno="15266"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pPool<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="15267"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="15268"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15269"><highlight class="normal"></highlight></codeline>
<codeline lineno="15270"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Add<sp/>to<sp/>m_Pools.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15271"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15272"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaMutexLockWrite<sp/>lock(m_PoolsMutex,<sp/>m_UseMutex);</highlight></codeline>
<codeline lineno="15273"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*pPool)-&gt;SetId(m_NextPoolId++);</highlight></codeline>
<codeline lineno="15274"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Pools.PushBack(*pPool);</highlight></codeline>
<codeline lineno="15275"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15276"><highlight class="normal"></highlight></codeline>
<codeline lineno="15277"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="15278"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15279"><highlight class="normal"></highlight></codeline>
<codeline lineno="15280"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocator_T::DestroyPool(<ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>pool)</highlight></codeline>
<codeline lineno="15281"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15282"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Remove<sp/>from<sp/>m_Pools.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15283"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15284"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaMutexLockWrite<sp/>lock(m_PoolsMutex,<sp/>m_UseMutex);</highlight></codeline>
<codeline lineno="15285"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Pools.Remove(pool);</highlight></codeline>
<codeline lineno="15286"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15287"><highlight class="normal"></highlight></codeline>
<codeline lineno="15288"><highlight class="normal"><sp/><sp/><sp/><sp/>vma_delete(</highlight><highlight class="keyword">this</highlight><highlight class="normal">,<sp/>pool);</highlight></codeline>
<codeline lineno="15289"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15290"><highlight class="normal"></highlight></codeline>
<codeline lineno="15291"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocator_T::GetPoolStatistics(<ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>pool,<sp/><ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref>*<sp/>pPoolStats)</highlight></codeline>
<codeline lineno="15292"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15293"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaClearStatistics(*pPoolStats);</highlight></codeline>
<codeline lineno="15294"><highlight class="normal"><sp/><sp/><sp/><sp/>pool-&gt;m_BlockVector.AddStatistics(*pPoolStats);</highlight></codeline>
<codeline lineno="15295"><highlight class="normal"><sp/><sp/><sp/><sp/>pool-&gt;m_DedicatedAllocations.AddStatistics(*pPoolStats);</highlight></codeline>
<codeline lineno="15296"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15297"><highlight class="normal"></highlight></codeline>
<codeline lineno="15298"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocator_T::CalculatePoolStatistics(<ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>pool,<sp/><ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>*<sp/>pPoolStats)</highlight></codeline>
<codeline lineno="15299"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15300"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaClearDetailedStatistics(*pPoolStats);</highlight></codeline>
<codeline lineno="15301"><highlight class="normal"><sp/><sp/><sp/><sp/>pool-&gt;m_BlockVector.AddDetailedStatistics(*pPoolStats);</highlight></codeline>
<codeline lineno="15302"><highlight class="normal"><sp/><sp/><sp/><sp/>pool-&gt;m_DedicatedAllocations.AddDetailedStatistics(*pPoolStats);</highlight></codeline>
<codeline lineno="15303"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15304"><highlight class="normal"></highlight></codeline>
<codeline lineno="15305"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocator_T::SetCurrentFrameIndex(uint32_t<sp/>frameIndex)</highlight></codeline>
<codeline lineno="15306"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15307"><highlight class="normal"><sp/><sp/><sp/><sp/>m_CurrentFrameIndex.store(frameIndex);</highlight></codeline>
<codeline lineno="15308"><highlight class="normal"></highlight></codeline>
<codeline lineno="15309"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_MEMORY_BUDGET</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15310"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_UseExtMemoryBudget)</highlight></codeline>
<codeline lineno="15311"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UpdateVulkanBudget();</highlight></codeline>
<codeline lineno="15313"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15314"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>VMA_MEMORY_BUDGET</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15315"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15316"><highlight class="normal"></highlight></codeline>
<codeline lineno="15317"><highlight class="normal">VkResult<sp/>VmaAllocator_T::CheckPoolCorruption(<ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>hPool)</highlight></codeline>
<codeline lineno="15318"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15319"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>hPool-&gt;m_BlockVector.CheckCorruption();</highlight></codeline>
<codeline lineno="15320"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15321"><highlight class="normal"></highlight></codeline>
<codeline lineno="15322"><highlight class="normal">VkResult<sp/>VmaAllocator_T::CheckCorruption(uint32_t<sp/>memoryTypeBits)</highlight></codeline>
<codeline lineno="15323"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15324"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>finalRes<sp/>=<sp/>VK_ERROR_FEATURE_NOT_PRESENT;</highlight></codeline>
<codeline lineno="15325"><highlight class="normal"></highlight></codeline>
<codeline lineno="15326"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Process<sp/>default<sp/>pools.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15327"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(uint32_t<sp/>memTypeIndex<sp/>=<sp/>0;<sp/>memTypeIndex<sp/>&lt;<sp/>GetMemoryTypeCount();<sp/>++memTypeIndex)</highlight></codeline>
<codeline lineno="15328"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaBlockVector*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>pBlockVector<sp/>=<sp/>m_pBlockVectors[memTypeIndex];</highlight></codeline>
<codeline lineno="15330"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pBlockVector<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="15331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15332"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkResult<sp/>localRes<sp/>=<sp/>pBlockVector-&gt;CheckCorruption();</highlight></codeline>
<codeline lineno="15333"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal">(localRes)</highlight></codeline>
<codeline lineno="15334"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15335"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VK_ERROR_FEATURE_NOT_PRESENT:</highlight></codeline>
<codeline lineno="15336"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="15337"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VK_SUCCESS:</highlight></codeline>
<codeline lineno="15338"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>finalRes<sp/>=<sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="15339"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="15340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="15341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>localRes;</highlight></codeline>
<codeline lineno="15342"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15344"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15345"><highlight class="normal"></highlight></codeline>
<codeline lineno="15346"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Process<sp/>custom<sp/>pools.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15347"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15348"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaMutexLockRead<sp/>lock(m_PoolsMutex,<sp/>m_UseMutex);</highlight></codeline>
<codeline lineno="15349"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(<ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>pool<sp/>=<sp/>m_Pools.Front();<sp/>pool<sp/>!=<sp/>VMA_NULL;<sp/>pool<sp/>=<sp/>m_Pools.GetNext(pool))</highlight></codeline>
<codeline lineno="15350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(((1u<sp/>&lt;&lt;<sp/>pool-&gt;m_BlockVector.GetMemoryTypeIndex())<sp/>&amp;<sp/>memoryTypeBits)<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="15352"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15353"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkResult<sp/>localRes<sp/>=<sp/>pool-&gt;m_BlockVector.CheckCorruption();</highlight></codeline>
<codeline lineno="15354"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal">(localRes)</highlight></codeline>
<codeline lineno="15355"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15356"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VK_ERROR_FEATURE_NOT_PRESENT:</highlight></codeline>
<codeline lineno="15357"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="15358"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VK_SUCCESS:</highlight></codeline>
<codeline lineno="15359"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>finalRes<sp/>=<sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="15360"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="15361"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="15362"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>localRes;</highlight></codeline>
<codeline lineno="15363"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15364"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15365"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15366"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15367"><highlight class="normal"></highlight></codeline>
<codeline lineno="15368"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>finalRes;</highlight></codeline>
<codeline lineno="15369"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15370"><highlight class="normal"></highlight></codeline>
<codeline lineno="15371"><highlight class="normal">VkResult<sp/>VmaAllocator_T::AllocateVulkanMemory(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkMemoryAllocateInfo*<sp/>pAllocateInfo,<sp/>VkDeviceMemory*<sp/>pMemory)</highlight></codeline>
<codeline lineno="15372"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15373"><highlight class="normal"><sp/><sp/><sp/><sp/>AtomicTransactionalIncrement&lt;uint32_t&gt;<sp/>deviceMemoryCountIncrement;</highlight></codeline>
<codeline lineno="15374"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint64_t<sp/>prevDeviceMemoryCount<sp/>=<sp/>deviceMemoryCountIncrement.Increment(&amp;m_DeviceMemoryCount);</highlight></codeline>
<codeline lineno="15375"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_DEBUG_DONT_EXCEED_MAX_MEMORY_ALLOCATION_COUNT</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15376"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(prevDeviceMemoryCount<sp/>&gt;=<sp/>m_PhysicalDeviceProperties.limits.maxMemoryAllocationCount)</highlight></codeline>
<codeline lineno="15377"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_TOO_MANY_OBJECTS;</highlight></codeline>
<codeline lineno="15379"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15380"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15381"><highlight class="normal"></highlight></codeline>
<codeline lineno="15382"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>heapIndex<sp/>=<sp/>MemoryTypeIndexToHeapIndex(pAllocateInfo-&gt;memoryTypeIndex);</highlight></codeline>
<codeline lineno="15383"><highlight class="normal"></highlight></codeline>
<codeline lineno="15384"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>HeapSizeLimit<sp/>is<sp/>in<sp/>effect<sp/>for<sp/>this<sp/>heap.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15385"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">((m_HeapSizeLimitMask<sp/>&amp;<sp/>(1u<sp/>&lt;&lt;<sp/>heapIndex))<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="15386"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15387"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>heapSize<sp/>=<sp/>m_MemProps.memoryHeaps[heapIndex].size;</highlight></codeline>
<codeline lineno="15388"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>blockBytes<sp/>=<sp/>m_Budget.m_BlockBytes[heapIndex];</highlight></codeline>
<codeline lineno="15389"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(;;)</highlight></codeline>
<codeline lineno="15390"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15391"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>blockBytesAfterAllocation<sp/>=<sp/>blockBytes<sp/>+<sp/>pAllocateInfo-&gt;allocationSize;</highlight></codeline>
<codeline lineno="15392"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(blockBytesAfterAllocation<sp/>&gt;<sp/>heapSize)</highlight></codeline>
<codeline lineno="15393"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15394"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_OUT_OF_DEVICE_MEMORY;</highlight></codeline>
<codeline lineno="15395"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15396"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_Budget.m_BlockBytes[heapIndex].compare_exchange_strong(blockBytes,<sp/>blockBytesAfterAllocation))</highlight></codeline>
<codeline lineno="15397"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15398"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="15399"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15400"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15401"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15402"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15403"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15404"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Budget.m_BlockBytes[heapIndex]<sp/>+=<sp/>pAllocateInfo-&gt;allocationSize;</highlight></codeline>
<codeline lineno="15405"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15406"><highlight class="normal"><sp/><sp/><sp/><sp/>++m_Budget.m_BlockCount[heapIndex];</highlight></codeline>
<codeline lineno="15407"><highlight class="normal"></highlight></codeline>
<codeline lineno="15408"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>VULKAN<sp/>CALL<sp/>vkAllocateMemory.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15409"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>(*m_VulkanFunctions.vkAllocateMemory)(m_hDevice,<sp/>pAllocateInfo,<sp/>GetAllocationCallbacks(),<sp/>pMemory);</highlight></codeline>
<codeline lineno="15410"><highlight class="normal"></highlight></codeline>
<codeline lineno="15411"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>==<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="15412"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15413"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_MEMORY_BUDGET</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15414"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++m_Budget.m_OperationsSinceBudgetFetch;</highlight></codeline>
<codeline lineno="15415"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15416"><highlight class="normal"></highlight></codeline>
<codeline lineno="15417"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Informative<sp/>callback.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15418"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_DeviceMemoryCallbacks.<ref refid="struct_vma_device_memory_callbacks_1ac02066cbe29d1f2f97c68c8c462ee3d5" kindref="member">pfnAllocate</ref><sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="15419"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15420"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*m_DeviceMemoryCallbacks.<ref refid="struct_vma_device_memory_callbacks_1ac02066cbe29d1f2f97c68c8c462ee3d5" kindref="member">pfnAllocate</ref>)(</highlight><highlight class="keyword">this</highlight><highlight class="normal">,<sp/>pAllocateInfo-&gt;memoryTypeIndex,<sp/>*pMemory,<sp/>pAllocateInfo-&gt;allocationSize,<sp/>m_DeviceMemoryCallbacks.<ref refid="struct_vma_device_memory_callbacks_1a84102b94fa445b59a8b02b44e7dcb43f" kindref="member">pUserData</ref>);</highlight></codeline>
<codeline lineno="15421"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15422"><highlight class="normal"></highlight></codeline>
<codeline lineno="15423"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deviceMemoryCountIncrement.Commit();</highlight></codeline>
<codeline lineno="15424"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15425"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15426"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15427"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--m_Budget.m_BlockCount[heapIndex];</highlight></codeline>
<codeline lineno="15428"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Budget.m_BlockBytes[heapIndex]<sp/>-=<sp/>pAllocateInfo-&gt;allocationSize;</highlight></codeline>
<codeline lineno="15429"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15430"><highlight class="normal"></highlight></codeline>
<codeline lineno="15431"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="15432"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15433"><highlight class="normal"></highlight></codeline>
<codeline lineno="15434"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocator_T::FreeVulkanMemory(uint32_t<sp/>memoryType,<sp/>VkDeviceSize<sp/>size,<sp/>VkDeviceMemory<sp/>hMemory)</highlight></codeline>
<codeline lineno="15435"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15436"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Informative<sp/>callback.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15437"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_DeviceMemoryCallbacks.<ref refid="struct_vma_device_memory_callbacks_1a74348a8b9bdb165535e010ed195bfdb9" kindref="member">pfnFree</ref><sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="15438"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15439"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*m_DeviceMemoryCallbacks.<ref refid="struct_vma_device_memory_callbacks_1a74348a8b9bdb165535e010ed195bfdb9" kindref="member">pfnFree</ref>)(</highlight><highlight class="keyword">this</highlight><highlight class="normal">,<sp/>memoryType,<sp/>hMemory,<sp/>size,<sp/>m_DeviceMemoryCallbacks.<ref refid="struct_vma_device_memory_callbacks_1a84102b94fa445b59a8b02b44e7dcb43f" kindref="member">pUserData</ref>);</highlight></codeline>
<codeline lineno="15440"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15441"><highlight class="normal"></highlight></codeline>
<codeline lineno="15442"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>VULKAN<sp/>CALL<sp/>vkFreeMemory.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15443"><highlight class="normal"><sp/><sp/><sp/><sp/>(*m_VulkanFunctions.vkFreeMemory)(m_hDevice,<sp/>hMemory,<sp/>GetAllocationCallbacks());</highlight></codeline>
<codeline lineno="15444"><highlight class="normal"></highlight></codeline>
<codeline lineno="15445"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>heapIndex<sp/>=<sp/>MemoryTypeIndexToHeapIndex(memoryType);</highlight></codeline>
<codeline lineno="15446"><highlight class="normal"><sp/><sp/><sp/><sp/>--m_Budget.m_BlockCount[heapIndex];</highlight></codeline>
<codeline lineno="15447"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Budget.m_BlockBytes[heapIndex]<sp/>-=<sp/>size;</highlight></codeline>
<codeline lineno="15448"><highlight class="normal"></highlight></codeline>
<codeline lineno="15449"><highlight class="normal"><sp/><sp/><sp/><sp/>--m_DeviceMemoryCount;</highlight></codeline>
<codeline lineno="15450"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15451"><highlight class="normal"></highlight></codeline>
<codeline lineno="15452"><highlight class="normal">VkResult<sp/>VmaAllocator_T::BindVulkanBuffer(</highlight></codeline>
<codeline lineno="15453"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceMemory<sp/>memory,</highlight></codeline>
<codeline lineno="15454"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>memoryOffset,</highlight></codeline>
<codeline lineno="15455"><highlight class="normal"><sp/><sp/><sp/><sp/>VkBuffer<sp/>buffer,</highlight></codeline>
<codeline lineno="15456"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pNext)</highlight></codeline>
<codeline lineno="15457"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15458"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pNext<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="15459"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15460"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1001000<sp/>||<sp/>VMA_BIND_MEMORY2</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">((m_UseKhrBindMemory2<sp/>||<sp/>m_VulkanApiVersion<sp/>&gt;=<sp/>VK_MAKE_VERSION(1,<sp/>1,<sp/>0))<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="15462"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkBindBufferMemory2KHR<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="15463"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15464"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkBindBufferMemoryInfoKHR<sp/>bindBufferMemoryInfo<sp/>=<sp/>{<sp/>VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR<sp/>};</highlight></codeline>
<codeline lineno="15465"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bindBufferMemoryInfo.pNext<sp/>=<sp/>pNext;</highlight></codeline>
<codeline lineno="15466"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bindBufferMemoryInfo.buffer<sp/>=<sp/>buffer;</highlight></codeline>
<codeline lineno="15467"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bindBufferMemoryInfo.memory<sp/>=<sp/>memory;</highlight></codeline>
<codeline lineno="15468"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bindBufferMemoryInfo.memoryOffset<sp/>=<sp/>memoryOffset;</highlight></codeline>
<codeline lineno="15469"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(*m_VulkanFunctions.vkBindBufferMemory2KHR)(m_hDevice,<sp/>1,<sp/>&amp;bindBufferMemoryInfo);</highlight></codeline>
<codeline lineno="15470"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15471"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15472"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1001000<sp/>||<sp/>VMA_BIND_MEMORY2</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15473"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15474"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_EXTENSION_NOT_PRESENT;</highlight></codeline>
<codeline lineno="15475"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15476"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15477"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15478"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15479"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(*m_VulkanFunctions.vkBindBufferMemory)(m_hDevice,<sp/>buffer,<sp/>memory,<sp/>memoryOffset);</highlight></codeline>
<codeline lineno="15480"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15481"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15482"><highlight class="normal"></highlight></codeline>
<codeline lineno="15483"><highlight class="normal">VkResult<sp/>VmaAllocator_T::BindVulkanImage(</highlight></codeline>
<codeline lineno="15484"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceMemory<sp/>memory,</highlight></codeline>
<codeline lineno="15485"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>memoryOffset,</highlight></codeline>
<codeline lineno="15486"><highlight class="normal"><sp/><sp/><sp/><sp/>VkImage<sp/>image,</highlight></codeline>
<codeline lineno="15487"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pNext)</highlight></codeline>
<codeline lineno="15488"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15489"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pNext<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="15490"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15491"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1001000<sp/>||<sp/>VMA_BIND_MEMORY2</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15492"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">((m_UseKhrBindMemory2<sp/>||<sp/>m_VulkanApiVersion<sp/>&gt;=<sp/>VK_MAKE_VERSION(1,<sp/>1,<sp/>0))<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="15493"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_VulkanFunctions.vkBindImageMemory2KHR<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="15494"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15495"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkBindImageMemoryInfoKHR<sp/>bindBufferMemoryInfo<sp/>=<sp/>{<sp/>VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR<sp/>};</highlight></codeline>
<codeline lineno="15496"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bindBufferMemoryInfo.pNext<sp/>=<sp/>pNext;</highlight></codeline>
<codeline lineno="15497"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bindBufferMemoryInfo.image<sp/>=<sp/>image;</highlight></codeline>
<codeline lineno="15498"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bindBufferMemoryInfo.memory<sp/>=<sp/>memory;</highlight></codeline>
<codeline lineno="15499"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bindBufferMemoryInfo.memoryOffset<sp/>=<sp/>memoryOffset;</highlight></codeline>
<codeline lineno="15500"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(*m_VulkanFunctions.vkBindImageMemory2KHR)(m_hDevice,<sp/>1,<sp/>&amp;bindBufferMemoryInfo);</highlight></codeline>
<codeline lineno="15501"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15502"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15503"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>VMA_BIND_MEMORY2</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15504"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15505"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_EXTENSION_NOT_PRESENT;</highlight></codeline>
<codeline lineno="15506"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15507"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15508"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15509"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15510"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(*m_VulkanFunctions.vkBindImageMemory)(m_hDevice,<sp/>image,<sp/>memory,<sp/>memoryOffset);</highlight></codeline>
<codeline lineno="15511"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15512"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15513"><highlight class="normal"></highlight></codeline>
<codeline lineno="15514"><highlight class="normal">VkResult<sp/>VmaAllocator_T::Map(<ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>hAllocation,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">**<sp/>ppData)</highlight></codeline>
<codeline lineno="15515"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15516"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal">(hAllocation-&gt;GetType())</highlight></codeline>
<codeline lineno="15517"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15518"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VmaAllocation_T::ALLOCATION_TYPE_BLOCK:</highlight></codeline>
<codeline lineno="15519"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15520"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>pBlock<sp/>=<sp/>hAllocation-&gt;GetBlock();</highlight></codeline>
<codeline lineno="15521"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*pBytes<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="15522"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>pBlock-&gt;Map(</highlight><highlight class="keyword">this</highlight><highlight class="normal">,<sp/>1,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">**)&amp;pBytes);</highlight></codeline>
<codeline lineno="15523"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>==<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="15524"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15525"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*ppData<sp/>=<sp/>pBytes<sp/>+<sp/>(ptrdiff_t)hAllocation-&gt;GetOffset();</highlight></codeline>
<codeline lineno="15526"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>hAllocation-&gt;BlockAllocMap();</highlight></codeline>
<codeline lineno="15527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15528"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="15529"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15530"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VmaAllocation_T::ALLOCATION_TYPE_DEDICATED:</highlight></codeline>
<codeline lineno="15531"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>hAllocation-&gt;DedicatedAllocMap(</highlight><highlight class="keyword">this</highlight><highlight class="normal">,<sp/>ppData);</highlight></codeline>
<codeline lineno="15532"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="15533"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="15534"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_MEMORY_MAP_FAILED;</highlight></codeline>
<codeline lineno="15535"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15536"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15537"><highlight class="normal"></highlight></codeline>
<codeline lineno="15538"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocator_T::Unmap(<ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>hAllocation)</highlight></codeline>
<codeline lineno="15539"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15540"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal">(hAllocation-&gt;GetType())</highlight></codeline>
<codeline lineno="15541"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15542"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VmaAllocation_T::ALLOCATION_TYPE_BLOCK:</highlight></codeline>
<codeline lineno="15543"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15544"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>pBlock<sp/>=<sp/>hAllocation-&gt;GetBlock();</highlight></codeline>
<codeline lineno="15545"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>hAllocation-&gt;BlockAllocUnmap();</highlight></codeline>
<codeline lineno="15546"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pBlock-&gt;Unmap(</highlight><highlight class="keyword">this</highlight><highlight class="normal">,<sp/>1);</highlight></codeline>
<codeline lineno="15547"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15548"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="15549"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VmaAllocation_T::ALLOCATION_TYPE_DEDICATED:</highlight></codeline>
<codeline lineno="15550"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>hAllocation-&gt;DedicatedAllocUnmap(</highlight><highlight class="keyword">this</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="15551"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="15552"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="15553"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="15554"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15555"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15556"><highlight class="normal"></highlight></codeline>
<codeline lineno="15557"><highlight class="normal">VkResult<sp/>VmaAllocator_T::BindBufferMemory(</highlight></codeline>
<codeline lineno="15558"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>hAllocation,</highlight></codeline>
<codeline lineno="15559"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocationLocalOffset,</highlight></codeline>
<codeline lineno="15560"><highlight class="normal"><sp/><sp/><sp/><sp/>VkBuffer<sp/>hBuffer,</highlight></codeline>
<codeline lineno="15561"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pNext)</highlight></codeline>
<codeline lineno="15562"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15563"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="15564"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal">(hAllocation-&gt;GetType())</highlight></codeline>
<codeline lineno="15565"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15566"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VmaAllocation_T::ALLOCATION_TYPE_DEDICATED:</highlight></codeline>
<codeline lineno="15567"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>BindVulkanBuffer(hAllocation-&gt;GetMemory(),<sp/>allocationLocalOffset,<sp/>hBuffer,<sp/>pNext);</highlight></codeline>
<codeline lineno="15568"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="15569"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VmaAllocation_T::ALLOCATION_TYPE_BLOCK:</highlight></codeline>
<codeline lineno="15570"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15571"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>pBlock<sp/>=<sp/>hAllocation-&gt;GetBlock();</highlight></codeline>
<codeline lineno="15572"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(pBlock<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Binding<sp/>buffer<sp/>to<sp/>allocation<sp/>that<sp/>doesn&apos;t<sp/>belong<sp/>to<sp/>any<sp/>block.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="15573"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>pBlock-&gt;BindBufferMemory(</highlight><highlight class="keyword">this</highlight><highlight class="normal">,<sp/>hAllocation,<sp/>allocationLocalOffset,<sp/>hBuffer,<sp/>pNext);</highlight></codeline>
<codeline lineno="15574"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="15575"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15576"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="15577"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="15578"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15579"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="15580"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15581"><highlight class="normal"></highlight></codeline>
<codeline lineno="15582"><highlight class="normal">VkResult<sp/>VmaAllocator_T::BindImageMemory(</highlight></codeline>
<codeline lineno="15583"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>hAllocation,</highlight></codeline>
<codeline lineno="15584"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocationLocalOffset,</highlight></codeline>
<codeline lineno="15585"><highlight class="normal"><sp/><sp/><sp/><sp/>VkImage<sp/>hImage,</highlight></codeline>
<codeline lineno="15586"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pNext)</highlight></codeline>
<codeline lineno="15587"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15588"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="15589"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal">(hAllocation-&gt;GetType())</highlight></codeline>
<codeline lineno="15590"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15591"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VmaAllocation_T::ALLOCATION_TYPE_DEDICATED:</highlight></codeline>
<codeline lineno="15592"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>BindVulkanImage(hAllocation-&gt;GetMemory(),<sp/>allocationLocalOffset,<sp/>hImage,<sp/>pNext);</highlight></codeline>
<codeline lineno="15593"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="15594"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VmaAllocation_T::ALLOCATION_TYPE_BLOCK:</highlight></codeline>
<codeline lineno="15595"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15596"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaDeviceMemoryBlock*<sp/>pBlock<sp/>=<sp/>hAllocation-&gt;GetBlock();</highlight></codeline>
<codeline lineno="15597"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(pBlock<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Binding<sp/>image<sp/>to<sp/>allocation<sp/>that<sp/>doesn&apos;t<sp/>belong<sp/>to<sp/>any<sp/>block.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="15598"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>pBlock-&gt;BindImageMemory(</highlight><highlight class="keyword">this</highlight><highlight class="normal">,<sp/>hAllocation,<sp/>allocationLocalOffset,<sp/>hImage,<sp/>pNext);</highlight></codeline>
<codeline lineno="15599"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="15600"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15601"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="15602"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="15603"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15604"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="15605"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15606"><highlight class="normal"></highlight></codeline>
<codeline lineno="15607"><highlight class="normal">VkResult<sp/>VmaAllocator_T::FlushOrInvalidateAllocation(</highlight></codeline>
<codeline lineno="15608"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>hAllocation,</highlight></codeline>
<codeline lineno="15609"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>offset,<sp/>VkDeviceSize<sp/>size,</highlight></codeline>
<codeline lineno="15610"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_CACHE_OPERATION<sp/>op)</highlight></codeline>
<codeline lineno="15611"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15612"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="15613"><highlight class="normal"></highlight></codeline>
<codeline lineno="15614"><highlight class="normal"><sp/><sp/><sp/><sp/>VkMappedMemoryRange<sp/>memRange<sp/>=<sp/>{};</highlight></codeline>
<codeline lineno="15615"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(GetFlushOrInvalidateRange(hAllocation,<sp/>offset,<sp/>size,<sp/>memRange))</highlight></codeline>
<codeline lineno="15616"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15617"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal">(op)</highlight></codeline>
<codeline lineno="15618"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15619"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VMA_CACHE_FLUSH:</highlight></codeline>
<codeline lineno="15620"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>(*GetVulkanFunctions().vkFlushMappedMemoryRanges)(m_hDevice,<sp/>1,<sp/>&amp;memRange);</highlight></codeline>
<codeline lineno="15621"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="15622"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VMA_CACHE_INVALIDATE:</highlight></codeline>
<codeline lineno="15623"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>(*GetVulkanFunctions().vkInvalidateMappedMemoryRanges)(m_hDevice,<sp/>1,<sp/>&amp;memRange);</highlight></codeline>
<codeline lineno="15624"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="15625"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="15626"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="15627"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15628"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15629"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>else:<sp/>Just<sp/>ignore<sp/>this<sp/>call.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15630"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="15631"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15632"><highlight class="normal"></highlight></codeline>
<codeline lineno="15633"><highlight class="normal">VkResult<sp/>VmaAllocator_T::FlushOrInvalidateAllocations(</highlight></codeline>
<codeline lineno="15634"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>allocationCount,</highlight></codeline>
<codeline lineno="15635"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>allocations,</highlight></codeline>
<codeline lineno="15636"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize*<sp/>offsets,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize*<sp/>sizes,</highlight></codeline>
<codeline lineno="15637"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_CACHE_OPERATION<sp/>op)</highlight></codeline>
<codeline lineno="15638"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15639"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VmaStlAllocator&lt;VkMappedMemoryRange&gt;<sp/>RangeAllocator;</highlight></codeline>
<codeline lineno="15640"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>VmaSmallVector&lt;VkMappedMemoryRange,<sp/>RangeAllocator,<sp/>16&gt;<sp/>RangeVector;</highlight></codeline>
<codeline lineno="15641"><highlight class="normal"><sp/><sp/><sp/><sp/>RangeVector<sp/>ranges<sp/>=<sp/>RangeVector(RangeAllocator(GetAllocationCallbacks()));</highlight></codeline>
<codeline lineno="15642"><highlight class="normal"></highlight></codeline>
<codeline lineno="15643"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(uint32_t<sp/>allocIndex<sp/>=<sp/>0;<sp/>allocIndex<sp/>&lt;<sp/>allocationCount;<sp/>++allocIndex)</highlight></codeline>
<codeline lineno="15644"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15645"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>alloc<sp/>=<sp/>allocations[allocIndex];</highlight></codeline>
<codeline lineno="15646"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>offset<sp/>=<sp/>offsets<sp/>!=<sp/>VMA_NULL<sp/>?<sp/>offsets[allocIndex]<sp/>:<sp/>0;</highlight></codeline>
<codeline lineno="15647"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>size<sp/>=<sp/>sizes<sp/>!=<sp/>VMA_NULL<sp/>?<sp/>sizes[allocIndex]<sp/>:<sp/>VK_WHOLE_SIZE;</highlight></codeline>
<codeline lineno="15648"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkMappedMemoryRange<sp/>newRange;</highlight></codeline>
<codeline lineno="15649"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(GetFlushOrInvalidateRange(alloc,<sp/>offset,<sp/>size,<sp/>newRange))</highlight></codeline>
<codeline lineno="15650"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15651"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ranges.push_back(newRange);</highlight></codeline>
<codeline lineno="15652"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15653"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15654"><highlight class="normal"></highlight></codeline>
<codeline lineno="15655"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="15656"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!ranges.empty())</highlight></codeline>
<codeline lineno="15657"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15658"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal">(op)</highlight></codeline>
<codeline lineno="15659"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15660"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VMA_CACHE_FLUSH:</highlight></codeline>
<codeline lineno="15661"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>(*GetVulkanFunctions().vkFlushMappedMemoryRanges)(m_hDevice,<sp/>(uint32_t)ranges.size(),<sp/>ranges.data());</highlight></codeline>
<codeline lineno="15662"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="15663"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VMA_CACHE_INVALIDATE:</highlight></codeline>
<codeline lineno="15664"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>(*GetVulkanFunctions().vkInvalidateMappedMemoryRanges)(m_hDevice,<sp/>(uint32_t)ranges.size(),<sp/>ranges.data());</highlight></codeline>
<codeline lineno="15665"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="15666"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="15667"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="15668"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15669"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15670"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>else:<sp/>Just<sp/>ignore<sp/>this<sp/>call.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15671"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="15672"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15673"><highlight class="normal"></highlight></codeline>
<codeline lineno="15674"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocator_T::FreeDedicatedMemory(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>allocation)</highlight></codeline>
<codeline lineno="15675"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15676"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocation<sp/>&amp;&amp;<sp/>allocation-&gt;GetType()<sp/>==<sp/>VmaAllocation_T::ALLOCATION_TYPE_DEDICATED);</highlight></codeline>
<codeline lineno="15677"><highlight class="normal"></highlight></codeline>
<codeline lineno="15678"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>memTypeIndex<sp/>=<sp/>allocation-&gt;GetMemoryTypeIndex();</highlight></codeline>
<codeline lineno="15679"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>parentPool<sp/>=<sp/>allocation-&gt;GetParentPool();</highlight></codeline>
<codeline lineno="15680"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(parentPool<sp/>==<sp/>VK_NULL_HANDLE)</highlight></codeline>
<codeline lineno="15681"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15682"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Default<sp/>pool</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15683"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_DedicatedAllocations[memTypeIndex].Unregister(allocation);</highlight></codeline>
<codeline lineno="15684"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15685"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15686"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15687"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Custom<sp/>pool</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15688"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>parentPool-&gt;m_DedicatedAllocations.Unregister(allocation);</highlight></codeline>
<codeline lineno="15689"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15690"><highlight class="normal"></highlight></codeline>
<codeline lineno="15691"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceMemory<sp/>hMemory<sp/>=<sp/>allocation-&gt;GetMemory();</highlight></codeline>
<codeline lineno="15692"><highlight class="normal"></highlight></codeline>
<codeline lineno="15693"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="15694"><highlight class="comment"><sp/><sp/><sp/><sp/>There<sp/>is<sp/>no<sp/>need<sp/>to<sp/>call<sp/>this,<sp/>because<sp/>Vulkan<sp/>spec<sp/>allows<sp/>to<sp/>skip<sp/>vkUnmapMemory</highlight></codeline>
<codeline lineno="15695"><highlight class="comment"><sp/><sp/><sp/><sp/>before<sp/>vkFreeMemory.</highlight></codeline>
<codeline lineno="15696"><highlight class="comment"></highlight></codeline>
<codeline lineno="15697"><highlight class="comment"><sp/><sp/><sp/><sp/>if(allocation-&gt;GetMappedData()<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="15698"><highlight class="comment"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15699"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*m_VulkanFunctions.vkUnmapMemory)(m_hDevice,<sp/>hMemory);</highlight></codeline>
<codeline lineno="15700"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15701"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15702"><highlight class="normal"></highlight></codeline>
<codeline lineno="15703"><highlight class="normal"><sp/><sp/><sp/><sp/>FreeVulkanMemory(memTypeIndex,<sp/>allocation-&gt;GetSize(),<sp/>hMemory);</highlight></codeline>
<codeline lineno="15704"><highlight class="normal"></highlight></codeline>
<codeline lineno="15705"><highlight class="normal"><sp/><sp/><sp/><sp/>m_Budget.RemoveAllocation(MemoryTypeIndexToHeapIndex(allocation-&gt;GetMemoryTypeIndex()),<sp/>allocation-&gt;GetSize());</highlight></codeline>
<codeline lineno="15706"><highlight class="normal"><sp/><sp/><sp/><sp/>m_AllocationObjectAllocator.Free(allocation);</highlight></codeline>
<codeline lineno="15707"><highlight class="normal"></highlight></codeline>
<codeline lineno="15708"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;<sp/><sp/><sp/><sp/>Freed<sp/>DedicatedMemory<sp/>MemoryTypeIndex=%u&quot;</highlight><highlight class="normal">,<sp/>memTypeIndex);</highlight></codeline>
<codeline lineno="15709"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15710"><highlight class="normal"></highlight></codeline>
<codeline lineno="15711"><highlight class="normal">uint32_t<sp/>VmaAllocator_T::CalculateGpuDefragmentationMemoryTypeBits()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="15712"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="15713"><highlight class="normal"><sp/><sp/><sp/><sp/>VkBufferCreateInfo<sp/>dummyBufCreateInfo;</highlight></codeline>
<codeline lineno="15714"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaFillGpuDefragmentationBufferCreateInfo(dummyBufCreateInfo);</highlight></codeline>
<codeline lineno="15715"><highlight class="normal"></highlight></codeline>
<codeline lineno="15716"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>memoryTypeBits<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="15717"><highlight class="normal"></highlight></codeline>
<codeline lineno="15718"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>buffer.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15719"><highlight class="normal"><sp/><sp/><sp/><sp/>VkBuffer<sp/>buf<sp/>=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="15720"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>(*GetVulkanFunctions().vkCreateBuffer)(</highlight></codeline>
<codeline lineno="15721"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_hDevice,<sp/>&amp;dummyBufCreateInfo,<sp/>GetAllocationCallbacks(),<sp/>&amp;buf);</highlight></codeline>
<codeline lineno="15722"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>==<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="15723"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15724"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Query<sp/>for<sp/>supported<sp/>memory<sp/>types.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15725"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkMemoryRequirements<sp/>memReq;</highlight></codeline>
<codeline lineno="15726"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*GetVulkanFunctions().vkGetBufferMemoryRequirements)(m_hDevice,<sp/>buf,<sp/>&amp;memReq);</highlight></codeline>
<codeline lineno="15727"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memoryTypeBits<sp/>=<sp/>memReq.memoryTypeBits;</highlight></codeline>
<codeline lineno="15728"><highlight class="normal"></highlight></codeline>
<codeline lineno="15729"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Destroy<sp/>buffer.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15730"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*GetVulkanFunctions().vkDestroyBuffer)(m_hDevice,<sp/>buf,<sp/>GetAllocationCallbacks());</highlight></codeline>
<codeline lineno="15731"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15732"><highlight class="normal"></highlight></codeline>
<codeline lineno="15733"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>memoryTypeBits;</highlight></codeline>
<codeline lineno="15734"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15735"><highlight class="normal"></highlight></codeline>
<codeline lineno="15736"><highlight class="normal">uint32_t<sp/>VmaAllocator_T::CalculateGlobalMemoryTypeBits()</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="15737"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="15738"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Make<sp/>sure<sp/>memory<sp/>information<sp/>is<sp/>already<sp/>fetched.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15739"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(GetMemoryTypeCount()<sp/>&gt;<sp/>0);</highlight></codeline>
<codeline lineno="15740"><highlight class="normal"></highlight></codeline>
<codeline lineno="15741"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>memoryTypeBits<sp/>=<sp/>UINT32_MAX;</highlight></codeline>
<codeline lineno="15742"><highlight class="normal"></highlight></codeline>
<codeline lineno="15743"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!m_UseAmdDeviceCoherentMemory)</highlight></codeline>
<codeline lineno="15744"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15745"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Exclude<sp/>memory<sp/>types<sp/>that<sp/>have<sp/>VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15746"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(uint32_t<sp/>memTypeIndex<sp/>=<sp/>0;<sp/>memTypeIndex<sp/>&lt;<sp/>GetMemoryTypeCount();<sp/>++memTypeIndex)</highlight></codeline>
<codeline lineno="15747"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15748"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">((m_MemProps.memoryTypes[memTypeIndex].propertyFlags<sp/>&amp;<sp/>VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD_COPY)<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="15749"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15750"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memoryTypeBits<sp/>&amp;=<sp/>~(1u<sp/>&lt;&lt;<sp/>memTypeIndex);</highlight></codeline>
<codeline lineno="15751"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15752"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15753"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15754"><highlight class="normal"></highlight></codeline>
<codeline lineno="15755"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>memoryTypeBits;</highlight></codeline>
<codeline lineno="15756"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15757"><highlight class="normal"></highlight></codeline>
<codeline lineno="15758"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>VmaAllocator_T::GetFlushOrInvalidateRange(</highlight></codeline>
<codeline lineno="15759"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="15760"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>offset,<sp/>VkDeviceSize<sp/>size,</highlight></codeline>
<codeline lineno="15761"><highlight class="normal"><sp/><sp/><sp/><sp/>VkMappedMemoryRange&amp;<sp/>outRange)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline lineno="15762"><highlight class="keyword"></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="15763"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>memTypeIndex<sp/>=<sp/>allocation-&gt;GetMemoryTypeIndex();</highlight></codeline>
<codeline lineno="15764"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(size<sp/>&gt;<sp/>0<sp/>&amp;&amp;<sp/>IsMemoryTypeNonCoherent(memTypeIndex))</highlight></codeline>
<codeline lineno="15765"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15766"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>nonCoherentAtomSize<sp/>=<sp/>m_PhysicalDeviceProperties.limits.nonCoherentAtomSize;</highlight></codeline>
<codeline lineno="15767"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>allocationSize<sp/>=<sp/>allocation-&gt;GetSize();</highlight></codeline>
<codeline lineno="15768"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(offset<sp/>&lt;=<sp/>allocationSize);</highlight></codeline>
<codeline lineno="15769"><highlight class="normal"></highlight></codeline>
<codeline lineno="15770"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outRange.sType<sp/>=<sp/>VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;</highlight></codeline>
<codeline lineno="15771"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outRange.pNext<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="15772"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outRange.memory<sp/>=<sp/>allocation-&gt;GetMemory();</highlight></codeline>
<codeline lineno="15773"><highlight class="normal"></highlight></codeline>
<codeline lineno="15774"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal">(allocation-&gt;GetType())</highlight></codeline>
<codeline lineno="15775"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15776"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VmaAllocation_T::ALLOCATION_TYPE_DEDICATED:</highlight></codeline>
<codeline lineno="15777"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outRange.offset<sp/>=<sp/>VmaAlignDown(offset,<sp/>nonCoherentAtomSize);</highlight></codeline>
<codeline lineno="15778"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(size<sp/>==<sp/>VK_WHOLE_SIZE)</highlight></codeline>
<codeline lineno="15779"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15780"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outRange.size<sp/>=<sp/>allocationSize<sp/>-<sp/>outRange.offset;</highlight></codeline>
<codeline lineno="15781"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15782"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15783"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15784"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(offset<sp/>+<sp/>size<sp/>&lt;=<sp/>allocationSize);</highlight></codeline>
<codeline lineno="15785"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outRange.size<sp/>=<sp/>VMA_MIN(</highlight></codeline>
<codeline lineno="15786"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaAlignUp(size<sp/>+<sp/>(offset<sp/>-<sp/>outRange.offset),<sp/>nonCoherentAtomSize),</highlight></codeline>
<codeline lineno="15787"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocationSize<sp/>-<sp/>outRange.offset);</highlight></codeline>
<codeline lineno="15788"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15789"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="15790"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>VmaAllocation_T::ALLOCATION_TYPE_BLOCK:</highlight></codeline>
<codeline lineno="15791"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15792"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>1.<sp/>Still<sp/>within<sp/>this<sp/>allocation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15793"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outRange.offset<sp/>=<sp/>VmaAlignDown(offset,<sp/>nonCoherentAtomSize);</highlight></codeline>
<codeline lineno="15794"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(size<sp/>==<sp/>VK_WHOLE_SIZE)</highlight></codeline>
<codeline lineno="15795"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15796"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>size<sp/>=<sp/>allocationSize<sp/>-<sp/>offset;</highlight></codeline>
<codeline lineno="15797"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15798"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15799"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15800"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(offset<sp/>+<sp/>size<sp/>&lt;=<sp/>allocationSize);</highlight></codeline>
<codeline lineno="15801"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15802"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outRange.size<sp/>=<sp/>VmaAlignUp(size<sp/>+<sp/>(offset<sp/>-<sp/>outRange.offset),<sp/>nonCoherentAtomSize);</highlight></codeline>
<codeline lineno="15803"><highlight class="normal"></highlight></codeline>
<codeline lineno="15804"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>2.<sp/>Adjust<sp/>to<sp/>whole<sp/>block.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15805"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>allocationOffset<sp/>=<sp/>allocation-&gt;GetOffset();</highlight></codeline>
<codeline lineno="15806"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(allocationOffset<sp/>%<sp/>nonCoherentAtomSize<sp/>==<sp/>0);</highlight></codeline>
<codeline lineno="15807"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize<sp/>blockSize<sp/>=<sp/>allocation-&gt;GetBlock()-&gt;m_pMetadata-&gt;GetSize();</highlight></codeline>
<codeline lineno="15808"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outRange.offset<sp/>+=<sp/>allocationOffset;</highlight></codeline>
<codeline lineno="15809"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>outRange.size<sp/>=<sp/>VMA_MIN(outRange.size,<sp/>blockSize<sp/>-<sp/>outRange.offset);</highlight></codeline>
<codeline lineno="15810"><highlight class="normal"></highlight></codeline>
<codeline lineno="15811"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="15812"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15813"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="15814"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0);</highlight></codeline>
<codeline lineno="15815"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15816"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="15817"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15818"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="15819"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15820"><highlight class="normal"></highlight></codeline>
<codeline lineno="15821"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_MEMORY_BUDGET</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15822"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocator_T::UpdateVulkanBudget()</highlight></codeline>
<codeline lineno="15823"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15824"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(m_UseExtMemoryBudget);</highlight></codeline>
<codeline lineno="15825"><highlight class="normal"></highlight></codeline>
<codeline lineno="15826"><highlight class="normal"><sp/><sp/><sp/><sp/>VkPhysicalDeviceMemoryProperties2KHR<sp/>memProps<sp/>=<sp/>{<sp/>VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR<sp/>};</highlight></codeline>
<codeline lineno="15827"><highlight class="normal"></highlight></codeline>
<codeline lineno="15828"><highlight class="normal"><sp/><sp/><sp/><sp/>VkPhysicalDeviceMemoryBudgetPropertiesEXT<sp/>budgetProps<sp/>=<sp/>{<sp/>VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT<sp/>};</highlight></codeline>
<codeline lineno="15829"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaPnextChainPushFront(&amp;memProps,<sp/>&amp;budgetProps);</highlight></codeline>
<codeline lineno="15830"><highlight class="normal"></highlight></codeline>
<codeline lineno="15831"><highlight class="normal"><sp/><sp/><sp/><sp/>GetVulkanFunctions().vkGetPhysicalDeviceMemoryProperties2KHR(m_PhysicalDevice,<sp/>&amp;memProps);</highlight></codeline>
<codeline lineno="15832"><highlight class="normal"></highlight></codeline>
<codeline lineno="15833"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15834"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaMutexLockWrite<sp/>lockWrite(m_Budget.m_BudgetMutex,<sp/>m_UseMutex);</highlight></codeline>
<codeline lineno="15835"><highlight class="normal"></highlight></codeline>
<codeline lineno="15836"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(uint32_t<sp/>heapIndex<sp/>=<sp/>0;<sp/>heapIndex<sp/>&lt;<sp/>GetMemoryHeapCount();<sp/>++heapIndex)</highlight></codeline>
<codeline lineno="15837"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15838"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Budget.m_VulkanUsage[heapIndex]<sp/>=<sp/>budgetProps.heapUsage[heapIndex];</highlight></codeline>
<codeline lineno="15839"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Budget.m_VulkanBudget[heapIndex]<sp/>=<sp/>budgetProps.heapBudget[heapIndex];</highlight></codeline>
<codeline lineno="15840"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Budget.m_BlockBytesAtBudgetFetch[heapIndex]<sp/>=<sp/>m_Budget.m_BlockBytes[heapIndex].load();</highlight></codeline>
<codeline lineno="15841"><highlight class="normal"></highlight></codeline>
<codeline lineno="15842"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Some<sp/>bugged<sp/>drivers<sp/>return<sp/>the<sp/>budget<sp/>incorrectly,<sp/>e.g.<sp/>0<sp/>or<sp/>much<sp/>bigger<sp/>than<sp/>heap<sp/>size.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15843"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_Budget.m_VulkanBudget[heapIndex]<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="15844"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15845"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Budget.m_VulkanBudget[heapIndex]<sp/>=<sp/>m_MemProps.memoryHeaps[heapIndex].size<sp/>*<sp/>8<sp/>/<sp/>10;<sp/></highlight><highlight class="comment">//<sp/>80%<sp/>heuristics.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15846"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15847"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_Budget.m_VulkanBudget[heapIndex]<sp/>&gt;<sp/>m_MemProps.memoryHeaps[heapIndex].size)</highlight></codeline>
<codeline lineno="15848"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15849"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Budget.m_VulkanBudget[heapIndex]<sp/>=<sp/>m_MemProps.memoryHeaps[heapIndex].size;</highlight></codeline>
<codeline lineno="15850"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15851"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(m_Budget.m_VulkanUsage[heapIndex]<sp/>==<sp/>0<sp/>&amp;&amp;<sp/>m_Budget.m_BlockBytesAtBudgetFetch[heapIndex]<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="15852"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15853"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Budget.m_VulkanUsage[heapIndex]<sp/>=<sp/>m_Budget.m_BlockBytesAtBudgetFetch[heapIndex];</highlight></codeline>
<codeline lineno="15854"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15855"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15856"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_Budget.m_OperationsSinceBudgetFetch<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="15857"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15858"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15859"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>VMA_MEMORY_BUDGET</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15860"><highlight class="normal"></highlight></codeline>
<codeline lineno="15861"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocator_T::FillAllocation(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>hAllocation,<sp/>uint8_t<sp/>pattern)</highlight></codeline>
<codeline lineno="15862"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15863"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(VMA_DEBUG_INITIALIZE_ALLOCATIONS<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="15864"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(m_MemProps.memoryTypes[hAllocation-&gt;GetMemoryTypeIndex()].propertyFlags<sp/>&amp;<sp/>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="15865"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15866"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pData<sp/>=<sp/>VMA_NULL;</highlight></codeline>
<codeline lineno="15867"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>Map(hAllocation,<sp/>&amp;pData);</highlight></codeline>
<codeline lineno="15868"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>==<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="15869"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15870"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memset(pData,<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">)pattern,<sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal">)hAllocation-&gt;GetSize());</highlight></codeline>
<codeline lineno="15871"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FlushOrInvalidateAllocation(hAllocation,<sp/>0,<sp/>VK_WHOLE_SIZE,<sp/>VMA_CACHE_FLUSH);</highlight></codeline>
<codeline lineno="15872"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Unmap(hAllocation);</highlight></codeline>
<codeline lineno="15873"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15874"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15875"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15876"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;VMA_DEBUG_INITIALIZE_ALLOCATIONS<sp/>is<sp/>enabled,<sp/>but<sp/>couldn&apos;t<sp/>map<sp/>memory<sp/>to<sp/>fill<sp/>allocation.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="15877"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15878"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15879"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15880"><highlight class="normal"></highlight></codeline>
<codeline lineno="15881"><highlight class="normal">uint32_t<sp/>VmaAllocator_T::GetGpuDefragmentationMemoryTypeBits()</highlight></codeline>
<codeline lineno="15882"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15883"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>memoryTypeBits<sp/>=<sp/>m_GpuDefragmentationMemoryTypeBits.load();</highlight></codeline>
<codeline lineno="15884"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(memoryTypeBits<sp/>==<sp/>UINT32_MAX)</highlight></codeline>
<codeline lineno="15885"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15886"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memoryTypeBits<sp/>=<sp/>CalculateGpuDefragmentationMemoryTypeBits();</highlight></codeline>
<codeline lineno="15887"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>m_GpuDefragmentationMemoryTypeBits.store(memoryTypeBits);</highlight></codeline>
<codeline lineno="15888"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15889"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>memoryTypeBits;</highlight></codeline>
<codeline lineno="15890"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15891"><highlight class="normal"></highlight></codeline>
<codeline lineno="15892"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15893"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>VmaAllocator_T::PrintDetailedMap(VmaJsonWriter&amp;<sp/>json)</highlight></codeline>
<codeline lineno="15894"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15895"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;DefaultPools&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="15896"><highlight class="normal"><sp/><sp/><sp/><sp/>json.BeginObject();</highlight></codeline>
<codeline lineno="15897"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15898"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(uint32_t<sp/>memTypeIndex<sp/>=<sp/>0;<sp/>memTypeIndex<sp/>&lt;<sp/>GetMemoryTypeCount();<sp/>++memTypeIndex)</highlight></codeline>
<codeline lineno="15899"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15900"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaBlockVector*<sp/>pBlockVector<sp/>=<sp/>m_pBlockVectors[memTypeIndex];</highlight></codeline>
<codeline lineno="15901"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaDedicatedAllocationList&amp;<sp/>dedicatedAllocList<sp/>=<sp/>m_DedicatedAllocations[memTypeIndex];</highlight></codeline>
<codeline lineno="15902"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(pBlockVector<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="15903"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15904"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.BeginString(</highlight><highlight class="stringliteral">&quot;Type<sp/>&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="15905"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.ContinueString(memTypeIndex);</highlight></codeline>
<codeline lineno="15906"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.EndString();</highlight></codeline>
<codeline lineno="15907"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.BeginObject();</highlight></codeline>
<codeline lineno="15908"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15909"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;PreferredBlockSize&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="15910"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteNumber(pBlockVector-&gt;GetPreferredBlockSize());</highlight></codeline>
<codeline lineno="15911"><highlight class="normal"></highlight></codeline>
<codeline lineno="15912"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;Blocks&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="15913"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pBlockVector-&gt;PrintDetailedMap(json);</highlight></codeline>
<codeline lineno="15914"><highlight class="normal"></highlight></codeline>
<codeline lineno="15915"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;DedicatedAllocations&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="15916"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dedicatedAllocList.BuildStatsString(json);</highlight></codeline>
<codeline lineno="15917"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15918"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.EndObject();</highlight></codeline>
<codeline lineno="15919"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15920"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15921"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15922"><highlight class="normal"><sp/><sp/><sp/><sp/>json.EndObject();</highlight></codeline>
<codeline lineno="15923"><highlight class="normal"></highlight></codeline>
<codeline lineno="15924"><highlight class="normal"><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;CustomPools&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="15925"><highlight class="normal"><sp/><sp/><sp/><sp/>json.BeginObject();</highlight></codeline>
<codeline lineno="15926"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15927"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaMutexLockRead<sp/>lock(m_PoolsMutex,<sp/>m_UseMutex);</highlight></codeline>
<codeline lineno="15928"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!m_Pools.IsEmpty())</highlight></codeline>
<codeline lineno="15929"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15930"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(uint32_t<sp/>memTypeIndex<sp/>=<sp/>0;<sp/>memTypeIndex<sp/>&lt;<sp/>GetMemoryTypeCount();<sp/>++memTypeIndex)</highlight></codeline>
<codeline lineno="15931"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15932"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>displayType<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="15933"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>index<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="15934"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>pool<sp/>=<sp/>m_Pools.Front();<sp/>pool<sp/>!=<sp/>VMA_NULL;<sp/>pool<sp/>=<sp/>m_Pools.GetNext(pool))</highlight></codeline>
<codeline lineno="15935"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15936"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaBlockVector&amp;<sp/>blockVector<sp/>=<sp/>pool-&gt;m_BlockVector;</highlight></codeline>
<codeline lineno="15937"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(blockVector.GetMemoryTypeIndex()<sp/>==<sp/>memTypeIndex)</highlight></codeline>
<codeline lineno="15938"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15939"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(displayType)</highlight></codeline>
<codeline lineno="15940"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15941"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.BeginString(</highlight><highlight class="stringliteral">&quot;Type<sp/>&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="15942"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.ContinueString(memTypeIndex);</highlight></codeline>
<codeline lineno="15943"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.EndString();</highlight></codeline>
<codeline lineno="15944"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.BeginArray();</highlight></codeline>
<codeline lineno="15945"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>displayType<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="15946"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15947"><highlight class="normal"></highlight></codeline>
<codeline lineno="15948"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.BeginObject();</highlight></codeline>
<codeline lineno="15949"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15950"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;Name&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="15951"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.BeginString();</highlight></codeline>
<codeline lineno="15952"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.ContinueString(index++);</highlight></codeline>
<codeline lineno="15953"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(pool-&gt;GetName())</highlight></codeline>
<codeline lineno="15954"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15955"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;<sp/>-<sp/>&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="15956"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(pool-&gt;GetName());</highlight></codeline>
<codeline lineno="15957"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15958"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.EndString();</highlight></codeline>
<codeline lineno="15959"><highlight class="normal"></highlight></codeline>
<codeline lineno="15960"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;PreferredBlockSize&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="15961"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteNumber(blockVector.GetPreferredBlockSize());</highlight></codeline>
<codeline lineno="15962"><highlight class="normal"></highlight></codeline>
<codeline lineno="15963"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;Blocks&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="15964"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>blockVector.PrintDetailedMap(json);</highlight></codeline>
<codeline lineno="15965"><highlight class="normal"></highlight></codeline>
<codeline lineno="15966"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;DedicatedAllocations&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="15967"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pool-&gt;m_DedicatedAllocations.BuildStatsString(json);</highlight></codeline>
<codeline lineno="15968"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15969"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.EndObject();</highlight></codeline>
<codeline lineno="15970"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15971"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15972"><highlight class="normal"></highlight></codeline>
<codeline lineno="15973"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!displayType)</highlight></codeline>
<codeline lineno="15974"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.EndArray();</highlight></codeline>
<codeline lineno="15975"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15976"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15977"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="15978"><highlight class="normal"><sp/><sp/><sp/><sp/>json.EndObject();</highlight></codeline>
<codeline lineno="15979"><highlight class="normal">}</highlight></codeline>
<codeline lineno="15980"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15981"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_ALLOCATOR_T_FUNCTIONS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15982"><highlight class="normal"></highlight></codeline>
<codeline lineno="15983"><highlight class="normal"></highlight></codeline>
<codeline lineno="15984"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_VMA_PUBLIC_INTERFACE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15985"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__init_1gaf77c946fbecfcc54d02c3d1c1e7e23e7" kindref="member">vmaCreateAllocator</ref>(</highlight></codeline>
<codeline lineno="15986"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocator_create_info" kindref="compound">VmaAllocatorCreateInfo</ref>*<sp/>pCreateInfo,</highlight></codeline>
<codeline lineno="15987"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref>*<sp/>pAllocator)</highlight></codeline>
<codeline lineno="15988"><highlight class="normal">{</highlight></codeline>
<codeline lineno="15989"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(pCreateInfo<sp/>&amp;&amp;<sp/>pAllocator);</highlight></codeline>
<codeline lineno="15990"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(pCreateInfo-&gt;<ref refid="struct_vma_allocator_create_info_1ae0ffc55139b54520a6bb704b29ffc285" kindref="member">vulkanApiVersion</ref><sp/>==<sp/>0<sp/>||</highlight></codeline>
<codeline lineno="15991"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(VK_VERSION_MAJOR(pCreateInfo-&gt;<ref refid="struct_vma_allocator_create_info_1ae0ffc55139b54520a6bb704b29ffc285" kindref="member">vulkanApiVersion</ref>)<sp/>==<sp/>1<sp/>&amp;&amp;<sp/>VK_VERSION_MINOR(pCreateInfo-&gt;<ref refid="struct_vma_allocator_create_info_1ae0ffc55139b54520a6bb704b29ffc285" kindref="member">vulkanApiVersion</ref>)<sp/>&lt;=<sp/>3));</highlight></codeline>
<codeline lineno="15992"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaCreateAllocator&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="15993"><highlight class="normal"><sp/><sp/><sp/><sp/>*pAllocator<sp/>=<sp/>vma_new(pCreateInfo-&gt;<ref refid="struct_vma_allocator_create_info_1aa84222aa55c2b42c1eff64b16978c8c2" kindref="member">pAllocationCallbacks</ref>,<sp/>VmaAllocator_T)(pCreateInfo);</highlight></codeline>
<codeline lineno="15994"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>result<sp/>=<sp/>(*pAllocator)-&gt;Init(pCreateInfo);</highlight></codeline>
<codeline lineno="15995"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(result<sp/>&lt;<sp/>0)</highlight></codeline>
<codeline lineno="15996"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="15997"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vma_delete(pCreateInfo-&gt;<ref refid="struct_vma_allocator_create_info_1aa84222aa55c2b42c1eff64b16978c8c2" kindref="member">pAllocationCallbacks</ref>,<sp/>*pAllocator);</highlight></codeline>
<codeline lineno="15998"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pAllocator<sp/>=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="15999"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16000"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>result;</highlight></codeline>
<codeline lineno="16001"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16002"><highlight class="normal"></highlight></codeline>
<codeline lineno="16003"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__init_1ga0383c8c957625914e9b89bd165ff13f3" kindref="member">vmaDestroyAllocator</ref>(</highlight></codeline>
<codeline lineno="16004"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator)</highlight></codeline>
<codeline lineno="16005"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16006"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(allocator<sp/>!=<sp/>VK_NULL_HANDLE)</highlight></codeline>
<codeline lineno="16007"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16008"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaDestroyAllocator&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16009"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkAllocationCallbacks<sp/>allocationCallbacks<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_AllocationCallbacks;<sp/></highlight><highlight class="comment">//<sp/>Have<sp/>to<sp/>copy<sp/>the<sp/>callbacks<sp/>when<sp/>destroying.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16010"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vma_delete(&amp;allocationCallbacks,<sp/>allocator);</highlight></codeline>
<codeline lineno="16011"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16012"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16013"><highlight class="normal"></highlight></codeline>
<codeline lineno="16014"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__init_1gaacc98daf40a09cddb3ca7940aba9bc3e" kindref="member">vmaGetAllocatorInfo</ref>(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,<sp/><ref refid="struct_vma_allocator_info" kindref="compound">VmaAllocatorInfo</ref>*<sp/>pAllocatorInfo)</highlight></codeline>
<codeline lineno="16015"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16016"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>pAllocatorInfo);</highlight></codeline>
<codeline lineno="16017"><highlight class="normal"><sp/><sp/><sp/><sp/>pAllocatorInfo-&gt;<ref refid="struct_vma_allocator_info_1a5b69acb4900a1a00b550ddec43de3eee" kindref="member">instance</ref><sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_hInstance;</highlight></codeline>
<codeline lineno="16018"><highlight class="normal"><sp/><sp/><sp/><sp/>pAllocatorInfo-&gt;<ref refid="struct_vma_allocator_info_1a45d976f4f410b9e57fd945af74400d5a" kindref="member">physicalDevice</ref><sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetPhysicalDevice();</highlight></codeline>
<codeline lineno="16019"><highlight class="normal"><sp/><sp/><sp/><sp/>pAllocatorInfo-&gt;<ref refid="struct_vma_allocator_info_1a9d4477914a3cbd67fcedd95e928c27a9" kindref="member">device</ref><sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_hDevice;</highlight></codeline>
<codeline lineno="16020"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16021"><highlight class="normal"></highlight></codeline>
<codeline lineno="16022"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__init_1gadcc2ca5c2f692c8c6b77bc7bcee97751" kindref="member">vmaGetPhysicalDeviceProperties</ref>(</highlight></codeline>
<codeline lineno="16023"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16024"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkPhysicalDeviceProperties<sp/>**ppPhysicalDeviceProperties)</highlight></codeline>
<codeline lineno="16025"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16026"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>ppPhysicalDeviceProperties);</highlight></codeline>
<codeline lineno="16027"><highlight class="normal"><sp/><sp/><sp/><sp/>*ppPhysicalDeviceProperties<sp/>=<sp/>&amp;<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_PhysicalDeviceProperties;</highlight></codeline>
<codeline lineno="16028"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16029"><highlight class="normal"></highlight></codeline>
<codeline lineno="16030"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__init_1ga33698c6107c0da349c1dbf43615284df" kindref="member">vmaGetMemoryProperties</ref>(</highlight></codeline>
<codeline lineno="16031"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16032"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkPhysicalDeviceMemoryProperties**<sp/>ppPhysicalDeviceMemoryProperties)</highlight></codeline>
<codeline lineno="16033"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16034"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>ppPhysicalDeviceMemoryProperties);</highlight></codeline>
<codeline lineno="16035"><highlight class="normal"><sp/><sp/><sp/><sp/>*ppPhysicalDeviceMemoryProperties<sp/>=<sp/>&amp;<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_MemProps;</highlight></codeline>
<codeline lineno="16036"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16037"><highlight class="normal"></highlight></codeline>
<codeline lineno="16038"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__init_1ga27cc36c466d171c3e4e0d062c48dc1e6" kindref="member">vmaGetMemoryTypeProperties</ref>(</highlight></codeline>
<codeline lineno="16039"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16040"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>memoryTypeIndex,</highlight></codeline>
<codeline lineno="16041"><highlight class="normal"><sp/><sp/><sp/><sp/>VkMemoryPropertyFlags*<sp/>pFlags)</highlight></codeline>
<codeline lineno="16042"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16043"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>pFlags);</highlight></codeline>
<codeline lineno="16044"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(memoryTypeIndex<sp/>&lt;<sp/>allocator-&gt;GetMemoryTypeCount());</highlight></codeline>
<codeline lineno="16045"><highlight class="normal"><sp/><sp/><sp/><sp/>*pFlags<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_MemProps.memoryTypes[memoryTypeIndex].propertyFlags;</highlight></codeline>
<codeline lineno="16046"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16047"><highlight class="normal"></highlight></codeline>
<codeline lineno="16048"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__init_1gab8e037d09b55f13312f792e0cd98cc03" kindref="member">vmaSetCurrentFrameIndex</ref>(</highlight></codeline>
<codeline lineno="16049"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16050"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>frameIndex)</highlight></codeline>
<codeline lineno="16051"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16052"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator);</highlight></codeline>
<codeline lineno="16053"><highlight class="normal"></highlight></codeline>
<codeline lineno="16054"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16055"><highlight class="normal"></highlight></codeline>
<codeline lineno="16056"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;SetCurrentFrameIndex(frameIndex);</highlight></codeline>
<codeline lineno="16057"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16058"><highlight class="normal"></highlight></codeline>
<codeline lineno="16059"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__stats_1gad176279c8da8f50399674b2ef03ca866" kindref="member">vmaCalculateStatistics</ref>(</highlight></codeline>
<codeline lineno="16060"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16061"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_total_statistics" kindref="compound">VmaTotalStatistics</ref>*<sp/>pStats)</highlight></codeline>
<codeline lineno="16062"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16063"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>pStats);</highlight></codeline>
<codeline lineno="16064"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16065"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;CalculateStatistics(pStats);</highlight></codeline>
<codeline lineno="16066"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16067"><highlight class="normal"></highlight></codeline>
<codeline lineno="16068"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__stats_1ga620eaa8a9d919860f7deaf4d0148b2a1" kindref="member">vmaGetHeapBudgets</ref>(</highlight></codeline>
<codeline lineno="16069"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16070"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_budget" kindref="compound">VmaBudget</ref>*<sp/>pBudgets)</highlight></codeline>
<codeline lineno="16071"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16072"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>pBudgets);</highlight></codeline>
<codeline lineno="16073"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16074"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetHeapBudgets(pBudgets,<sp/>0,<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetMemoryHeapCount());</highlight></codeline>
<codeline lineno="16075"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16076"><highlight class="normal"></highlight></codeline>
<codeline lineno="16077"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16078"><highlight class="normal"></highlight></codeline>
<codeline lineno="16079"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__stats_1ga9326cba3c64929b59a15c3ca9cdc8cdb" kindref="member">vmaBuildStatsString</ref>(</highlight></codeline>
<codeline lineno="16080"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16081"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>ppStatsString,</highlight></codeline>
<codeline lineno="16082"><highlight class="normal"><sp/><sp/><sp/><sp/>VkBool32<sp/>detailedMap)</highlight></codeline>
<codeline lineno="16083"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16084"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>ppStatsString);</highlight></codeline>
<codeline lineno="16085"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16086"><highlight class="normal"></highlight></codeline>
<codeline lineno="16087"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaStringBuilder<sp/>sb(<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationCallbacks());</highlight></codeline>
<codeline lineno="16088"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16089"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_budget" kindref="compound">VmaBudget</ref><sp/>budgets[VK_MAX_MEMORY_HEAPS];</highlight></codeline>
<codeline lineno="16090"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetHeapBudgets(budgets,<sp/>0,<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetMemoryHeapCount());</highlight></codeline>
<codeline lineno="16091"><highlight class="normal"></highlight></codeline>
<codeline lineno="16092"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_vma_total_statistics" kindref="compound">VmaTotalStatistics</ref><sp/>stats;</highlight></codeline>
<codeline lineno="16093"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;CalculateStatistics(&amp;stats);</highlight></codeline>
<codeline lineno="16094"><highlight class="normal"></highlight></codeline>
<codeline lineno="16095"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaJsonWriter<sp/>json(<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationCallbacks(),<sp/>sb);</highlight></codeline>
<codeline lineno="16096"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.BeginObject();</highlight></codeline>
<codeline lineno="16097"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16098"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;General&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16099"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.BeginObject();</highlight></codeline>
<codeline lineno="16100"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16101"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkPhysicalDeviceProperties&amp;<sp/>deviceProperties<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_PhysicalDeviceProperties;</highlight></codeline>
<codeline lineno="16102"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkPhysicalDeviceMemoryProperties&amp;<sp/>memoryProperties<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_MemProps;</highlight></codeline>
<codeline lineno="16103"><highlight class="normal"></highlight></codeline>
<codeline lineno="16104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;API&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16105"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;Vulkan&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16106"><highlight class="normal"></highlight></codeline>
<codeline lineno="16107"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;apiVersion&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16108"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.BeginString();</highlight></codeline>
<codeline lineno="16109"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.ContinueString(VK_API_VERSION_MAJOR(deviceProperties.apiVersion));</highlight></codeline>
<codeline lineno="16110"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.ContinueString(</highlight><highlight class="stringliteral">&quot;.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16111"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.ContinueString(VK_API_VERSION_MINOR(deviceProperties.apiVersion));</highlight></codeline>
<codeline lineno="16112"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.ContinueString(</highlight><highlight class="stringliteral">&quot;.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.ContinueString(VK_API_VERSION_PATCH(deviceProperties.apiVersion));</highlight></codeline>
<codeline lineno="16114"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.EndString();</highlight></codeline>
<codeline lineno="16115"><highlight class="normal"></highlight></codeline>
<codeline lineno="16116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;GPU&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(deviceProperties.deviceName);</highlight></codeline>
<codeline lineno="16118"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;deviceType&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16119"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteNumber(</highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">uint32_t</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(deviceProperties.deviceType));</highlight></codeline>
<codeline lineno="16120"><highlight class="normal"></highlight></codeline>
<codeline lineno="16121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;maxMemoryAllocationCount&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteNumber(deviceProperties.limits.maxMemoryAllocationCount);</highlight></codeline>
<codeline lineno="16123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;bufferImageGranularity&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16124"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteNumber(deviceProperties.limits.bufferImageGranularity);</highlight></codeline>
<codeline lineno="16125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;nonCoherentAtomSize&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteNumber(deviceProperties.limits.nonCoherentAtomSize);</highlight></codeline>
<codeline lineno="16127"><highlight class="normal"></highlight></codeline>
<codeline lineno="16128"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;memoryHeapCount&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16129"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteNumber(memoryProperties.memoryHeapCount);</highlight></codeline>
<codeline lineno="16130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;memoryTypeCount&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteNumber(memoryProperties.memoryTypeCount);</highlight></codeline>
<codeline lineno="16132"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16133"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.EndObject();</highlight></codeline>
<codeline lineno="16134"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16135"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16136"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;Total&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16137"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaPrintDetailedStatistics(json,<sp/>stats.<ref refid="struct_vma_total_statistics_1a76f1935f7101883f5bb2a03b6c5649d2" kindref="member">total</ref>);</highlight></codeline>
<codeline lineno="16138"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16139"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16140"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;MemoryInfo&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16141"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.BeginObject();</highlight></codeline>
<codeline lineno="16142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16143"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(uint32_t<sp/>heapIndex<sp/>=<sp/>0;<sp/>heapIndex<sp/>&lt;<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetMemoryHeapCount();<sp/>++heapIndex)</highlight></codeline>
<codeline lineno="16144"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.BeginString(</highlight><highlight class="stringliteral">&quot;Heap<sp/>&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.ContinueString(heapIndex);</highlight></codeline>
<codeline lineno="16147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.EndString();</highlight></codeline>
<codeline lineno="16148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.BeginObject();</highlight></codeline>
<codeline lineno="16149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16150"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkMemoryHeap&amp;<sp/>heapInfo<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_MemProps.memoryHeaps[heapIndex];</highlight></codeline>
<codeline lineno="16151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;Flags&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.BeginArray(</highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16153"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16154"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(heapInfo.flags<sp/>&amp;<sp/>VK_MEMORY_HEAP_DEVICE_LOCAL_BIT)</highlight></codeline>
<codeline lineno="16155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;DEVICE_LOCAL&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16156"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#if<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1001000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16157"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(heapInfo.flags<sp/>&amp;<sp/>VK_MEMORY_HEAP_MULTI_INSTANCE_BIT)</highlight></codeline>
<codeline lineno="16158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;MULTI_INSTANCE&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16159"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16160"><highlight class="normal"></highlight></codeline>
<codeline lineno="16161"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkMemoryHeapFlags<sp/>flags<sp/>=<sp/>heapInfo.flags<sp/>&amp;</highlight></codeline>
<codeline lineno="16162"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>~(VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</highlight></codeline>
<codeline lineno="16163"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#if<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1001000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16164"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>VK_MEMORY_HEAP_MULTI_INSTANCE_BIT</highlight></codeline>
<codeline lineno="16165"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16166"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>);</highlight></codeline>
<codeline lineno="16167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(flags<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="16168"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteNumber(flags);</highlight></codeline>
<codeline lineno="16169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16170"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.EndArray();</highlight></codeline>
<codeline lineno="16171"><highlight class="normal"></highlight></codeline>
<codeline lineno="16172"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;Size&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteNumber(heapInfo.size);</highlight></codeline>
<codeline lineno="16174"><highlight class="normal"></highlight></codeline>
<codeline lineno="16175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;Budget&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16176"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.BeginObject();</highlight></codeline>
<codeline lineno="16177"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16178"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;BudgetBytes&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16179"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteNumber(budgets[heapIndex].budget);</highlight></codeline>
<codeline lineno="16180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;UsageBytes&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16181"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteNumber(budgets[heapIndex].usage);</highlight></codeline>
<codeline lineno="16182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.EndObject();</highlight></codeline>
<codeline lineno="16184"><highlight class="normal"></highlight></codeline>
<codeline lineno="16185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;Stats&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaPrintDetailedStatistics(json,<sp/>stats.<ref refid="struct_vma_total_statistics_1a39beeba5b3a2e7cfe5f5e2331a2705ce" kindref="member">memoryHeap</ref>[heapIndex]);</highlight></codeline>
<codeline lineno="16187"><highlight class="normal"></highlight></codeline>
<codeline lineno="16188"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;MemoryPools&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16189"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.BeginObject();</highlight></codeline>
<codeline lineno="16190"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16191"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(uint32_t<sp/>typeIndex<sp/>=<sp/>0;<sp/>typeIndex<sp/>&lt;<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetMemoryTypeCount();<sp/>++typeIndex)</highlight></codeline>
<codeline lineno="16192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16193"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;MemoryTypeIndexToHeapIndex(typeIndex)<sp/>==<sp/>heapIndex)</highlight></codeline>
<codeline lineno="16194"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.BeginString(</highlight><highlight class="stringliteral">&quot;Type<sp/>&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16196"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.ContinueString(typeIndex);</highlight></codeline>
<codeline lineno="16197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.EndString();</highlight></codeline>
<codeline lineno="16198"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.BeginObject();</highlight></codeline>
<codeline lineno="16199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;Flags&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.BeginArray(</highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16203"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkMemoryPropertyFlags<sp/>flags<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_MemProps.memoryTypes[typeIndex].propertyFlags;</highlight></codeline>
<codeline lineno="16204"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(flags<sp/>&amp;<sp/>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT)</highlight></codeline>
<codeline lineno="16205"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;DEVICE_LOCAL&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16206"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(flags<sp/>&amp;<sp/>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT)</highlight></codeline>
<codeline lineno="16207"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;HOST_VISIBLE&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(flags<sp/>&amp;<sp/>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT)</highlight></codeline>
<codeline lineno="16209"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;HOST_COHERENT&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16210"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(flags<sp/>&amp;<sp/>VK_MEMORY_PROPERTY_HOST_CACHED_BIT)</highlight></codeline>
<codeline lineno="16211"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;HOST_CACHED&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16212"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(flags<sp/>&amp;<sp/>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT)</highlight></codeline>
<codeline lineno="16213"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;LAZILY_ALLOCATED&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16214"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#if<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1001000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16215"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(flags<sp/>&amp;<sp/>VK_MEMORY_PROPERTY_PROTECTED_BIT)</highlight></codeline>
<codeline lineno="16216"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;PROTECTED&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16217"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16218"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#if<sp/>VK_AMD_device_coherent_memory</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16219"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(flags<sp/>&amp;<sp/>VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD_COPY)</highlight></codeline>
<codeline lineno="16220"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;DEVICE_COHERENT_AMD&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16221"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(flags<sp/>&amp;<sp/>VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD_COPY)</highlight></codeline>
<codeline lineno="16222"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;DEVICE_UNCACHED_AMD&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16223"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16224"><highlight class="normal"></highlight></codeline>
<codeline lineno="16225"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>flags<sp/>&amp;=<sp/>~(VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</highlight></codeline>
<codeline lineno="16226"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#if<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1001000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16227"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</highlight></codeline>
<codeline lineno="16228"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16229"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#if<sp/>VK_AMD_device_coherent_memory</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16230"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD_COPY</highlight></codeline>
<codeline lineno="16231"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD_COPY</highlight></codeline>
<codeline lineno="16232"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16233"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</highlight></codeline>
<codeline lineno="16234"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</highlight></codeline>
<codeline lineno="16235"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>VK_MEMORY_PROPERTY_HOST_CACHED_BIT);</highlight></codeline>
<codeline lineno="16236"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(flags<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="16237"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteNumber(flags);</highlight></codeline>
<codeline lineno="16238"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16239"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.EndArray();</highlight></codeline>
<codeline lineno="16240"><highlight class="normal"></highlight></codeline>
<codeline lineno="16241"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.WriteString(</highlight><highlight class="stringliteral">&quot;Stats&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16242"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaPrintDetailedStatistics(json,<sp/>stats.<ref refid="struct_vma_total_statistics_1acb70e5b7fe543813ed8ba9282640969d" kindref="member">memoryType</ref>[typeIndex]);</highlight></codeline>
<codeline lineno="16243"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16244"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.EndObject();</highlight></codeline>
<codeline lineno="16245"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16246"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16247"><highlight class="normal"></highlight></codeline>
<codeline lineno="16248"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16249"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.EndObject();</highlight></codeline>
<codeline lineno="16250"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16251"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.EndObject();</highlight></codeline>
<codeline lineno="16252"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16253"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16254"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.EndObject();</highlight></codeline>
<codeline lineno="16255"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16256"><highlight class="normal"></highlight></codeline>
<codeline lineno="16257"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(detailedMap<sp/>==<sp/>VK_TRUE)</highlight></codeline>
<codeline lineno="16258"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;PrintDetailedMap(json);</highlight></codeline>
<codeline lineno="16259"><highlight class="normal"></highlight></codeline>
<codeline lineno="16260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>json.EndObject();</highlight></codeline>
<codeline lineno="16261"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16262"><highlight class="normal"></highlight></codeline>
<codeline lineno="16263"><highlight class="normal"><sp/><sp/><sp/><sp/>*ppStatsString<sp/>=<sp/>VmaCreateStringCopy(<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationCallbacks(),<sp/>sb.GetData(),<sp/>sb.GetLength());</highlight></codeline>
<codeline lineno="16264"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16265"><highlight class="normal"></highlight></codeline>
<codeline lineno="16266"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__stats_1gad9b3c6a5dce6aea00719ccb2d3a780f3" kindref="member">vmaFreeStatsString</ref>(</highlight></codeline>
<codeline lineno="16267"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16268"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>pStatsString)</highlight></codeline>
<codeline lineno="16269"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16270"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pStatsString<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="16271"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16272"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator);</highlight></codeline>
<codeline lineno="16273"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaFreeString(<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationCallbacks(),<sp/>pStatsString);</highlight></codeline>
<codeline lineno="16274"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16275"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16276"><highlight class="normal"></highlight></codeline>
<codeline lineno="16277"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16278"><highlight class="normal"></highlight></codeline>
<codeline lineno="16279"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="16280"><highlight class="comment">This<sp/>function<sp/>is<sp/>not<sp/>protected<sp/>by<sp/>any<sp/>mutex<sp/>because<sp/>it<sp/>just<sp/>reads<sp/>immutable<sp/>data.</highlight></codeline>
<codeline lineno="16281"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16282"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga03cee2bfc7fef20382fa56f5870f3b2f" kindref="member">vmaFindMemoryTypeIndex</ref>(</highlight></codeline>
<codeline lineno="16283"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16284"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>memoryTypeBits,</highlight></codeline>
<codeline lineno="16285"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>*<sp/>pAllocationCreateInfo,</highlight></codeline>
<codeline lineno="16286"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t*<sp/>pMemoryTypeIndex)</highlight></codeline>
<codeline lineno="16287"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16288"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>!=<sp/>VK_NULL_HANDLE);</highlight></codeline>
<codeline lineno="16289"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(pAllocationCreateInfo<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="16290"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(pMemoryTypeIndex<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="16291"><highlight class="normal"></highlight></codeline>
<codeline lineno="16292"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;FindMemoryTypeIndex(memoryTypeBits,<sp/>pAllocationCreateInfo,<sp/>UINT32_MAX,<sp/>pMemoryTypeIndex);</highlight></codeline>
<codeline lineno="16293"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16294"><highlight class="normal"></highlight></codeline>
<codeline lineno="16295"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga723f5683b363c306bf860dab1861f299" kindref="member">vmaFindMemoryTypeIndexForBufferInfo</ref>(</highlight></codeline>
<codeline lineno="16296"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16297"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkBufferCreateInfo*<sp/>pBufferCreateInfo,</highlight></codeline>
<codeline lineno="16298"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>*<sp/>pAllocationCreateInfo,</highlight></codeline>
<codeline lineno="16299"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t*<sp/>pMemoryTypeIndex)</highlight></codeline>
<codeline lineno="16300"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16301"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>!=<sp/>VK_NULL_HANDLE);</highlight></codeline>
<codeline lineno="16302"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(pBufferCreateInfo<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="16303"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(pAllocationCreateInfo<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="16304"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(pMemoryTypeIndex<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="16305"><highlight class="normal"></highlight></codeline>
<codeline lineno="16306"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDevice<sp/>hDev<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_hDevice;</highlight></codeline>
<codeline lineno="16307"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_vulkan_functions" kindref="compound">VmaVulkanFunctions</ref>*<sp/>funcs<sp/>=<sp/>&amp;<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetVulkanFunctions();</highlight></codeline>
<codeline lineno="16308"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>res;</highlight></codeline>
<codeline lineno="16309"><highlight class="normal"></highlight></codeline>
<codeline lineno="16310"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1003000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16311"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(funcs-&gt;vkGetDeviceBufferMemoryRequirements)</highlight></codeline>
<codeline lineno="16312"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16313"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Can<sp/>query<sp/>straight<sp/>from<sp/>VkBufferCreateInfo<sp/>:)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16314"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceBufferMemoryRequirements<sp/>devBufMemReq<sp/>=<sp/>{VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS};</highlight></codeline>
<codeline lineno="16315"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>devBufMemReq.pCreateInfo<sp/>=<sp/>pBufferCreateInfo;</highlight></codeline>
<codeline lineno="16316"><highlight class="normal"></highlight></codeline>
<codeline lineno="16317"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkMemoryRequirements2<sp/>memReq<sp/>=<sp/>{VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2};</highlight></codeline>
<codeline lineno="16318"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*funcs-&gt;vkGetDeviceBufferMemoryRequirements)(hDev,<sp/>&amp;devBufMemReq,<sp/>&amp;memReq);</highlight></codeline>
<codeline lineno="16319"><highlight class="normal"></highlight></codeline>
<codeline lineno="16320"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;FindMemoryTypeIndex(</highlight></codeline>
<codeline lineno="16321"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memReq.memoryRequirements.memoryTypeBits,<sp/>pAllocationCreateInfo,<sp/>pBufferCreateInfo-&gt;usage,<sp/>pMemoryTypeIndex);</highlight></codeline>
<codeline lineno="16322"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16323"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16324"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1003000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16325"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Must<sp/>create<sp/>a<sp/>dummy<sp/>buffer<sp/>to<sp/>query<sp/>:(</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkBuffer<sp/>hBuffer<sp/>=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="16328"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>funcs-&gt;<ref refid="struct_vma_vulkan_functions_1a0bd2f3dbbfb386e856fcb0bde76329e0" kindref="member">vkCreateBuffer</ref>(</highlight></codeline>
<codeline lineno="16329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>hDev,<sp/>pBufferCreateInfo,<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationCallbacks(),<sp/>&amp;hBuffer);</highlight></codeline>
<codeline lineno="16330"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>==<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="16331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16332"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkMemoryRequirements<sp/>memReq<sp/>=<sp/>{};</highlight></codeline>
<codeline lineno="16333"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>funcs-&gt;<ref refid="struct_vma_vulkan_functions_1aea05477481ca6f88a38182de3e0fc26a" kindref="member">vkGetBufferMemoryRequirements</ref>(hDev,<sp/>hBuffer,<sp/>&amp;memReq);</highlight></codeline>
<codeline lineno="16334"><highlight class="normal"></highlight></codeline>
<codeline lineno="16335"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;FindMemoryTypeIndex(</highlight></codeline>
<codeline lineno="16336"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memReq.memoryTypeBits,<sp/>pAllocationCreateInfo,<sp/>pBufferCreateInfo-&gt;usage,<sp/>pMemoryTypeIndex);</highlight></codeline>
<codeline lineno="16337"><highlight class="normal"></highlight></codeline>
<codeline lineno="16338"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>funcs-&gt;<ref refid="struct_vma_vulkan_functions_1a8d54d31cc46f21c00fa5fc78085dfc90" kindref="member">vkDestroyBuffer</ref>(</highlight></codeline>
<codeline lineno="16339"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>hDev,<sp/>hBuffer,<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationCallbacks());</highlight></codeline>
<codeline lineno="16340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16341"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16342"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="16343"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16344"><highlight class="normal"></highlight></codeline>
<codeline lineno="16345"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gaaf05345771a087328949b485ff2da4db" kindref="member">vmaFindMemoryTypeIndexForImageInfo</ref>(</highlight></codeline>
<codeline lineno="16346"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16347"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkImageCreateInfo*<sp/>pImageCreateInfo,</highlight></codeline>
<codeline lineno="16348"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>*<sp/>pAllocationCreateInfo,</highlight></codeline>
<codeline lineno="16349"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t*<sp/>pMemoryTypeIndex)</highlight></codeline>
<codeline lineno="16350"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16351"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>!=<sp/>VK_NULL_HANDLE);</highlight></codeline>
<codeline lineno="16352"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(pImageCreateInfo<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="16353"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(pAllocationCreateInfo<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="16354"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(pMemoryTypeIndex<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="16355"><highlight class="normal"></highlight></codeline>
<codeline lineno="16356"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDevice<sp/>hDev<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_hDevice;</highlight></codeline>
<codeline lineno="16357"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_vulkan_functions" kindref="compound">VmaVulkanFunctions</ref>*<sp/>funcs<sp/>=<sp/>&amp;<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetVulkanFunctions();</highlight></codeline>
<codeline lineno="16358"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>res;</highlight></codeline>
<codeline lineno="16359"><highlight class="normal"></highlight></codeline>
<codeline lineno="16360"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1003000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16361"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(funcs-&gt;vkGetDeviceImageMemoryRequirements)</highlight></codeline>
<codeline lineno="16362"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16363"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Can<sp/>query<sp/>straight<sp/>from<sp/>VkImageCreateInfo<sp/>:)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16364"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkDeviceImageMemoryRequirements<sp/>devImgMemReq<sp/>=<sp/>{VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS};</highlight></codeline>
<codeline lineno="16365"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>devImgMemReq.pCreateInfo<sp/>=<sp/>pImageCreateInfo;</highlight></codeline>
<codeline lineno="16366"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(pImageCreateInfo-&gt;tiling<sp/>!=<sp/>VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT_COPY<sp/>&amp;&amp;<sp/>(pImageCreateInfo-&gt;flags<sp/>&amp;<sp/>VK_IMAGE_CREATE_DISJOINT_BIT_COPY)<sp/>==<sp/>0<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="16367"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;Cannot<sp/>use<sp/>this<sp/>VkImageCreateInfo<sp/>with<sp/>vmaFindMemoryTypeIndexForImageInfo<sp/>as<sp/>I<sp/>don&apos;t<sp/>know<sp/>what<sp/>to<sp/>pass<sp/>as<sp/>VkDeviceImageMemoryRequirements::planeAspect.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16368"><highlight class="normal"></highlight></codeline>
<codeline lineno="16369"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkMemoryRequirements2<sp/>memReq<sp/>=<sp/>{VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2};</highlight></codeline>
<codeline lineno="16370"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*funcs-&gt;vkGetDeviceImageMemoryRequirements)(hDev,<sp/>&amp;devImgMemReq,<sp/>&amp;memReq);</highlight></codeline>
<codeline lineno="16371"><highlight class="normal"></highlight></codeline>
<codeline lineno="16372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;FindMemoryTypeIndex(</highlight></codeline>
<codeline lineno="16373"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memReq.memoryRequirements.memoryTypeBits,<sp/>pAllocationCreateInfo,<sp/>pImageCreateInfo-&gt;usage,<sp/>pMemoryTypeIndex);</highlight></codeline>
<codeline lineno="16374"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16375"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16376"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>#if<sp/>VMA_VULKAN_VERSION<sp/>&gt;=<sp/>1003000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16377"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Must<sp/>create<sp/>a<sp/>dummy<sp/>image<sp/>to<sp/>query<sp/>:(</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16379"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkImage<sp/>hImage<sp/>=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="16380"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>funcs-&gt;<ref refid="struct_vma_vulkan_functions_1abf5b72637db39313cfe1645cb7f07fdd" kindref="member">vkCreateImage</ref>(</highlight></codeline>
<codeline lineno="16381"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>hDev,<sp/>pImageCreateInfo,<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationCallbacks(),<sp/>&amp;hImage);</highlight></codeline>
<codeline lineno="16382"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>==<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="16383"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16384"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkMemoryRequirements<sp/>memReq<sp/>=<sp/>{};</highlight></codeline>
<codeline lineno="16385"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>funcs-&gt;<ref refid="struct_vma_vulkan_functions_1aed58624ef2f8d410b7889db504ff55c7" kindref="member">vkGetImageMemoryRequirements</ref>(hDev,<sp/>hImage,<sp/>&amp;memReq);</highlight></codeline>
<codeline lineno="16386"><highlight class="normal"></highlight></codeline>
<codeline lineno="16387"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;FindMemoryTypeIndex(</highlight></codeline>
<codeline lineno="16388"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memReq.memoryTypeBits,<sp/>pAllocationCreateInfo,<sp/>pImageCreateInfo-&gt;usage,<sp/>pMemoryTypeIndex);</highlight></codeline>
<codeline lineno="16389"><highlight class="normal"></highlight></codeline>
<codeline lineno="16390"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>funcs-&gt;<ref refid="struct_vma_vulkan_functions_1a14b5141287f45780bb1194a1ba6ff272" kindref="member">vkDestroyImage</ref>(</highlight></codeline>
<codeline lineno="16391"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>hDev,<sp/>hImage,<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationCallbacks());</highlight></codeline>
<codeline lineno="16392"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16393"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16394"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="16395"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16396"><highlight class="normal"></highlight></codeline>
<codeline lineno="16397"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga250d4f6f4c09a6a03b82323f999c9c4e" kindref="member">vmaCreatePool</ref>(</highlight></codeline>
<codeline lineno="16398"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16399"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_pool_create_info" kindref="compound">VmaPoolCreateInfo</ref>*<sp/>pCreateInfo,</highlight></codeline>
<codeline lineno="16400"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref>*<sp/>pPool)</highlight></codeline>
<codeline lineno="16401"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16402"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>pCreateInfo<sp/>&amp;&amp;<sp/>pPool);</highlight></codeline>
<codeline lineno="16403"><highlight class="normal"></highlight></codeline>
<codeline lineno="16404"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaCreatePool&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16405"><highlight class="normal"></highlight></codeline>
<codeline lineno="16406"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16407"><highlight class="normal"></highlight></codeline>
<codeline lineno="16408"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;CreatePool(pCreateInfo,<sp/>pPool);</highlight></codeline>
<codeline lineno="16409"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16410"><highlight class="normal"></highlight></codeline>
<codeline lineno="16411"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gad03da7fd4d8b772bc2a299bc34850d98" kindref="member">vmaDestroyPool</ref>(</highlight></codeline>
<codeline lineno="16412"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16413"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>pool)</highlight></codeline>
<codeline lineno="16414"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16415"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator);</highlight></codeline>
<codeline lineno="16416"><highlight class="normal"></highlight></codeline>
<codeline lineno="16417"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pool<sp/>==<sp/>VK_NULL_HANDLE)</highlight></codeline>
<codeline lineno="16418"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16419"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="16420"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16421"><highlight class="normal"></highlight></codeline>
<codeline lineno="16422"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaDestroyPool&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16423"><highlight class="normal"></highlight></codeline>
<codeline lineno="16424"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16425"><highlight class="normal"></highlight></codeline>
<codeline lineno="16426"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;DestroyPool(pool);</highlight></codeline>
<codeline lineno="16427"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16428"><highlight class="normal"></highlight></codeline>
<codeline lineno="16429"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__stats_1ga7e489a68f893dbefc78a6ac9413c4220" kindref="member">vmaGetPoolStatistics</ref>(</highlight></codeline>
<codeline lineno="16430"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16431"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>pool,</highlight></codeline>
<codeline lineno="16432"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref>*<sp/>pPoolStats)</highlight></codeline>
<codeline lineno="16433"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16434"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>pool<sp/>&amp;&amp;<sp/>pPoolStats);</highlight></codeline>
<codeline lineno="16435"><highlight class="normal"></highlight></codeline>
<codeline lineno="16436"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16437"><highlight class="normal"></highlight></codeline>
<codeline lineno="16438"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetPoolStatistics(pool,<sp/>pPoolStats);</highlight></codeline>
<codeline lineno="16439"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16440"><highlight class="normal"></highlight></codeline>
<codeline lineno="16441"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__stats_1ga54b57aa8f511406711f4b918028d8f60" kindref="member">vmaCalculatePoolStatistics</ref>(</highlight></codeline>
<codeline lineno="16442"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16443"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>pool,</highlight></codeline>
<codeline lineno="16444"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>*<sp/>pPoolStats)</highlight></codeline>
<codeline lineno="16445"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16446"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>pool<sp/>&amp;&amp;<sp/>pPoolStats);</highlight></codeline>
<codeline lineno="16447"><highlight class="normal"></highlight></codeline>
<codeline lineno="16448"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16449"><highlight class="normal"></highlight></codeline>
<codeline lineno="16450"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;CalculatePoolStatistics(pool,<sp/>pPoolStats);</highlight></codeline>
<codeline lineno="16451"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16452"><highlight class="normal"></highlight></codeline>
<codeline lineno="16453"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga19e2e174d6acb8abfdeb8c200517a468" kindref="member">vmaCheckPoolCorruption</ref>(<ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,<sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>pool)</highlight></codeline>
<codeline lineno="16454"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16455"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>pool);</highlight></codeline>
<codeline lineno="16456"><highlight class="normal"></highlight></codeline>
<codeline lineno="16457"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16458"><highlight class="normal"></highlight></codeline>
<codeline lineno="16459"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaCheckPoolCorruption&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16460"><highlight class="normal"></highlight></codeline>
<codeline lineno="16461"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;CheckPoolCorruption(pool);</highlight></codeline>
<codeline lineno="16462"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16463"><highlight class="normal"></highlight></codeline>
<codeline lineno="16464"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga77b2f609887eabcc36ab90e94230acbf" kindref="member">vmaGetPoolName</ref>(</highlight></codeline>
<codeline lineno="16465"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16466"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>pool,</highlight></codeline>
<codeline lineno="16467"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>ppName)</highlight></codeline>
<codeline lineno="16468"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16469"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>pool<sp/>&amp;&amp;<sp/>ppName);</highlight></codeline>
<codeline lineno="16470"><highlight class="normal"></highlight></codeline>
<codeline lineno="16471"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaGetPoolName&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16472"><highlight class="normal"></highlight></codeline>
<codeline lineno="16473"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16474"><highlight class="normal"></highlight></codeline>
<codeline lineno="16475"><highlight class="normal"><sp/><sp/><sp/><sp/>*ppName<sp/>=<sp/>pool-&gt;GetName();</highlight></codeline>
<codeline lineno="16476"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16477"><highlight class="normal"></highlight></codeline>
<codeline lineno="16478"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gac0322f7ac6c6425492aec787397d5597" kindref="member">vmaSetPoolName</ref>(</highlight></codeline>
<codeline lineno="16479"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16480"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>pool,</highlight></codeline>
<codeline lineno="16481"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>pName)</highlight></codeline>
<codeline lineno="16482"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16483"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>pool);</highlight></codeline>
<codeline lineno="16484"><highlight class="normal"></highlight></codeline>
<codeline lineno="16485"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaSetPoolName&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16486"><highlight class="normal"></highlight></codeline>
<codeline lineno="16487"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16488"><highlight class="normal"></highlight></codeline>
<codeline lineno="16489"><highlight class="normal"><sp/><sp/><sp/><sp/>pool-&gt;SetName(pName);</highlight></codeline>
<codeline lineno="16490"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16491"><highlight class="normal"></highlight></codeline>
<codeline lineno="16492"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gaf813f55a0667016a8cd68bb4b8b3b30c" kindref="member">vmaAllocateMemory</ref>(</highlight></codeline>
<codeline lineno="16493"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16494"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkMemoryRequirements*<sp/>pVkMemoryRequirements,</highlight></codeline>
<codeline lineno="16495"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>*<sp/>pCreateInfo,</highlight></codeline>
<codeline lineno="16496"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>pAllocation,</highlight></codeline>
<codeline lineno="16497"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref>*<sp/>pAllocationInfo)</highlight></codeline>
<codeline lineno="16498"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16499"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>pVkMemoryRequirements<sp/>&amp;&amp;<sp/>pCreateInfo<sp/>&amp;&amp;<sp/>pAllocation);</highlight></codeline>
<codeline lineno="16500"><highlight class="normal"></highlight></codeline>
<codeline lineno="16501"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaAllocateMemory&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16502"><highlight class="normal"></highlight></codeline>
<codeline lineno="16503"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16504"><highlight class="normal"></highlight></codeline>
<codeline lineno="16505"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>result<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;AllocateMemory(</highlight></codeline>
<codeline lineno="16506"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pVkMemoryRequirements,</highlight></codeline>
<codeline lineno="16507"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">,<sp/></highlight><highlight class="comment">//<sp/>requiresDedicatedAllocation</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16508"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">,<sp/></highlight><highlight class="comment">//<sp/>prefersDedicatedAllocation</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16509"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VK_NULL_HANDLE,<sp/></highlight><highlight class="comment">//<sp/>dedicatedBuffer</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16510"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VK_NULL_HANDLE,<sp/></highlight><highlight class="comment">//<sp/>dedicatedImage</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16511"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UINT32_MAX,<sp/></highlight><highlight class="comment">//<sp/>dedicatedBufferImageUsage</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16512"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pCreateInfo,</highlight></codeline>
<codeline lineno="16513"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_SUBALLOCATION_TYPE_UNKNOWN,</highlight></codeline>
<codeline lineno="16514"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1,<sp/></highlight><highlight class="comment">//<sp/>allocationCount</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16515"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocation);</highlight></codeline>
<codeline lineno="16516"><highlight class="normal"></highlight></codeline>
<codeline lineno="16517"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pAllocationInfo<sp/>!=<sp/>VMA_NULL<sp/>&amp;&amp;<sp/>result<sp/>==<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="16518"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16519"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationInfo(*pAllocation,<sp/>pAllocationInfo);</highlight></codeline>
<codeline lineno="16520"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16521"><highlight class="normal"></highlight></codeline>
<codeline lineno="16522"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>result;</highlight></codeline>
<codeline lineno="16523"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16524"><highlight class="normal"></highlight></codeline>
<codeline lineno="16525"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gafe6834626398ff26264a94ab7581e150" kindref="member">vmaAllocateMemoryPages</ref>(</highlight></codeline>
<codeline lineno="16526"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16527"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkMemoryRequirements*<sp/>pVkMemoryRequirements,</highlight></codeline>
<codeline lineno="16528"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>*<sp/>pCreateInfo,</highlight></codeline>
<codeline lineno="16529"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>allocationCount,</highlight></codeline>
<codeline lineno="16530"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>pAllocations,</highlight></codeline>
<codeline lineno="16531"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref>*<sp/>pAllocationInfo)</highlight></codeline>
<codeline lineno="16532"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16533"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(allocationCount<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="16534"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16535"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="16536"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16537"><highlight class="normal"></highlight></codeline>
<codeline lineno="16538"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>pVkMemoryRequirements<sp/>&amp;&amp;<sp/>pCreateInfo<sp/>&amp;&amp;<sp/>pAllocations);</highlight></codeline>
<codeline lineno="16539"><highlight class="normal"></highlight></codeline>
<codeline lineno="16540"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaAllocateMemoryPages&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16541"><highlight class="normal"></highlight></codeline>
<codeline lineno="16542"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16543"><highlight class="normal"></highlight></codeline>
<codeline lineno="16544"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>result<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;AllocateMemory(</highlight></codeline>
<codeline lineno="16545"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pVkMemoryRequirements,</highlight></codeline>
<codeline lineno="16546"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">,<sp/></highlight><highlight class="comment">//<sp/>requiresDedicatedAllocation</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16547"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">,<sp/></highlight><highlight class="comment">//<sp/>prefersDedicatedAllocation</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16548"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VK_NULL_HANDLE,<sp/></highlight><highlight class="comment">//<sp/>dedicatedBuffer</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16549"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VK_NULL_HANDLE,<sp/></highlight><highlight class="comment">//<sp/>dedicatedImage</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16550"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UINT32_MAX,<sp/></highlight><highlight class="comment">//<sp/>dedicatedBufferImageUsage</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16551"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pCreateInfo,</highlight></codeline>
<codeline lineno="16552"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_SUBALLOCATION_TYPE_UNKNOWN,</highlight></codeline>
<codeline lineno="16553"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>allocationCount,</highlight></codeline>
<codeline lineno="16554"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocations);</highlight></codeline>
<codeline lineno="16555"><highlight class="normal"></highlight></codeline>
<codeline lineno="16556"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pAllocationInfo<sp/>!=<sp/>VMA_NULL<sp/>&amp;&amp;<sp/>result<sp/>==<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="16557"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16558"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>allocationCount;<sp/>++i)</highlight></codeline>
<codeline lineno="16559"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16560"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationInfo(pAllocations[i],<sp/>pAllocationInfo<sp/>+<sp/>i);</highlight></codeline>
<codeline lineno="16561"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16562"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16563"><highlight class="normal"></highlight></codeline>
<codeline lineno="16564"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>result;</highlight></codeline>
<codeline lineno="16565"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16566"><highlight class="normal"></highlight></codeline>
<codeline lineno="16567"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gaf7010aa90a4ccdda56f83db8597b9896" kindref="member">vmaAllocateMemoryForBuffer</ref>(</highlight></codeline>
<codeline lineno="16568"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16569"><highlight class="normal"><sp/><sp/><sp/><sp/>VkBuffer<sp/>buffer,</highlight></codeline>
<codeline lineno="16570"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>*<sp/>pCreateInfo,</highlight></codeline>
<codeline lineno="16571"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>pAllocation,</highlight></codeline>
<codeline lineno="16572"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref>*<sp/>pAllocationInfo)</highlight></codeline>
<codeline lineno="16573"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16574"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>buffer<sp/>!=<sp/>VK_NULL_HANDLE<sp/>&amp;&amp;<sp/>pCreateInfo<sp/>&amp;&amp;<sp/>pAllocation);</highlight></codeline>
<codeline lineno="16575"><highlight class="normal"></highlight></codeline>
<codeline lineno="16576"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaAllocateMemoryForBuffer&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16577"><highlight class="normal"></highlight></codeline>
<codeline lineno="16578"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16579"><highlight class="normal"></highlight></codeline>
<codeline lineno="16580"><highlight class="normal"><sp/><sp/><sp/><sp/>VkMemoryRequirements<sp/>vkMemReq<sp/>=<sp/>{};</highlight></codeline>
<codeline lineno="16581"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>requiresDedicatedAllocation<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="16582"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>prefersDedicatedAllocation<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="16583"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetBufferMemoryRequirements(buffer,<sp/>vkMemReq,</highlight></codeline>
<codeline lineno="16584"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>requiresDedicatedAllocation,</highlight></codeline>
<codeline lineno="16585"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prefersDedicatedAllocation);</highlight></codeline>
<codeline lineno="16586"><highlight class="normal"></highlight></codeline>
<codeline lineno="16587"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>result<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;AllocateMemory(</highlight></codeline>
<codeline lineno="16588"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vkMemReq,</highlight></codeline>
<codeline lineno="16589"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>requiresDedicatedAllocation,</highlight></codeline>
<codeline lineno="16590"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prefersDedicatedAllocation,</highlight></codeline>
<codeline lineno="16591"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>buffer,<sp/></highlight><highlight class="comment">//<sp/>dedicatedBuffer</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16592"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VK_NULL_HANDLE,<sp/></highlight><highlight class="comment">//<sp/>dedicatedImage</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16593"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UINT32_MAX,<sp/></highlight><highlight class="comment">//<sp/>dedicatedBufferImageUsage</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16594"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pCreateInfo,</highlight></codeline>
<codeline lineno="16595"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_SUBALLOCATION_TYPE_BUFFER,</highlight></codeline>
<codeline lineno="16596"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1,<sp/></highlight><highlight class="comment">//<sp/>allocationCount</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16597"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocation);</highlight></codeline>
<codeline lineno="16598"><highlight class="normal"></highlight></codeline>
<codeline lineno="16599"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pAllocationInfo<sp/>&amp;&amp;<sp/>result<sp/>==<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="16600"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16601"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationInfo(*pAllocation,<sp/>pAllocationInfo);</highlight></codeline>
<codeline lineno="16602"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16603"><highlight class="normal"></highlight></codeline>
<codeline lineno="16604"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>result;</highlight></codeline>
<codeline lineno="16605"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16606"><highlight class="normal"></highlight></codeline>
<codeline lineno="16607"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga4b7f39281cb383c1496b68f97cb7f4c5" kindref="member">vmaAllocateMemoryForImage</ref>(</highlight></codeline>
<codeline lineno="16608"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16609"><highlight class="normal"><sp/><sp/><sp/><sp/>VkImage<sp/>image,</highlight></codeline>
<codeline lineno="16610"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>*<sp/>pCreateInfo,</highlight></codeline>
<codeline lineno="16611"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>pAllocation,</highlight></codeline>
<codeline lineno="16612"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref>*<sp/>pAllocationInfo)</highlight></codeline>
<codeline lineno="16613"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16614"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>image<sp/>!=<sp/>VK_NULL_HANDLE<sp/>&amp;&amp;<sp/>pCreateInfo<sp/>&amp;&amp;<sp/>pAllocation);</highlight></codeline>
<codeline lineno="16615"><highlight class="normal"></highlight></codeline>
<codeline lineno="16616"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaAllocateMemoryForImage&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16617"><highlight class="normal"></highlight></codeline>
<codeline lineno="16618"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16619"><highlight class="normal"></highlight></codeline>
<codeline lineno="16620"><highlight class="normal"><sp/><sp/><sp/><sp/>VkMemoryRequirements<sp/>vkMemReq<sp/>=<sp/>{};</highlight></codeline>
<codeline lineno="16621"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>requiresDedicatedAllocation<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="16622"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>prefersDedicatedAllocation<sp/><sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="16623"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetImageMemoryRequirements(image,<sp/>vkMemReq,</highlight></codeline>
<codeline lineno="16624"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>requiresDedicatedAllocation,<sp/>prefersDedicatedAllocation);</highlight></codeline>
<codeline lineno="16625"><highlight class="normal"></highlight></codeline>
<codeline lineno="16626"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>result<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;AllocateMemory(</highlight></codeline>
<codeline lineno="16627"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vkMemReq,</highlight></codeline>
<codeline lineno="16628"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>requiresDedicatedAllocation,</highlight></codeline>
<codeline lineno="16629"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prefersDedicatedAllocation,</highlight></codeline>
<codeline lineno="16630"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VK_NULL_HANDLE,<sp/></highlight><highlight class="comment">//<sp/>dedicatedBuffer</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16631"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>image,<sp/></highlight><highlight class="comment">//<sp/>dedicatedImage</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16632"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>UINT32_MAX,<sp/></highlight><highlight class="comment">//<sp/>dedicatedBufferImageUsage</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16633"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pCreateInfo,</highlight></codeline>
<codeline lineno="16634"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_SUBALLOCATION_TYPE_IMAGE_UNKNOWN,</highlight></codeline>
<codeline lineno="16635"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1,<sp/></highlight><highlight class="comment">//<sp/>allocationCount</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16636"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocation);</highlight></codeline>
<codeline lineno="16637"><highlight class="normal"></highlight></codeline>
<codeline lineno="16638"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pAllocationInfo<sp/>&amp;&amp;<sp/>result<sp/>==<sp/>VK_SUCCESS)</highlight></codeline>
<codeline lineno="16639"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16640"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationInfo(*pAllocation,<sp/>pAllocationInfo);</highlight></codeline>
<codeline lineno="16641"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16642"><highlight class="normal"></highlight></codeline>
<codeline lineno="16643"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>result;</highlight></codeline>
<codeline lineno="16644"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16645"><highlight class="normal"></highlight></codeline>
<codeline lineno="16646"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga5c9baca5124d440046bbe508f61d2839" kindref="member">vmaFreeMemory</ref>(</highlight></codeline>
<codeline lineno="16647"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16648"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>allocation)</highlight></codeline>
<codeline lineno="16649"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16650"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator);</highlight></codeline>
<codeline lineno="16651"><highlight class="normal"></highlight></codeline>
<codeline lineno="16652"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(allocation<sp/>==<sp/>VK_NULL_HANDLE)</highlight></codeline>
<codeline lineno="16653"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16654"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="16655"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16656"><highlight class="normal"></highlight></codeline>
<codeline lineno="16657"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaFreeMemory&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16658"><highlight class="normal"></highlight></codeline>
<codeline lineno="16659"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16660"><highlight class="normal"></highlight></codeline>
<codeline lineno="16661"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;FreeMemory(</highlight></codeline>
<codeline lineno="16662"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1,<sp/></highlight><highlight class="comment">//<sp/>allocationCount</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16663"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;allocation);</highlight></codeline>
<codeline lineno="16664"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16665"><highlight class="normal"></highlight></codeline>
<codeline lineno="16666"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga033c6727ed2efed0745ec24ce01d5e1b" kindref="member">vmaFreeMemoryPages</ref>(</highlight></codeline>
<codeline lineno="16667"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16668"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>allocationCount,</highlight></codeline>
<codeline lineno="16669"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>pAllocations)</highlight></codeline>
<codeline lineno="16670"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16671"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(allocationCount<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="16672"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16673"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="16674"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16675"><highlight class="normal"></highlight></codeline>
<codeline lineno="16676"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator);</highlight></codeline>
<codeline lineno="16677"><highlight class="normal"></highlight></codeline>
<codeline lineno="16678"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaFreeMemoryPages&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16679"><highlight class="normal"></highlight></codeline>
<codeline lineno="16680"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16681"><highlight class="normal"></highlight></codeline>
<codeline lineno="16682"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;FreeMemory(allocationCount,<sp/>pAllocations);</highlight></codeline>
<codeline lineno="16683"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16684"><highlight class="normal"></highlight></codeline>
<codeline lineno="16685"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gab9c96ca6bb55ad9069829fe8355bbb79" kindref="member">vmaGetAllocationInfo</ref>(</highlight></codeline>
<codeline lineno="16686"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16687"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="16688"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref>*<sp/>pAllocationInfo)</highlight></codeline>
<codeline lineno="16689"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16690"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>allocation<sp/>&amp;&amp;<sp/>pAllocationInfo);</highlight></codeline>
<codeline lineno="16691"><highlight class="normal"></highlight></codeline>
<codeline lineno="16692"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16693"><highlight class="normal"></highlight></codeline>
<codeline lineno="16694"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationInfo(allocation,<sp/>pAllocationInfo);</highlight></codeline>
<codeline lineno="16695"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16696"><highlight class="normal"></highlight></codeline>
<codeline lineno="16697"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gac1f392a3c70a647f0c53a9ddaa7a6f14" kindref="member">vmaSetAllocationUserData</ref>(</highlight></codeline>
<codeline lineno="16698"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16699"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="16700"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pUserData)</highlight></codeline>
<codeline lineno="16701"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16702"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>allocation);</highlight></codeline>
<codeline lineno="16703"><highlight class="normal"></highlight></codeline>
<codeline lineno="16704"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16705"><highlight class="normal"></highlight></codeline>
<codeline lineno="16706"><highlight class="normal"><sp/><sp/><sp/><sp/>allocation-&gt;SetUserData(allocator,<sp/>pUserData);</highlight></codeline>
<codeline lineno="16707"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16708"><highlight class="normal"></highlight></codeline>
<codeline lineno="16709"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga29b210b1f39e49de844fc7b6944736d7" kindref="member">vmaSetAllocationName</ref>(</highlight></codeline>
<codeline lineno="16710"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16711"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="16712"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>pName)</highlight></codeline>
<codeline lineno="16713"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16714"><highlight class="normal"><sp/><sp/><sp/><sp/>allocation-&gt;SetName(allocator,<sp/>pName);</highlight></codeline>
<codeline lineno="16715"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16716"><highlight class="normal"></highlight></codeline>
<codeline lineno="16717"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gaf6785483eda8b53561437e05e2177d7b" kindref="member">vmaGetAllocationMemoryProperties</ref>(</highlight></codeline>
<codeline lineno="16718"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16719"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="16720"><highlight class="normal"><sp/><sp/><sp/><sp/>VkMemoryPropertyFlags*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pFlags)</highlight></codeline>
<codeline lineno="16721"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16722"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>allocation<sp/>&amp;&amp;<sp/>pFlags);</highlight></codeline>
<codeline lineno="16723"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint32_t<sp/>memTypeIndex<sp/>=<sp/>allocation-&gt;GetMemoryTypeIndex();</highlight></codeline>
<codeline lineno="16724"><highlight class="normal"><sp/><sp/><sp/><sp/>*pFlags<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_MemProps.memoryTypes[memTypeIndex].propertyFlags;</highlight></codeline>
<codeline lineno="16725"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16726"><highlight class="normal"></highlight></codeline>
<codeline lineno="16727"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga13b93ec0ed38ad7232300cb94931c8d2" kindref="member">vmaMapMemory</ref>(</highlight></codeline>
<codeline lineno="16728"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16729"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="16730"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">**<sp/>ppData)</highlight></codeline>
<codeline lineno="16731"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16732"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>allocation<sp/>&amp;&amp;<sp/>ppData);</highlight></codeline>
<codeline lineno="16733"><highlight class="normal"></highlight></codeline>
<codeline lineno="16734"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16735"><highlight class="normal"></highlight></codeline>
<codeline lineno="16736"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;Map(allocation,<sp/>ppData);</highlight></codeline>
<codeline lineno="16737"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16738"><highlight class="normal"></highlight></codeline>
<codeline lineno="16739"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gaec4645c1787976e2b50d2dfd31279a2b" kindref="member">vmaUnmapMemory</ref>(</highlight></codeline>
<codeline lineno="16740"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16741"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>allocation)</highlight></codeline>
<codeline lineno="16742"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16743"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>allocation);</highlight></codeline>
<codeline lineno="16744"><highlight class="normal"></highlight></codeline>
<codeline lineno="16745"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16746"><highlight class="normal"></highlight></codeline>
<codeline lineno="16747"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;Unmap(allocation);</highlight></codeline>
<codeline lineno="16748"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16749"><highlight class="normal"></highlight></codeline>
<codeline lineno="16750"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gab8093faf3afb114596d964d4bd24cb4a" kindref="member">vmaFlushAllocation</ref>(</highlight></codeline>
<codeline lineno="16751"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16752"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="16753"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>offset,</highlight></codeline>
<codeline lineno="16754"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size)</highlight></codeline>
<codeline lineno="16755"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16756"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>allocation);</highlight></codeline>
<codeline lineno="16757"><highlight class="normal"></highlight></codeline>
<codeline lineno="16758"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaFlushAllocation&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16759"><highlight class="normal"></highlight></codeline>
<codeline lineno="16760"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16761"><highlight class="normal"></highlight></codeline>
<codeline lineno="16762"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkResult<sp/>res<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;FlushOrInvalidateAllocation(allocation,<sp/>offset,<sp/>size,<sp/>VMA_CACHE_FLUSH);</highlight></codeline>
<codeline lineno="16763"><highlight class="normal"></highlight></codeline>
<codeline lineno="16764"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="16765"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16766"><highlight class="normal"></highlight></codeline>
<codeline lineno="16767"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga1059764930e85ac377a92b5237b5b919" kindref="member">vmaInvalidateAllocation</ref>(</highlight></codeline>
<codeline lineno="16768"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16769"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="16770"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>offset,</highlight></codeline>
<codeline lineno="16771"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>size)</highlight></codeline>
<codeline lineno="16772"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16773"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>allocation);</highlight></codeline>
<codeline lineno="16774"><highlight class="normal"></highlight></codeline>
<codeline lineno="16775"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaInvalidateAllocation&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16776"><highlight class="normal"></highlight></codeline>
<codeline lineno="16777"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16778"><highlight class="normal"></highlight></codeline>
<codeline lineno="16779"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkResult<sp/>res<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;FlushOrInvalidateAllocation(allocation,<sp/>offset,<sp/>size,<sp/>VMA_CACHE_INVALIDATE);</highlight></codeline>
<codeline lineno="16780"><highlight class="normal"></highlight></codeline>
<codeline lineno="16781"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="16782"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16783"><highlight class="normal"></highlight></codeline>
<codeline lineno="16784"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga09b0a57c5c45949a324ac7c0a4ec42d5" kindref="member">vmaFlushAllocations</ref>(</highlight></codeline>
<codeline lineno="16785"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16786"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>allocationCount,</highlight></codeline>
<codeline lineno="16787"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>allocations,</highlight></codeline>
<codeline lineno="16788"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize*<sp/>offsets,</highlight></codeline>
<codeline lineno="16789"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize*<sp/>sizes)</highlight></codeline>
<codeline lineno="16790"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16791"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator);</highlight></codeline>
<codeline lineno="16792"><highlight class="normal"></highlight></codeline>
<codeline lineno="16793"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(allocationCount<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="16794"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16795"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="16796"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16797"><highlight class="normal"></highlight></codeline>
<codeline lineno="16798"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocations);</highlight></codeline>
<codeline lineno="16799"><highlight class="normal"></highlight></codeline>
<codeline lineno="16800"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaFlushAllocations&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16801"><highlight class="normal"></highlight></codeline>
<codeline lineno="16802"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16803"><highlight class="normal"></highlight></codeline>
<codeline lineno="16804"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkResult<sp/>res<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;FlushOrInvalidateAllocations(allocationCount,<sp/>allocations,<sp/>offsets,<sp/>sizes,<sp/>VMA_CACHE_FLUSH);</highlight></codeline>
<codeline lineno="16805"><highlight class="normal"></highlight></codeline>
<codeline lineno="16806"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="16807"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16808"><highlight class="normal"></highlight></codeline>
<codeline lineno="16809"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga693a1ae5faed72fac89f12685e1d366f" kindref="member">vmaInvalidateAllocations</ref>(</highlight></codeline>
<codeline lineno="16810"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16811"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>allocationCount,</highlight></codeline>
<codeline lineno="16812"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>allocations,</highlight></codeline>
<codeline lineno="16813"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize*<sp/>offsets,</highlight></codeline>
<codeline lineno="16814"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkDeviceSize*<sp/>sizes)</highlight></codeline>
<codeline lineno="16815"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16816"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator);</highlight></codeline>
<codeline lineno="16817"><highlight class="normal"></highlight></codeline>
<codeline lineno="16818"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(allocationCount<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="16819"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16820"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="16821"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16822"><highlight class="normal"></highlight></codeline>
<codeline lineno="16823"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocations);</highlight></codeline>
<codeline lineno="16824"><highlight class="normal"></highlight></codeline>
<codeline lineno="16825"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaInvalidateAllocations&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16826"><highlight class="normal"></highlight></codeline>
<codeline lineno="16827"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16828"><highlight class="normal"></highlight></codeline>
<codeline lineno="16829"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkResult<sp/>res<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;FlushOrInvalidateAllocations(allocationCount,<sp/>allocations,<sp/>offsets,<sp/>sizes,<sp/>VMA_CACHE_INVALIDATE);</highlight></codeline>
<codeline lineno="16830"><highlight class="normal"></highlight></codeline>
<codeline lineno="16831"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="16832"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16833"><highlight class="normal"></highlight></codeline>
<codeline lineno="16834"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga0baa58dd12991e7b0fe42dcdf22bb100" kindref="member">vmaCheckCorruption</ref>(</highlight></codeline>
<codeline lineno="16835"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16836"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>memoryTypeBits)</highlight></codeline>
<codeline lineno="16837"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16838"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator);</highlight></codeline>
<codeline lineno="16839"><highlight class="normal"></highlight></codeline>
<codeline lineno="16840"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaCheckCorruption&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16841"><highlight class="normal"></highlight></codeline>
<codeline lineno="16842"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16843"><highlight class="normal"></highlight></codeline>
<codeline lineno="16844"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;CheckCorruption(memoryTypeBits);</highlight></codeline>
<codeline lineno="16845"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16846"><highlight class="normal"></highlight></codeline>
<codeline lineno="16847"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga0cdd7b0b8653745fa95af9e78d919e70" kindref="member">vmaBeginDefragmentation</ref>(</highlight></codeline>
<codeline lineno="16848"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16849"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_defragmentation_info" kindref="compound">VmaDefragmentationInfo</ref>*<sp/>pInfo,</highlight></codeline>
<codeline lineno="16850"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_defragmentation_context" kindref="compound">VmaDefragmentationContext</ref>*<sp/>pContext)</highlight></codeline>
<codeline lineno="16851"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16852"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>pInfo<sp/>&amp;&amp;<sp/>pContext);</highlight></codeline>
<codeline lineno="16853"><highlight class="normal"></highlight></codeline>
<codeline lineno="16854"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaBeginDefragmentation&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16855"><highlight class="normal"></highlight></codeline>
<codeline lineno="16856"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(pInfo-&gt;<ref refid="struct_vma_defragmentation_info_1a3302955190e6b5f0d8103698753de949" kindref="member">pool</ref><sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="16857"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16858"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>if<sp/>run<sp/>on<sp/>supported<sp/>algorithms</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16859"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(pInfo-&gt;<ref refid="struct_vma_defragmentation_info_1a3302955190e6b5f0d8103698753de949" kindref="member">pool</ref>-&gt;m_BlockVector.GetAlgorithm()<sp/>&amp;<sp/><ref refid="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726" kindref="member">VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</ref>)</highlight></codeline>
<codeline lineno="16860"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_FEATURE_NOT_PRESENT;</highlight></codeline>
<codeline lineno="16861"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16862"><highlight class="normal"></highlight></codeline>
<codeline lineno="16863"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16864"><highlight class="normal"></highlight></codeline>
<codeline lineno="16865"><highlight class="normal"><sp/><sp/><sp/><sp/>*pContext<sp/>=<sp/>vma_new(allocator,<sp/>VmaDefragmentationContext_T)(<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>,<sp/>*pInfo);</highlight></codeline>
<codeline lineno="16866"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="16867"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16868"><highlight class="normal"></highlight></codeline>
<codeline lineno="16869"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gae419e366d1c015716165bdfd5aafef6f" kindref="member">vmaEndDefragmentation</ref>(</highlight></codeline>
<codeline lineno="16870"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16871"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_defragmentation_context" kindref="compound">VmaDefragmentationContext</ref><sp/>context,</highlight></codeline>
<codeline lineno="16872"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_defragmentation_stats" kindref="compound">VmaDefragmentationStats</ref>*<sp/>pStats)</highlight></codeline>
<codeline lineno="16873"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16874"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>context);</highlight></codeline>
<codeline lineno="16875"><highlight class="normal"></highlight></codeline>
<codeline lineno="16876"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaEndDefragmentation&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16877"><highlight class="normal"></highlight></codeline>
<codeline lineno="16878"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16879"><highlight class="normal"></highlight></codeline>
<codeline lineno="16880"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(pStats)</highlight></codeline>
<codeline lineno="16881"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>context-&gt;GetStats(*pStats);</highlight></codeline>
<codeline lineno="16882"><highlight class="normal"><sp/><sp/><sp/><sp/>vma_delete(allocator,<sp/>context);</highlight></codeline>
<codeline lineno="16883"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16884"><highlight class="normal"></highlight></codeline>
<codeline lineno="16885"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gacbe4a77fdfa7ea29328d2f940d423ab7" kindref="member">vmaBeginDefragmentationPass</ref>(</highlight></codeline>
<codeline lineno="16886"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16887"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_defragmentation_context" kindref="compound">VmaDefragmentationContext</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>context,</highlight></codeline>
<codeline lineno="16888"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_defragmentation_pass_move_info" kindref="compound">VmaDefragmentationPassMoveInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pPassInfo)</highlight></codeline>
<codeline lineno="16889"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16890"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(context<sp/>&amp;&amp;<sp/>pPassInfo);</highlight></codeline>
<codeline lineno="16891"><highlight class="normal"></highlight></codeline>
<codeline lineno="16892"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaBeginDefragmentationPass&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16893"><highlight class="normal"></highlight></codeline>
<codeline lineno="16894"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16895"><highlight class="normal"></highlight></codeline>
<codeline lineno="16896"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>context-&gt;DefragmentPassBegin(*pPassInfo);</highlight></codeline>
<codeline lineno="16897"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16898"><highlight class="normal"></highlight></codeline>
<codeline lineno="16899"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gabbc69db60f82972ddffaceb6653e344a" kindref="member">vmaEndDefragmentationPass</ref>(</highlight></codeline>
<codeline lineno="16900"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16901"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_defragmentation_context" kindref="compound">VmaDefragmentationContext</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>context,</highlight></codeline>
<codeline lineno="16902"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_defragmentation_pass_move_info" kindref="compound">VmaDefragmentationPassMoveInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pPassInfo)</highlight></codeline>
<codeline lineno="16903"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16904"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(context<sp/>&amp;&amp;<sp/>pPassInfo);</highlight></codeline>
<codeline lineno="16905"><highlight class="normal"></highlight></codeline>
<codeline lineno="16906"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaEndDefragmentationPass&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16907"><highlight class="normal"></highlight></codeline>
<codeline lineno="16908"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16909"><highlight class="normal"></highlight></codeline>
<codeline lineno="16910"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>context-&gt;DefragmentPassEnd(*pPassInfo);</highlight></codeline>
<codeline lineno="16911"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16912"><highlight class="normal"></highlight></codeline>
<codeline lineno="16913"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga7748e60ccc54e240777a848cb260bb19" kindref="member">vmaBindBufferMemory</ref>(</highlight></codeline>
<codeline lineno="16914"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16915"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="16916"><highlight class="normal"><sp/><sp/><sp/><sp/>VkBuffer<sp/>buffer)</highlight></codeline>
<codeline lineno="16917"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16918"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>allocation<sp/>&amp;&amp;<sp/>buffer);</highlight></codeline>
<codeline lineno="16919"><highlight class="normal"></highlight></codeline>
<codeline lineno="16920"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaBindBufferMemory&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16921"><highlight class="normal"></highlight></codeline>
<codeline lineno="16922"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16923"><highlight class="normal"></highlight></codeline>
<codeline lineno="16924"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;BindBufferMemory(allocation,<sp/>0,<sp/>buffer,<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="16925"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16926"><highlight class="normal"></highlight></codeline>
<codeline lineno="16927"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga4a71c30e3474a835bdd7fd0507740be7" kindref="member">vmaBindBufferMemory2</ref>(</highlight></codeline>
<codeline lineno="16928"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16929"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="16930"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocationLocalOffset,</highlight></codeline>
<codeline lineno="16931"><highlight class="normal"><sp/><sp/><sp/><sp/>VkBuffer<sp/>buffer,</highlight></codeline>
<codeline lineno="16932"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pNext)</highlight></codeline>
<codeline lineno="16933"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16934"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>allocation<sp/>&amp;&amp;<sp/>buffer);</highlight></codeline>
<codeline lineno="16935"><highlight class="normal"></highlight></codeline>
<codeline lineno="16936"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaBindBufferMemory2&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16937"><highlight class="normal"></highlight></codeline>
<codeline lineno="16938"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16939"><highlight class="normal"></highlight></codeline>
<codeline lineno="16940"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;BindBufferMemory(allocation,<sp/>allocationLocalOffset,<sp/>buffer,<sp/>pNext);</highlight></codeline>
<codeline lineno="16941"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16942"><highlight class="normal"></highlight></codeline>
<codeline lineno="16943"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga3a5d8d9f2a29b42cf87f0f8dfef591f4" kindref="member">vmaBindImageMemory</ref>(</highlight></codeline>
<codeline lineno="16944"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16945"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="16946"><highlight class="normal"><sp/><sp/><sp/><sp/>VkImage<sp/>image)</highlight></codeline>
<codeline lineno="16947"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16948"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>allocation<sp/>&amp;&amp;<sp/>image);</highlight></codeline>
<codeline lineno="16949"><highlight class="normal"></highlight></codeline>
<codeline lineno="16950"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaBindImageMemory&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16951"><highlight class="normal"></highlight></codeline>
<codeline lineno="16952"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16953"><highlight class="normal"></highlight></codeline>
<codeline lineno="16954"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;BindImageMemory(allocation,<sp/>0,<sp/>image,<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="16955"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16956"><highlight class="normal"></highlight></codeline>
<codeline lineno="16957"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga0216b9225b02a66ac610cb45d4729d00" kindref="member">vmaBindImageMemory2</ref>(</highlight></codeline>
<codeline lineno="16958"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16959"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="16960"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>allocationLocalOffset,</highlight></codeline>
<codeline lineno="16961"><highlight class="normal"><sp/><sp/><sp/><sp/>VkImage<sp/>image,</highlight></codeline>
<codeline lineno="16962"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pNext)</highlight></codeline>
<codeline lineno="16963"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16964"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>allocation<sp/>&amp;&amp;<sp/>image);</highlight></codeline>
<codeline lineno="16965"><highlight class="normal"></highlight></codeline>
<codeline lineno="16966"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaBindImageMemory2&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16967"><highlight class="normal"></highlight></codeline>
<codeline lineno="16968"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16969"><highlight class="normal"></highlight></codeline>
<codeline lineno="16970"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;BindImageMemory(allocation,<sp/>allocationLocalOffset,<sp/>image,<sp/>pNext);</highlight></codeline>
<codeline lineno="16971"><highlight class="normal">}</highlight></codeline>
<codeline lineno="16972"><highlight class="normal"></highlight></codeline>
<codeline lineno="16973"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer</ref>(</highlight></codeline>
<codeline lineno="16974"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="16975"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkBufferCreateInfo*<sp/>pBufferCreateInfo,</highlight></codeline>
<codeline lineno="16976"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>*<sp/>pAllocationCreateInfo,</highlight></codeline>
<codeline lineno="16977"><highlight class="normal"><sp/><sp/><sp/><sp/>VkBuffer*<sp/>pBuffer,</highlight></codeline>
<codeline lineno="16978"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>pAllocation,</highlight></codeline>
<codeline lineno="16979"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref>*<sp/>pAllocationInfo)</highlight></codeline>
<codeline lineno="16980"><highlight class="normal">{</highlight></codeline>
<codeline lineno="16981"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>pBufferCreateInfo<sp/>&amp;&amp;<sp/>pAllocationCreateInfo<sp/>&amp;&amp;<sp/>pBuffer<sp/>&amp;&amp;<sp/>pAllocation);</highlight></codeline>
<codeline lineno="16982"><highlight class="normal"></highlight></codeline>
<codeline lineno="16983"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pBufferCreateInfo-&gt;size<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="16984"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16985"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_INITIALIZATION_FAILED;</highlight></codeline>
<codeline lineno="16986"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16987"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">((pBufferCreateInfo-&gt;usage<sp/>&amp;<sp/>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_COPY)<sp/>!=<sp/>0<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="16988"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>!<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_UseKhrBufferDeviceAddress)</highlight></codeline>
<codeline lineno="16989"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="16990"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Creating<sp/>a<sp/>buffer<sp/>with<sp/>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT<sp/>is<sp/>not<sp/>valid<sp/>if<sp/>VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT<sp/>was<sp/>not<sp/>used.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16991"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_INITIALIZATION_FAILED;</highlight></codeline>
<codeline lineno="16992"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="16993"><highlight class="normal"></highlight></codeline>
<codeline lineno="16994"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaCreateBuffer&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="16995"><highlight class="normal"></highlight></codeline>
<codeline lineno="16996"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="16997"><highlight class="normal"></highlight></codeline>
<codeline lineno="16998"><highlight class="normal"><sp/><sp/><sp/><sp/>*pBuffer<sp/>=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="16999"><highlight class="normal"><sp/><sp/><sp/><sp/>*pAllocation<sp/>=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="17000"><highlight class="normal"></highlight></codeline>
<codeline lineno="17001"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>1.<sp/>Create<sp/>VkBuffer.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17002"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>(*<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetVulkanFunctions().vkCreateBuffer)(</highlight></codeline>
<codeline lineno="17003"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_hDevice,</highlight></codeline>
<codeline lineno="17004"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pBufferCreateInfo,</highlight></codeline>
<codeline lineno="17005"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationCallbacks(),</highlight></codeline>
<codeline lineno="17006"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pBuffer);</highlight></codeline>
<codeline lineno="17007"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>&gt;=<sp/>0)</highlight></codeline>
<codeline lineno="17008"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17009"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>2.<sp/>vkGetBufferMemoryRequirements.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17010"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkMemoryRequirements<sp/>vkMemReq<sp/>=<sp/>{};</highlight></codeline>
<codeline lineno="17011"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>requiresDedicatedAllocation<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="17012"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>prefersDedicatedAllocation<sp/><sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="17013"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetBufferMemoryRequirements(*pBuffer,<sp/>vkMemReq,</highlight></codeline>
<codeline lineno="17014"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>requiresDedicatedAllocation,<sp/>prefersDedicatedAllocation);</highlight></codeline>
<codeline lineno="17015"><highlight class="normal"></highlight></codeline>
<codeline lineno="17016"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>3.<sp/>Allocate<sp/>memory<sp/>using<sp/>allocator.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17017"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;AllocateMemory(</highlight></codeline>
<codeline lineno="17018"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vkMemReq,</highlight></codeline>
<codeline lineno="17019"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>requiresDedicatedAllocation,</highlight></codeline>
<codeline lineno="17020"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prefersDedicatedAllocation,</highlight></codeline>
<codeline lineno="17021"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pBuffer,<sp/></highlight><highlight class="comment">//<sp/>dedicatedBuffer</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17022"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VK_NULL_HANDLE,<sp/></highlight><highlight class="comment">//<sp/>dedicatedImage</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17023"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pBufferCreateInfo-&gt;usage,<sp/></highlight><highlight class="comment">//<sp/>dedicatedBufferImageUsage</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17024"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pAllocationCreateInfo,</highlight></codeline>
<codeline lineno="17025"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_SUBALLOCATION_TYPE_BUFFER,</highlight></codeline>
<codeline lineno="17026"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1,<sp/></highlight><highlight class="comment">//<sp/>allocationCount</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17027"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocation);</highlight></codeline>
<codeline lineno="17028"><highlight class="normal"></highlight></codeline>
<codeline lineno="17029"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>&gt;=<sp/>0)</highlight></codeline>
<codeline lineno="17030"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17031"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>3.<sp/>Bind<sp/>buffer<sp/>with<sp/>memory.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17032"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">((pAllocationCreateInfo-&gt;<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a2310568c62208af432724305fe29ccea" kindref="member">VMA_ALLOCATION_CREATE_DONT_BIND_BIT</ref>)<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="17033"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17034"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;BindBufferMemory(*pAllocation,<sp/>0,<sp/>*pBuffer,<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="17035"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17036"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>&gt;=<sp/>0)</highlight></codeline>
<codeline lineno="17037"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17038"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>All<sp/>steps<sp/>succeeded.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17039"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17040"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*pAllocation)-&gt;InitBufferImageUsage(pBufferCreateInfo-&gt;usage);</highlight></codeline>
<codeline lineno="17041"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17042"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pAllocationInfo<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="17043"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17044"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationInfo(*pAllocation,<sp/>pAllocationInfo);</highlight></codeline>
<codeline lineno="17045"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17046"><highlight class="normal"></highlight></codeline>
<codeline lineno="17047"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="17048"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17049"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;FreeMemory(</highlight></codeline>
<codeline lineno="17050"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1,<sp/></highlight><highlight class="comment">//<sp/>allocationCount</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17051"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocation);</highlight></codeline>
<codeline lineno="17052"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pAllocation<sp/>=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="17053"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetVulkanFunctions().vkDestroyBuffer)(<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_hDevice,<sp/>*pBuffer,<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationCallbacks());</highlight></codeline>
<codeline lineno="17054"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pBuffer<sp/>=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="17055"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="17056"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17057"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetVulkanFunctions().vkDestroyBuffer)(<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_hDevice,<sp/>*pBuffer,<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationCallbacks());</highlight></codeline>
<codeline lineno="17058"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pBuffer<sp/>=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="17059"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="17060"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17061"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="17062"><highlight class="normal">}</highlight></codeline>
<codeline lineno="17063"><highlight class="normal"></highlight></codeline>
<codeline lineno="17064"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga0a4d6890fe94cf4d234ca1d78af91229" kindref="member">vmaCreateBufferWithAlignment</ref>(</highlight></codeline>
<codeline lineno="17065"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="17066"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkBufferCreateInfo*<sp/>pBufferCreateInfo,</highlight></codeline>
<codeline lineno="17067"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>*<sp/>pAllocationCreateInfo,</highlight></codeline>
<codeline lineno="17068"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize<sp/>minAlignment,</highlight></codeline>
<codeline lineno="17069"><highlight class="normal"><sp/><sp/><sp/><sp/>VkBuffer*<sp/>pBuffer,</highlight></codeline>
<codeline lineno="17070"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>pAllocation,</highlight></codeline>
<codeline lineno="17071"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref>*<sp/>pAllocationInfo)</highlight></codeline>
<codeline lineno="17072"><highlight class="normal">{</highlight></codeline>
<codeline lineno="17073"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>pBufferCreateInfo<sp/>&amp;&amp;<sp/>pAllocationCreateInfo<sp/>&amp;&amp;<sp/>VmaIsPow2(minAlignment)<sp/>&amp;&amp;<sp/>pBuffer<sp/>&amp;&amp;<sp/>pAllocation);</highlight></codeline>
<codeline lineno="17074"><highlight class="normal"></highlight></codeline>
<codeline lineno="17075"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pBufferCreateInfo-&gt;size<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="17076"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17077"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_INITIALIZATION_FAILED;</highlight></codeline>
<codeline lineno="17078"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17079"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">((pBufferCreateInfo-&gt;usage<sp/>&amp;<sp/>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_COPY)<sp/>!=<sp/>0<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="17080"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>!<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_UseKhrBufferDeviceAddress)</highlight></codeline>
<codeline lineno="17081"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17082"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Creating<sp/>a<sp/>buffer<sp/>with<sp/>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT<sp/>is<sp/>not<sp/>valid<sp/>if<sp/>VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT<sp/>was<sp/>not<sp/>used.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="17083"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_INITIALIZATION_FAILED;</highlight></codeline>
<codeline lineno="17084"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17085"><highlight class="normal"></highlight></codeline>
<codeline lineno="17086"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaCreateBufferWithAlignment&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="17087"><highlight class="normal"></highlight></codeline>
<codeline lineno="17088"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="17089"><highlight class="normal"></highlight></codeline>
<codeline lineno="17090"><highlight class="normal"><sp/><sp/><sp/><sp/>*pBuffer<sp/>=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="17091"><highlight class="normal"><sp/><sp/><sp/><sp/>*pAllocation<sp/>=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="17092"><highlight class="normal"></highlight></codeline>
<codeline lineno="17093"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>1.<sp/>Create<sp/>VkBuffer.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17094"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>(*<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetVulkanFunctions().vkCreateBuffer)(</highlight></codeline>
<codeline lineno="17095"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_hDevice,</highlight></codeline>
<codeline lineno="17096"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pBufferCreateInfo,</highlight></codeline>
<codeline lineno="17097"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationCallbacks(),</highlight></codeline>
<codeline lineno="17098"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pBuffer);</highlight></codeline>
<codeline lineno="17099"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>&gt;=<sp/>0)</highlight></codeline>
<codeline lineno="17100"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17101"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>2.<sp/>vkGetBufferMemoryRequirements.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17102"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkMemoryRequirements<sp/>vkMemReq<sp/>=<sp/>{};</highlight></codeline>
<codeline lineno="17103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>requiresDedicatedAllocation<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="17104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>prefersDedicatedAllocation<sp/><sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="17105"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetBufferMemoryRequirements(*pBuffer,<sp/>vkMemReq,</highlight></codeline>
<codeline lineno="17106"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>requiresDedicatedAllocation,<sp/>prefersDedicatedAllocation);</highlight></codeline>
<codeline lineno="17107"><highlight class="normal"></highlight></codeline>
<codeline lineno="17108"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>2a.<sp/>Include<sp/>minAlignment</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17109"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vkMemReq.alignment<sp/>=<sp/>VMA_MAX(vkMemReq.alignment,<sp/>minAlignment);</highlight></codeline>
<codeline lineno="17110"><highlight class="normal"></highlight></codeline>
<codeline lineno="17111"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>3.<sp/>Allocate<sp/>memory<sp/>using<sp/>allocator.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17112"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;AllocateMemory(</highlight></codeline>
<codeline lineno="17113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vkMemReq,</highlight></codeline>
<codeline lineno="17114"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>requiresDedicatedAllocation,</highlight></codeline>
<codeline lineno="17115"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prefersDedicatedAllocation,</highlight></codeline>
<codeline lineno="17116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pBuffer,<sp/></highlight><highlight class="comment">//<sp/>dedicatedBuffer</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VK_NULL_HANDLE,<sp/></highlight><highlight class="comment">//<sp/>dedicatedImage</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17118"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pBufferCreateInfo-&gt;usage,<sp/></highlight><highlight class="comment">//<sp/>dedicatedBufferImageUsage</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17119"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pAllocationCreateInfo,</highlight></codeline>
<codeline lineno="17120"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_SUBALLOCATION_TYPE_BUFFER,</highlight></codeline>
<codeline lineno="17121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1,<sp/></highlight><highlight class="comment">//<sp/>allocationCount</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocation);</highlight></codeline>
<codeline lineno="17123"><highlight class="normal"></highlight></codeline>
<codeline lineno="17124"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>&gt;=<sp/>0)</highlight></codeline>
<codeline lineno="17125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>3.<sp/>Bind<sp/>buffer<sp/>with<sp/>memory.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17127"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">((pAllocationCreateInfo-&gt;<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a2310568c62208af432724305fe29ccea" kindref="member">VMA_ALLOCATION_CREATE_DONT_BIND_BIT</ref>)<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="17128"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17129"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;BindBufferMemory(*pAllocation,<sp/>0,<sp/>*pBuffer,<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="17130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>&gt;=<sp/>0)</highlight></codeline>
<codeline lineno="17132"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17133"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>All<sp/>steps<sp/>succeeded.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17134"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17135"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*pAllocation)-&gt;InitBufferImageUsage(pBufferCreateInfo-&gt;usage);</highlight></codeline>
<codeline lineno="17136"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17137"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pAllocationInfo<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="17138"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17139"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationInfo(*pAllocation,<sp/>pAllocationInfo);</highlight></codeline>
<codeline lineno="17140"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17141"><highlight class="normal"></highlight></codeline>
<codeline lineno="17142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="17143"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17144"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;FreeMemory(</highlight></codeline>
<codeline lineno="17145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1,<sp/></highlight><highlight class="comment">//<sp/>allocationCount</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocation);</highlight></codeline>
<codeline lineno="17147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pAllocation<sp/>=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="17148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetVulkanFunctions().vkDestroyBuffer)(<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_hDevice,<sp/>*pBuffer,<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationCallbacks());</highlight></codeline>
<codeline lineno="17149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pBuffer<sp/>=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="17150"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="17151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetVulkanFunctions().vkDestroyBuffer)(<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_hDevice,<sp/>*pBuffer,<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationCallbacks());</highlight></codeline>
<codeline lineno="17153"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pBuffer<sp/>=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="17154"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="17155"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17156"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="17157"><highlight class="normal">}</highlight></codeline>
<codeline lineno="17158"><highlight class="normal"></highlight></codeline>
<codeline lineno="17159"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga41a76d0f9f98a001900a889f55973536" kindref="member">vmaCreateAliasingBuffer</ref>(</highlight></codeline>
<codeline lineno="17160"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="17161"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="17162"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkBufferCreateInfo*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pBufferCreateInfo,</highlight></codeline>
<codeline lineno="17163"><highlight class="normal"><sp/><sp/><sp/><sp/>VkBuffer<sp/><ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pBuffer)</highlight></codeline>
<codeline lineno="17164"><highlight class="normal">{</highlight></codeline>
<codeline lineno="17165"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>pBufferCreateInfo<sp/>&amp;&amp;<sp/>pBuffer<sp/>&amp;&amp;<sp/>allocation);</highlight></codeline>
<codeline lineno="17166"><highlight class="normal"></highlight></codeline>
<codeline lineno="17167"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaCreateAliasingBuffer&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="17168"><highlight class="normal"></highlight></codeline>
<codeline lineno="17169"><highlight class="normal"><sp/><sp/><sp/><sp/>*pBuffer<sp/>=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="17170"><highlight class="normal"></highlight></codeline>
<codeline lineno="17171"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(pBufferCreateInfo-&gt;size<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="17172"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_INITIALIZATION_FAILED;</highlight></codeline>
<codeline lineno="17174"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17175"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((pBufferCreateInfo-&gt;usage<sp/>&amp;<sp/>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_COPY)<sp/>!=<sp/>0<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="17176"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>!<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_UseKhrBufferDeviceAddress)</highlight></codeline>
<codeline lineno="17177"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17178"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(0<sp/>&amp;&amp;<sp/></highlight><highlight class="stringliteral">&quot;Creating<sp/>a<sp/>buffer<sp/>with<sp/>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT<sp/>is<sp/>not<sp/>valid<sp/>if<sp/>VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT<sp/>was<sp/>not<sp/>used.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="17179"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_INITIALIZATION_FAILED;</highlight></codeline>
<codeline lineno="17180"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17181"><highlight class="normal"></highlight></codeline>
<codeline lineno="17182"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="17183"><highlight class="normal"></highlight></codeline>
<codeline lineno="17184"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>1.<sp/>Create<sp/>VkBuffer.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17185"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>(*<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetVulkanFunctions().vkCreateBuffer)(</highlight></codeline>
<codeline lineno="17186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_hDevice,</highlight></codeline>
<codeline lineno="17187"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pBufferCreateInfo,</highlight></codeline>
<codeline lineno="17188"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationCallbacks(),</highlight></codeline>
<codeline lineno="17189"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pBuffer);</highlight></codeline>
<codeline lineno="17190"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res<sp/>&gt;=<sp/>0)</highlight></codeline>
<codeline lineno="17191"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>2.<sp/>Bind<sp/>buffer<sp/>with<sp/>memory.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17193"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;BindBufferMemory(allocation,<sp/>0,<sp/>*pBuffer,<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="17194"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res<sp/>&gt;=<sp/>0)</highlight></codeline>
<codeline lineno="17195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17196"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="17197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17198"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetVulkanFunctions().vkDestroyBuffer)(<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_hDevice,<sp/>*pBuffer,<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationCallbacks());</highlight></codeline>
<codeline lineno="17199"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17200"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="17201"><highlight class="normal">}</highlight></codeline>
<codeline lineno="17202"><highlight class="normal"></highlight></codeline>
<codeline lineno="17203"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gafcc45e5a6388ab35daa9a46688baee20" kindref="member">vmaDestroyBuffer</ref>(</highlight></codeline>
<codeline lineno="17204"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="17205"><highlight class="normal"><sp/><sp/><sp/><sp/>VkBuffer<sp/>buffer,</highlight></codeline>
<codeline lineno="17206"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>allocation)</highlight></codeline>
<codeline lineno="17207"><highlight class="normal">{</highlight></codeline>
<codeline lineno="17208"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator);</highlight></codeline>
<codeline lineno="17209"><highlight class="normal"></highlight></codeline>
<codeline lineno="17210"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(buffer<sp/>==<sp/>VK_NULL_HANDLE<sp/>&amp;&amp;<sp/>allocation<sp/>==<sp/>VK_NULL_HANDLE)</highlight></codeline>
<codeline lineno="17211"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17212"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="17213"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17214"><highlight class="normal"></highlight></codeline>
<codeline lineno="17215"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaDestroyBuffer&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="17216"><highlight class="normal"></highlight></codeline>
<codeline lineno="17217"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="17218"><highlight class="normal"></highlight></codeline>
<codeline lineno="17219"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(buffer<sp/>!=<sp/>VK_NULL_HANDLE)</highlight></codeline>
<codeline lineno="17220"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17221"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetVulkanFunctions().vkDestroyBuffer)(<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_hDevice,<sp/>buffer,<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationCallbacks());</highlight></codeline>
<codeline lineno="17222"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17223"><highlight class="normal"></highlight></codeline>
<codeline lineno="17224"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(allocation<sp/>!=<sp/>VK_NULL_HANDLE)</highlight></codeline>
<codeline lineno="17225"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17226"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;FreeMemory(</highlight></codeline>
<codeline lineno="17227"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1,<sp/></highlight><highlight class="comment">//<sp/>allocationCount</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17228"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;allocation);</highlight></codeline>
<codeline lineno="17229"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17230"><highlight class="normal">}</highlight></codeline>
<codeline lineno="17231"><highlight class="normal"></highlight></codeline>
<codeline lineno="17232"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1gaa76142ae43535c862ad9e194a6e38aaa" kindref="member">vmaCreateImage</ref>(</highlight></codeline>
<codeline lineno="17233"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="17234"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkImageCreateInfo*<sp/>pImageCreateInfo,</highlight></codeline>
<codeline lineno="17235"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>*<sp/>pAllocationCreateInfo,</highlight></codeline>
<codeline lineno="17236"><highlight class="normal"><sp/><sp/><sp/><sp/>VkImage*<sp/>pImage,</highlight></codeline>
<codeline lineno="17237"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>*<sp/>pAllocation,</highlight></codeline>
<codeline lineno="17238"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref>*<sp/>pAllocationInfo)</highlight></codeline>
<codeline lineno="17239"><highlight class="normal">{</highlight></codeline>
<codeline lineno="17240"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>pImageCreateInfo<sp/>&amp;&amp;<sp/>pAllocationCreateInfo<sp/>&amp;&amp;<sp/>pImage<sp/>&amp;&amp;<sp/>pAllocation);</highlight></codeline>
<codeline lineno="17241"><highlight class="normal"></highlight></codeline>
<codeline lineno="17242"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pImageCreateInfo-&gt;extent.width<sp/>==<sp/>0<sp/>||</highlight></codeline>
<codeline lineno="17243"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pImageCreateInfo-&gt;extent.height<sp/>==<sp/>0<sp/>||</highlight></codeline>
<codeline lineno="17244"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pImageCreateInfo-&gt;extent.depth<sp/>==<sp/>0<sp/>||</highlight></codeline>
<codeline lineno="17245"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pImageCreateInfo-&gt;mipLevels<sp/>==<sp/>0<sp/>||</highlight></codeline>
<codeline lineno="17246"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pImageCreateInfo-&gt;arrayLayers<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="17247"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17248"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_INITIALIZATION_FAILED;</highlight></codeline>
<codeline lineno="17249"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17250"><highlight class="normal"></highlight></codeline>
<codeline lineno="17251"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaCreateImage&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="17252"><highlight class="normal"></highlight></codeline>
<codeline lineno="17253"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="17254"><highlight class="normal"></highlight></codeline>
<codeline lineno="17255"><highlight class="normal"><sp/><sp/><sp/><sp/>*pImage<sp/>=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="17256"><highlight class="normal"><sp/><sp/><sp/><sp/>*pAllocation<sp/>=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="17257"><highlight class="normal"></highlight></codeline>
<codeline lineno="17258"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>1.<sp/>Create<sp/>VkImage.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17259"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>(*<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetVulkanFunctions().vkCreateImage)(</highlight></codeline>
<codeline lineno="17260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_hDevice,</highlight></codeline>
<codeline lineno="17261"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pImageCreateInfo,</highlight></codeline>
<codeline lineno="17262"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationCallbacks(),</highlight></codeline>
<codeline lineno="17263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pImage);</highlight></codeline>
<codeline lineno="17264"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>&gt;=<sp/>0)</highlight></codeline>
<codeline lineno="17265"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17266"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaSuballocationType<sp/>suballocType<sp/>=<sp/>pImageCreateInfo-&gt;tiling<sp/>==<sp/>VK_IMAGE_TILING_OPTIMAL<sp/>?</highlight></codeline>
<codeline lineno="17267"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_SUBALLOCATION_TYPE_IMAGE_OPTIMAL<sp/>:</highlight></codeline>
<codeline lineno="17268"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_SUBALLOCATION_TYPE_IMAGE_LINEAR;</highlight></codeline>
<codeline lineno="17269"><highlight class="normal"></highlight></codeline>
<codeline lineno="17270"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>2.<sp/>Allocate<sp/>memory<sp/>using<sp/>allocator.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17271"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkMemoryRequirements<sp/>vkMemReq<sp/>=<sp/>{};</highlight></codeline>
<codeline lineno="17272"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>requiresDedicatedAllocation<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="17273"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>prefersDedicatedAllocation<sp/><sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="17274"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetImageMemoryRequirements(*pImage,<sp/>vkMemReq,</highlight></codeline>
<codeline lineno="17275"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>requiresDedicatedAllocation,<sp/>prefersDedicatedAllocation);</highlight></codeline>
<codeline lineno="17276"><highlight class="normal"></highlight></codeline>
<codeline lineno="17277"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;AllocateMemory(</highlight></codeline>
<codeline lineno="17278"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vkMemReq,</highlight></codeline>
<codeline lineno="17279"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>requiresDedicatedAllocation,</highlight></codeline>
<codeline lineno="17280"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prefersDedicatedAllocation,</highlight></codeline>
<codeline lineno="17281"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VK_NULL_HANDLE,<sp/></highlight><highlight class="comment">//<sp/>dedicatedBuffer</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17282"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pImage,<sp/></highlight><highlight class="comment">//<sp/>dedicatedImage</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17283"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pImageCreateInfo-&gt;usage,<sp/></highlight><highlight class="comment">//<sp/>dedicatedBufferImageUsage</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17284"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pAllocationCreateInfo,</highlight></codeline>
<codeline lineno="17285"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>suballocType,</highlight></codeline>
<codeline lineno="17286"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1,<sp/></highlight><highlight class="comment">//<sp/>allocationCount</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocation);</highlight></codeline>
<codeline lineno="17288"><highlight class="normal"></highlight></codeline>
<codeline lineno="17289"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>&gt;=<sp/>0)</highlight></codeline>
<codeline lineno="17290"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17291"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>3.<sp/>Bind<sp/>image<sp/>with<sp/>memory.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17292"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">((pAllocationCreateInfo-&gt;<ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a2310568c62208af432724305fe29ccea" kindref="member">VMA_ALLOCATION_CREATE_DONT_BIND_BIT</ref>)<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="17293"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17294"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;BindImageMemory(*pAllocation,<sp/>0,<sp/>*pImage,<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="17295"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17296"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>&gt;=<sp/>0)</highlight></codeline>
<codeline lineno="17297"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17298"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>All<sp/>steps<sp/>succeeded.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17299"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17300"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*pAllocation)-&gt;InitBufferImageUsage(pImageCreateInfo-&gt;usage);</highlight></codeline>
<codeline lineno="17301"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17302"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pAllocationInfo<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="17303"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17304"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationInfo(*pAllocation,<sp/>pAllocationInfo);</highlight></codeline>
<codeline lineno="17305"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17306"><highlight class="normal"></highlight></codeline>
<codeline lineno="17307"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="17308"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17309"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;FreeMemory(</highlight></codeline>
<codeline lineno="17310"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1,<sp/></highlight><highlight class="comment">//<sp/>allocationCount</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17311"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pAllocation);</highlight></codeline>
<codeline lineno="17312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pAllocation<sp/>=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="17313"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetVulkanFunctions().vkDestroyImage)(<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_hDevice,<sp/>*pImage,<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationCallbacks());</highlight></codeline>
<codeline lineno="17314"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pImage<sp/>=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="17315"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="17316"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17317"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetVulkanFunctions().vkDestroyImage)(<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_hDevice,<sp/>*pImage,<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationCallbacks());</highlight></codeline>
<codeline lineno="17318"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pImage<sp/>=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="17319"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="17320"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17321"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="17322"><highlight class="normal">}</highlight></codeline>
<codeline lineno="17323"><highlight class="normal"></highlight></codeline>
<codeline lineno="17324"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga9ef2c5794b39fea75da48305e3a17084" kindref="member">vmaCreateAliasingImage</ref>(</highlight></codeline>
<codeline lineno="17325"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="17326"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocation,</highlight></codeline>
<codeline lineno="17327"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkImageCreateInfo*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pImageCreateInfo,</highlight></codeline>
<codeline lineno="17328"><highlight class="normal"><sp/><sp/><sp/><sp/>VkImage<sp/><ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pImage)</highlight></codeline>
<codeline lineno="17329"><highlight class="normal">{</highlight></codeline>
<codeline lineno="17330"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator<sp/>&amp;&amp;<sp/>pImageCreateInfo<sp/>&amp;&amp;<sp/>pImage<sp/>&amp;&amp;<sp/>allocation);</highlight></codeline>
<codeline lineno="17331"><highlight class="normal"></highlight></codeline>
<codeline lineno="17332"><highlight class="normal"><sp/><sp/><sp/><sp/>*pImage<sp/>=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="17333"><highlight class="normal"></highlight></codeline>
<codeline lineno="17334"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaCreateImage&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="17335"><highlight class="normal"></highlight></codeline>
<codeline lineno="17336"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(pImageCreateInfo-&gt;extent.width<sp/>==<sp/>0<sp/>||</highlight></codeline>
<codeline lineno="17337"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pImageCreateInfo-&gt;extent.height<sp/>==<sp/>0<sp/>||</highlight></codeline>
<codeline lineno="17338"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pImageCreateInfo-&gt;extent.depth<sp/>==<sp/>0<sp/>||</highlight></codeline>
<codeline lineno="17339"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pImageCreateInfo-&gt;mipLevels<sp/>==<sp/>0<sp/>||</highlight></codeline>
<codeline lineno="17340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pImageCreateInfo-&gt;arrayLayers<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="17341"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17342"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_ERROR_INITIALIZATION_FAILED;</highlight></codeline>
<codeline lineno="17343"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17344"><highlight class="normal"></highlight></codeline>
<codeline lineno="17345"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="17346"><highlight class="normal"></highlight></codeline>
<codeline lineno="17347"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>1.<sp/>Create<sp/>VkImage.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17348"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>(*<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetVulkanFunctions().vkCreateImage)(</highlight></codeline>
<codeline lineno="17349"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_hDevice,</highlight></codeline>
<codeline lineno="17350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pImageCreateInfo,</highlight></codeline>
<codeline lineno="17351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationCallbacks(),</highlight></codeline>
<codeline lineno="17352"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pImage);</highlight></codeline>
<codeline lineno="17353"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res<sp/>&gt;=<sp/>0)</highlight></codeline>
<codeline lineno="17354"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17355"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>2.<sp/>Bind<sp/>image<sp/>with<sp/>memory.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17356"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;BindImageMemory(allocation,<sp/>0,<sp/>*pImage,<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="17357"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res<sp/>&gt;=<sp/>0)</highlight></codeline>
<codeline lineno="17358"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17359"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>VK_SUCCESS;</highlight></codeline>
<codeline lineno="17360"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17361"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetVulkanFunctions().vkDestroyImage)(<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_hDevice,<sp/>*pImage,<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationCallbacks());</highlight></codeline>
<codeline lineno="17362"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17363"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="17364"><highlight class="normal">}</highlight></codeline>
<codeline lineno="17365"><highlight class="normal"></highlight></codeline>
<codeline lineno="17366"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__alloc_1ga2f6367e612daace5c5ecd7ef9e47c3fd" kindref="member">vmaDestroyImage</ref>(</highlight></codeline>
<codeline lineno="17367"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>allocator,</highlight></codeline>
<codeline lineno="17368"><highlight class="normal"><sp/><sp/><sp/><sp/>VkImage<sp/><ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref><sp/>image,</highlight></codeline>
<codeline lineno="17369"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>allocation)</highlight></codeline>
<codeline lineno="17370"><highlight class="normal">{</highlight></codeline>
<codeline lineno="17371"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(allocator);</highlight></codeline>
<codeline lineno="17372"><highlight class="normal"></highlight></codeline>
<codeline lineno="17373"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(image<sp/>==<sp/>VK_NULL_HANDLE<sp/>&amp;&amp;<sp/>allocation<sp/>==<sp/>VK_NULL_HANDLE)</highlight></codeline>
<codeline lineno="17374"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17375"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="17376"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17377"><highlight class="normal"></highlight></codeline>
<codeline lineno="17378"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaDestroyImage&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="17379"><highlight class="normal"></highlight></codeline>
<codeline lineno="17380"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK</highlight></codeline>
<codeline lineno="17381"><highlight class="normal"></highlight></codeline>
<codeline lineno="17382"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(image<sp/>!=<sp/>VK_NULL_HANDLE)</highlight></codeline>
<codeline lineno="17383"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17384"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(*<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetVulkanFunctions().vkDestroyImage)(<ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;m_hDevice,<sp/>image,<sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;GetAllocationCallbacks());</highlight></codeline>
<codeline lineno="17385"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17386"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(allocation<sp/>!=<sp/>VK_NULL_HANDLE)</highlight></codeline>
<codeline lineno="17387"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17388"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespace_vk_tools_1a7195f698aad36f4aa2a4a9e977991486" kindref="member">allocator</ref>-&gt;FreeMemory(</highlight></codeline>
<codeline lineno="17389"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1,<sp/></highlight><highlight class="comment">//<sp/>allocationCount</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17390"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;allocation);</highlight></codeline>
<codeline lineno="17391"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17392"><highlight class="normal">}</highlight></codeline>
<codeline lineno="17393"><highlight class="normal"></highlight></codeline>
<codeline lineno="17394"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__virtual_1ga869baad02bf3b5fb012d61e1a43f92c5" kindref="member">vmaCreateVirtualBlock</ref>(</highlight></codeline>
<codeline lineno="17395"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_virtual_block_create_info" kindref="compound">VmaVirtualBlockCreateInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pCreateInfo,</highlight></codeline>
<codeline lineno="17396"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref><sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pVirtualBlock)</highlight></codeline>
<codeline lineno="17397"><highlight class="normal">{</highlight></codeline>
<codeline lineno="17398"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(pCreateInfo<sp/>&amp;&amp;<sp/>pVirtualBlock);</highlight></codeline>
<codeline lineno="17399"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(pCreateInfo-&gt;size<sp/>&gt;<sp/>0);</highlight></codeline>
<codeline lineno="17400"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaCreateVirtualBlock&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="17401"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK;</highlight></codeline>
<codeline lineno="17402"><highlight class="normal"><sp/><sp/><sp/><sp/>*pVirtualBlock<sp/>=<sp/>vma_new(pCreateInfo-&gt;pAllocationCallbacks,<sp/>VmaVirtualBlock_T)(*pCreateInfo);</highlight></codeline>
<codeline lineno="17403"><highlight class="normal"><sp/><sp/><sp/><sp/>VkResult<sp/>res<sp/>=<sp/>(*pVirtualBlock)-&gt;Init();</highlight></codeline>
<codeline lineno="17404"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(res<sp/>&lt;<sp/>0)</highlight></codeline>
<codeline lineno="17405"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17406"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vma_delete(pCreateInfo-&gt;pAllocationCallbacks,<sp/>*pVirtualBlock);</highlight></codeline>
<codeline lineno="17407"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*pVirtualBlock<sp/>=<sp/>VK_NULL_HANDLE;</highlight></codeline>
<codeline lineno="17408"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17409"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="17410"><highlight class="normal">}</highlight></codeline>
<codeline lineno="17411"><highlight class="normal"></highlight></codeline>
<codeline lineno="17412"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__virtual_1ga1a464943809fb27dd3b78d1cd6e3d534" kindref="member">vmaDestroyVirtualBlock</ref>(<ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref><sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>virtualBlock)</highlight></codeline>
<codeline lineno="17413"><highlight class="normal">{</highlight></codeline>
<codeline lineno="17414"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(virtualBlock<sp/>!=<sp/>VK_NULL_HANDLE)</highlight></codeline>
<codeline lineno="17415"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17416"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaDestroyVirtualBlock&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="17417"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK;</highlight></codeline>
<codeline lineno="17418"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VkAllocationCallbacks<sp/>allocationCallbacks<sp/>=<sp/>virtualBlock-&gt;m_AllocationCallbacks;<sp/></highlight><highlight class="comment">//<sp/>Have<sp/>to<sp/>copy<sp/>the<sp/>callbacks<sp/>when<sp/>destroying.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17419"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vma_delete(&amp;allocationCallbacks,<sp/>virtualBlock);</highlight></codeline>
<codeline lineno="17420"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17421"><highlight class="normal">}</highlight></codeline>
<codeline lineno="17422"><highlight class="normal"></highlight></codeline>
<codeline lineno="17423"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkBool32<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__virtual_1ga59f870a818a9acf8506aa36760549a48" kindref="member">vmaIsVirtualBlockEmpty</ref>(<ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>virtualBlock)</highlight></codeline>
<codeline lineno="17424"><highlight class="normal">{</highlight></codeline>
<codeline lineno="17425"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(virtualBlock<sp/>!=<sp/>VK_NULL_HANDLE);</highlight></codeline>
<codeline lineno="17426"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaIsVirtualBlockEmpty&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="17427"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK;</highlight></codeline>
<codeline lineno="17428"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>virtualBlock-&gt;IsEmpty()<sp/>?<sp/>VK_TRUE<sp/>:<sp/>VK_FALSE;</highlight></codeline>
<codeline lineno="17429"><highlight class="normal">}</highlight></codeline>
<codeline lineno="17430"><highlight class="normal"></highlight></codeline>
<codeline lineno="17431"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__virtual_1ga64b8c2939b82f83fbec507f29a43307b" kindref="member">vmaGetVirtualAllocationInfo</ref>(<ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>virtualBlock,</highlight></codeline>
<codeline lineno="17432"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_virtual_allocation" kindref="compound">VmaVirtualAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" kindref="member">VMA_NOT_NULL_NON_DISPATCHABLE</ref><sp/>allocation,<sp/><ref refid="struct_vma_virtual_allocation_info" kindref="compound">VmaVirtualAllocationInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pVirtualAllocInfo)</highlight></codeline>
<codeline lineno="17433"><highlight class="normal">{</highlight></codeline>
<codeline lineno="17434"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(virtualBlock<sp/>!=<sp/>VK_NULL_HANDLE<sp/>&amp;&amp;<sp/>pVirtualAllocInfo<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="17435"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaGetVirtualAllocationInfo&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="17436"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK;</highlight></codeline>
<codeline lineno="17437"><highlight class="normal"><sp/><sp/><sp/><sp/>virtualBlock-&gt;GetAllocationInfo(allocation,<sp/>*pVirtualAllocInfo);</highlight></codeline>
<codeline lineno="17438"><highlight class="normal">}</highlight></codeline>
<codeline lineno="17439"><highlight class="normal"></highlight></codeline>
<codeline lineno="17440"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/>VkResult<sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__virtual_1ga2f6cd8f6b98e754be7016b5860d02dac" kindref="member">vmaVirtualAllocate</ref>(<ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>virtualBlock,</highlight></codeline>
<codeline lineno="17441"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="struct_vma_virtual_allocation_create_info" kindref="compound">VmaVirtualAllocationCreateInfo</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pCreateInfo,<sp/><ref refid="struct_vma_virtual_allocation" kindref="compound">VmaVirtualAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pAllocation,</highlight></codeline>
<codeline lineno="17442"><highlight class="normal"><sp/><sp/><sp/><sp/>VkDeviceSize*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>pOffset)</highlight></codeline>
<codeline lineno="17443"><highlight class="normal">{</highlight></codeline>
<codeline lineno="17444"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(virtualBlock<sp/>!=<sp/>VK_NULL_HANDLE<sp/>&amp;&amp;<sp/>pCreateInfo<sp/>!=<sp/>VMA_NULL<sp/>&amp;&amp;<sp/>pAllocation<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="17445"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaVirtualAllocate&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="17446"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK;</highlight></codeline>
<codeline lineno="17447"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>virtualBlock-&gt;Allocate(*pCreateInfo,<sp/>*pAllocation,<sp/>pOffset);</highlight></codeline>
<codeline lineno="17448"><highlight class="normal">}</highlight></codeline>
<codeline lineno="17449"><highlight class="normal"></highlight></codeline>
<codeline lineno="17450"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__virtual_1ga9f82fb8b8160d10bb469ae06b90134d2" kindref="member">vmaVirtualFree</ref>(<ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>virtualBlock,<sp/><ref refid="struct_vma_virtual_allocation" kindref="compound">VmaVirtualAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref><sp/>allocation)</highlight></codeline>
<codeline lineno="17451"><highlight class="normal">{</highlight></codeline>
<codeline lineno="17452"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(allocation<sp/>!=<sp/>VK_NULL_HANDLE)</highlight></codeline>
<codeline lineno="17453"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17454"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(virtualBlock<sp/>!=<sp/>VK_NULL_HANDLE);</highlight></codeline>
<codeline lineno="17455"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaVirtualFree&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="17456"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK;</highlight></codeline>
<codeline lineno="17457"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>virtualBlock-&gt;Free(allocation);</highlight></codeline>
<codeline lineno="17458"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17459"><highlight class="normal">}</highlight></codeline>
<codeline lineno="17460"><highlight class="normal"></highlight></codeline>
<codeline lineno="17461"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__virtual_1ga3114a4b34e1225b3d0a246b219d29d9d" kindref="member">vmaClearVirtualBlock</ref>(<ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>virtualBlock)</highlight></codeline>
<codeline lineno="17462"><highlight class="normal">{</highlight></codeline>
<codeline lineno="17463"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(virtualBlock<sp/>!=<sp/>VK_NULL_HANDLE);</highlight></codeline>
<codeline lineno="17464"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaClearVirtualBlock&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="17465"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK;</highlight></codeline>
<codeline lineno="17466"><highlight class="normal"><sp/><sp/><sp/><sp/>virtualBlock-&gt;Clear();</highlight></codeline>
<codeline lineno="17467"><highlight class="normal">}</highlight></codeline>
<codeline lineno="17468"><highlight class="normal"></highlight></codeline>
<codeline lineno="17469"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__virtual_1ga9e697c001a3750c3bf1a081ee15f6b10" kindref="member">vmaSetVirtualAllocationUserData</ref>(<ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>virtualBlock,</highlight></codeline>
<codeline lineno="17470"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_virtual_allocation" kindref="compound">VmaVirtualAllocation</ref><sp/><ref refid="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" kindref="member">VMA_NOT_NULL_NON_DISPATCHABLE</ref><sp/>allocation,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>pUserData)</highlight></codeline>
<codeline lineno="17471"><highlight class="normal">{</highlight></codeline>
<codeline lineno="17472"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(virtualBlock<sp/>!=<sp/>VK_NULL_HANDLE);</highlight></codeline>
<codeline lineno="17473"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaSetVirtualAllocationUserData&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="17474"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK;</highlight></codeline>
<codeline lineno="17475"><highlight class="normal"><sp/><sp/><sp/><sp/>virtualBlock-&gt;SetAllocationUserData(allocation,<sp/>pUserData);</highlight></codeline>
<codeline lineno="17476"><highlight class="normal">}</highlight></codeline>
<codeline lineno="17477"><highlight class="normal"></highlight></codeline>
<codeline lineno="17478"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__virtual_1gac63bab2c8ae8e74451a11ef6dab48a5d" kindref="member">vmaGetVirtualBlockStatistics</ref>(<ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>virtualBlock,</highlight></codeline>
<codeline lineno="17479"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_statistics" kindref="compound">VmaStatistics</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pStats)</highlight></codeline>
<codeline lineno="17480"><highlight class="normal">{</highlight></codeline>
<codeline lineno="17481"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(virtualBlock<sp/>!=<sp/>VK_NULL_HANDLE<sp/>&amp;&amp;<sp/>pStats<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="17482"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaGetVirtualBlockStatistics&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="17483"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK;</highlight></codeline>
<codeline lineno="17484"><highlight class="normal"><sp/><sp/><sp/><sp/>virtualBlock-&gt;GetStatistics(*pStats);</highlight></codeline>
<codeline lineno="17485"><highlight class="normal">}</highlight></codeline>
<codeline lineno="17486"><highlight class="normal"></highlight></codeline>
<codeline lineno="17487"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__virtual_1ga87017b57fb0e9623573f07c236c37566" kindref="member">vmaCalculateVirtualBlockStatistics</ref>(<ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>virtualBlock,</highlight></codeline>
<codeline lineno="17488"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_vma_detailed_statistics" kindref="compound">VmaDetailedStatistics</ref>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>pStats)</highlight></codeline>
<codeline lineno="17489"><highlight class="normal">{</highlight></codeline>
<codeline lineno="17490"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(virtualBlock<sp/>!=<sp/>VK_NULL_HANDLE<sp/>&amp;&amp;<sp/>pStats<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="17491"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_LOG(</highlight><highlight class="stringliteral">&quot;vmaCalculateVirtualBlockStatistics&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="17492"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK;</highlight></codeline>
<codeline lineno="17493"><highlight class="normal"><sp/><sp/><sp/><sp/>virtualBlock-&gt;CalculateDetailedStatistics(*pStats);</highlight></codeline>
<codeline lineno="17494"><highlight class="normal">}</highlight></codeline>
<codeline lineno="17495"><highlight class="normal"></highlight></codeline>
<codeline lineno="17496"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17497"><highlight class="normal"></highlight></codeline>
<codeline lineno="17498"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__stats_1ga874ef8790380b6643ee5c1144ae5b32b" kindref="member">vmaBuildVirtualBlockStatsString</ref>(<ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>virtualBlock,</highlight></codeline>
<codeline lineno="17499"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>*<sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>ppStatsString,<sp/>VkBool32<sp/>detailedMap)</highlight></codeline>
<codeline lineno="17500"><highlight class="normal">{</highlight></codeline>
<codeline lineno="17501"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_ASSERT(virtualBlock<sp/>!=<sp/>VK_NULL_HANDLE<sp/>&amp;&amp;<sp/>ppStatsString<sp/>!=<sp/>VMA_NULL);</highlight></codeline>
<codeline lineno="17502"><highlight class="normal"><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK;</highlight></codeline>
<codeline lineno="17503"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VkAllocationCallbacks*<sp/>allocationCallbacks<sp/>=<sp/>virtualBlock-&gt;GetAllocationCallbacks();</highlight></codeline>
<codeline lineno="17504"><highlight class="normal"><sp/><sp/><sp/><sp/>VmaStringBuilder<sp/>sb(allocationCallbacks);</highlight></codeline>
<codeline lineno="17505"><highlight class="normal"><sp/><sp/><sp/><sp/>virtualBlock-&gt;BuildStatsString(detailedMap<sp/>!=<sp/>VK_FALSE,<sp/>sb);</highlight></codeline>
<codeline lineno="17506"><highlight class="normal"><sp/><sp/><sp/><sp/>*ppStatsString<sp/>=<sp/>VmaCreateStringCopy(allocationCallbacks,<sp/>sb.GetData(),<sp/>sb.GetLength());</highlight></codeline>
<codeline lineno="17507"><highlight class="normal">}</highlight></codeline>
<codeline lineno="17508"><highlight class="normal"></highlight></codeline>
<codeline lineno="17509"><highlight class="normal"><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref><sp/><ref refid="group__group__stats_1ga5b3acd266c1f20d0b360d4259ff411bf" kindref="member">vmaFreeVirtualBlockStatsString</ref>(<ref refid="struct_vma_virtual_block" kindref="compound">VmaVirtualBlock</ref><sp/><ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref><sp/>virtualBlock,</highlight></codeline>
<codeline lineno="17510"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/><ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref><sp/>pStatsString)</highlight></codeline>
<codeline lineno="17511"><highlight class="normal">{</highlight></codeline>
<codeline lineno="17512"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(pStatsString<sp/>!=<sp/>VMA_NULL)</highlight></codeline>
<codeline lineno="17513"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="17514"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_ASSERT(virtualBlock<sp/>!=<sp/>VK_NULL_HANDLE);</highlight></codeline>
<codeline lineno="17515"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VMA_DEBUG_GLOBAL_MUTEX_LOCK;</highlight></codeline>
<codeline lineno="17516"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>VmaFreeString(virtualBlock-&gt;GetAllocationCallbacks(),<sp/>pStatsString);</highlight></codeline>
<codeline lineno="17517"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="17518"><highlight class="normal">}</highlight></codeline>
<codeline lineno="17519"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>VMA_STATS_STRING_ENABLED</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17520"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>_VMA_PUBLIC_INTERFACE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17521"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>VMA_IMPLEMENTATION</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17522"><highlight class="normal"></highlight></codeline>
    </programlisting>
    <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h"/>
  </compounddef>
</doxygen>
