<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.5" xml:lang="en-US">
  <compounddef id="group__group__alloc" kind="group">
    <compoundname>group_alloc</compoundname>
    <title>Memory allocation</title>
    <innerclass refid="struct_vma_allocation_create_info" prot="public">VmaAllocationCreateInfo</innerclass>
    <innerclass refid="struct_vma_pool_create_info" prot="public">VmaPoolCreateInfo</innerclass>
    <innerclass refid="struct_vma_allocation_info" prot="public">VmaAllocationInfo</innerclass>
    <innerclass refid="struct_vma_defragmentation_info" prot="public">VmaDefragmentationInfo</innerclass>
    <innerclass refid="struct_vma_defragmentation_move" prot="public">VmaDefragmentationMove</innerclass>
    <innerclass refid="struct_vma_defragmentation_pass_move_info" prot="public">VmaDefragmentationPassMoveInfo</innerclass>
    <innerclass refid="struct_vma_defragmentation_stats" prot="public">VmaDefragmentationStats</innerclass>
    <innerclass refid="struct_vma_pool" prot="public">VmaPool</innerclass>
    <innerclass refid="struct_vma_allocation" prot="public">VmaAllocation</innerclass>
    <innerclass refid="struct_vma_defragmentation_context" prot="public">VmaDefragmentationContext</innerclass>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="group__group__alloc_1gaa5846affa1e9da3800e3e78fae2305cc" prot="public" static="no" strong="no">
        <type></type>
        <name>VmaMemoryUsage</name>
        <enumvalue id="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305ccaf50d27e34e0925cf3a63db8c839121dd" prot="public">
          <name>VMA_MEMORY_USAGE_UNKNOWN</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>No intended memory usage specified. Use other members of <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref> to specify your requirements. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305ccac6b5dc1432d88647aa4cd456246eadf7" prot="public">
          <name>VMA_MEMORY_USAGE_GPU_ONLY</name>
          <initializer>= 1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><xrefsect id="deprecated_1_deprecated000001"><xreftitle>Deprecated</xreftitle><xrefdescription><para>Obsolete, preserved for backward compatibility. Prefers `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`. </para>
</xrefdescription></xrefsect></para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca40bdf4cddeffeb12f43d45ca1286e0a5" prot="public">
          <name>VMA_MEMORY_USAGE_CPU_ONLY</name>
          <initializer>= 2</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><xrefsect id="deprecated_1_deprecated000002"><xreftitle>Deprecated</xreftitle><xrefdescription><para>Obsolete, preserved for backward compatibility. Guarantees `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` and `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT`. </para>
</xrefdescription></xrefsect></para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca9066b52c5a7079bb74a69aaf8b92ff67" prot="public">
          <name>VMA_MEMORY_USAGE_CPU_TO_GPU</name>
          <initializer>= 3</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><xrefsect id="deprecated_1_deprecated000003"><xreftitle>Deprecated</xreftitle><xrefdescription><para>Obsolete, preserved for backward compatibility. Guarantees `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`, prefers `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`. </para>
</xrefdescription></xrefsect></para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca7b586d2fdaf82a463b58f581ed72be27" prot="public">
          <name>VMA_MEMORY_USAGE_GPU_TO_CPU</name>
          <initializer>= 4</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><xrefsect id="deprecated_1_deprecated000004"><xreftitle>Deprecated</xreftitle><xrefdescription><para>Obsolete, preserved for backward compatibility. Guarantees `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`, prefers `VK_MEMORY_PROPERTY_HOST_CACHED_BIT`. </para>
</xrefdescription></xrefsect></para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca416a444d4d0fc20067c3f76f32ff2500" prot="public">
          <name>VMA_MEMORY_USAGE_CPU_COPY</name>
          <initializer>= 5</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><xrefsect id="deprecated_1_deprecated000005"><xreftitle>Deprecated</xreftitle><xrefdescription><para>Obsolete, preserved for backward compatibility. Prefers not `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`. </para>
</xrefdescription></xrefsect></para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca835333d9072db63a653818030e17614d" prot="public">
          <name>VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED</name>
          <initializer>= 6</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Lazily allocated GPU memory having `VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT`. Exists mostly on mobile platforms. Using it on desktop PC or other GPUs with no such memory type present will fail the allocation.</para>
<para>Usage: Memory for transient attachment images (color attachments, depth attachments etc.), created with `VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT`.</para>
<para>Allocations with this usage are always created as dedicated - it implies <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" kindref="member">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</ref>. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e" prot="public">
          <name>VMA_MEMORY_USAGE_AUTO</name>
          <initializer>= 7</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Selects best memory type automatically. This flag is recommended for most common use cases.</para>
<para>When using this flag, if you want to map the allocation (using <ref refid="group__group__alloc_1ga13b93ec0ed38ad7232300cb94931c8d2" kindref="member">vmaMapMemory()</ref> or <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" kindref="member">VMA_ALLOCATION_CREATE_MAPPED_BIT</ref>), you must pass one of the flags: <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</ref> or <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</ref> in <ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">VmaAllocationCreateInfo::flags</ref>.</para>
<para>It can be used only with functions that let the library know `VkBufferCreateInfo` or `VkImageCreateInfo`, e.g. <ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer()</ref>, <ref refid="group__group__alloc_1gaa76142ae43535c862ad9e194a6e38aaa" kindref="member">vmaCreateImage()</ref>, <ref refid="group__group__alloc_1ga723f5683b363c306bf860dab1861f299" kindref="member">vmaFindMemoryTypeIndexForBufferInfo()</ref>, <ref refid="group__group__alloc_1gaaf05345771a087328949b485ff2da4db" kindref="member">vmaFindMemoryTypeIndexForImageInfo()</ref> and not with generic memory allocation functions. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305ccae2adb696d6a73c18bb20c23666661327" prot="public">
          <name>VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE</name>
          <initializer>= 8</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Selects best memory type automatically with preference for GPU (device) memory.</para>
<para>When using this flag, if you want to map the allocation (using <ref refid="group__group__alloc_1ga13b93ec0ed38ad7232300cb94931c8d2" kindref="member">vmaMapMemory()</ref> or <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" kindref="member">VMA_ALLOCATION_CREATE_MAPPED_BIT</ref>), you must pass one of the flags: <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</ref> or <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</ref> in <ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">VmaAllocationCreateInfo::flags</ref>.</para>
<para>It can be used only with functions that let the library know `VkBufferCreateInfo` or `VkImageCreateInfo`, e.g. <ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer()</ref>, <ref refid="group__group__alloc_1gaa76142ae43535c862ad9e194a6e38aaa" kindref="member">vmaCreateImage()</ref>, <ref refid="group__group__alloc_1ga723f5683b363c306bf860dab1861f299" kindref="member">vmaFindMemoryTypeIndexForBufferInfo()</ref>, <ref refid="group__group__alloc_1gaaf05345771a087328949b485ff2da4db" kindref="member">vmaFindMemoryTypeIndexForImageInfo()</ref> and not with generic memory allocation functions. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca9b422585242160b8ed3418310ee6664d" prot="public">
          <name>VMA_MEMORY_USAGE_AUTO_PREFER_HOST</name>
          <initializer>= 9</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Selects best memory type automatically with preference for CPU (host) memory.</para>
<para>When using this flag, if you want to map the allocation (using <ref refid="group__group__alloc_1ga13b93ec0ed38ad7232300cb94931c8d2" kindref="member">vmaMapMemory()</ref> or <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" kindref="member">VMA_ALLOCATION_CREATE_MAPPED_BIT</ref>), you must pass one of the flags: <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</ref> or <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</ref> in <ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">VmaAllocationCreateInfo::flags</ref>.</para>
<para>It can be used only with functions that let the library know `VkBufferCreateInfo` or `VkImageCreateInfo`, e.g. <ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer()</ref>, <ref refid="group__group__alloc_1gaa76142ae43535c862ad9e194a6e38aaa" kindref="member">vmaCreateImage()</ref>, <ref refid="group__group__alloc_1ga723f5683b363c306bf860dab1861f299" kindref="member">vmaFindMemoryTypeIndexForBufferInfo()</ref>, <ref refid="group__group__alloc_1gaaf05345771a087328949b485ff2da4db" kindref="member">vmaFindMemoryTypeIndexForImageInfo()</ref> and not with generic memory allocation functions. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca091e69437ef693e8d0d287f1c719ba6e" prot="public">
          <name>VMA_MEMORY_USAGE_MAX_ENUM</name>
          <initializer>= 0x7FFFFFFF</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Intended usage of the allocated memory. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="440" column="1" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="441" bodyend="519"/>
      </memberdef>
      <memberdef kind="enum" id="group__group__alloc_1gad9889c10c798b040d59c92f257cae597" prot="public" static="no" strong="no">
        <type></type>
        <name>VmaAllocationCreateFlagBits</name>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" prot="public">
          <name>VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</name>
          <initializer>= 0x00000001</initializer>
          <briefdescription>
<para>Set this flag if the allocation should have its own memory block. </para>
          </briefdescription>
          <detaileddescription>
<para>Use it for special, big resources, like fullscreen images used as attachments. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a89759603401014eb325eb22a3839f2ff" prot="public">
          <name>VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</name>
          <initializer>= 0x00000002</initializer>
          <briefdescription>
<para>Set this flag to only try to allocate from existing `VkDeviceMemory` blocks and never create new such block. </para>
          </briefdescription>
          <detaileddescription>
<para>If new allocation cannot be placed in any of the existing blocks, allocation fails with `VK_ERROR_OUT_OF_DEVICE_MEMORY` error.</para>
<para>You should not use <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" kindref="member">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</ref> and <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a89759603401014eb325eb22a3839f2ff" kindref="member">VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</ref> at the same time. It makes no sense. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" prot="public">
          <name>VMA_ALLOCATION_CREATE_MAPPED_BIT</name>
          <initializer>= 0x00000004</initializer>
          <briefdescription>
<para>Set this flag to use a memory that will be persistently mapped and retrieve pointer to it. </para>
          </briefdescription>
          <detaileddescription>
<para>Pointer to mapped memory will be returned through <ref refid="struct_vma_allocation_info_1a17a39eb34201a610347acb91b38eca79" kindref="member">VmaAllocationInfo::pMappedData</ref>.</para>
<para>It is valid to use this flag for allocation made from memory type that is not `HOST_VISIBLE`. This flag is then ignored and memory is not mapped. This is useful if you need an allocation that is efficient to use on GPU (`DEVICE_LOCAL`) and still want to map it directly if possible on platforms that support it (e.g. Intel GPU). </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597aa6f24f821cd6a7c5e4a443f7bf59c520" prot="public">
          <name>VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</name>
          <initializer>= 0x00000020</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><xrefsect id="deprecated_1_deprecated000006"><xreftitle>Deprecated</xreftitle><xrefdescription><para>Preserved for backward compatibility. Consider using <ref refid="group__group__alloc_1ga29b210b1f39e49de844fc7b6944736d7" kindref="member">vmaSetAllocationName()</ref> instead.</para>
</xrefdescription></xrefsect></para>
<para>Set this flag to treat <ref refid="struct_vma_allocation_create_info_1a74e2eb74b3772b657c59473ce605058a" kindref="member">VmaAllocationCreateInfo::pUserData</ref> as pointer to a null-terminated string. Instead of copying pointer value, a local copy of the string is made and stored in allocation&apos;s `pName`. The string is automatically freed together with the allocation. It is also used in <ref refid="group__group__stats_1ga9326cba3c64929b59a15c3ca9cdc8cdb" kindref="member">vmaBuildStatsString()</ref>. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a42ba3a2d2c7117953210b7c3ef8da0df" prot="public">
          <name>VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT</name>
          <initializer>= 0x00000040</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Allocation will be created from upper stack in a double stack pool.</para>
<para>This flag is only allowed for custom pools created with <ref refid="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726" kindref="member">VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</ref> flag. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a2310568c62208af432724305fe29ccea" prot="public">
          <name>VMA_ALLOCATION_CREATE_DONT_BIND_BIT</name>
          <initializer>= 0x00000080</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Create both buffer/image and allocation, but don&apos;t bind them together. It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions. The flag is meaningful only with functions that bind by default: <ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer()</ref>, <ref refid="group__group__alloc_1gaa76142ae43535c862ad9e194a6e38aaa" kindref="member">vmaCreateImage()</ref>. Otherwise it is ignored.</para>
<para>If you want to make sure the new buffer/image is not tied to the new memory allocation through `VkMemoryDedicatedAllocateInfoKHR` structure in case the allocation ends up in its own memory block, use also flag <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597afb0ee060cd733aaa5e249704ff589ad6" kindref="member">VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT</ref>. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597ab8b1764f3e9022368e440c057783b92d" prot="public">
          <name>VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT</name>
          <initializer>= 0x00000100</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Create allocation only if additional device memory required for it, if any, won&apos;t exceed memory budget. Otherwise return `VK_ERROR_OUT_OF_DEVICE_MEMORY`. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597afb0ee060cd733aaa5e249704ff589ad6" prot="public">
          <name>VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT</name>
          <initializer>= 0x00000200</initializer>
          <briefdescription>
<para>Set this flag if the allocated memory will have aliasing resources. </para>
          </briefdescription>
          <detaileddescription>
<para>Usage of this flag prevents supplying `VkMemoryDedicatedAllocateInfoKHR` when <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" kindref="member">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</ref> is specified. Otherwise created dedicated memory will not be suitable for aliasing resources, resulting in Vulkan Validation Layer errors. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5" prot="public">
          <name>VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</name>
          <initializer>= 0x00000400</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Requests possibility to map the allocation (using <ref refid="group__group__alloc_1ga13b93ec0ed38ad7232300cb94931c8d2" kindref="member">vmaMapMemory()</ref> or <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" kindref="member">VMA_ALLOCATION_CREATE_MAPPED_BIT</ref>).</para>
<para><itemizedlist>
<listitem><para>If you use <ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e" kindref="member">VMA_MEMORY_USAGE_AUTO</ref> or other `VMA_MEMORY_USAGE_AUTO*` value, you must use this flag to be able to map the allocation. Otherwise, mapping is incorrect.</para>
</listitem><listitem><para>If you use other value of <ref refid="group__group__alloc_1gaa5846affa1e9da3800e3e78fae2305cc" kindref="member">VmaMemoryUsage</ref>, this flag is ignored and mapping is always possible in memory types that are `HOST_VISIBLE`. This includes allocations created in <ref refid="custom_memory_pools" kindref="compound">Custom memory pools</ref>.</para>
</listitem></itemizedlist>
</para>
<para>Declares that mapped memory will only be written sequentially, e.g. using `memcpy()` or a loop writing number-by-number, never read or accessed randomly, so a memory type can be selected that is uncached and write-combined.</para>
<para><simplesect kind="warning"><para>Violating this declaration may work correctly, but will likely be very slow. Watch out for implicit reads introduced by doing e.g. `pMappedData[i] += x;` Better prepare your data in a local variable and `memcpy()` it to the mapped pointer all at once. </para>
</simplesect>
</para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492" prot="public">
          <name>VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</name>
          <initializer>= 0x00000800</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Requests possibility to map the allocation (using <ref refid="group__group__alloc_1ga13b93ec0ed38ad7232300cb94931c8d2" kindref="member">vmaMapMemory()</ref> or <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" kindref="member">VMA_ALLOCATION_CREATE_MAPPED_BIT</ref>).</para>
<para><itemizedlist>
<listitem><para>If you use <ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e" kindref="member">VMA_MEMORY_USAGE_AUTO</ref> or other `VMA_MEMORY_USAGE_AUTO*` value, you must use this flag to be able to map the allocation. Otherwise, mapping is incorrect.</para>
</listitem><listitem><para>If you use other value of <ref refid="group__group__alloc_1gaa5846affa1e9da3800e3e78fae2305cc" kindref="member">VmaMemoryUsage</ref>, this flag is ignored and mapping is always possible in memory types that are `HOST_VISIBLE`. This includes allocations created in <ref refid="custom_memory_pools" kindref="compound">Custom memory pools</ref>.</para>
</listitem></itemizedlist>
</para>
<para>Declares that mapped memory can be read, written, and accessed in random order, so a `HOST_CACHED` memory type is required. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11337f96eacf34c1016c339eac165cad" prot="public">
          <name>VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT</name>
          <initializer>= 0x00001000</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Together with <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a9be224df3bfc1cfa06203aed689a30c5" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT</ref> or <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597add61238d98e20917b9a06c617763f492" kindref="member">VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT</ref>, it says that despite request for host access, a not-`HOST_VISIBLE` memory type can be selected if it may improve performance.</para>
<para>By using this flag, you declare that you will check if the allocation ended up in a `HOST_VISIBLE` memory type (e.g. using <ref refid="group__group__alloc_1gaf6785483eda8b53561437e05e2177d7b" kindref="member">vmaGetAllocationMemoryProperties()</ref>) and if not, you will create some &quot;staging&quot; buffer and issue an explicit transfer to write/read your data. To prepare for this possibility, don&apos;t forget to add appropriate flags like `VK_BUFFER_USAGE_TRANSFER_DST_BIT`, `VK_BUFFER_USAGE_TRANSFER_SRC_BIT` to the parameters of created buffer or image. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8af1210cf591784afa026d94998f735d" prot="public">
          <name>VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</name>
          <initializer>= 0x00010000</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Allocation strategy that chooses smallest possible free range for the allocation to minimize memory usage and fragmentation, possibly at the expense of allocation time. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a0729e932b7ea170e3a128cad96c5cf6d" prot="public">
          <name>VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</name>
          <initializer>= 0x00020000</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Allocation strategy that chooses first suitable free range for the allocation - not necessarily in terms of the smallest offset but the one that is easiest and fastest to find to minimize allocation time, possibly at the expense of allocation quality. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8099acedc0d04cdccaaddcfe37fd227d" prot="public">
          <name>VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</name>
          <initializer>= 0x00040000</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Allocation strategy that chooses always the lowest offset in available space. This is not the most efficient strategy but achieves highly packed data. Used internally by defragmentation, not recomended in typical usage. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a839826775c62319466441f86496f036d" prot="public">
          <name>VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT</name>
          <initializer>= VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Alias to <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8af1210cf591784afa026d94998f735d" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT</ref>. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a33eb2052674f3ad92386c714a65fb777" prot="public">
          <name>VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT</name>
          <initializer>= VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Alias to <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a0729e932b7ea170e3a128cad96c5cf6d" kindref="member">VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT</ref>. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a8e16845d81ae3d27c47106d4770d5c7e" prot="public">
          <name>VMA_ALLOCATION_CREATE_STRATEGY_MASK</name>
          <initializer>=
        VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT |
        VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT |
        VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>A bit mask to extract only `STRATEGY` bits from entire set of flags. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597ae5633ec569f4899cf8f29e7385b2f882" prot="public">
          <name>VMA_ALLOCATION_CREATE_FLAG_BITS_MAX_ENUM</name>
          <initializer>= 0x7FFFFFFF</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Flags to be passed as <ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">VmaAllocationCreateInfo::flags</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="522" column="1" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="523" bodyend="651"/>
      </memberdef>
      <memberdef kind="enum" id="group__group__alloc_1ga9a7c45f9c863695d98c83fa5ac940fe7" prot="public" static="no" strong="no">
        <type></type>
        <name>VmaPoolCreateFlagBits</name>
        <enumvalue id="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7a9f1a499508a8edb4e8ba40aa0290a3d2" prot="public">
          <name>VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT</name>
          <initializer>= 0x00000002</initializer>
          <briefdescription>
<para>Use this flag if you always allocate only buffers and linear images or only optimal images out of this pool and so Buffer-Image Granularity can be ignored. </para>
          </briefdescription>
          <detaileddescription>
<para>This is an optional optimization flag.</para>
<para>If you always allocate using <ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer()</ref>, <ref refid="group__group__alloc_1gaa76142ae43535c862ad9e194a6e38aaa" kindref="member">vmaCreateImage()</ref>, <ref refid="group__group__alloc_1gaf7010aa90a4ccdda56f83db8597b9896" kindref="member">vmaAllocateMemoryForBuffer()</ref>, then you don&apos;t need to use it because allocator knows exact type of your allocations so it can handle Buffer-Image Granularity in the optimal way.</para>
<para>If you also allocate using <ref refid="group__group__alloc_1ga4b7f39281cb383c1496b68f97cb7f4c5" kindref="member">vmaAllocateMemoryForImage()</ref> or <ref refid="group__group__alloc_1gaf813f55a0667016a8cd68bb4b8b3b30c" kindref="member">vmaAllocateMemory()</ref>, exact type of such allocations is not known, so allocator must be conservative in handling Buffer-Image Granularity, which can lead to suboptimal allocation (wasted memory). In that case, if you can make sure you always allocate only buffers and linear images or only optimal images out of this pool, use this flag to make allocator disregard Buffer-Image Granularity and so make allocations faster and more optimal. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726" prot="public">
          <name>VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</name>
          <initializer>= 0x00000004</initializer>
          <briefdescription>
<para>Enables alternative, linear allocation algorithm in this pool. </para>
          </briefdescription>
          <detaileddescription>
<para>Specify this flag to enable linear allocation algorithm, which always creates new allocations after last one and doesn&apos;t reuse space from allocations freed in between. It trades memory consumption for simplified algorithm and data structure, which has better performance and uses less memory for metadata.</para>
<para>By using this flag, you can achieve behavior of free-at-once, stack, ring buffer, and double stack. For details, see documentation chapter <ref refid="custom_memory_pools_1linear_algorithm" kindref="member">Linear allocation algorithm</ref>. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7af4d270f8f42517a0f70037ceb6ac1d9c" prot="public">
          <name>VMA_POOL_CREATE_ALGORITHM_MASK</name>
          <initializer>=
        VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Bit mask to extract only `ALGORITHM` bits from entire set of flags. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7a1c7312bea9ea246846b9054fd6bd6aec" prot="public">
          <name>VMA_POOL_CREATE_FLAG_BITS_MAX_ENUM</name>
          <initializer>= 0x7FFFFFFF</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Flags to be passed as <ref refid="struct_vma_pool_create_info_1a8405139f63d078340ae74513a59f5446" kindref="member">VmaPoolCreateInfo::flags</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="656" column="1" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="657" bodyend="696"/>
      </memberdef>
      <memberdef kind="enum" id="group__group__alloc_1ga6552a65b71d16f378c6994b3ceaef50c" prot="public" static="no" strong="no">
        <type></type>
        <name>VmaDefragmentationFlagBits</name>
        <enumvalue id="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50ca2e6469bcf5a094776ceb5d118263f04b" prot="public">
          <name>VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT</name>
          <initializer>= 0x1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50caec35a4138111605a6ff32ca61aa871b6" prot="public">
          <name>VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT</name>
          <initializer>= 0x2</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50cafa162eac5be800bcdd4011427a71156d" prot="public">
          <name>VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT</name>
          <initializer>= 0x4</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50cae45a9469e5337731627758671741e412" prot="public">
          <name>VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT</name>
          <initializer>= 0x8</initializer>
          <briefdescription>
<para>Use the most roboust algorithm at the cost of time to compute and number of copies to make. Only available when bufferImageGranularity is greater than 1, since it aims to reduce alignment issues between different types of resources. Otherwise falls back to same behavior as <ref refid="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50cafa162eac5be800bcdd4011427a71156d" kindref="member">VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT</ref>. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50cabcbbdb3bfd53c4c3ab4eaeb5fd4894e9" prot="public">
          <name>VMA_DEFRAGMENTATION_FLAG_ALGORITHM_MASK</name>
          <initializer>= 
        VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT |
        VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT |
        VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT |
        VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT</initializer>
          <briefdescription>
<para>A bit mask to extract only `ALGORITHM` bits from entire set of flags. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1gga6552a65b71d16f378c6994b3ceaef50cab87ec33154803bfeb5ac2b379f1d6a97" prot="public">
          <name>VMA_DEFRAGMENTATION_FLAG_BITS_MAX_ENUM</name>
          <initializer>= 0x7FFFFFFF</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Flags to be passed as <ref refid="struct_vma_defragmentation_info_1a3e23080c978ecf3abb3180f5b2069da7" kindref="member">VmaDefragmentationInfo::flags</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="701" column="1" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="702" bodyend="730"/>
      </memberdef>
      <memberdef kind="enum" id="group__group__alloc_1gada9e3861caf96f08894b0bcc160ec257" prot="public" static="no" strong="no">
        <type></type>
        <name>VmaDefragmentationMoveOperation</name>
        <enumvalue id="group__group__alloc_1ggada9e3861caf96f08894b0bcc160ec257ad4a06ac46c4cb1c67b0ebc1edfab9f18" prot="public">
          <name>VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY</name>
          <initializer>= 0</initializer>
          <briefdescription>
<para>Buffer/image has been recreated at `dstTmpAllocation`, data has been copied, old buffer/image has been destroyed. `srcAllocation` should be changed to point to the new place. This is the default value set by <ref refid="group__group__alloc_1gacbe4a77fdfa7ea29328d2f940d423ab7" kindref="member">vmaBeginDefragmentationPass()</ref>. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggada9e3861caf96f08894b0bcc160ec257ad25bc6f816b226b4fd5170e845f218d2" prot="public">
          <name>VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE</name>
          <initializer>= 1</initializer>
          <briefdescription>
<para>Set this value if you cannot move the allocation. New place reserved at `dstTmpAllocation` will be freed. `srcAllocation` will remain unchanged. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__group__alloc_1ggada9e3861caf96f08894b0bcc160ec257a9786f8492a9be2c03bd26395e352ab85" prot="public">
          <name>VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY</name>
          <initializer>= 2</initializer>
          <briefdescription>
<para>Set this value if you decide to abandon the allocation and you destroyed the buffer/image. New place reserved at `dstTmpAllocation` will be freed, along with `srcAllocation`, which will be destroyed. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Operation performed on single defragmentation move. See structure <ref refid="struct_vma_defragmentation_move" kindref="compound">VmaDefragmentationMove</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="735" column="1" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="736" bodyend="743"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="group__group__alloc_1ga806e8499dde802e59eb72a1dc811c35f" prot="public" static="no">
        <type>enum <ref refid="group__group__alloc_1gaa5846affa1e9da3800e3e78fae2305cc" kindref="member">VmaMemoryUsage</ref></type>
        <definition>typedef enum VmaMemoryUsage VmaMemoryUsage</definition>
        <argsstring></argsstring>
        <name>VmaMemoryUsage</name>
        <briefdescription>
<para>Intended usage of the allocated memory. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="519" column="16"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1ga4fceecc301f4064dc808d3cd6c038941" prot="public" static="no">
        <type>enum <ref refid="group__group__alloc_1gad9889c10c798b040d59c92f257cae597" kindref="member">VmaAllocationCreateFlagBits</ref></type>
        <definition>typedef enum VmaAllocationCreateFlagBits VmaAllocationCreateFlagBits</definition>
        <argsstring></argsstring>
        <name>VmaAllocationCreateFlagBits</name>
        <briefdescription>
<para>Flags to be passed as <ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">VmaAllocationCreateInfo::flags</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="651" column="29"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1ga5225e5e11f8376f6a31a1791f3d6e817" prot="public" static="no">
        <type>VkFlags</type>
        <definition>typedef VkFlags VmaAllocationCreateFlags</definition>
        <argsstring></argsstring>
        <name>VmaAllocationCreateFlags</name>
        <briefdescription>
<para>See <ref refid="group__group__alloc_1gad9889c10c798b040d59c92f257cae597" kindref="member">VmaAllocationCreateFlagBits</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="653" column="17" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="653" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1ga4d4f2efc2509157a9e4ecd4fd7942303" prot="public" static="no">
        <type>enum <ref refid="group__group__alloc_1ga9a7c45f9c863695d98c83fa5ac940fe7" kindref="member">VmaPoolCreateFlagBits</ref></type>
        <definition>typedef enum VmaPoolCreateFlagBits VmaPoolCreateFlagBits</definition>
        <argsstring></argsstring>
        <name>VmaPoolCreateFlagBits</name>
        <briefdescription>
<para>Flags to be passed as <ref refid="struct_vma_pool_create_info_1a8405139f63d078340ae74513a59f5446" kindref="member">VmaPoolCreateInfo::flags</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="696" column="23"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1ga2770e325ea42e087c1b91fdf46d0292a" prot="public" static="no">
        <type>VkFlags</type>
        <definition>typedef VkFlags VmaPoolCreateFlags</definition>
        <argsstring></argsstring>
        <name>VmaPoolCreateFlags</name>
        <briefdescription>
<para>Flags to be passed as <ref refid="struct_vma_pool_create_info_1a8405139f63d078340ae74513a59f5446" kindref="member">VmaPoolCreateInfo::flags</ref>. See <ref refid="group__group__alloc_1ga9a7c45f9c863695d98c83fa5ac940fe7" kindref="member">VmaPoolCreateFlagBits</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="698" column="17" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="698" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1ga13415cc0b443353a7b5abda300b833fc" prot="public" static="no">
        <type>enum <ref refid="group__group__alloc_1ga6552a65b71d16f378c6994b3ceaef50c" kindref="member">VmaDefragmentationFlagBits</ref></type>
        <definition>typedef enum VmaDefragmentationFlagBits VmaDefragmentationFlagBits</definition>
        <argsstring></argsstring>
        <name>VmaDefragmentationFlagBits</name>
        <briefdescription>
<para>Flags to be passed as <ref refid="struct_vma_defragmentation_info_1a3e23080c978ecf3abb3180f5b2069da7" kindref="member">VmaDefragmentationInfo::flags</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="730" column="28"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1ga88a77cef37e5d3c4fc9eb328885d048d" prot="public" static="no">
        <type>VkFlags</type>
        <definition>typedef VkFlags VmaDefragmentationFlags</definition>
        <argsstring></argsstring>
        <name>VmaDefragmentationFlags</name>
        <briefdescription>
<para>See <ref refid="group__group__alloc_1ga6552a65b71d16f378c6994b3ceaef50c" kindref="member">VmaDefragmentationFlagBits</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="732" column="17" bodyfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" bodystart="732" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1ga2ea666deeb3c2c74806a097e27cdb4a1" prot="public" static="no">
        <type>enum <ref refid="group__group__alloc_1gada9e3861caf96f08894b0bcc160ec257" kindref="member">VmaDefragmentationMoveOperation</ref></type>
        <definition>typedef enum VmaDefragmentationMoveOperation VmaDefragmentationMoveOperation</definition>
        <argsstring></argsstring>
        <name>VmaDefragmentationMoveOperation</name>
        <briefdescription>
<para>Operation performed on single defragmentation move. See structure <ref refid="struct_vma_defragmentation_move" kindref="compound">VmaDefragmentationMove</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="743" column="33"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1ga3bf110892ea2fb4649fedb68488d026a" prot="public" static="no">
        <type>struct <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref></type>
        <definition>typedef struct VmaAllocationCreateInfo VmaAllocationCreateInfo</definition>
        <argsstring></argsstring>
        <name>VmaAllocationCreateInfo</name>
        <briefdescription>
<para>Parameters of new <ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>To be used with functions like <ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer()</ref>, <ref refid="group__group__alloc_1gaa76142ae43535c862ad9e194a6e38aaa" kindref="member">vmaCreateImage()</ref>, and many others. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1269" column="25"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1ga1017aa83489c0eee8d2163d2bf253f67" prot="public" static="no">
        <type>struct <ref refid="struct_vma_pool_create_info" kindref="compound">VmaPoolCreateInfo</ref></type>
        <definition>typedef struct VmaPoolCreateInfo VmaPoolCreateInfo</definition>
        <argsstring></argsstring>
        <name>VmaPoolCreateInfo</name>
        <briefdescription>
<para>Describes parameter of created <ref refid="struct_vma_pool" kindref="compound">VmaPool</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1326" column="19"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1ga1cf7774606721026a68aabe3af2e5b50" prot="public" static="no">
        <type>struct <ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref></type>
        <definition>typedef struct VmaAllocationInfo VmaAllocationInfo</definition>
        <argsstring></argsstring>
        <name>VmaAllocationInfo</name>
        <briefdescription>
<para>Parameters of <ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> objects, that can be retrieved using function <ref refid="group__group__alloc_1gab9c96ca6bb55ad9069829fe8355bbb79" kindref="member">vmaGetAllocationInfo()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1393" column="19"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1ga2bf47f96bf92bed2a49461bd9af3acfa" prot="public" static="no">
        <type>struct <ref refid="struct_vma_defragmentation_info" kindref="compound">VmaDefragmentationInfo</ref></type>
        <definition>typedef struct VmaDefragmentationInfo VmaDefragmentationInfo</definition>
        <argsstring></argsstring>
        <name>VmaDefragmentationInfo</name>
        <briefdescription>
<para>Parameters for defragmentation. </para>
        </briefdescription>
        <detaileddescription>
<para>To be used with function <ref refid="group__group__alloc_1ga0cdd7b0b8653745fa95af9e78d919e70" kindref="member">vmaBeginDefragmentation()</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1418" column="24"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1ga563f4b43d3e31ed603d80cacc9ba8589" prot="public" static="no">
        <type>struct <ref refid="struct_vma_defragmentation_move" kindref="compound">VmaDefragmentationMove</ref></type>
        <definition>typedef struct VmaDefragmentationMove VmaDefragmentationMove</definition>
        <argsstring></argsstring>
        <name>VmaDefragmentationMove</name>
        <briefdescription>
<para>Single move of an allocation to be done for defragmentation. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1434" column="24"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1gad6799e8e2b1527abfc84d33bc44aeaf5" prot="public" static="no">
        <type>struct <ref refid="struct_vma_defragmentation_pass_move_info" kindref="compound">VmaDefragmentationPassMoveInfo</ref></type>
        <definition>typedef struct VmaDefragmentationPassMoveInfo VmaDefragmentationPassMoveInfo</definition>
        <argsstring></argsstring>
        <name>VmaDefragmentationPassMoveInfo</name>
        <briefdescription>
<para>Parameters for incremental defragmentation steps. </para>
        </briefdescription>
        <detaileddescription>
<para>To be used with function <ref refid="group__group__alloc_1gacbe4a77fdfa7ea29328d2f940d423ab7" kindref="member">vmaBeginDefragmentationPass()</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1468" column="32"/>
      </memberdef>
      <memberdef kind="typedef" id="group__group__alloc_1gad94034192259c2e34a4d1c5e27810403" prot="public" static="no">
        <type>struct <ref refid="struct_vma_defragmentation_stats" kindref="compound">VmaDefragmentationStats</ref></type>
        <definition>typedef struct VmaDefragmentationStats VmaDefragmentationStats</definition>
        <argsstring></argsstring>
        <name>VmaDefragmentationStats</name>
        <briefdescription>
<para>Statistics returned for defragmentation process in function <ref refid="group__group__alloc_1gae419e366d1c015716165bdfd5aafef6f" kindref="member">vmaEndDefragmentation()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1481" column="25"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__group__alloc_1ga03cee2bfc7fef20382fa56f5870f3b2f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaFindMemoryTypeIndex</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, uint32_t memoryTypeBits, const VmaAllocationCreateInfo *VMA_NOT_NULL pAllocationCreateInfo, uint32_t *VMA_NOT_NULL pMemoryTypeIndex)</argsstring>
        <name>vmaFindMemoryTypeIndex</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>memoryTypeBits</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocationCreateInfo</declname>
        </param>
        <param>
          <type>uint32_t *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pMemoryTypeIndex</declname>
        </param>
        <briefdescription>
<para>Helps to find memoryTypeIndex, given memoryTypeBits and <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>This algorithm tries to find a memory type that:</para>
<para><itemizedlist>
<listitem><para>Is allowed by memoryTypeBits.</para>
</listitem><listitem><para>Contains all the flags from pAllocationCreateInfo-&gt;requiredFlags.</para>
</listitem><listitem><para>Matches intended usage.</para>
</listitem><listitem><para>Has as many flags from pAllocationCreateInfo-&gt;preferredFlags as possible.</para>
</listitem></itemizedlist>
</para>
<para><simplesect kind="return"><para>Returns VK_ERROR_FEATURE_NOT_PRESENT if not found. Receiving such result from this function or any other allocating function probably means that your device doesn&apos;t support any memory type with requested features for the specific type of resource you want to use it for. Please check parameters of your resource, like image layout (OPTIMAL versus LINEAR) or mip level count. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1675" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1675" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga723f5683b363c306bf860dab1861f299" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaFindMemoryTypeIndexForBufferInfo</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, const VkBufferCreateInfo *VMA_NOT_NULL pBufferCreateInfo, const VmaAllocationCreateInfo *VMA_NOT_NULL pAllocationCreateInfo, uint32_t *VMA_NOT_NULL pMemoryTypeIndex)</argsstring>
        <name>vmaFindMemoryTypeIndexForBufferInfo</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>const VkBufferCreateInfo *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pBufferCreateInfo</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocationCreateInfo</declname>
        </param>
        <param>
          <type>uint32_t *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pMemoryTypeIndex</declname>
        </param>
        <briefdescription>
<para>Helps to find memoryTypeIndex, given VkBufferCreateInfo and <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>It can be useful e.g. to determine value to be used as <ref refid="struct_vma_pool_create_info_1a596fa76b685d3f1f688f84a709a5b319" kindref="member">VmaPoolCreateInfo::memoryTypeIndex</ref>. It internally creates a temporary, dummy buffer that never has memory bound. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1687" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1687" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gaaf05345771a087328949b485ff2da4db" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaFindMemoryTypeIndexForImageInfo</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, const VkImageCreateInfo *VMA_NOT_NULL pImageCreateInfo, const VmaAllocationCreateInfo *VMA_NOT_NULL pAllocationCreateInfo, uint32_t *VMA_NOT_NULL pMemoryTypeIndex)</argsstring>
        <name>vmaFindMemoryTypeIndexForImageInfo</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>const VkImageCreateInfo *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pImageCreateInfo</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocationCreateInfo</declname>
        </param>
        <param>
          <type>uint32_t *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pMemoryTypeIndex</declname>
        </param>
        <briefdescription>
<para>Helps to find memoryTypeIndex, given VkImageCreateInfo and <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>It can be useful e.g. to determine value to be used as <ref refid="struct_vma_pool_create_info_1a596fa76b685d3f1f688f84a709a5b319" kindref="member">VmaPoolCreateInfo::memoryTypeIndex</ref>. It internally creates a temporary, dummy image that never has memory bound. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1699" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1699" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga250d4f6f4c09a6a03b82323f999c9c4e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreatePool</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, const VmaPoolCreateInfo *VMA_NOT_NULL pCreateInfo, VmaPool VMA_NULLABLE *VMA_NOT_NULL pPool)</argsstring>
        <name>vmaCreatePool</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_pool_create_info" kindref="compound">VmaPoolCreateInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pCreateInfo</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pPool</declname>
        </param>
        <briefdescription>
<para>Allocates Vulkan device memory and creates <ref refid="struct_vma_pool" kindref="compound">VmaPool</ref> object. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para>Allocator object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pCreateInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Parameters of pool to create. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pPool</parametername>
</parameternamelist>
<parameterdescription>
<para>Handle to created pool. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1711" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1711" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gad03da7fd4d8b772bc2a299bc34850d98" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaDestroyPool</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaPool VMA_NULLABLE pool)</argsstring>
        <name>vmaDestroyPool</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pool</declname>
        </param>
        <briefdescription>
<para>Destroys <ref refid="struct_vma_pool" kindref="compound">VmaPool</ref> object and frees Vulkan device memory. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1718" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1718" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga19e2e174d6acb8abfdeb8c200517a468" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaCheckPoolCorruption</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaPool VMA_NOT_NULL pool)</argsstring>
        <name>vmaCheckPoolCorruption</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pool</declname>
        </param>
        <briefdescription>
<para>Checks magic number in margins around all allocations in given memory pool in search for corruptions. </para>
        </briefdescription>
        <detaileddescription>
<para>Corruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero, `VMA_DEBUG_MARGIN` is defined to nonzero and the pool is created in memory type that is `HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](<ref refid="debugging_memory_usage_1debugging_memory_usage_corruption_detection" kindref="member">Corruption detection</ref>).</para>
<para>Possible return values:</para>
<para><itemizedlist>
<listitem><para>`VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for specified pool.</para>
</listitem><listitem><para>`VK_SUCCESS` - corruption detection has been performed and succeeded.</para>
</listitem><listitem><para>`VK_ERROR_UNKNOWN` - corruption detection has been performed and found memory corruptions around one of the allocations. `VMA_ASSERT` is also fired in that case.</para>
</listitem><listitem><para>Other value: Error returned by Vulkan, e.g. memory mapping failure. </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1772" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1772" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga77b2f609887eabcc36ab90e94230acbf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaGetPoolName</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaPool VMA_NOT_NULL pool, const char *VMA_NULLABLE *VMA_NOT_NULL ppName)</argsstring>
        <name>vmaGetPoolName</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pool</declname>
        </param>
        <param>
          <type>const char *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>ppName</declname>
        </param>
        <briefdescription>
<para>Retrieves name of a custom pool. </para>
        </briefdescription>
        <detaileddescription>
<para>After the call `ppName` is either null or points to an internally-owned null-terminated string containing name of the pool that was previously set. The pointer becomes invalid when the pool is destroyed or its name is changed using <ref refid="group__group__alloc_1gac0322f7ac6c6425492aec787397d5597" kindref="member">vmaSetPoolName()</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1782" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1782" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gac0322f7ac6c6425492aec787397d5597" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaSetPoolName</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaPool VMA_NOT_NULL pool, const char *VMA_NULLABLE pName)</argsstring>
        <name>vmaSetPoolName</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pool</declname>
        </param>
        <param>
          <type>const char *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pName</declname>
        </param>
        <briefdescription>
<para>Sets name of a custom pool. </para>
        </briefdescription>
        <detaileddescription>
<para>`pName` can be either null or pointer to a null-terminated string with new name for the pool. Function makes internal copy of the string, so it can be changed or freed immediately after this call. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1792" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1792" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gaf813f55a0667016a8cd68bb4b8b3b30c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemory</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, const VkMemoryRequirements *VMA_NOT_NULL pVkMemoryRequirements, const VmaAllocationCreateInfo *VMA_NOT_NULL pCreateInfo, VmaAllocation VMA_NULLABLE *VMA_NOT_NULL pAllocation, VmaAllocationInfo *VMA_NULLABLE pAllocationInfo)</argsstring>
        <name>vmaAllocateMemory</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>const VkMemoryRequirements *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pVkMemoryRequirements</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pCreateInfo</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocation</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref> *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pAllocationInfo</declname>
        </param>
        <briefdescription>
<para>General purpose memory allocation. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pVkMemoryRequirements</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pCreateInfo</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pAllocation</parametername>
</parameternamelist>
<parameterdescription>
<para>Handle to allocated memory. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pAllocationInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Optional. Information about allocated memory. It can be later fetched using function <ref refid="group__group__alloc_1gab9c96ca6bb55ad9069829fe8355bbb79" kindref="member">vmaGetAllocationInfo()</ref>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
You should free the memory using <ref refid="group__group__alloc_1ga5c9baca5124d440046bbe508f61d2839" kindref="member">vmaFreeMemory()</ref> or <ref refid="group__group__alloc_1ga033c6727ed2efed0745ec24ce01d5e1b" kindref="member">vmaFreeMemoryPages()</ref>.</para>
<para>It is recommended to use <ref refid="group__group__alloc_1gaf7010aa90a4ccdda56f83db8597b9896" kindref="member">vmaAllocateMemoryForBuffer()</ref>, <ref refid="group__group__alloc_1ga4b7f39281cb383c1496b68f97cb7f4c5" kindref="member">vmaAllocateMemoryForImage()</ref>, <ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer()</ref>, <ref refid="group__group__alloc_1gaa76142ae43535c862ad9e194a6e38aaa" kindref="member">vmaCreateImage()</ref> instead whenever possible. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1810" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1810" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gafe6834626398ff26264a94ab7581e150" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemoryPages</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, const VkMemoryRequirements *VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(allocationCount) pVkMemoryRequirements, const VmaAllocationCreateInfo *VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(allocationCount) pCreateInfo, size_t allocationCount, VmaAllocation VMA_NULLABLE *VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(allocationCount) pAllocations, VmaAllocationInfo *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) pAllocationInfo)</argsstring>
        <name>vmaAllocateMemoryPages</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>const VkMemoryRequirements *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref> <ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)</type>
          <declname>pVkMemoryRequirements</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref> <ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)</type>
          <declname>pCreateInfo</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>allocationCount</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref> <ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)</type>
          <declname>pAllocations</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref> *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> <ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)</type>
          <declname>pAllocationInfo</declname>
        </param>
        <briefdescription>
<para>General purpose memory allocation for multiple allocation objects at once. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para>Allocator object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pVkMemoryRequirements</parametername>
</parameternamelist>
<parameterdescription>
<para>Memory requirements for each allocation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pCreateInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Creation parameters for each allocation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>allocationCount</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of allocations to make. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pAllocations</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to array that will be filled with handles to created allocations. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pAllocationInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Optional. Pointer to array that will be filled with parameters of created allocations.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
You should free the memory using <ref refid="group__group__alloc_1ga5c9baca5124d440046bbe508f61d2839" kindref="member">vmaFreeMemory()</ref> or <ref refid="group__group__alloc_1ga033c6727ed2efed0745ec24ce01d5e1b" kindref="member">vmaFreeMemoryPages()</ref>.</para>
<para>Word &quot;pages&quot; is just a suggestion to use this function to allocate pieces of memory needed for sparse binding. It is just a general purpose allocation function able to make multiple allocations at once. It may be internally optimized to be more efficient than calling <ref refid="group__group__alloc_1gaf813f55a0667016a8cd68bb4b8b3b30c" kindref="member">vmaAllocateMemory()</ref> `allocationCount` times.</para>
<para>All allocations are made using same parameters. All of them are created out of the same memory pool and type. If any allocation fails, all allocations already made within this function call are also freed, so that when returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1836" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1836" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gaf7010aa90a4ccdda56f83db8597b9896" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemoryForBuffer</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VkBuffer VMA_NOT_NULL_NON_DISPATCHABLE buffer, const VmaAllocationCreateInfo *VMA_NOT_NULL pCreateInfo, VmaAllocation VMA_NULLABLE *VMA_NOT_NULL pAllocation, VmaAllocationInfo *VMA_NULLABLE pAllocationInfo)</argsstring>
        <name>vmaAllocateMemoryForBuffer</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>VkBuffer <ref refid="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" kindref="member">VMA_NOT_NULL_NON_DISPATCHABLE</ref></type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pCreateInfo</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocation</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref> *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pAllocationInfo</declname>
        </param>
        <briefdescription>
<para>Allocates memory suitable for given `VkBuffer`. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pCreateInfo</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pAllocation</parametername>
</parameternamelist>
<parameterdescription>
<para>Handle to allocated memory. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pAllocationInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Optional. Information about allocated memory. It can be later fetched using function <ref refid="group__group__alloc_1gab9c96ca6bb55ad9069829fe8355bbb79" kindref="member">vmaGetAllocationInfo()</ref>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
It only creates <ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>. To bind the memory to the buffer, use <ref refid="group__group__alloc_1ga7748e60ccc54e240777a848cb260bb19" kindref="member">vmaBindBufferMemory()</ref>.</para>
<para>This is a special-purpose function. In most cases you should use <ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer()</ref>.</para>
<para>You must free the allocation using <ref refid="group__group__alloc_1ga5c9baca5124d440046bbe508f61d2839" kindref="member">vmaFreeMemory()</ref> when no longer needed. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1858" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1858" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga4b7f39281cb383c1496b68f97cb7f4c5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaAllocateMemoryForImage</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VkImage VMA_NOT_NULL_NON_DISPATCHABLE image, const VmaAllocationCreateInfo *VMA_NOT_NULL pCreateInfo, VmaAllocation VMA_NULLABLE *VMA_NOT_NULL pAllocation, VmaAllocationInfo *VMA_NULLABLE pAllocationInfo)</argsstring>
        <name>vmaAllocateMemoryForImage</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>VkImage <ref refid="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" kindref="member">VMA_NOT_NULL_NON_DISPATCHABLE</ref></type>
          <declname>image</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pCreateInfo</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocation</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref> *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pAllocationInfo</declname>
        </param>
        <briefdescription>
<para>Allocates memory suitable for given `VkImage`. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>image</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pCreateInfo</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pAllocation</parametername>
</parameternamelist>
<parameterdescription>
<para>Handle to allocated memory. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pAllocationInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Optional. Information about allocated memory. It can be later fetched using function <ref refid="group__group__alloc_1gab9c96ca6bb55ad9069829fe8355bbb79" kindref="member">vmaGetAllocationInfo()</ref>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
It only creates <ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref>. To bind the memory to the buffer, use <ref refid="group__group__alloc_1ga3a5d8d9f2a29b42cf87f0f8dfef591f4" kindref="member">vmaBindImageMemory()</ref>.</para>
<para>This is a special-purpose function. In most cases you should use <ref refid="group__group__alloc_1gaa76142ae43535c862ad9e194a6e38aaa" kindref="member">vmaCreateImage()</ref>.</para>
<para>You must free the allocation using <ref refid="group__group__alloc_1ga5c9baca5124d440046bbe508f61d2839" kindref="member">vmaFreeMemory()</ref> when no longer needed. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1879" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1879" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga5c9baca5124d440046bbe508f61d2839" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaFreeMemory</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, const VmaAllocation VMA_NULLABLE allocation)</argsstring>
        <name>vmaFreeMemory</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>allocation</declname>
        </param>
        <briefdescription>
<para>Frees memory previously allocated using <ref refid="group__group__alloc_1gaf813f55a0667016a8cd68bb4b8b3b30c" kindref="member">vmaAllocateMemory()</ref>, <ref refid="group__group__alloc_1gaf7010aa90a4ccdda56f83db8597b9896" kindref="member">vmaAllocateMemoryForBuffer()</ref>, or <ref refid="group__group__alloc_1ga4b7f39281cb383c1496b68f97cb7f4c5" kindref="member">vmaAllocateMemoryForImage()</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>Passing `VK_NULL_HANDLE` as `allocation` is valid. Such function call is just skipped. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1890" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1890" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga033c6727ed2efed0745ec24ce01d5e1b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaFreeMemoryPages</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, size_t allocationCount, const VmaAllocation VMA_NULLABLE *VMA_NOT_NULL VMA_LEN_IF_NOT_NULL(allocationCount) pAllocations)</argsstring>
        <name>vmaFreeMemoryPages</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>allocationCount</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref> <ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)</type>
          <declname>pAllocations</declname>
        </param>
        <briefdescription>
<para>Frees memory and destroys multiple allocations. </para>
        </briefdescription>
        <detaileddescription>
<para>Word &quot;pages&quot; is just a suggestion to use this function to free pieces of memory used for sparse binding. It is just a general purpose function to free memory and destroy allocations made using e.g. <ref refid="group__group__alloc_1gaf813f55a0667016a8cd68bb4b8b3b30c" kindref="member">vmaAllocateMemory()</ref>, <ref refid="group__group__alloc_1gafe6834626398ff26264a94ab7581e150" kindref="member">vmaAllocateMemoryPages()</ref> and other functions. It may be internally optimized to be more efficient than calling <ref refid="group__group__alloc_1ga5c9baca5124d440046bbe508f61d2839" kindref="member">vmaFreeMemory()</ref> `allocationCount` times.</para>
<para>Allocations in `pAllocations` array can come from any memory pools and types. Passing `VK_NULL_HANDLE` as elements of `pAllocations` array is valid. Such entries are just skipped. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1904" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1904" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gab9c96ca6bb55ad9069829fe8355bbb79" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaGetAllocationInfo</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VmaAllocationInfo *VMA_NOT_NULL pAllocationInfo)</argsstring>
        <name>vmaGetAllocationInfo</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocationInfo</declname>
        </param>
        <briefdescription>
<para>Returns current information about specified allocation. </para>
        </briefdescription>
        <detaileddescription>
<para>Current paramteres of given allocation are returned in `pAllocationInfo`.</para>
<para>Although this function doesn&apos;t lock any mutex, so it should be quite efficient, you should avoid calling it too often. You can retrieve same <ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref> structure while creating your resource, from function <ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer()</ref>, <ref refid="group__group__alloc_1gaa76142ae43535c862ad9e194a6e38aaa" kindref="member">vmaCreateImage()</ref>. You can remember it if you are sure parameters don&apos;t change (e.g. due to defragmentation). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1919" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1919" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gac1f392a3c70a647f0c53a9ddaa7a6f14" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaSetAllocationUserData</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, void *VMA_NULLABLE pUserData)</argsstring>
        <name>vmaSetAllocationUserData</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type>void *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pUserData</declname>
        </param>
        <briefdescription>
<para>Sets pUserData in given allocation to new value. </para>
        </briefdescription>
        <detaileddescription>
<para>The value of pointer `pUserData` is copied to allocation&apos;s `pUserData`. It is opaque, so you can use it however you want - e.g. as a pointer, ordinal number or some handle to you own data. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1930" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1930" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga29b210b1f39e49de844fc7b6944736d7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaSetAllocationName</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, const char *VMA_NULLABLE pName)</argsstring>
        <name>vmaSetAllocationName</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type>const char *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pName</declname>
        </param>
        <briefdescription>
<para>Sets pName in given allocation to new value. </para>
        </briefdescription>
        <detaileddescription>
<para>`pName` must be either null, or pointer to a null-terminated string. The function makes local copy of the string and sets it as allocation&apos;s `pName`. String passed as pName doesn&apos;t need to be valid for whole lifetime of the allocation - you can free it after this call. String previously pointed by allocation&apos;s `pName` is freed from memory. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1943" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1943" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gaf6785483eda8b53561437e05e2177d7b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaGetAllocationMemoryProperties</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VkMemoryPropertyFlags *VMA_NOT_NULL pFlags)</argsstring>
        <name>vmaGetAllocationMemoryProperties</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type>VkMemoryPropertyFlags *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pFlags</declname>
        </param>
        <briefdescription>
<para>Given an allocation, returns Property Flags of its memory type. </para>
        </briefdescription>
        <detaileddescription>
<para>This is just a convenience function. Same information can be obtained using <ref refid="group__group__alloc_1gab9c96ca6bb55ad9069829fe8355bbb79" kindref="member">vmaGetAllocationInfo()</ref> + <ref refid="group__group__init_1ga33698c6107c0da349c1dbf43615284df" kindref="member">vmaGetMemoryProperties()</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1954" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1954" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga13b93ec0ed38ad7232300cb94931c8d2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaMapMemory</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, void *VMA_NULLABLE *VMA_NOT_NULL ppData)</argsstring>
        <name>vmaMapMemory</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type>void *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>ppData</declname>
        </param>
        <briefdescription>
<para>Maps memory represented by given allocation and returns pointer to it. </para>
        </briefdescription>
        <detaileddescription>
<para>Maps memory represented by given allocation to make it accessible to CPU code. When succeeded, `*ppData` contains pointer to first byte of this memory.</para>
<para><simplesect kind="warning"><para>If the allocation is part of a bigger `VkDeviceMemory` block, returned pointer is correctly offsetted to the beginning of region assigned to this particular allocation. Unlike the result of `vkMapMemory`, it points to the allocation, not to the beginning of the whole block. You should not add <ref refid="struct_vma_allocation_info_1a4a3c732388dbdc7a23f9365b00825268" kindref="member">VmaAllocationInfo::offset</ref> to it!</para>
</simplesect>
Mapping is internally reference-counted and synchronized, so despite raw Vulkan function `vkMapMemory()` cannot be used to map same block of `VkDeviceMemory` multiple times simultaneously, it is safe to call this function on allocations assigned to the same memory block. Actual Vulkan memory will be mapped on first mapping and unmapped on last unmapping.</para>
<para>If the function succeeded, you must call <ref refid="group__group__alloc_1gaec4645c1787976e2b50d2dfd31279a2b" kindref="member">vmaUnmapMemory()</ref> to unmap the allocation when mapping is no longer needed or before freeing the allocation, at the latest.</para>
<para>It also safe to call this function multiple times on the same allocation. You must call <ref refid="group__group__alloc_1gaec4645c1787976e2b50d2dfd31279a2b" kindref="member">vmaUnmapMemory()</ref> same number of times as you called <ref refid="group__group__alloc_1ga13b93ec0ed38ad7232300cb94931c8d2" kindref="member">vmaMapMemory()</ref>.</para>
<para>It is also safe to call this function on allocation created with <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" kindref="member">VMA_ALLOCATION_CREATE_MAPPED_BIT</ref> flag. Its memory stays mapped all the time. You must still call <ref refid="group__group__alloc_1gaec4645c1787976e2b50d2dfd31279a2b" kindref="member">vmaUnmapMemory()</ref> same number of times as you called <ref refid="group__group__alloc_1ga13b93ec0ed38ad7232300cb94931c8d2" kindref="member">vmaMapMemory()</ref>. You must not call <ref refid="group__group__alloc_1gaec4645c1787976e2b50d2dfd31279a2b" kindref="member">vmaUnmapMemory()</ref> additional time to free the &quot;0-th&quot; mapping made automatically due to <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a11da372cc3a82931c5e5d6146cd9dd1f" kindref="member">VMA_ALLOCATION_CREATE_MAPPED_BIT</ref> flag.</para>
<para>This function fails when used on allocation made in memory type that is not `HOST_VISIBLE`.</para>
<para>This function doesn&apos;t automatically flush or invalidate caches. If the allocation is made from a memory types that is not `HOST_COHERENT`, you also need to use <ref refid="group__group__alloc_1ga1059764930e85ac377a92b5237b5b919" kindref="member">vmaInvalidateAllocation()</ref> / <ref refid="group__group__alloc_1gab8093faf3afb114596d964d4bd24cb4a" kindref="member">vmaFlushAllocation()</ref>, as required by Vulkan specification. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="1996" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="1996" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gaec4645c1787976e2b50d2dfd31279a2b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaUnmapMemory</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation)</argsstring>
        <name>vmaUnmapMemory</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <briefdescription>
<para>Unmaps memory represented by given allocation, mapped previously using <ref refid="group__group__alloc_1ga13b93ec0ed38ad7232300cb94931c8d2" kindref="member">vmaMapMemory()</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>For details, see description of <ref refid="group__group__alloc_1ga13b93ec0ed38ad7232300cb94931c8d2" kindref="member">vmaMapMemory()</ref>.</para>
<para>This function doesn&apos;t automatically flush or invalidate caches. If the allocation is made from a memory types that is not `HOST_COHERENT`, you also need to use <ref refid="group__group__alloc_1ga1059764930e85ac377a92b5237b5b919" kindref="member">vmaInvalidateAllocation()</ref> / <ref refid="group__group__alloc_1gab8093faf3afb114596d964d4bd24cb4a" kindref="member">vmaFlushAllocation()</ref>, as required by Vulkan specification. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2009" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2009" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gab8093faf3afb114596d964d4bd24cb4a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaFlushAllocation</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VkDeviceSize offset, VkDeviceSize size)</argsstring>
        <name>vmaFlushAllocation</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type>VkDeviceSize</type>
          <declname>offset</declname>
        </param>
        <param>
          <type>VkDeviceSize</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Flushes memory of given allocation. </para>
        </briefdescription>
        <detaileddescription>
<para>Calls `vkFlushMappedMemoryRanges()` for memory associated with given range of given allocation. It needs to be called after writing to a mapped memory for memory types that are not `HOST_COHERENT`. Unmap operation doesn&apos;t do that automatically.</para>
<para><itemizedlist>
<listitem><para>`offset` must be relative to the beginning of allocation.</para>
</listitem><listitem><para>`size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation.</para>
</listitem><listitem><para>`offset` and `size` don&apos;t have to be aligned. They are internally rounded down/up to multiply of `nonCoherentAtomSize`.</para>
</listitem><listitem><para>If `size` is 0, this call is ignored.</para>
</listitem><listitem><para>If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`, this call is ignored.</para>
</listitem></itemizedlist>
</para>
<para>Warning! `offset` and `size` are relative to the contents of given `allocation`. If you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively. Do not pass allocation&apos;s offset as `offset`!!!</para>
<para>This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is called, otherwise `VK_SUCCESS`. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2034" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2034" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga1059764930e85ac377a92b5237b5b919" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaInvalidateAllocation</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VkDeviceSize offset, VkDeviceSize size)</argsstring>
        <name>vmaInvalidateAllocation</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type>VkDeviceSize</type>
          <declname>offset</declname>
        </param>
        <param>
          <type>VkDeviceSize</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Invalidates memory of given allocation. </para>
        </briefdescription>
        <detaileddescription>
<para>Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given range of given allocation. It needs to be called before reading from a mapped memory for memory types that are not `HOST_COHERENT`. Map operation doesn&apos;t do that automatically.</para>
<para><itemizedlist>
<listitem><para>`offset` must be relative to the beginning of allocation.</para>
</listitem><listitem><para>`size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation.</para>
</listitem><listitem><para>`offset` and `size` don&apos;t have to be aligned. They are internally rounded down/up to multiply of `nonCoherentAtomSize`.</para>
</listitem><listitem><para>If `size` is 0, this call is ignored.</para>
</listitem><listitem><para>If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`, this call is ignored.</para>
</listitem></itemizedlist>
</para>
<para>Warning! `offset` and `size` are relative to the contents of given `allocation`. If you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively. Do not pass allocation&apos;s offset as `offset`!!!</para>
<para>This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is called, otherwise `VK_SUCCESS`. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2061" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2061" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga09b0a57c5c45949a324ac7c0a4ec42d5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaFlushAllocations</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, uint32_t allocationCount, const VmaAllocation VMA_NOT_NULL *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) allocations, const VkDeviceSize *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) offsets, const VkDeviceSize *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) sizes)</argsstring>
        <name>vmaFlushAllocations</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>allocationCount</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref> *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> <ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)</type>
          <declname>allocations</declname>
        </param>
        <param>
          <type>const VkDeviceSize *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> <ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)</type>
          <declname>offsets</declname>
        </param>
        <param>
          <type>const VkDeviceSize *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> <ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)</type>
          <declname>sizes</declname>
        </param>
        <briefdescription>
<para>Flushes memory of given set of allocations. </para>
        </briefdescription>
        <detaileddescription>
<para>Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations. For more information, see documentation of <ref refid="group__group__alloc_1gab8093faf3afb114596d964d4bd24cb4a" kindref="member">vmaFlushAllocation()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>allocationCount</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>allocations</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offsets</parametername>
</parameternamelist>
<parameterdescription>
<para>If not null, it must point to an array of offsets of regions to flush, relative to the beginning of respective allocations. Null means all ofsets are zero. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sizes</parametername>
</parameternamelist>
<parameterdescription>
<para>If not null, it must point to an array of sizes of regions to flush in respective allocations. Null means `VK_WHOLE_SIZE` for all allocations.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is called, otherwise `VK_SUCCESS`. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2081" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2081" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga693a1ae5faed72fac89f12685e1d366f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaInvalidateAllocations</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, uint32_t allocationCount, const VmaAllocation VMA_NOT_NULL *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) allocations, const VkDeviceSize *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) offsets, const VkDeviceSize *VMA_NULLABLE VMA_LEN_IF_NOT_NULL(allocationCount) sizes)</argsstring>
        <name>vmaInvalidateAllocations</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>allocationCount</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref> *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> <ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)</type>
          <declname>allocations</declname>
        </param>
        <param>
          <type>const VkDeviceSize *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> <ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)</type>
          <declname>offsets</declname>
        </param>
        <param>
          <type>const VkDeviceSize *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> <ref refid="vk__mem__alloc_8h_1a46eb2044bea3404c06b76c961a126e6a" kindref="member">VMA_LEN_IF_NOT_NULL</ref>(allocationCount)</type>
          <declname>sizes</declname>
        </param>
        <briefdescription>
<para>Invalidates memory of given set of allocations. </para>
        </briefdescription>
        <detaileddescription>
<para>Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations. For more information, see documentation of <ref refid="group__group__alloc_1ga1059764930e85ac377a92b5237b5b919" kindref="member">vmaInvalidateAllocation()</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>allocationCount</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>allocations</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>offsets</parametername>
</parameternamelist>
<parameterdescription>
<para>If not null, it must point to an array of offsets of regions to flush, relative to the beginning of respective allocations. Null means all ofsets are zero. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sizes</parametername>
</parameternamelist>
<parameterdescription>
<para>If not null, it must point to an array of sizes of regions to flush in respective allocations. Null means `VK_WHOLE_SIZE` for all allocations.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is called, otherwise `VK_SUCCESS`. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2102" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2102" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga0baa58dd12991e7b0fe42dcdf22bb100" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaCheckCorruption</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, uint32_t memoryTypeBits)</argsstring>
        <name>vmaCheckCorruption</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>memoryTypeBits</declname>
        </param>
        <briefdescription>
<para>Checks magic number in margins around all allocations in given memory types (in both default and custom pools) in search for corruptions. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>memoryTypeBits</parametername>
</parameternamelist>
<parameterdescription>
<para>Bit mask, where each bit set means that a memory type with that index should be checked.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Corruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero, `VMA_DEBUG_MARGIN` is defined to nonzero and only for memory types that are `HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](<ref refid="debugging_memory_usage_1debugging_memory_usage_corruption_detection" kindref="member">Corruption detection</ref>).</para>
<para>Possible return values:</para>
<para><itemizedlist>
<listitem><para>`VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for any of specified memory types.</para>
</listitem><listitem><para>`VK_SUCCESS` - corruption detection has been performed and succeeded.</para>
</listitem><listitem><para>`VK_ERROR_UNKNOWN` - corruption detection has been performed and found memory corruptions around one of the allocations. `VMA_ASSERT` is also fired in that case.</para>
</listitem><listitem><para>Other value: Error returned by Vulkan, e.g. memory mapping failure. </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2126" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2126" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga0cdd7b0b8653745fa95af9e78d919e70" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaBeginDefragmentation</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, const VmaDefragmentationInfo *VMA_NOT_NULL pInfo, VmaDefragmentationContext VMA_NULLABLE *VMA_NOT_NULL pContext)</argsstring>
        <name>vmaBeginDefragmentation</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_defragmentation_info" kindref="compound">VmaDefragmentationInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pInfo</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_defragmentation_context" kindref="compound">VmaDefragmentationContext</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pContext</declname>
        </param>
        <briefdescription>
<para>Begins defragmentation process. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para>Allocator object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Structure filled with parameters of defragmentation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pContext</parametername>
</parameternamelist>
<parameterdescription>
<para>Context object that must be passed to <ref refid="group__group__alloc_1gae419e366d1c015716165bdfd5aafef6f" kindref="member">vmaEndDefragmentation()</ref> to finish defragmentation. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><itemizedlist>
<listitem><para>`VK_SUCCESS` if defragmentation can begin.</para>
</listitem><listitem><para>`VK_ERROR_FEATURE_NOT_PRESENT` if defragmentation is not supported.</para>
</listitem></itemizedlist>
</para>
</simplesect>
For more information about defragmentation, see documentation chapter: [Defragmentation](<ref refid="defragmentation" kindref="compound">Defragmentation</ref>). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2142" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2142" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gae419e366d1c015716165bdfd5aafef6f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaEndDefragmentation</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaDefragmentationContext VMA_NOT_NULL context, VmaDefragmentationStats *VMA_NULLABLE pStats)</argsstring>
        <name>vmaEndDefragmentation</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_defragmentation_context" kindref="compound">VmaDefragmentationContext</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>context</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_defragmentation_stats" kindref="compound">VmaDefragmentationStats</ref> *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pStats</declname>
        </param>
        <briefdescription>
<para>Ends defragmentation process. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para>Allocator object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>context</parametername>
</parameternamelist>
<parameterdescription>
<para>Context object that has been created by <ref refid="group__group__alloc_1ga0cdd7b0b8653745fa95af9e78d919e70" kindref="member">vmaBeginDefragmentation()</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pStats</parametername>
</parameternamelist>
<parameterdescription>
<para>Optional stats for the defragmentation. Can be null.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Use this function to finish defragmentation started by <ref refid="group__group__alloc_1ga0cdd7b0b8653745fa95af9e78d919e70" kindref="member">vmaBeginDefragmentation()</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2155" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2155" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gacbe4a77fdfa7ea29328d2f940d423ab7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaBeginDefragmentationPass</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaDefragmentationContext VMA_NOT_NULL context, VmaDefragmentationPassMoveInfo *VMA_NOT_NULL pPassInfo)</argsstring>
        <name>vmaBeginDefragmentationPass</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_defragmentation_context" kindref="compound">VmaDefragmentationContext</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>context</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_defragmentation_pass_move_info" kindref="compound">VmaDefragmentationPassMoveInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pPassInfo</declname>
        </param>
        <briefdescription>
<para>Starts single defragmentation pass. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para>Allocator object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>context</parametername>
</parameternamelist>
<parameterdescription>
<para>Context object that has been created by <ref refid="group__group__alloc_1ga0cdd7b0b8653745fa95af9e78d919e70" kindref="member">vmaBeginDefragmentation()</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pPassInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Computed informations for current pass. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><itemizedlist>
<listitem><para>`VK_SUCCESS` if no more moves are possible. Then you can omit call to <ref refid="group__group__alloc_1gabbc69db60f82972ddffaceb6653e344a" kindref="member">vmaEndDefragmentationPass()</ref> and simply end whole defragmentation.</para>
</listitem><listitem><para>`VK_INCOMPLETE` if there are pending moves returned in `pPassInfo`. You need to perform them, call <ref refid="group__group__alloc_1gabbc69db60f82972ddffaceb6653e344a" kindref="member">vmaEndDefragmentationPass()</ref>, and then preferably try another pass with <ref refid="group__group__alloc_1gacbe4a77fdfa7ea29328d2f940d423ab7" kindref="member">vmaBeginDefragmentationPass()</ref>. </para>
</listitem></itemizedlist>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2170" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2170" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gabbc69db60f82972ddffaceb6653e344a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaEndDefragmentationPass</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaDefragmentationContext VMA_NOT_NULL context, VmaDefragmentationPassMoveInfo *VMA_NOT_NULL pPassInfo)</argsstring>
        <name>vmaEndDefragmentationPass</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_defragmentation_context" kindref="compound">VmaDefragmentationContext</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>context</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_defragmentation_pass_move_info" kindref="compound">VmaDefragmentationPassMoveInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pPassInfo</declname>
        </param>
        <briefdescription>
<para>Ends single defragmentation pass. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para>Allocator object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>context</parametername>
</parameternamelist>
<parameterdescription>
<para>Context object that has been created by <ref refid="group__group__alloc_1ga0cdd7b0b8653745fa95af9e78d919e70" kindref="member">vmaBeginDefragmentation()</ref>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pPassInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Computed informations for current pass filled by <ref refid="group__group__alloc_1gacbe4a77fdfa7ea29328d2f940d423ab7" kindref="member">vmaBeginDefragmentationPass()</ref> and possibly modified by you.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Returns `VK_SUCCESS` if no more moves are possible or `VK_INCOMPLETE` if more defragmentations are possible.</para>
<para>Ends incremental defragmentation pass and commits all defragmentation moves from `pPassInfo`. After this call:</para>
<para><itemizedlist>
<listitem><para>Allocations at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==` <ref refid="group__group__alloc_1ggada9e3861caf96f08894b0bcc160ec257ad4a06ac46c4cb1c67b0ebc1edfab9f18" kindref="member">VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY</ref> (which is the default) will be pointing to the new destination place.</para>
</listitem><listitem><para>Allocation at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==` <ref refid="group__group__alloc_1ggada9e3861caf96f08894b0bcc160ec257a9786f8492a9be2c03bd26395e352ab85" kindref="member">VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY</ref> will be freed.</para>
</listitem></itemizedlist>
</para>
<para>If no more moves are possible you can end whole defragmentation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2193" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2193" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga7748e60ccc54e240777a848cb260bb19" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindBufferMemory</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VkBuffer VMA_NOT_NULL_NON_DISPATCHABLE buffer)</argsstring>
        <name>vmaBindBufferMemory</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type>VkBuffer <ref refid="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" kindref="member">VMA_NOT_NULL_NON_DISPATCHABLE</ref></type>
          <declname>buffer</declname>
        </param>
        <briefdescription>
<para>Binds buffer to allocation. </para>
        </briefdescription>
        <detaileddescription>
<para>Binds specified buffer to region of memory represented by specified allocation. Gets `VkDeviceMemory` handle and offset from the allocation. If you want to create a buffer, allocate memory for it and bind them together separately, you should use this function for binding instead of standard `vkBindBufferMemory()`, because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won&apos;t happen from multiple threads simultaneously (which is illegal in Vulkan).</para>
<para>It is recommended to use function <ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer()</ref> instead of this one. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2210" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2210" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga4a71c30e3474a835bdd7fd0507740be7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindBufferMemory2</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VkDeviceSize allocationLocalOffset, VkBuffer VMA_NOT_NULL_NON_DISPATCHABLE buffer, const void *VMA_NULLABLE pNext)</argsstring>
        <name>vmaBindBufferMemory2</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type>VkDeviceSize</type>
          <declname>allocationLocalOffset</declname>
        </param>
        <param>
          <type>VkBuffer <ref refid="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" kindref="member">VMA_NOT_NULL_NON_DISPATCHABLE</ref></type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>const void *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pNext</declname>
        </param>
        <briefdescription>
<para>Binds buffer to allocation with additional parameters. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>allocation</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>allocationLocalOffset</parametername>
</parameternamelist>
<parameterdescription>
<para>Additional offset to be added while binding, relative to the beginning of the `allocation`. Normally it should be 0. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pNext</parametername>
</parameternamelist>
<parameterdescription>
<para>A chain of structures to be attached to `VkBindBufferMemoryInfoKHR` structure used internally. Normally it should be null.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This function is similar to <ref refid="group__group__alloc_1ga7748e60ccc54e240777a848cb260bb19" kindref="member">vmaBindBufferMemory()</ref>, but it provides additional parameters.</para>
<para>If `pNext` is not null, <ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> object must have been created with <ref refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7ca8fb75bf07cd184ab903596295e863dee" kindref="member">VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</ref> flag or with <ref refid="struct_vma_allocator_create_info_1ae0ffc55139b54520a6bb704b29ffc285" kindref="member">VmaAllocatorCreateInfo::vulkanApiVersion</ref> `&gt;= VK_API_VERSION_1_1`. Otherwise the call fails. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2228" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2228" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga3a5d8d9f2a29b42cf87f0f8dfef591f4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindImageMemory</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VkImage VMA_NOT_NULL_NON_DISPATCHABLE image)</argsstring>
        <name>vmaBindImageMemory</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type>VkImage <ref refid="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" kindref="member">VMA_NOT_NULL_NON_DISPATCHABLE</ref></type>
          <declname>image</declname>
        </param>
        <briefdescription>
<para>Binds image to allocation. </para>
        </briefdescription>
        <detaileddescription>
<para>Binds specified image to region of memory represented by specified allocation. Gets `VkDeviceMemory` handle and offset from the allocation. If you want to create an image, allocate memory for it and bind them together separately, you should use this function for binding instead of standard `vkBindImageMemory()`, because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won&apos;t happen from multiple threads simultaneously (which is illegal in Vulkan).</para>
<para>It is recommended to use function <ref refid="group__group__alloc_1gaa76142ae43535c862ad9e194a6e38aaa" kindref="member">vmaCreateImage()</ref> instead of this one. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2247" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2247" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga0216b9225b02a66ac610cb45d4729d00" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaBindImageMemory2</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, VkDeviceSize allocationLocalOffset, VkImage VMA_NOT_NULL_NON_DISPATCHABLE image, const void *VMA_NULLABLE pNext)</argsstring>
        <name>vmaBindImageMemory2</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type>VkDeviceSize</type>
          <declname>allocationLocalOffset</declname>
        </param>
        <param>
          <type>VkImage <ref refid="vk__mem__alloc_8h_1af10160f1e2fdeb1e5445ee48f61fd2f2" kindref="member">VMA_NOT_NULL_NON_DISPATCHABLE</ref></type>
          <declname>image</declname>
        </param>
        <param>
          <type>const void *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pNext</declname>
        </param>
        <briefdescription>
<para>Binds image to allocation with additional parameters. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>allocation</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>allocationLocalOffset</parametername>
</parameternamelist>
<parameterdescription>
<para>Additional offset to be added while binding, relative to the beginning of the `allocation`. Normally it should be 0. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>image</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pNext</parametername>
</parameternamelist>
<parameterdescription>
<para>A chain of structures to be attached to `VkBindImageMemoryInfoKHR` structure used internally. Normally it should be null.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This function is similar to <ref refid="group__group__alloc_1ga3a5d8d9f2a29b42cf87f0f8dfef591f4" kindref="member">vmaBindImageMemory()</ref>, but it provides additional parameters.</para>
<para>If `pNext` is not null, <ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> object must have been created with <ref refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7ca8fb75bf07cd184ab903596295e863dee" kindref="member">VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</ref> flag or with <ref refid="struct_vma_allocator_create_info_1ae0ffc55139b54520a6bb704b29ffc285" kindref="member">VmaAllocatorCreateInfo::vulkanApiVersion</ref> `&gt;= VK_API_VERSION_1_1`. Otherwise the call fails. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2265" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2265" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateBuffer</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, const VkBufferCreateInfo *VMA_NOT_NULL pBufferCreateInfo, const VmaAllocationCreateInfo *VMA_NOT_NULL pAllocationCreateInfo, VkBuffer VMA_NULLABLE_NON_DISPATCHABLE *VMA_NOT_NULL pBuffer, VmaAllocation VMA_NULLABLE *VMA_NOT_NULL pAllocation, VmaAllocationInfo *VMA_NULLABLE pAllocationInfo)</argsstring>
        <name>vmaCreateBuffer</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>const VkBufferCreateInfo *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pBufferCreateInfo</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocationCreateInfo</declname>
        </param>
        <param>
          <type>VkBuffer <ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pBuffer</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocation</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref> *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pAllocationInfo</declname>
        </param>
        <briefdescription>
<para>Creates a new `VkBuffer`, allocates and binds memory for it. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pBufferCreateInfo</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pAllocationCreateInfo</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pBuffer</parametername>
</parameternamelist>
<parameterdescription>
<para>Buffer that was created. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pAllocation</parametername>
</parameternamelist>
<parameterdescription>
<para>Allocation that was created. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pAllocationInfo</parametername>
</parameternamelist>
<parameterdescription>
<para>Optional. Information about allocated memory. It can be later fetched using function <ref refid="group__group__alloc_1gab9c96ca6bb55ad9069829fe8355bbb79" kindref="member">vmaGetAllocationInfo()</ref>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This function automatically:</para>
<para><orderedlist>
<listitem><para>Creates buffer.</para>
</listitem><listitem><para>Allocates appropriate memory for it.</para>
</listitem><listitem><para>Binds the buffer with the memory.</para>
</listitem></orderedlist>
</para>
<para>If any of these operations fail, buffer and allocation are not created, returned value is negative error code, `*pBuffer` and `*pAllocation` are null.</para>
<para>If the function succeeded, you must destroy both buffer and allocation when you no longer need them using either convenience function <ref refid="group__group__alloc_1gafcc45e5a6388ab35daa9a46688baee20" kindref="member">vmaDestroyBuffer()</ref> or separately, using `vkDestroyBuffer()` and <ref refid="group__group__alloc_1ga5c9baca5124d440046bbe508f61d2839" kindref="member">vmaFreeMemory()</ref>.</para>
<para>If <ref refid="group__group__init_1gga4f87c9100d154a65a4ad495f7763cf7cace7da7cc6e71a625dfa763c55a597878" kindref="member">VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT</ref> flag was used, VK_KHR_dedicated_allocation extension is used internally to query driver whether it requires or prefers the new buffer to have dedicated allocation. If yes, and if dedicated allocation is possible (<ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a89759603401014eb325eb22a3839f2ff" kindref="member">VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</ref> is not used), it creates dedicated allocation for this buffer, just like when using <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" kindref="member">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</ref>.</para>
<para><simplesect kind="note"><para>This function creates a new `VkBuffer`. Sub-allocation of parts of one large buffer, although recommended as a good practice, is out of scope of this library and could be implemented by the user as a higher-level logic on top of VMA. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2306" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2306" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga0a4d6890fe94cf4d234ca1d78af91229" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateBufferWithAlignment</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, const VkBufferCreateInfo *VMA_NOT_NULL pBufferCreateInfo, const VmaAllocationCreateInfo *VMA_NOT_NULL pAllocationCreateInfo, VkDeviceSize minAlignment, VkBuffer VMA_NULLABLE_NON_DISPATCHABLE *VMA_NOT_NULL pBuffer, VmaAllocation VMA_NULLABLE *VMA_NOT_NULL pAllocation, VmaAllocationInfo *VMA_NULLABLE pAllocationInfo)</argsstring>
        <name>vmaCreateBufferWithAlignment</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>const VkBufferCreateInfo *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pBufferCreateInfo</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocationCreateInfo</declname>
        </param>
        <param>
          <type>VkDeviceSize</type>
          <declname>minAlignment</declname>
        </param>
        <param>
          <type>VkBuffer <ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pBuffer</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocation</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref> *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pAllocationInfo</declname>
        </param>
        <briefdescription>
<para>Creates a buffer with additional minimum alignment. </para>
        </briefdescription>
        <detaileddescription>
<para>Similar to <ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer()</ref> but provides additional parameter `minAlignment` which allows to specify custom, minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g. for interop with OpenGL. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2320" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2320" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga41a76d0f9f98a001900a889f55973536" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateAliasingBuffer</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, const VkBufferCreateInfo *VMA_NOT_NULL pBufferCreateInfo, VkBuffer VMA_NULLABLE_NON_DISPATCHABLE *VMA_NOT_NULL pBuffer)</argsstring>
        <name>vmaCreateAliasingBuffer</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type>const VkBufferCreateInfo *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pBufferCreateInfo</declname>
        </param>
        <param>
          <type>VkBuffer <ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pBuffer</declname>
        </param>
        <briefdescription>
<para>Creates a new `VkBuffer`, binds already created memory for it. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>allocator</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>allocation</parametername>
</parameternamelist>
<parameterdescription>
<para>Allocation that provides memory to be used for binding new buffer to it. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pBufferCreateInfo</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">pBuffer</parametername>
</parameternamelist>
<parameterdescription>
<para>Buffer that was created.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This function automatically:</para>
<para><orderedlist>
<listitem><para>Creates buffer.</para>
</listitem><listitem><para>Binds the buffer with the supplied memory.</para>
</listitem></orderedlist>
</para>
<para>If any of these operations fail, buffer is not created, returned value is negative error code and `*pBuffer` is null.</para>
<para>If the function succeeded, you must destroy the buffer when you no longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding allocation you can use convenience function <ref refid="group__group__alloc_1gafcc45e5a6388ab35daa9a46688baee20" kindref="member">vmaDestroyBuffer()</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2348" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2348" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gafcc45e5a6388ab35daa9a46688baee20" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaDestroyBuffer</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VkBuffer VMA_NULLABLE_NON_DISPATCHABLE buffer, VmaAllocation VMA_NULLABLE allocation)</argsstring>
        <name>vmaDestroyBuffer</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>VkBuffer <ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref></type>
          <declname>buffer</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>allocation</declname>
        </param>
        <briefdescription>
<para>Destroys Vulkan buffer and frees allocated memory. </para>
        </briefdescription>
        <detaileddescription>
<para>This is just a convenience function equivalent to:</para>
<para><programlisting><codeline><highlight class="normal">vkDestroyBuffer(device,<sp/>buffer,<sp/>allocationCallbacks);</highlight></codeline>
<codeline><highlight class="normal">vmaFreeMemory(allocator,<sp/>allocation);</highlight></codeline>
</programlisting></para>
<para>It it safe to pass null as buffer and/or allocation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2365" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2365" declcolumn="33"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1gaa76142ae43535c862ad9e194a6e38aaa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateImage</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, const VkImageCreateInfo *VMA_NOT_NULL pImageCreateInfo, const VmaAllocationCreateInfo *VMA_NOT_NULL pAllocationCreateInfo, VkImage VMA_NULLABLE_NON_DISPATCHABLE *VMA_NOT_NULL pImage, VmaAllocation VMA_NULLABLE *VMA_NOT_NULL pAllocation, VmaAllocationInfo *VMA_NULLABLE pAllocationInfo)</argsstring>
        <name>vmaCreateImage</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>const VkImageCreateInfo *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pImageCreateInfo</declname>
        </param>
        <param>
          <type>const <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocationCreateInfo</declname>
        </param>
        <param>
          <type>VkImage <ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pImage</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pAllocation</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation_info" kindref="compound">VmaAllocationInfo</ref> *<ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>pAllocationInfo</declname>
        </param>
        <briefdescription>
<para>Function similar to <ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2371" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2371" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga9ef2c5794b39fea75da48305e3a17084" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> VkResult <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE VkResult VMA_CALL_POST vmaCreateAliasingImage</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VmaAllocation VMA_NOT_NULL allocation, const VkImageCreateInfo *VMA_NOT_NULL pImageCreateInfo, VkImage VMA_NULLABLE_NON_DISPATCHABLE *VMA_NOT_NULL pImage)</argsstring>
        <name>vmaCreateAliasingImage</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocation</declname>
        </param>
        <param>
          <type>const VkImageCreateInfo *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pImageCreateInfo</declname>
        </param>
        <param>
          <type>VkImage <ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref> *<ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>pImage</declname>
        </param>
        <briefdescription>
<para>Function similar to <ref refid="group__group__alloc_1ga41a76d0f9f98a001900a889f55973536" kindref="member">vmaCreateAliasingBuffer()</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2380" column="37" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2380" declcolumn="37"/>
      </memberdef>
      <memberdef kind="function" id="group__group__alloc_1ga2f6367e612daace5c5ecd7ef9e47c3fd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="vk__mem__alloc_8h_1a3f0fa870030b4d421bf71e3928d5fe31" kindref="member">VMA_CALL_PRE</ref> void <ref refid="vk__mem__alloc_8h_1aab7d949b3d77783f0ba704ae5e3136e0" kindref="member">VMA_CALL_POST</ref></type>
        <definition>VMA_CALL_PRE void VMA_CALL_POST vmaDestroyImage</definition>
        <argsstring>(VmaAllocator VMA_NOT_NULL allocator, VkImage VMA_NULLABLE_NON_DISPATCHABLE image, VmaAllocation VMA_NULLABLE allocation)</argsstring>
        <name>vmaDestroyImage</name>
        <param>
          <type><ref refid="struct_vma_allocator" kindref="compound">VmaAllocator</ref> <ref refid="vk__mem__alloc_8h_1a0366f45516136c073f98582341ecf9de" kindref="member">VMA_NOT_NULL</ref></type>
          <declname>allocator</declname>
        </param>
        <param>
          <type>VkImage <ref refid="vk__mem__alloc_8h_1ab2073c76e8756145dd9426345e13b57e" kindref="member">VMA_NULLABLE_NON_DISPATCHABLE</ref></type>
          <declname>image</declname>
        </param>
        <param>
          <type><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref> <ref refid="vk__mem__alloc_8h_1a3ff043960766509fbba947bc2c68bdb6" kindref="member">VMA_NULLABLE</ref></type>
          <declname>allocation</declname>
        </param>
        <briefdescription>
<para>Destroys Vulkan image and frees allocated memory. </para>
        </briefdescription>
        <detaileddescription>
<para>This is just a convenience function equivalent to:</para>
<para><programlisting><codeline><highlight class="normal">vkDestroyImage(device,<sp/>image,<sp/>allocationCallbacks);</highlight></codeline>
<codeline><highlight class="normal">vmaFreeMemory(allocator,<sp/>allocation);</highlight></codeline>
</programlisting></para>
<para>It it safe to pass null as image and/or allocation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" line="2397" column="33" declfile="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h" declline="2397" declcolumn="33"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>API elements related to the allocation, deallocation, and management of Vulkan memory, buffers, images. Most basic ones being: <ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer()</ref>, <ref refid="group__group__alloc_1gaa76142ae43535c862ad9e194a6e38aaa" kindref="member">vmaCreateImage()</ref>. </para>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
  </compounddef>
</doxygen>
