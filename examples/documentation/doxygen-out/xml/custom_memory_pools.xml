<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.5" xml:lang="en-US">
  <compounddef id="custom_memory_pools" kind="page">
    <compoundname>custom_memory_pools</compoundname>
    <title>Custom memory pools</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>A memory pool contains a number of `VkDeviceMemory` blocks. The library automatically creates and manages default pool for each memory type available on the device. Default memory pool automatically grows in size. Size of allocated blocks is also variable and managed automatically.</para>
<para>You can create custom pool and allocate memory out of it. It can be useful if you want to:</para>
<para><itemizedlist>
<listitem><para>Keep certain kind of allocations separate from others.</para>
</listitem><listitem><para>Enforce particular, fixed size of Vulkan memory blocks.</para>
</listitem><listitem><para>Limit maximum amount of Vulkan memory allocated for that pool.</para>
</listitem><listitem><para>Reserve minimum or fixed amount of Vulkan memory always preallocated for that pool.</para>
</listitem><listitem><para>Use extra parameters for a set of your allocations that are available in <ref refid="struct_vma_pool_create_info" kindref="compound">VmaPoolCreateInfo</ref> but not in <ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref> - e.g., custom minimum alignment, custom `pNext` chain.</para>
</listitem><listitem><para>Perform defragmentation on a specific subset of your allocations.</para>
</listitem></itemizedlist>
</para>
<para>To use custom memory pools:</para>
<para><orderedlist>
<listitem><para>Fill <ref refid="struct_vma_pool_create_info" kindref="compound">VmaPoolCreateInfo</ref> structure.</para>
</listitem><listitem><para>Call <ref refid="group__group__alloc_1ga250d4f6f4c09a6a03b82323f999c9c4e" kindref="member">vmaCreatePool()</ref> to obtain <ref refid="struct_vma_pool" kindref="compound">VmaPool</ref> handle.</para>
</listitem><listitem><para>When making an allocation, set <ref refid="struct_vma_allocation_create_info_1ad5aa903b9be1fa934abf2dd6c650fca6" kindref="member">VmaAllocationCreateInfo::pool</ref> to this handle. You don&apos;t need to specify any other parameters of this structure, like `usage`.</para>
</listitem></orderedlist>
</para>
<para>Example:</para>
<para><programlisting><codeline><highlight class="comment">//<sp/>Find<sp/>memoryTypeIndex<sp/>for<sp/>the<sp/>pool.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VkBufferCreateInfo<sp/>sampleBufCreateInfo<sp/>=<sp/>{<sp/>VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO<sp/>};</highlight></codeline>
<codeline><highlight class="normal">sampleBufCreateInfo.size<sp/>=<sp/>0x10000;<sp/></highlight><highlight class="comment">//<sp/>Doesn&apos;t<sp/>matter.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">sampleBufCreateInfo.usage<sp/>=<sp/>VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT<sp/>|<sp/>VK_BUFFER_USAGE_TRANSFER_DST_BIT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref><sp/>sampleAllocCreateInfo<sp/>=<sp/>{};</highlight></codeline>
<codeline><highlight class="normal">sampleAllocCreateInfo.<ref refid="struct_vma_allocation_create_info_1accb8b06b1f677d858cb9af20705fa910" kindref="member">usage</ref><sp/>=<sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e" kindref="member">VMA_MEMORY_USAGE_AUTO</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">uint32_t<sp/>memTypeIndex;</highlight></codeline>
<codeline><highlight class="normal">VkResult<sp/>res<sp/>=<sp/><ref refid="group__group__alloc_1ga723f5683b363c306bf860dab1861f299" kindref="member">vmaFindMemoryTypeIndexForBufferInfo</ref>(allocator,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&amp;sampleBufCreateInfo,<sp/>&amp;sampleAllocCreateInfo,<sp/>&amp;memTypeIndex);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Check<sp/>res...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>pool<sp/>that<sp/>can<sp/>have<sp/>at<sp/>most<sp/>2<sp/>blocks,<sp/>128<sp/>MiB<sp/>each.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="struct_vma_pool_create_info" kindref="compound">VmaPoolCreateInfo</ref><sp/>poolCreateInfo<sp/>=<sp/>{};</highlight></codeline>
<codeline><highlight class="normal">poolCreateInfo.<ref refid="struct_vma_pool_create_info_1a596fa76b685d3f1f688f84a709a5b319" kindref="member">memoryTypeIndex</ref><sp/>=<sp/>memTypeIndex;</highlight></codeline>
<codeline><highlight class="normal">poolCreateInfo.<ref refid="struct_vma_pool_create_info_1aa4265160536cdb9be821b7686c16c676" kindref="member">blockSize</ref><sp/>=<sp/>128ull<sp/>*<sp/>1024<sp/>*<sp/>1024;</highlight></codeline>
<codeline><highlight class="normal">poolCreateInfo.<ref refid="struct_vma_pool_create_info_1ae41142f2834fcdc82baa4883c187b75c" kindref="member">maxBlockCount</ref><sp/>=<sp/>2;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="struct_vma_pool" kindref="compound">VmaPool</ref><sp/>pool;</highlight></codeline>
<codeline><highlight class="normal">res<sp/>=<sp/><ref refid="group__group__alloc_1ga250d4f6f4c09a6a03b82323f999c9c4e" kindref="member">vmaCreatePool</ref>(allocator,<sp/>&amp;poolCreateInfo,<sp/>&amp;pool);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Check<sp/>res...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Allocate<sp/>a<sp/>buffer<sp/>out<sp/>of<sp/>it.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VkBufferCreateInfo<sp/>bufCreateInfo<sp/>=<sp/>{<sp/>VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO<sp/>};</highlight></codeline>
<codeline><highlight class="normal">bufCreateInfo.size<sp/>=<sp/>1024;</highlight></codeline>
<codeline><highlight class="normal">bufCreateInfo.usage<sp/>=<sp/>VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT<sp/>|<sp/>VK_BUFFER_USAGE_TRANSFER_DST_BIT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref><sp/>allocCreateInfo<sp/>=<sp/>{};</highlight></codeline>
<codeline><highlight class="normal">allocCreateInfo.<ref refid="struct_vma_allocation_create_info_1ad5aa903b9be1fa934abf2dd6c650fca6" kindref="member">pool</ref><sp/>=<sp/>pool;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VkBuffer<sp/>buf;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>alloc;</highlight></codeline>
<codeline><highlight class="normal">res<sp/>=<sp/><ref refid="group__group__alloc_1gae9773fe0ef8582e23136d2d83c336ab9" kindref="member">vmaCreateBuffer</ref>(allocator,<sp/>&amp;bufCreateInfo,<sp/>&amp;allocCreateInfo,<sp/>&amp;buf,<sp/>&amp;alloc,<sp/></highlight><highlight class="keyword">nullptr</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Check<sp/>res...</highlight></codeline>
</programlisting></para>
<para>You have to free all allocations made from this pool before destroying it.</para>
<para><programlisting><codeline><highlight class="normal"><ref refid="group__group__alloc_1gafcc45e5a6388ab35daa9a46688baee20" kindref="member">vmaDestroyBuffer</ref>(allocator,<sp/>buf,<sp/>alloc);</highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__group__alloc_1gad03da7fd4d8b772bc2a299bc34850d98" kindref="member">vmaDestroyPool</ref>(allocator,<sp/>pool);</highlight></codeline>
</programlisting></para>
<para>New versions of this library support creating dedicated allocations in custom pools. It is supported only when <ref refid="struct_vma_pool_create_info_1aa4265160536cdb9be821b7686c16c676" kindref="member">VmaPoolCreateInfo::blockSize</ref> = 0. To use this feature, set <ref refid="struct_vma_allocation_create_info_1ad5aa903b9be1fa934abf2dd6c650fca6" kindref="member">VmaAllocationCreateInfo::pool</ref> to the pointer to your custom pool and <ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">VmaAllocationCreateInfo::flags</ref> to <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a3fc311d855c2ff53f1090ef5c722b38f" kindref="member">VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</ref>.</para>
<para><simplesect kind="note"><para>Excessive use of custom pools is a common mistake when using this library. Custom pools may be useful for special purposes - when you want to keep certain type of resources separate e.g. to reserve minimum amount of memory for them or limit maximum amount of memory they can occupy. For most resources this is not needed and so it is not recommended to create <ref refid="struct_vma_pool" kindref="compound">VmaPool</ref> objects and allocations out of them. Allocating from the default pool is sufficient.</para>
</simplesect>
</para>
<sect1 id="custom_memory_pools_1custom_memory_pools_MemTypeIndex">
<title>Choosing memory type index</title>
<para>When creating a pool, you must explicitly specify memory type index. To find the one suitable for your buffers or images, you can use helper functions <ref refid="group__group__alloc_1ga723f5683b363c306bf860dab1861f299" kindref="member">vmaFindMemoryTypeIndexForBufferInfo()</ref>, <ref refid="group__group__alloc_1gaaf05345771a087328949b485ff2da4db" kindref="member">vmaFindMemoryTypeIndexForImageInfo()</ref>. You need to provide structures with example parameters of buffers or images that you are going to create in that pool.</para>
<para><programlisting><codeline><highlight class="normal">VkBufferCreateInfo<sp/>exampleBufCreateInfo<sp/>=<sp/>{<sp/>VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO<sp/>};</highlight></codeline>
<codeline><highlight class="normal">exampleBufCreateInfo.size<sp/>=<sp/>1024;<sp/></highlight><highlight class="comment">//<sp/>Doesn&apos;t<sp/>matter</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">exampleBufCreateInfo.usage<sp/>=<sp/>VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT<sp/>|<sp/>VK_BUFFER_USAGE_TRANSFER_DST_BIT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref><sp/>allocCreateInfo<sp/>=<sp/>{};</highlight></codeline>
<codeline><highlight class="normal">allocCreateInfo.<ref refid="struct_vma_allocation_create_info_1accb8b06b1f677d858cb9af20705fa910" kindref="member">usage</ref><sp/>=<sp/><ref refid="group__group__alloc_1ggaa5846affa1e9da3800e3e78fae2305cca27cde9026a84d34d525777baa41fce6e" kindref="member">VMA_MEMORY_USAGE_AUTO</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">uint32_t<sp/>memTypeIndex;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__group__alloc_1ga723f5683b363c306bf860dab1861f299" kindref="member">vmaFindMemoryTypeIndexForBufferInfo</ref>(allocator,<sp/>&amp;exampleBufCreateInfo,<sp/>&amp;allocCreateInfo,<sp/>&amp;memTypeIndex);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="struct_vma_pool_create_info" kindref="compound">VmaPoolCreateInfo</ref><sp/>poolCreateInfo<sp/>=<sp/>{};</highlight></codeline>
<codeline><highlight class="normal">poolCreateInfo.<ref refid="struct_vma_pool_create_info_1a596fa76b685d3f1f688f84a709a5b319" kindref="member">memoryTypeIndex</ref><sp/>=<sp/>memTypeIndex;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>...</highlight></codeline>
</programlisting></para>
<para>When creating buffers/images allocated in that pool, provide following parameters:</para>
<para><itemizedlist>
<listitem><para>`VkBufferCreateInfo`: Prefer to pass same parameters as above. Otherwise you risk creating resources in a memory type that is not suitable for them, which may result in undefined behavior. Using different `VK_BUFFER_USAGE_` flags may work, but you shouldn&apos;t create images in a pool intended for buffers or the other way around.</para>
</listitem><listitem><para><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref>: You don&apos;t need to pass same parameters. Fill only `pool` member. Other members are ignored anyway.</para>
</listitem></itemizedlist>
</para>
</sect1>
<sect1 id="custom_memory_pools_1linear_algorithm">
<title>Linear allocation algorithm</title>
<para>Each Vulkan memory block managed by this library has accompanying metadata that keeps track of used and unused regions. By default, the metadata structure and algorithm tries to find best place for new allocations among free regions to optimize memory usage. This way you can allocate and free objects in any order.</para>
<para>![Default allocation algorithm](../gfx/Linear_allocator_1_algo_default.png)</para>
<para>Sometimes there is a need to use simpler, linear allocation algorithm. You can create custom pool that uses such algorithm by adding flag <ref refid="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726" kindref="member">VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</ref> to <ref refid="struct_vma_pool_create_info_1a8405139f63d078340ae74513a59f5446" kindref="member">VmaPoolCreateInfo::flags</ref> while creating <ref refid="struct_vma_pool" kindref="compound">VmaPool</ref> object. Then an alternative metadata management is used. It always creates new allocations after last one and doesn&apos;t reuse free regions after allocations freed in the middle. It results in better allocation performance and less memory consumed by metadata.</para>
<para>![Linear allocation algorithm](../gfx/Linear_allocator_2_algo_linear.png)</para>
<para>With this one flag, you can create a custom pool that can be used in many ways: free-at-once, stack, double stack, and ring buffer. See below for details. You don&apos;t need to specify explicitly which of these options you are going to use - it is detected automatically.</para>
<sect2 id="custom_memory_pools_1linear_algorithm_free_at_once">
<title>Free-at-once</title>
<para>In a pool that uses linear algorithm, you still need to free all the allocations individually, e.g. by using <ref refid="group__group__alloc_1ga5c9baca5124d440046bbe508f61d2839" kindref="member">vmaFreeMemory()</ref> or <ref refid="group__group__alloc_1gafcc45e5a6388ab35daa9a46688baee20" kindref="member">vmaDestroyBuffer()</ref>. You can free them in any order. New allocations are always made after last one - free space in the middle is not reused. However, when you release all the allocation and the pool becomes empty, allocation starts from the beginning again. This way you can use linear algorithm to speed up creation of allocations that you are going to release all at once.</para>
<para>![Free-at-once](../gfx/Linear_allocator_3_free_at_once.png)</para>
<para>This mode is also available for pools created with <ref refid="struct_vma_pool_create_info_1ae41142f2834fcdc82baa4883c187b75c" kindref="member">VmaPoolCreateInfo::maxBlockCount</ref> value that allows multiple memory blocks.</para>
</sect2>
<sect2 id="custom_memory_pools_1linear_algorithm_stack">
<title>Stack</title>
<para>When you free an allocation that was created last, its space can be reused. Thanks to this, if you always release allocations in the order opposite to their creation (LIFO - Last In First Out), you can achieve behavior of a stack.</para>
<para>![Stack](../gfx/Linear_allocator_4_stack.png)</para>
<para>This mode is also available for pools created with <ref refid="struct_vma_pool_create_info_1ae41142f2834fcdc82baa4883c187b75c" kindref="member">VmaPoolCreateInfo::maxBlockCount</ref> value that allows multiple memory blocks.</para>
</sect2>
<sect2 id="custom_memory_pools_1linear_algorithm_double_stack">
<title>Double stack</title>
<para>The space reserved by a custom pool with linear algorithm may be used by two stacks:</para>
<para><itemizedlist>
<listitem><para>First, default one, growing up from offset 0.</para>
</listitem><listitem><para>Second, &quot;upper&quot; one, growing down from the end towards lower offsets.</para>
</listitem></itemizedlist>
</para>
<para>To make allocation from the upper stack, add flag <ref refid="group__group__alloc_1ggad9889c10c798b040d59c92f257cae597a42ba3a2d2c7117953210b7c3ef8da0df" kindref="member">VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT</ref> to <ref refid="struct_vma_allocation_create_info_1add09658ac14fe290ace25470ddd6d41b" kindref="member">VmaAllocationCreateInfo::flags</ref>.</para>
<para>![Double stack](../gfx/Linear_allocator_7_double_stack.png)</para>
<para>Double stack is available only in pools with one memory block - <ref refid="struct_vma_pool_create_info_1ae41142f2834fcdc82baa4883c187b75c" kindref="member">VmaPoolCreateInfo::maxBlockCount</ref> must be 1. Otherwise behavior is undefined.</para>
<para>When the two stacks&apos; ends meet so there is not enough space between them for a new allocation, such allocation fails with usual `VK_ERROR_OUT_OF_DEVICE_MEMORY` error.</para>
</sect2>
<sect2 id="custom_memory_pools_1linear_algorithm_ring_buffer">
<title>Ring buffer</title>
<para>When you free some allocations from the beginning and there is not enough free space for a new one at the end of a pool, allocator&apos;s &quot;cursor&quot; wraps around to the beginning and starts allocation there. Thanks to this, if you always release allocations in the same order as you created them (FIFO - First In First Out), you can achieve behavior of a ring buffer / queue.</para>
<para>![Ring buffer](../gfx/Linear_allocator_5_ring_buffer.png)</para>
<para>Ring buffer is available only in pools with one memory block - <ref refid="struct_vma_pool_create_info_1ae41142f2834fcdc82baa4883c187b75c" kindref="member">VmaPoolCreateInfo::maxBlockCount</ref> must be 1. Otherwise behavior is undefined.</para>
<para><simplesect kind="note"><para><ref refid="defragmentation" kindref="compound">Defragmentation</ref> is not supported in custom pools created with <ref refid="group__group__alloc_1gga9a7c45f9c863695d98c83fa5ac940fe7a13c8a444197c67866be9cb05599fc726" kindref="member">VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT</ref>. </para>
</simplesect>
</para>
</sect2>
</sect1>
    </detaileddescription>
    <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h"/>
  </compounddef>
</doxygen>
