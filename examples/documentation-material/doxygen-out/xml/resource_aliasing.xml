<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.5" xml:lang="en-US">
  <compounddef id="resource_aliasing" kind="page">
    <compoundname>resource_aliasing</compoundname>
    <title>Resource aliasing (overlap)</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>New explicit graphics APIs (Vulkan and Direct3D 12), thanks to manual memory management, give an opportunity to alias (overlap) multiple resources in the same region of memory - a feature not available in the old APIs (Direct3D 11, OpenGL). It can be useful to save video memory, but it must be used with caution.</para>
<para>For example, if you know the flow of your whole render frame in advance, you are going to use some intermediate textures or buffers only during a small range of render passes, and you know these ranges don&apos;t overlap in time, you can bind these resources to the same place in memory, even if they have completely different parameters (width, height, format etc.).</para>
<para>![Resource aliasing (overlap)](../gfx/Aliasing.png)</para>
<para>Such scenario is possible using VMA, but you need to create your images manually. Then you need to calculate parameters of an allocation to be made using formula:</para>
<para><itemizedlist>
<listitem><para>allocation size = max(size of each image)</para>
</listitem><listitem><para>allocation alignment = max(alignment of each image)</para>
</listitem><listitem><para>allocation memoryTypeBits = bitwise AND(memoryTypeBits of each image)</para>
</listitem></itemizedlist>
</para>
<para>Following example shows two different images bound to the same place in memory, allocated to fit largest of them.</para>
<para><programlisting><codeline><highlight class="comment">//<sp/>A<sp/>512x512<sp/>texture<sp/>to<sp/>be<sp/>sampled.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VkImageCreateInfo<sp/>img1CreateInfo<sp/>=<sp/>{<sp/>VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO<sp/>};</highlight></codeline>
<codeline><highlight class="normal">img1CreateInfo.imageType<sp/>=<sp/>VK_IMAGE_TYPE_2D;</highlight></codeline>
<codeline><highlight class="normal">img1CreateInfo.extent.width<sp/>=<sp/>512;</highlight></codeline>
<codeline><highlight class="normal">img1CreateInfo.extent.height<sp/>=<sp/>512;</highlight></codeline>
<codeline><highlight class="normal">img1CreateInfo.extent.depth<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">img1CreateInfo.mipLevels<sp/>=<sp/>10;</highlight></codeline>
<codeline><highlight class="normal">img1CreateInfo.arrayLayers<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">img1CreateInfo.format<sp/>=<sp/>VK_FORMAT_R8G8B8A8_SRGB;</highlight></codeline>
<codeline><highlight class="normal">img1CreateInfo.tiling<sp/>=<sp/>VK_IMAGE_TILING_OPTIMAL;</highlight></codeline>
<codeline><highlight class="normal">img1CreateInfo.initialLayout<sp/>=<sp/>VK_IMAGE_LAYOUT_UNDEFINED;</highlight></codeline>
<codeline><highlight class="normal">img1CreateInfo.usage<sp/>=<sp/>VK_IMAGE_USAGE_TRANSFER_DST_BIT<sp/>|<sp/>VK_IMAGE_USAGE_SAMPLED_BIT;</highlight></codeline>
<codeline><highlight class="normal">img1CreateInfo.samples<sp/>=<sp/>VK_SAMPLE_COUNT_1_BIT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>A<sp/>full<sp/>screen<sp/>texture<sp/>to<sp/>be<sp/>used<sp/>as<sp/>color<sp/>attachment.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VkImageCreateInfo<sp/>img2CreateInfo<sp/>=<sp/>{<sp/>VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO<sp/>};</highlight></codeline>
<codeline><highlight class="normal">img2CreateInfo.imageType<sp/>=<sp/>VK_IMAGE_TYPE_2D;</highlight></codeline>
<codeline><highlight class="normal">img2CreateInfo.extent.width<sp/>=<sp/>1920;</highlight></codeline>
<codeline><highlight class="normal">img2CreateInfo.extent.height<sp/>=<sp/>1080;</highlight></codeline>
<codeline><highlight class="normal">img2CreateInfo.extent.depth<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">img2CreateInfo.mipLevels<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">img2CreateInfo.arrayLayers<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">img2CreateInfo.format<sp/>=<sp/>VK_FORMAT_R8G8B8A8_UNORM;</highlight></codeline>
<codeline><highlight class="normal">img2CreateInfo.tiling<sp/>=<sp/>VK_IMAGE_TILING_OPTIMAL;</highlight></codeline>
<codeline><highlight class="normal">img2CreateInfo.initialLayout<sp/>=<sp/>VK_IMAGE_LAYOUT_UNDEFINED;</highlight></codeline>
<codeline><highlight class="normal">img2CreateInfo.usage<sp/>=<sp/>VK_IMAGE_USAGE_SAMPLED_BIT<sp/>|<sp/>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;</highlight></codeline>
<codeline><highlight class="normal">img2CreateInfo.samples<sp/>=<sp/>VK_SAMPLE_COUNT_1_BIT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VkImage<sp/>img1;</highlight></codeline>
<codeline><highlight class="normal">res<sp/>=<sp/>vkCreateImage(device,<sp/>&amp;img1CreateInfo,<sp/></highlight><highlight class="keyword">nullptr</highlight><highlight class="normal">,<sp/>&amp;img1);</highlight></codeline>
<codeline><highlight class="normal">VkImage<sp/>img2;</highlight></codeline>
<codeline><highlight class="normal">res<sp/>=<sp/>vkCreateImage(device,<sp/>&amp;img2CreateInfo,<sp/></highlight><highlight class="keyword">nullptr</highlight><highlight class="normal">,<sp/>&amp;img2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VkMemoryRequirements<sp/>img1MemReq;</highlight></codeline>
<codeline><highlight class="normal">vkGetImageMemoryRequirements(device,<sp/>img1,<sp/>&amp;img1MemReq);</highlight></codeline>
<codeline><highlight class="normal">VkMemoryRequirements<sp/>img2MemReq;</highlight></codeline>
<codeline><highlight class="normal">vkGetImageMemoryRequirements(device,<sp/>img2,<sp/>&amp;img2MemReq);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">VkMemoryRequirements<sp/>finalMemReq<sp/>=<sp/>{};</highlight></codeline>
<codeline><highlight class="normal">finalMemReq.size<sp/>=<sp/>std::max(img1MemReq.size,<sp/>img2MemReq.size);</highlight></codeline>
<codeline><highlight class="normal">finalMemReq.alignment<sp/>=<sp/>std::max(img1MemReq.alignment,<sp/>img2MemReq.alignment);</highlight></codeline>
<codeline><highlight class="normal">finalMemReq.memoryTypeBits<sp/>=<sp/>img1MemReq.memoryTypeBits<sp/>&amp;<sp/>img2MemReq.memoryTypeBits;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Validate<sp/>if(finalMemReq.memoryTypeBits<sp/>!=<sp/>0)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="struct_vma_allocation_create_info" kindref="compound">VmaAllocationCreateInfo</ref><sp/>allocCreateInfo<sp/>=<sp/>{};</highlight></codeline>
<codeline><highlight class="normal">allocCreateInfo.<ref refid="struct_vma_allocation_create_info_1a7fe8d81a1ad10b2a2faacacee5b15d6d" kindref="member">preferredFlags</ref><sp/>=<sp/>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="struct_vma_allocation" kindref="compound">VmaAllocation</ref><sp/>alloc;</highlight></codeline>
<codeline><highlight class="normal">res<sp/>=<sp/><ref refid="group__group__alloc_1gaf813f55a0667016a8cd68bb4b8b3b30c" kindref="member">vmaAllocateMemory</ref>(allocator,<sp/>&amp;finalMemReq,<sp/>&amp;allocCreateInfo,<sp/>&amp;alloc,<sp/></highlight><highlight class="keyword">nullptr</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">res<sp/>=<sp/><ref refid="group__group__alloc_1ga3a5d8d9f2a29b42cf87f0f8dfef591f4" kindref="member">vmaBindImageMemory</ref>(allocator,<sp/>alloc,<sp/>img1);</highlight></codeline>
<codeline><highlight class="normal">res<sp/>=<sp/><ref refid="group__group__alloc_1ga3a5d8d9f2a29b42cf87f0f8dfef591f4" kindref="member">vmaBindImageMemory</ref>(allocator,<sp/>alloc,<sp/>img2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>You<sp/>can<sp/>use<sp/>img1,<sp/>img2<sp/>here,<sp/>but<sp/>not<sp/>at<sp/>the<sp/>same<sp/>time!</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="group__group__alloc_1ga5c9baca5124d440046bbe508f61d2839" kindref="member">vmaFreeMemory</ref>(allocator,<sp/>alloc);</highlight></codeline>
<codeline><highlight class="normal">vkDestroyImage(allocator,<sp/>img2,<sp/></highlight><highlight class="keyword">nullptr</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">vkDestroyImage(allocator,<sp/>img1,<sp/></highlight><highlight class="keyword">nullptr</highlight><highlight class="normal">);</highlight></codeline>
</programlisting></para>
<para>Remember that using resources that alias in memory requires proper synchronization. You need to issue a memory barrier to make sure commands that use `img1` and `img2` don&apos;t overlap on GPU timeline. You also need to treat a resource after aliasing as uninitialized - containing garbage data. For example, if you use `img1` and then want to use `img2`, you need to issue an image memory barrier for `img2` with `oldLayout` = `VK_IMAGE_LAYOUT_UNDEFINED`.</para>
<para>Additional considerations:</para>
<para><itemizedlist>
<listitem><para>Vulkan also allows to interpret contents of memory between aliasing resources consistently in some cases. See chapter 11.8. &quot;Memory Aliasing&quot; of Vulkan specification or `VK_IMAGE_CREATE_ALIAS_BIT` flag.</para>
</listitem><listitem><para>You can create more complex layout where different images and buffers are bound at different offsets inside one large allocation. For example, one can imagine a big texture used in some render passes, aliasing with a set of many small buffers used between in some further passes. To bind a resource at non-zero offset in an allocation, use <ref refid="group__group__alloc_1ga4a71c30e3474a835bdd7fd0507740be7" kindref="member">vmaBindBufferMemory2()</ref> / <ref refid="group__group__alloc_1ga0216b9225b02a66ac610cb45d4729d00" kindref="member">vmaBindImageMemory2()</ref>.</para>
</listitem><listitem><para>Before allocating memory for the resources you want to alias, check `memoryTypeBits` returned in memory requirements of each resource to make sure the bits overlap. Some GPUs may expose multiple memory types suitable e.g. only for buffers or images with `COLOR_ATTACHMENT` usage, so the sets of memory types supported by your resources may be disjoint. Aliasing them is not possible in that case. </para>
</listitem></itemizedlist>
</para>
    </detaileddescription>
    <location file="shadow-engine/shadow-renderer/inc/vulkan/vk_mem_alloc.h"/>
  </compounddef>
</doxygen>
